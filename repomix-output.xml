This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*/*.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
android/
  app/
    src/
      debug/
        AndroidManifest.xml
      main/
        kotlin/
          com/
            glp1/
              n06/
                MainActivity.kt
        res/
          drawable/
            launch_background.xml
          drawable-v21/
            launch_background.xml
          values/
            styles.xml
          values-night/
            styles.xml
        AndroidManifest.xml
      profile/
        AndroidManifest.xml
    build.gradle.kts
    proguard-rules.pro
  gradle/
    wrapper/
      gradle-wrapper.properties
  .gitignore
  build.gradle.kts
  gradle.properties
  settings.gradle.kts
appendix/
  changelog/
    CHANGES_SUMMARY.txt
    FIX_SUMMARY.txt
ios/
  Flutter/
    AppFrameworkInfo.plist
    Debug.xcconfig
    Release.xcconfig
  Runner/
    Assets.xcassets/
      AppIcon.appiconset/
        Contents.json
      LaunchImage.imageset/
        Contents.json
    Base.lproj/
      LaunchScreen.storyboard
      Main.storyboard
    AppDelegate.swift
    Info.plist
    Runner-Bridging-Header.h
  Runner.xcodeproj/
    project.xcworkspace/
      xcshareddata/
        IDEWorkspaceChecks.plist
        WorkspaceSettings.xcsettings
      contents.xcworkspacedata
    xcshareddata/
      xcschemes/
        Runner.xcscheme
    project.pbxproj
  Runner.xcworkspace/
    xcshareddata/
      IDEWorkspaceChecks.plist
      WorkspaceSettings.xcsettings
    contents.xcworkspacedata
  RunnerTests/
    RunnerTests.swift
  .gitignore
  Podfile
lib/
  core/
    errors/
      domain_exception.dart
    routing/
      app_router.dart
    services/
      secure_storage_service.dart
    providers.dart
  features/
    authentication/
      application/
        notifiers/
          auth_notifier.dart
        providers.dart
      domain/
        entities/
          consent_record.dart
          user.dart
        exceptions/
          auth_exceptions.dart
        repositories/
          auth_repository.dart
          secure_storage_repository.dart
        usecases/
          logout_usecase.dart
      infrastructure/
        datasources/
          kakao_auth_datasource.dart
          naver_auth_datasource.dart
        dtos/
          consent_record_dto.dart
          user_dto.dart
        repositories/
          flutter_secure_storage_repository.dart
          isar_auth_repository.dart
      presentation/
        screens/
          login_screen.dart
        widgets/
          logout_confirm_dialog.dart
    coping_guide/
      application/
        notifiers/
          coping_guide_notifier.dart
        providers.dart
      domain/
        entities/
          coping_guide_state.dart
          coping_guide.dart
          guide_feedback.dart
          guide_section.dart
        repositories/
          coping_guide_repository.dart
          feedback_repository.dart
      infrastructure/
        dtos/
          guide_feedback_dto.dart
        repositories/
          isar_feedback_repository.dart
          static_coping_guide_repository.dart
      presentation/
        screens/
          coping_guide_screen.dart
          detailed_guide_screen.dart
        widgets/
          coping_guide_card.dart
          feedback_widget.dart
          severity_warning_banner.dart
    dashboard/
      application/
        notifiers/
          dashboard_notifier.dart
        providers.dart
      domain/
        entities/
          badge_definition.dart
          dashboard_data.dart
          index.dart
          next_schedule.dart
          timeline_event.dart
          user_badge.dart
          weekly_progress.dart
          weekly_summary.dart
        repositories/
          badge_repository.dart
        usecases/
          calculate_adherence_usecase.dart
          calculate_continuous_record_days_usecase.dart
          calculate_current_week_usecase.dart
          calculate_weekly_progress_usecase.dart
          calculate_weight_goal_estimate_usecase.dart
          index.dart
          verify_badge_conditions_usecase.dart
      infrastructure/
        dtos/
          badge_definition_dto.dart
          user_badge_dto.dart
        repositories/
          isar_badge_repository.dart
      presentation/
        screens/
          home_dashboard_screen.dart
        widgets/
          badge_widget.dart
          greeting_widget.dart
          index.dart
          next_schedule_widget.dart
          quick_action_widget.dart
          timeline_widget.dart
          weekly_progress_widget.dart
          weekly_report_widget.dart
    data_sharing/
      application/
        notifiers/
          data_sharing_notifier.dart
        providers.dart
      domain/
        entities/
          emergency_symptom_check.dart
          shared_data_report.dart
        repositories/
          date_range.dart
          shared_data_repository.dart
        usecases/
          data_sharing_aggregator.dart
      infrastructure/
        repositories/
          isar_shared_data_repository.dart
      presentation/
        screens/
          data_sharing_screen.dart
    notification/
      application/
        notifiers/
          notification_notifier.dart
        providers.dart
      domain/
        entities/
          notification_settings.dart
        repositories/
          notification_repository.dart
        services/
          notification_scheduler.dart
      infrastructure/
        dtos/
          notification_settings_dto.dart
        repositories/
          isar_notification_repository.dart
        services/
          local_notification_scheduler.dart
          permission_service.dart
      presentation/
        screens/
          notification_settings_screen.dart
        widgets/
          time_picker_button.dart
    onboarding/
      application/
        notifiers/
          onboarding_notifier.dart
        providers.dart
      domain/
        entities/
          dosage_plan.dart
          dose_schedule.dart
          escalation_step.dart
          user_profile.dart
          user.dart
          weight_log.dart
        repositories/
          medication_repository.dart
          profile_repository.dart
          schedule_repository.dart
          tracking_repository.dart
          user_repository.dart
        usecases/
          calculate_weekly_goal_usecase.dart
          check_onboarding_status_usecase.dart
          generate_dose_schedules_usecase.dart
          validate_dosage_plan_usecase.dart
        value_objects/
          medication_name.dart
          start_date.dart
          weight.dart
      infrastructure/
        dtos/
          dosage_plan_dto.dart
          dose_schedule_dto.dart
          escalation_step_dto.dart
          user_dto.dart
          user_profile_dto.dart
          weight_log_dto.dart
        repositories/
          isar_medication_repository.dart
          isar_profile_repository.dart
          isar_schedule_repository.dart
          isar_tracking_repository.dart
          isar_user_repository.dart
        services/
          transaction_service.dart
      presentation/
        screens/
          onboarding_screen.dart
        widgets/
          basic_profile_form.dart
          dosage_plan_form.dart
          summary_screen.dart
          weight_goal_form.dart
    profile/
      application/
        notifiers/
          profile_notifier.dart
      domain/
        repositories/
          profile_repository.dart
        usecases/
          update_profile_usecase.dart
      infrastructure/
        dtos/
          user_profile_dto.dart
        repositories/
          isar_profile_repository.dart
      presentation/
        screens/
          profile_edit_screen.dart
          weekly_goal_settings_screen.dart
        widgets/
          profile_edit_form.dart
          weekly_goal_input_widget.dart
    settings/
      presentation/
        screens/
          settings_screen.dart
        widgets/
          settings_menu_item.dart
    tracking/
      application/
        notifiers/
          dose_record_edit_notifier.dart
          emergency_check_notifier.dart
          medication_notifier.dart
          symptom_record_edit_notifier.dart
          tracking_notifier.dart
          weight_record_edit_notifier.dart
        usecases/
          update_dosage_plan_usecase.dart
        providers.dart
      domain/
        entities/
          audit_log.dart
          dosage_plan.dart
          dose_record.dart
          dose_schedule.dart
          emergency_symptom_check.dart
          plan_change_history.dart
          symptom_log.dart
          validation_result.dart
          weight_log.dart
        repositories/
          audit_repository.dart
          dosage_plan_repository.dart
          dose_schedule_repository.dart
          emergency_check_repository.dart
          medication_repository.dart
          tracking_repository.dart
        usecases/
          analyze_plan_change_impact_usecase.dart
          dose_notification_usecase.dart
          index.dart
          injection_site_rotation_usecase.dart
          log_record_change_usecase.dart
          missed_dose_analyzer_usecase.dart
          recalculate_dose_schedule_usecase.dart
          schedule_generator_usecase.dart
          validate_date_unique_constraint_usecase.dart
          validate_dosage_plan_usecase.dart
          validate_symptom_edit_usecase.dart
          validate_weight_edit_usecase.dart
      infrastructure/
        dtos/
          dosage_plan_dto.dart
          dose_record_dto.dart
          dose_schedule_dto.dart
          emergency_symptom_check_dto.dart
          plan_change_history_dto.dart
          symptom_context_tag_dto.dart
          symptom_log_dto.dart
          weight_log_dto.dart
        repositories/
          isar_audit_repository.dart
          isar_dosage_plan_repository.dart
          isar_dose_schedule_repository.dart
          isar_emergency_check_repository.dart
          isar_medication_repository.dart
          isar_tracking_repository.dart
        services/
          notification_service.dart
      presentation/
        dialogs/
          dose_edit_dialog.dart
          record_delete_dialog.dart
          symptom_edit_dialog.dart
          weight_edit_dialog.dart
        screens/
          edit_dosage_plan_screen.dart
          emergency_check_screen.dart
          symptom_record_screen.dart
          weight_record_screen.dart
        sheets/
          record_detail_sheet.dart
        widgets/
          consultation_recommendation_dialog.dart
          coping_guide_widget.dart
          date_selection_widget.dart
          input_validation_widget.dart
  main.dart
linux/
  flutter/
    CMakeLists.txt
  runner/
    CMakeLists.txt
    main.cc
    my_application.cc
    my_application.h
  .gitignore
  CMakeLists.txt
macos/
  Runner/
    Assets.xcassets/
      AppIcon.appiconset/
        Contents.json
    Base.lproj/
      MainMenu.xib
    Configs/
      AppInfo.xcconfig
      Debug.xcconfig
      Release.xcconfig
      Warnings.xcconfig
    AppDelegate.swift
    DebugProfile.entitlements
    Info.plist
    MainFlutterWindow.swift
    Release.entitlements
  Runner.xcodeproj/
    project.xcworkspace/
      xcshareddata/
        IDEWorkspaceChecks.plist
    xcshareddata/
      xcschemes/
        Runner.xcscheme
    project.pbxproj
  Runner.xcworkspace/
    xcshareddata/
      IDEWorkspaceChecks.plist
    contents.xcworkspacedata
  RunnerTests/
    RunnerTests.swift
  .gitignore
  Podfile
  Podfile.lock
supabase/
  migrations/
    01_initial_schema.sql
test/
  core/
    routing/
      app_router_test.dart
    services/
      secure_storage_service_test.dart
  fakes/
    fake_medication_repository.dart
    fake_repository_base.dart
  features/
    authentication/
      domain/
        entities/
          consent_record_test.dart
          user_test.dart
        repositories/
          secure_storage_repository_test.dart
        usecases/
          logout_usecase_test.dart
      infrastructure/
        datasources/
          kakao_auth_datasource_test.dart
          naver_auth_datasource_test.dart
        dtos/
          consent_record_dto_test.dart
          user_dto_test.dart
        repositories/
          flutter_secure_storage_repository_test.dart
      presentation/
        widgets/
          logout_confirm_dialog_test.dart
    coping_guide/
      application/
        notifiers/
          coping_guide_notifier_test.dart
      domain/
        entities/
          coping_guide_test.dart
      infrastructure/
        dtos/
          guide_feedback_dto_test.dart
        repositories/
          isar_feedback_repository_test.dart
          static_coping_guide_repository_test.dart
      presentation/
        screens/
          coping_guide_screen_test.dart
          detailed_guide_screen_test.dart
        widgets/
          coping_guide_card_test.dart
          feedback_widget_test.dart
          severity_warning_banner_test.dart
    dashboard/
      domain/
        entities/
          dashboard_data_test.dart
        usecases/
          calculate_continuous_record_days_usecase_test.dart
    data_sharing/
      domain/
        entities/
          shared_data_report_test.dart
      infrastructure/
        repositories/
          isar_shared_data_repository_test.dart
    notification/
      application/
        notifiers/
          notification_notifier_test.dart
      domain/
        entities/
          notification_settings_test.dart
        repositories/
          notification_repository_test.dart
        services/
          notification_scheduler_test.dart
      infrastructure/
        dtos/
          notification_settings_dto_test.dart
        repositories/
          isar_notification_repository_test.dart
        services/
          local_notification_scheduler_test.dart
          permission_service_test.dart
      presentation/
        screens/
          notification_settings_screen_test.dart
    onboarding/
      domain/
        entities/
          user_test.dart
        value_objects/
          medication_name_test.dart
          start_date_test.dart
          weight_test.dart
    profile/
      application/
        notifiers/
          profile_notifier_test.dart
          profile_notifier_update_weekly_goals_test.dart
      domain/
        entities/
          user_profile_weekly_goals_test.dart
        usecases/
          update_profile_usecase_test.dart
      infrastructure/
        repositories/
          isar_profile_repository_update_weekly_goals_test.dart
    settings/
      presentation/
        settings_screen_test.dart
    tracking/
      application/
        notifiers/
          emergency_check_notifier_test.dart
          tracking_notifier_test.dart
      domain/
        entities/
          dosage_plan_test.dart
          dose_record_test.dart
          dose_schedule_test.dart
          emergency_symptom_check_test.dart
          symptom_log_test.dart
          weight_log_test.dart
        repositories/
          emergency_check_repository_test.dart
        usecases/
          analyze_plan_change_impact_usecase_test.dart
          injection_site_rotation_usecase_test.dart
          missed_dose_analyzer_usecase_test.dart
          recalculate_dose_schedule_usecase_test.dart
          schedule_generator_usecase_test.dart
          validate_dosage_plan_usecase_test.dart
          validate_symptom_edit_usecase_test.dart
          validate_weight_edit_usecase_test.dart
      infrastructure/
        dtos/
          emergency_symptom_check_dto_test.dart
          symptom_log_dto_test.dart
          weight_log_dto_test.dart
        repositories/
          isar_dosage_plan_repository_test.dart
          isar_dose_schedule_repository_test.dart
          isar_emergency_check_repository_test.dart
          isar_tracking_repository_test.dart
      presentation/
        dialogs/
          dose_edit_dialog_test.dart
          record_delete_dialog_test.dart
          symptom_edit_dialog_test.dart
          weight_edit_dialog_test.dart
        screens/
          symptom_record_screen_test.dart
          weight_record_screen_test.dart
        sheets/
          record_detail_sheet_test.dart
        widgets/
          coping_guide_widget_test.dart
          date_selection_widget_test.dart
          input_validation_widget_test.dart
  helpers/
    test_async_utils.dart
    test_data_builders.dart
    test_riverpod_utils.dart
  unit/
    test_environment_validation_test.dart
  widget_test.dart
web/
  index.html
  manifest.json
windows/
  flutter/
    CMakeLists.txt
  runner/
    CMakeLists.txt
    flutter_window.cpp
    flutter_window.h
    main.cpp
    resource.h
    runner.exe.manifest
    Runner.rc
    utils.cpp
    utils.h
    win32_window.cpp
    win32_window.h
  .gitignore
  CMakeLists.txt
.gitignore
.metadata
analysis_options.yaml
build.yaml
claude.md
devtools_options.yaml
pubspec.lock
pubspec.yaml
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "WebSearch",
      "WebFetch(domain:clerk.com)",
      "WebFetch(domain:www.npmjs.com)",
      "Bash(mkdir:*)",
      "WebFetch(domain:docs.tosspayments.com)",
      "WebFetch(domain:supabase.com)",
      "Bash(npm install:*)",
      "Bash(cat:*)",
      "Bash(npm run lint:*)",
      "Bash(npm run build:*)",
      "Bash(node -e:*)",
      "WebFetch(domain:dashboard.clerk.com)",
      "Bash(rm:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(git push:*)",
      "Bash(curl:*)",
      "Bash(npx tsc:*)",
      "Bash(npx shadcn@latest add alert-dialog)",
      "Bash(npm run type-check:*)",
      "Bash(timeout 10 npm run dev:*)",
      "Bash(xargs:*)",
      "Bash(ls:*)",
      "Bash(echo:*)",
      "Bash(mv:*)",
      "Bash(npm run dev:*)",
      "Read(//private/tmp/**)",
      "Bash(kill:*)",
      "Bash(lsof:*)",
      "Bash(npm run test:run:*)",
      "Bash(npx playwright test:*)",
      "Bash(npx playwright:*)",
      "Bash(npm run test:e2e:*)",
      "Bash(for dir in 003-student-dashboard 004-publication-dashboard 005-department-kpi-dashboard 006-dashboard-filtering)",
      "Bash(do echo \"=== $dir ===\")",
      "Bash(done)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path="android/app/src/debug/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
</file>

<file path="android/app/src/main/res/drawable/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
</file>

<file path="android/app/src/main/res/drawable-v21/launch_background.xml">
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>
</file>

<file path="android/app/src/main/res/values/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="android/app/src/main/res/values-night/styles.xml">
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>
</file>

<file path="android/app/src/profile/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>
</file>

<file path="android/app/proguard-rules.pro">
# OkHttp Platform used by Firebase and other libraries
-dontwarn okhttp3.internal.platform.**
-dontwarn org.conscrypt.**
-dontwarn org.bouncycastle.**
-dontwarn org.openjsse.**

# Keep OkHttp platform implementations
-keep class okhttp3.internal.platform.** { *; }
</file>

<file path="android/gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.12-all.zip
</file>

<file path="android/.gitignore">
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java
.cxx/

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks
</file>

<file path="android/settings.gradle.kts">
pluginManagement {
    val flutterSdkPath =
        run {
            val properties = java.util.Properties()
            file("local.properties").inputStream().use { properties.load(it) }
            val flutterSdkPath = properties.getProperty("flutter.sdk")
            require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
            flutterSdkPath
        }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.9.1" apply false
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")
</file>

<file path="appendix/changelog/CHANGES_SUMMARY.txt">
================================================================================
  SymptomRecordScreen 위젯 테스트 화면 크기 수정 - 변경 요약
================================================================================

작업 완료일: 2025-11-08
상태: COMPLETED

================================================================================
1. 수정된 파일
================================================================================

파일명: test/features/tracking/presentation/screens/symptom_record_screen_test.dart
라인 수: 320 -> 340 (20 라인 추가)

================================================================================
2. 추가된 Import
================================================================================

+ import 'package:mockito/mockito.dart';
+ import 'package:n06/features/tracking/domain/repositories/tracking_repository.dart';
+ import 'package:n06/features/tracking/application/providers.dart';

================================================================================
3. 추가된 클래스
================================================================================

+ class MockTrackingRepository extends Mock implements TrackingRepository {}

================================================================================
4. 추가된 Helper 함수
================================================================================

+ Widget _buildTestableWidget(MockTrackingRepository mockRepo) {
+   return ProviderScope(
+     overrides: [
+       trackingRepositoryProvider.overrideWithValue(mockRepo),
+     ],
+     child: MaterialApp(
+       home: SymptomRecordScreen(),
+     ),
+   );
+ }

================================================================================
5. 추가된 setUp
================================================================================

+ setUp(() {
+   mockTrackingRepository = MockTrackingRepository();
+ });

================================================================================
6. 모든 testWidgets에 추가된 화면 크기 설정
================================================================================

각 testWidgets 함수 시작 부분에 다음 코드 추가:

+ tester.binding.window.physicalSizeTestValue = const Size(1280, 1600);
+ addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

적용 대상:
- should render SymptomRecordScreen (라인 31-46)
- should render symptom list (라인 48-74)
- should render severity slider (라인 76-92)
- should allow selecting multiple symptoms (라인 94-106)
- should display severity slider correctly (라인 108-127)
- should update severity value when slider is dragged (라인 129-151)
- should show 24h persistence question for severity 7-10 (라인 153-179)
- should not show question for severity below 7 (라인 181-199)
- should allow selecting context tags for severity 1-6 (라인 201-223)
- should not show context tags for severity 7-10 (라인 225-247)
- should allow entering memo (라인 249-277)
- should display days since escalation when available (라인 279-299)
- should show coping guide after saving (라인 301-321)
- should prompt emergency check for severity 7-10 with persistence (라인 323-342)
- should show error when no symptom is selected (라인 344-374)
- should show error when severity 7-10 without persistence selection (라인 376-408)

================================================================================
7. 스크롤 기능 추가 (TC-SRS-10 오류 처리 테스트)
================================================================================

테스트 1: should show error when no symptom is selected

+ await tester.drag(
+   find.byType(SingleChildScrollView),
+   const Offset(0, -500),
+ );
+ await tester.pumpAndSettle();

테스트 2: should show error when severity 7-10 without persistence selection

+ await tester.drag(
+   find.byType(SingleChildScrollView),
+   const Offset(0, -500),
+ );
+ await tester.pumpAndSettle();

================================================================================
8. testWidgets 호출 변경
================================================================================

이전: 
  await tester.pumpWidget(
    ProviderScope(
      child: MaterialApp(home: SymptomRecordScreen()),
    ),
  );

이후:
  await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

적용 범위: 모든 16개 testWidgets

================================================================================
9. 기술 스펙
================================================================================

화면 크기:
  이전: 800x600 (기본값)
  이후: 1280x1600 (확대)

Mock 처리:
  - Mockito 라이브러리 사용
  - TrackingRepository 인터페이스 구현
  - overrideWithValue()로 프로바이더 오버라이드

스크롤:
  - SingleChildScrollView 드래그
  - Y축 -500 픽셀 이동
  - pumpAndSettle()로 동기화

================================================================================
10. 테스트 커버리지
================================================================================

총 testWidgets: 16개
화면 크기 설정: 16개 (100%)
스크롤 기능: 2개 (TC-SRS-10)
Mock 적용: 16개 (100%)

================================================================================
11. 검증 결과
================================================================================

✓ 모든 testWidgets에 화면 크기 설정 적용
✓ Mock 프로바이더 통합
✓ 스크롤 기능 필요 테스트에만 추가
✓ TearDown으로 테스트 격리 보장
✓ 코드 스타일 일관성 유지
✓ 기존 테스트 로직 변경 없음

================================================================================
12. 예상 효과
================================================================================

이전 상태: 9개 testWidgets 실패
  - 저장 버튼이 화면 범위 벗어남
  - 레이아웃 오류로 상호작용 불가능

이후 상태: 모든 16개 testWidgets 정상 작동
  - 모든 UI 요소가 한 화면에 표시됨
  - 필요한 스크롤 기능 제공
  - 독립적인 테스트 환경 보장

================================================================================
13. 파일 위치
================================================================================

수정 파일:
  /Users/pro16/Desktop/project/n06/test/features/tracking/presentation/screens/symptom_record_screen_test.dart

완료 보고서:
  /Users/pro16/Desktop/project/n06/FINAL_COMPLETION_REPORT.md
  /Users/pro16/Desktop/project/n06/IMPLEMENTATION_SUMMARY.md
  /Users/pro16/Desktop/project/n06/SCREEN_SIZE_FIX_REPORT.md

================================================================================
14. 실행 명령
================================================================================

테스트 실행:
  flutter test test/features/tracking/presentation/screens/symptom_record_screen_test.dart

상세 로그:
  flutter test test/features/tracking/presentation/screens/symptom_record_screen_test.dart -vv

특정 테스트:
  flutter test test/features/tracking/presentation/screens/symptom_record_screen_test.dart \
    -p vm --plain-name 'TC-SRS-01'

================================================================================
최종 상태: 완료
================================================================================
</file>

<file path="appendix/changelog/FIX_SUMMARY.txt">
DTO CONSTRUCTOR SYNTAX FIX - QUICK SUMMARY
==========================================

TASK COMPLETED: Fixed DTO constructor calls to use cascade notation instead of named parameters

FILE 1: test/features/data_sharing/infrastructure/repositories/isar_shared_data_repository_test.dart
Status: FIXED - All 14 DTO instantiations converted

Transformations Applied:
1. Lines 48-52: DoseRecordDto() - Test "should fetch dose records within date range" (instance 1)
2. Lines 53-57: DoseRecordDto() - Test "should fetch dose records within date range" (instance 2)
3. Lines 75-78: WeightLogDto() - Test "should fetch weight logs within date range" (instance 1)
4. Lines 79-82: WeightLogDto() - Test "should fetch weight logs within date range" (instance 2)
5. Lines 100-104: SymptomLogDto() - Test "should fetch symptom logs within date range" (instance 1)
6. Lines 105-109: SymptomLogDto() - Test "should fetch symptom logs within date range" (instance 2)
7. Lines 138-142: DoseRecordDto() - Test "should handle partial data correctly"
8. Lines 161-164: DoseScheduleDto() - Test "should fetch dose schedules" (instance 1)
9. Lines 165-168: DoseScheduleDto() - Test "should fetch dose schedules" (instance 2)
10. Lines 183-187: DoseRecordDto() - Test "should handle allTime date range correctly" (instance 1)
11. Lines 188-192: DoseRecordDto() - Test "should handle allTime date range correctly" (instance 2)
12. Lines 193-197: DoseRecordDto() - Test "should handle allTime date range correctly" (instance 3)
13. Lines 215-218: WeightLogDto() - Test "should filter by correct user" (instance 1)
14. Lines 219-222: WeightLogDto() - Test "should filter by correct user" (instance 2)

DTO Breakdown:
- DoseRecordDto: 6 instances fixed
- WeightLogDto: 4 instances fixed
- SymptomLogDto: 2 instances fixed
- DoseScheduleDto: 2 instances fixed

FILE 2: test/features/tracking/infrastructure/repositories/isar_tracking_repository_test.dart
Status: NO CHANGES NEEDED - Uses entity constructors (WeightLog, SymptomLog), not DTOs

Verification:
✓ Flutter analyze: 0 errors (only unused import warnings)
✓ No "id:" parameters remain in file
✓ All 14 cascade notations verified
✓ Compilation successful
✓ Test logic preserved
✓ All field values preserved

Pattern Used:
Old:  DoseRecordDto(id: '1', dosagePlanId: 'plan1', ...)
New:  DoseRecordDto() .. dosagePlanId = 'plan1' ... 

Key Point: id field is NOT set because it's auto-incremented by Isar
</file>

<file path="ios/Flutter/AppFrameworkInfo.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>App</string>
  <key>CFBundleIdentifier</key>
  <string>io.flutter.flutter.app</string>
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundleName</key>
  <string>App</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0</string>
  <key>MinimumOSVersion</key>
  <string>13.0</string>
</dict>
</plist>
</file>

<file path="ios/Flutter/Debug.xcconfig">
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"
#include "Generated.xcconfig"
</file>

<file path="ios/Flutter/Release.xcconfig">
#include? "Pods/Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"
#include "Generated.xcconfig"
</file>

<file path="ios/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "20x20",
      "idiom" : "iphone",
      "filename" : "Icon-App-20x20@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "iphone",
      "filename" : "Icon-App-29x29@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "iphone",
      "filename" : "Icon-App-40x40@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "60x60",
      "idiom" : "iphone",
      "filename" : "Icon-App-60x60@3x.png",
      "scale" : "3x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "20x20",
      "idiom" : "ipad",
      "filename" : "Icon-App-20x20@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "29x29",
      "idiom" : "ipad",
      "filename" : "Icon-App-29x29@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "40x40",
      "idiom" : "ipad",
      "filename" : "Icon-App-40x40@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@1x.png",
      "scale" : "1x"
    },
    {
      "size" : "76x76",
      "idiom" : "ipad",
      "filename" : "Icon-App-76x76@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "83.5x83.5",
      "idiom" : "ipad",
      "filename" : "Icon-App-83.5x83.5@2x.png",
      "scale" : "2x"
    },
    {
      "size" : "1024x1024",
      "idiom" : "ios-marketing",
      "filename" : "Icon-App-1024x1024@1x.png",
      "scale" : "1x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
</file>

<file path="ios/Runner/Assets.xcassets/LaunchImage.imageset/Contents.json">
{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "LaunchImage.png",
      "scale" : "1x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@2x.png",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "filename" : "LaunchImage@3x.png",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
</file>

<file path="ios/Runner/Base.lproj/LaunchScreen.storyboard">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="12121" systemVersion="16G29" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="12089"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="Ydg-fD-yQy"/>
                        <viewControllerLayoutGuide type="bottom" id="xbc-2k-c8Z"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <imageView opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" image="LaunchImage" translatesAutoresizingMaskIntoConstraints="NO" id="YRO-k0-Ey4">
                            </imageView>
                        </subviews>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="1a2-6s-vTC"/>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="4X2-HB-R7a"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <image name="LaunchImage" width="168" height="185"/>
    </resources>
</document>
</file>

<file path="ios/Runner/Base.lproj/Main.storyboard">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="10117" systemVersion="15F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" initialViewController="BYZ-38-t0r">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="10085"/>
    </dependencies>
    <scenes>
        <!--Flutter View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="FlutterViewController" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="y3c-jy-aDJ"/>
                        <viewControllerLayoutGuide type="bottom" id="wfy-db-euE"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>
</file>

<file path="ios/Runner/AppDelegate.swift">
import Flutter
import UIKit

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}
</file>

<file path="ios/Runner/Runner-Bridging-Header.h">
#import "GeneratedPluginRegistrant.h"
</file>

<file path="ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>
</file>

<file path="ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>PreviewsEnabled</key>
	<false/>
</dict>
</plist>
</file>

<file path="ios/Runner.xcodeproj/project.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>
</file>

<file path="ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme">
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1510"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "97C146ED1CF9000F007C117D"
               BuildableName = "Runner.app"
               BlueprintName = "Runner"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      customLLDBInitFile = "$(SRCROOT)/Flutter/ephemeral/flutter_lldbinit"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "331C8080294A63A400263BE5"
               BuildableName = "RunnerTests.xctest"
               BlueprintName = "RunnerTests"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      customLLDBInitFile = "$(SRCROOT)/Flutter/ephemeral/flutter_lldbinit"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      enableGPUValidationMode = "1"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Profile"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>
</file>

<file path="ios/Runner.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>
</file>

<file path="ios/Runner.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>PreviewsEnabled</key>
	<false/>
</dict>
</plist>
</file>

<file path="ios/RunnerTests/RunnerTests.swift">
import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}
</file>

<file path="ios/.gitignore">
**/dgph
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
**/*sync/
.sconsign.dblite
.tags*
**/.vagrant/
**/DerivedData/
Icon?
**/Pods/
**/.symlinks/
profile
xcuserdata
**/.generated/
Flutter/App.framework
Flutter/Flutter.framework
Flutter/Flutter.podspec
Flutter/Generated.xcconfig
Flutter/ephemeral/
Flutter/app.flx
Flutter/app.zip
Flutter/flutter_assets/
Flutter/flutter_export_environment.sh
ServiceDefinitions.json
Runner/GeneratedPluginRegistrant.*

# Exceptions to above rules.
!default.mode1v3
!default.mode2v3
!default.pbxuser
!default.perspectivev3
</file>

<file path="lib/core/errors/domain_exception.dart">
/// Domain Layer에서 발생하는 예외
class DomainException implements Exception {
  final String message;
  final String? code;

  DomainException({
    required this.message,
    this.code,
  });

  @override
  String toString() => 'DomainException: $message${code != null ? ' ($code)' : ''}';
}
</file>

<file path="lib/core/services/secure_storage_service.dart">
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

/// Service for securely storing OAuth tokens with expiry time management.
///
/// Uses FlutterSecureStorage to encrypt and store tokens in platform-specific
/// secure storage (Keychain on iOS, KeyStore on Android).
class SecureStorageService {
  final FlutterSecureStorage _storage;

  static const _accessTokenKey = 'ACCESS_TOKEN';
  static const _accessTokenExpiresAtKey = 'ACCESS_TOKEN_EXPIRES_AT';
  static const _refreshTokenKey = 'REFRESH_TOKEN';

  SecureStorageService({FlutterSecureStorage? storage})
      : _storage = storage ?? const FlutterSecureStorage();

  /// Saves access token with its expiry time.
  ///
  /// [token] The access token string.
  /// [expiresAt] The exact DateTime when the token expires.
  Future<void> saveAccessToken(String token, DateTime expiresAt) async {
    await _storage.write(key: _accessTokenKey, value: token);
    await _storage.write(
      key: _accessTokenExpiresAtKey,
      value: expiresAt.toIso8601String(),
    );
  }

  /// Gets the access token if it's still valid.
  ///
  /// Returns null if:
  /// - No token exists
  /// - Token has expired
  /// - Expiry time cannot be parsed
  Future<String?> getAccessToken() async {
    final token = await _storage.read(key: _accessTokenKey);
    if (token == null) return null;

    // Check expiry
    final isExpired = await isAccessTokenExpired();
    if (isExpired) return null;

    return token;
  }

  /// Checks if the access token has expired.
  ///
  /// Returns true if:
  /// - No expiry time is stored
  /// - Expiry time has passed
  /// - Expiry time cannot be parsed
  Future<bool> isAccessTokenExpired() async {
    final expiresAtString = await _storage.read(key: _accessTokenExpiresAtKey);
    if (expiresAtString == null) return true;

    try {
      final expiresAt = DateTime.parse(expiresAtString);
      return DateTime.now().isAfter(expiresAt);
    } catch (e) {
      // If parsing fails, consider token expired
      return true;
    }
  }

  /// Saves refresh token securely.
  Future<void> saveRefreshToken(String token) async {
    await _storage.write(key: _refreshTokenKey, value: token);
  }

  /// Gets the refresh token.
  ///
  /// Returns null if no refresh token exists.
  Future<String?> getRefreshToken() async {
    return await _storage.read(key: _refreshTokenKey);
  }

  /// Deletes all stored tokens.
  ///
  /// This should be called on logout to ensure clean state.
  Future<void> deleteAllTokens() async {
    await _storage.delete(key: _accessTokenKey);
    await _storage.delete(key: _accessTokenExpiresAtKey);
    await _storage.delete(key: _refreshTokenKey);
  }
}
</file>

<file path="lib/core/providers.dart">
import 'package:isar/isar.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'providers.g.dart';

/// Global Isar Database Instance Provider
///
/// Provides access to the globally initialized Isar database instance.
/// The instance must be initialized in main.dart before running the app.
///
/// This provider is watched by feature repositories to perform database operations.
@riverpod
Isar isar(IsarRef ref) {
  throw UnimplementedError(
    'isarProvider must be initialized via ProviderScope override in main.dart',
  );
}
</file>

<file path="lib/features/authentication/application/providers.dart">
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:n06/features/authentication/domain/repositories/secure_storage_repository.dart';
import 'package:n06/features/authentication/domain/usecases/logout_usecase.dart';
import 'package:n06/features/authentication/infrastructure/repositories/flutter_secure_storage_repository.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:n06/features/authentication/application/notifiers/auth_notifier.dart';

part 'providers.g.dart';

/// Provider for SecureStorageRepository
@riverpod
SecureStorageRepository secureStorageRepository(SecureStorageRepositoryRef ref) {
  final secureStorage = const FlutterSecureStorage();
  return FlutterSecureStorageRepository(secureStorage);
}

/// Provider for LogoutUseCase
@riverpod
LogoutUseCase logoutUseCase(LogoutUseCaseRef ref) {
  final storageRepository = ref.watch(secureStorageRepositoryProvider);
  final authRepository = ref.watch(authRepositoryProvider);
  return LogoutUseCase(
    storageRepository: storageRepository,
    authRepository: authRepository,
  );
}
</file>

<file path="lib/features/authentication/domain/entities/consent_record.dart">
import 'package:equatable/equatable.dart';

/// ConsentRecord entity representing user consent for terms and policies
class ConsentRecord extends Equatable {
  final String id;
  final String userId;
  final bool termsOfService;
  final bool privacyPolicy;
  final DateTime agreedAt;

  const ConsentRecord({
    required this.id,
    required this.userId,
    required this.termsOfService,
    required this.privacyPolicy,
    required this.agreedAt,
  });

  ConsentRecord copyWith({
    String? id,
    String? userId,
    bool? termsOfService,
    bool? privacyPolicy,
    DateTime? agreedAt,
  }) {
    return ConsentRecord(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      termsOfService: termsOfService ?? this.termsOfService,
      privacyPolicy: privacyPolicy ?? this.privacyPolicy,
      agreedAt: agreedAt ?? this.agreedAt,
    );
  }

  @override
  List<Object?> get props => [
        id,
        userId,
        termsOfService,
        privacyPolicy,
        agreedAt,
      ];
}
</file>

<file path="lib/features/authentication/domain/entities/user.dart">
import 'package:equatable/equatable.dart';

/// User entity representing authenticated user account information
class User extends Equatable {
  final String id;
  final String oauthProvider;
  final String oauthUserId;
  final String name;
  final String email;
  final String? profileImageUrl;
  final DateTime lastLoginAt;

  const User({
    required this.id,
    required this.oauthProvider,
    required this.oauthUserId,
    required this.name,
    required this.email,
    this.profileImageUrl,
    required this.lastLoginAt,
  });

  User copyWith({
    String? id,
    String? oauthProvider,
    String? oauthUserId,
    String? name,
    String? email,
    String? profileImageUrl,
    DateTime? lastLoginAt,
  }) {
    return User(
      id: id ?? this.id,
      oauthProvider: oauthProvider ?? this.oauthProvider,
      oauthUserId: oauthUserId ?? this.oauthUserId,
      name: name ?? this.name,
      email: email ?? this.email,
      profileImageUrl: profileImageUrl ?? this.profileImageUrl,
      lastLoginAt: lastLoginAt ?? this.lastLoginAt,
    );
  }

  @override
  List<Object?> get props => [
        id,
        oauthProvider,
        oauthUserId,
        name,
        email,
        profileImageUrl,
        lastLoginAt,
      ];
}
</file>

<file path="lib/features/authentication/domain/exceptions/auth_exceptions.dart">
/// Exception thrown when OAuth authentication is cancelled by the user
class OAuthCancelledException implements Exception {
  final String message;

  OAuthCancelledException(this.message);

  @override
  String toString() => 'OAuthCancelledException: $message';
}

/// Exception thrown when maximum retry attempts are exceeded
class MaxRetriesExceededException implements Exception {
  final String message;

  MaxRetriesExceededException(this.message);

  @override
  String toString() => 'MaxRetriesExceededException: $message';
}
</file>

<file path="lib/features/authentication/domain/repositories/auth_repository.dart">
import 'package:n06/features/authentication/domain/entities/user.dart';

/// Authentication repository interface
///
/// This interface defines the contract for authentication operations.
/// Implementations should handle OAuth flow, token management, and user persistence.
abstract class AuthRepository {
  /// Login with Kakao OAuth
  ///
  /// Returns authenticated [User] on success.
  /// Throws exception on failure (network error, OAuth cancellation, etc.)
  Future<User> loginWithKakao({
    required bool agreedToTerms,
    required bool agreedToPrivacy,
  });

  /// Login with Naver OAuth
  ///
  /// Returns authenticated [User] on success.
  /// Throws exception on failure (network error, OAuth cancellation, etc.)
  Future<User> loginWithNaver({
    required bool agreedToTerms,
    required bool agreedToPrivacy,
  });

  /// Logout current user
  ///
  /// Clears all tokens and session data.
  /// Always succeeds even if network request fails (local cleanup guaranteed).
  Future<void> logout();

  /// Get currently authenticated user
  ///
  /// Returns [User] if authenticated, null otherwise.
  Future<User?> getCurrentUser();

  /// Check if this is user's first login
  ///
  /// Returns true if user has never logged in before (lastLoginAt is null).
  /// Returns false for returning users.
  Future<bool> isFirstLogin();

  /// Check if access token is still valid
  ///
  /// Returns true if token exists and not expired.
  /// Returns false otherwise.
  Future<bool> isAccessTokenValid();

  /// Refresh access token using refresh token
  ///
  /// Returns new access token on success.
  /// Throws exception if refresh token is also expired.
  Future<String> refreshAccessToken(String refreshToken);
}
</file>

<file path="lib/features/authentication/domain/repositories/secure_storage_repository.dart">
/// Secure token storage repository interface
///
/// This interface abstracts token storage operations, allowing for flexible
/// implementations (FlutterSecureStorage, Keychain, etc.)
abstract class SecureStorageRepository {
  /// Clears all stored tokens from secure storage.
  ///
  /// This method will:
  /// 1. Delete access token
  /// 2. Delete refresh token
  /// 3. Delete token expiry information
  ///
  /// Throws exception if deletion fails.
  /// Returns successfully even if tokens don't exist.
  Future<void> clearTokens();

  /// Gets the stored access token if it exists and is valid.
  ///
  /// Returns null if:
  /// - No token exists
  /// - Token has expired
  /// - Reading fails
  Future<String?> getAccessToken();

  /// Gets the stored refresh token.
  ///
  /// Returns null if no refresh token exists.
  Future<String?> getRefreshToken();

  /// Gets the token expiry time.
  ///
  /// Returns null if no expiry time is stored.
  Future<DateTime?> getTokenExpiresAt();

  /// Checks if the access token has expired.
  ///
  /// Returns true if:
  /// - No token exists
  /// - Token has expired
  /// - Expiry time cannot be parsed
  Future<bool> isAccessTokenExpired();

  /// Saves access token with expiry time.
  Future<void> saveAccessToken(String token, DateTime expiresAt);

  /// Saves refresh token.
  Future<void> saveRefreshToken(String token);
}
</file>

<file path="lib/features/authentication/domain/usecases/logout_usecase.dart">
import 'package:n06/features/authentication/domain/repositories/auth_repository.dart';
import 'package:n06/features/authentication/domain/repositories/secure_storage_repository.dart';

/// Logout use case
///
/// Handles the complete logout process:
/// 1. Clears tokens from secure storage (with retry logic)
/// 2. Clears session from auth repository
/// 3. Preserves local Isar data (Phase 0)
///
/// The logout process is designed to be resilient:
/// - Token deletion will retry up to 3 times
/// - Session clearing always happens, even if token deletion fails
/// - Network errors are handled gracefully
class LogoutUseCase {
  final SecureStorageRepository _storageRepository;
  final AuthRepository _authRepository;

  static const int _maxRetries = 3;
  static const int _retryDelayMs = 100;

  LogoutUseCase({
    required SecureStorageRepository storageRepository,
    required AuthRepository authRepository,
  })  : _storageRepository = storageRepository,
        _authRepository = authRepository;

  /// Execute logout process
  ///
  /// Returns successfully when:
  /// - Tokens are cleared (with retries)
  /// - Session is cleared
  ///
  /// Throws exception only if critical operations fail
  Future<void> execute() async {
    // Step 1: Clear tokens from secure storage (with retry)
    await _clearTokensWithRetry();

    // Step 2: Clear session (always happens, even if token clearing fails)
    await _authRepository.logout();
  }

  /// Clear tokens with retry logic
  ///
  /// Retries up to 3 times before giving up
  /// After all retries exhausted, continues with session clearing
  /// (per EC3: Even if token deletion fails, session must be cleared)
  Future<void> _clearTokensWithRetry() async {
    for (int attempt = 1; attempt <= _maxRetries; attempt++) {
      try {
        await _storageRepository.clearTokens();
        return; // Success
      } catch (e) {
        if (attempt < _maxRetries) {
          // Wait before retrying
          await Future.delayed(Duration(milliseconds: _retryDelayMs));
        }
        // If last attempt, silently fail and continue to session clearing
      }
    }
  }
}
</file>

<file path="lib/features/authentication/infrastructure/dtos/consent_record_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/authentication/domain/entities/consent_record.dart';

part 'consent_record_dto.g.dart';

/// Isar DTO for ConsentRecord entity.
///
/// Stores user consent information in Isar local database.
@collection
class ConsentRecordDto {
  ConsentRecordDto();

  Id id = Isar.autoIncrement;

  @Index()
  late String userId;

  late bool termsOfService;
  late bool privacyPolicy;
  late DateTime agreedAt;

  /// Converts DTO to Domain Entity.
  ConsentRecord toEntity() {
    return ConsentRecord(
      id: id.toString(),
      userId: userId,
      termsOfService: termsOfService,
      privacyPolicy: privacyPolicy,
      agreedAt: agreedAt,
    );
  }

  /// Creates DTO from Domain Entity.
  factory ConsentRecordDto.fromEntity(ConsentRecord entity) {
    return ConsentRecordDto()
      ..id = entity.id.isNotEmpty ? int.tryParse(entity.id) ?? Isar.autoIncrement : Isar.autoIncrement
      ..userId = entity.userId
      ..termsOfService = entity.termsOfService
      ..privacyPolicy = entity.privacyPolicy
      ..agreedAt = entity.agreedAt;
  }
}
</file>

<file path="lib/features/authentication/infrastructure/dtos/user_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/authentication/domain/entities/user.dart';

part 'user_dto.g.dart';

/// Isar DTO for User entity.
///
/// Stores user account information in Isar local database.
@collection
class UserDto {
  UserDto();

  Id id = Isar.autoIncrement;

  @Index(unique: true, composite: [CompositeIndex('oauthUserId')])
  late String oauthProvider;

  late String oauthUserId;
  late String name;
  late String email;
  String? profileImageUrl;
  late DateTime lastLoginAt;

  /// Converts DTO to Domain Entity.
  User toEntity() {
    return User(
      id: id.toString(),
      oauthProvider: oauthProvider,
      oauthUserId: oauthUserId,
      name: name,
      email: email,
      profileImageUrl: profileImageUrl,
      lastLoginAt: lastLoginAt,
    );
  }

  /// Creates DTO from Domain Entity.
  factory UserDto.fromEntity(User entity) {
    return UserDto()
      ..id = entity.id.isNotEmpty ? int.tryParse(entity.id) ?? Isar.autoIncrement : Isar.autoIncrement
      ..oauthProvider = entity.oauthProvider
      ..oauthUserId = entity.oauthUserId
      ..name = entity.name
      ..email = entity.email
      ..profileImageUrl = entity.profileImageUrl
      ..lastLoginAt = entity.lastLoginAt;
  }
}
</file>

<file path="lib/features/authentication/infrastructure/repositories/flutter_secure_storage_repository.dart">
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:n06/features/authentication/domain/repositories/secure_storage_repository.dart';

/// FlutterSecureStorage implementation of SecureStorageRepository
///
/// Manages OAuth tokens and expiry times using platform-specific secure storage:
/// - iOS: Keychain
/// - Android: KeyStore
/// - Windows/Linux: Encrypted file
class FlutterSecureStorageRepository implements SecureStorageRepository {
  final FlutterSecureStorage _storage;

  static const String _accessTokenKey = 'ACCESS_TOKEN';
  static const String _refreshTokenKey = 'REFRESH_TOKEN';
  static const String _tokenExpiresAtKey = 'TOKEN_EXPIRES_AT';

  FlutterSecureStorageRepository(this._storage);

  @override
  Future<void> clearTokens() async {
    await _storage.delete(key: _accessTokenKey);
    await _storage.delete(key: _refreshTokenKey);
    await _storage.delete(key: _tokenExpiresAtKey);
  }

  @override
  Future<String?> getAccessToken() async {
    final token = await _storage.read(key: _accessTokenKey);
    if (token == null) return null;

    // Check if token has expired
    final isExpired = await isAccessTokenExpired();
    if (isExpired) return null;

    return token;
  }

  @override
  Future<String?> getRefreshToken() async {
    return await _storage.read(key: _refreshTokenKey);
  }

  @override
  Future<DateTime?> getTokenExpiresAt() async {
    final expiresAtString = await _storage.read(key: _tokenExpiresAtKey);
    if (expiresAtString == null) return null;

    try {
      return DateTime.parse(expiresAtString);
    } catch (e) {
      return null;
    }
  }

  @override
  Future<bool> isAccessTokenExpired() async {
    final expiresAtString = await _storage.read(key: _tokenExpiresAtKey);
    if (expiresAtString == null) return true;

    try {
      final expiresAt = DateTime.parse(expiresAtString);
      return DateTime.now().isAfter(expiresAt);
    } catch (e) {
      // If parsing fails, consider token expired
      return true;
    }
  }

  @override
  Future<void> saveAccessToken(String token, DateTime expiresAt) async {
    await _storage.write(key: _accessTokenKey, value: token);
    await _storage.write(
      key: _tokenExpiresAtKey,
      value: expiresAt.toIso8601String(),
    );
  }

  @override
  Future<void> saveRefreshToken(String token) async {
    await _storage.write(key: _refreshTokenKey, value: token);
  }
}
</file>

<file path="lib/features/authentication/presentation/widgets/logout_confirm_dialog.dart">
import 'package:flutter/material.dart';

/// Logout confirmation dialog
///
/// Shows a confirmation dialog asking the user if they want to logout.
/// Prevents accidental logouts through user confirmation.
class LogoutConfirmDialog extends StatelessWidget {
  /// Callback when user confirms logout
  final VoidCallback onConfirm;

  /// Optional callback when user cancels
  final VoidCallback? onCancel;

  const LogoutConfirmDialog({
    super.key,
    required this.onConfirm,
    this.onCancel,
  });

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('로그아웃'),
      content: const Text('로그아웃하시겠습니까?'),
      actions: [
        TextButton(
          onPressed: () {
            Navigator.pop(context);
            onCancel?.call();
          },
          child: const Text('취소'),
        ),
        ElevatedButton(
          onPressed: () {
            Navigator.pop(context);
            onConfirm();
          },
          child: const Text('확인'),
        ),
      ],
    );
  }
}
</file>

<file path="lib/features/coping_guide/application/notifiers/coping_guide_notifier.dart">
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../domain/entities/coping_guide.dart';
import '../../domain/entities/coping_guide_state.dart';
import '../../domain/entities/guide_feedback.dart';
import '../providers.dart';

part 'coping_guide_notifier.g.dart';

/// 부작용 대처 가이드 조회 및 관리 Notifier
@riverpod
class CopingGuideNotifier extends _$CopingGuideNotifier {
  @override
  Future<CopingGuideState> build() async {
    final defaultGuide = CopingGuide(
      symptomName: '일반',
      shortGuide: '전문가와 상담하여 구체적인 조언을 받으시기 바랍니다.',
    );
    return CopingGuideState(guide: defaultGuide);
  }

  /// 증상명으로 가이드 조회
  Future<void> getGuideBySymptom(String symptomName) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(copingGuideRepositoryProvider);
      final guide = await repository.getGuideBySymptom(symptomName);

      if (guide == null) {
        // 기본 가이드 반환
        return CopingGuideState(
          guide: CopingGuide(
            symptomName: '일반',
            shortGuide: '전문가와 상담하여 구체적인 조언을 받으시기 바랍니다.',
          ),
        );
      }

      return CopingGuideState(guide: guide);
    });
  }

  /// 심각도 확인 및 가이드 조회
  /// [symptomName]: 증상명
  /// [severity]: 심각도 (1-10)
  /// [isPersistent24h]: 24시간 이상 지속 여부
  Future<void> checkSeverityAndGuide(
    String symptomName,
    int severity,
    bool isPersistent24h,
  ) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(copingGuideRepositoryProvider);
      final guide = await repository.getGuideBySymptom(symptomName) ??
          CopingGuide(
            symptomName: '일반',
            shortGuide: '전문가와 상담하여 구체적인 조언을 받으시기 바랍니다.',
          );

      // 심각도 7-10점 AND 24시간 이상 지속 시 경고 활성화
      final showWarning = severity >= 7 && isPersistent24h;

      return CopingGuideState(
        guide: guide,
        showSeverityWarning: showWarning,
      );
    });
  }

  /// 피드백 제출
  Future<void> submitFeedback(String symptomName, {required bool helpful}) async {
    final repository = ref.read(feedbackRepositoryProvider);
    final feedback = GuideFeedback(
      symptomName: symptomName,
      helpful: helpful,
      timestamp: DateTime.now(),
    );
    await repository.saveFeedback(feedback);
  }
}

/// 모든 가이드 목록 조회 Notifier
@riverpod
class CopingGuideListNotifier extends _$CopingGuideListNotifier {
  @override
  Future<List<CopingGuide>> build() async {
    return [];
  }

  /// 모든 가이드 로드
  Future<void> loadAllGuides() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(copingGuideRepositoryProvider);
      return repository.getAllGuides();
    });
  }
}
</file>

<file path="lib/features/coping_guide/application/providers.dart">
import 'package:isar/isar.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../domain/repositories/coping_guide_repository.dart';
import '../domain/repositories/feedback_repository.dart';
import '../infrastructure/repositories/isar_feedback_repository.dart';
import '../infrastructure/repositories/static_coping_guide_repository.dart';

part 'providers.g.dart';

/// Isar 인스턴스 Provider (from core)
@riverpod
Isar isar(IsarRef ref) {
  throw UnimplementedError('isarProvider must be implemented in core');
}

@riverpod
CopingGuideRepository copingGuideRepository(CopingGuideRepositoryRef ref) {
  return StaticCopingGuideRepository();
}

@riverpod
FeedbackRepository feedbackRepository(FeedbackRepositoryRef ref) {
  final isarInstance = ref.watch(isarProvider);
  return IsarFeedbackRepository(isarInstance);
}
</file>

<file path="lib/features/coping_guide/domain/entities/coping_guide_state.dart">
import 'package:flutter/foundation.dart';
import 'coping_guide.dart';

/// 가이드 상태 (심각도 경고 포함)
@immutable
class CopingGuideState {
  final CopingGuide guide;
  final bool showSeverityWarning;

  const CopingGuideState({
    required this.guide,
    this.showSeverityWarning = false,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CopingGuideState &&
          runtimeType == other.runtimeType &&
          guide == other.guide &&
          showSeverityWarning == other.showSeverityWarning;

  @override
  int get hashCode => guide.hashCode ^ showSeverityWarning.hashCode;

  @override
  String toString() =>
      'CopingGuideState(guide: $guide, showSeverityWarning: $showSeverityWarning)';
}
</file>

<file path="lib/features/coping_guide/domain/entities/coping_guide.dart">
import 'package:flutter/foundation.dart';

import 'guide_section.dart';

/// 부작용 대처 가이드 엔터티
@immutable
class CopingGuide {
  final String symptomName;
  final String shortGuide;
  final List<GuideSection>? detailedSections;

  const CopingGuide({
    required this.symptomName,
    required this.shortGuide,
    this.detailedSections,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CopingGuide &&
          runtimeType == other.runtimeType &&
          symptomName == other.symptomName &&
          shortGuide == other.shortGuide &&
          detailedSections == other.detailedSections;

  @override
  int get hashCode =>
      symptomName.hashCode ^ shortGuide.hashCode ^ detailedSections.hashCode;

  @override
  String toString() =>
      'CopingGuide(symptomName: $symptomName, shortGuide: $shortGuide, detailedSections: $detailedSections)';
}
</file>

<file path="lib/features/coping_guide/domain/entities/guide_feedback.dart">
import 'package:flutter/foundation.dart';

/// 가이드 피드백 엔터티 (도움이 되었는지 여부)
@immutable
class GuideFeedback {
  final String symptomName;
  final bool helpful;
  final DateTime timestamp;

  const GuideFeedback({
    required this.symptomName,
    required this.helpful,
    required this.timestamp,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GuideFeedback &&
          runtimeType == other.runtimeType &&
          symptomName == other.symptomName &&
          helpful == other.helpful &&
          timestamp == other.timestamp;

  @override
  int get hashCode =>
      symptomName.hashCode ^ helpful.hashCode ^ timestamp.hashCode;

  @override
  String toString() =>
      'GuideFeedback(symptomName: $symptomName, helpful: $helpful, timestamp: $timestamp)';
}
</file>

<file path="lib/features/coping_guide/domain/entities/guide_section.dart">
import 'package:flutter/foundation.dart';

/// 상세 가이드 섹션 (제목과 내용)
@immutable
class GuideSection {
  final String title;
  final String content;

  const GuideSection({
    required this.title,
    required this.content,
  });

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GuideSection &&
          runtimeType == other.runtimeType &&
          title == other.title &&
          content == other.content;

  @override
  int get hashCode => title.hashCode ^ content.hashCode;

  @override
  String toString() => 'GuideSection(title: $title, content: $content)';
}
</file>

<file path="lib/features/coping_guide/domain/repositories/coping_guide_repository.dart">
import '../entities/coping_guide.dart';

/// 부작용 대처 가이드 조회 인터페이스
abstract class CopingGuideRepository {
  /// 증상명으로 가이드 조회
  ///
  /// [symptomName]: 증상 이름
  /// 반환: 해당 증상의 가이드, 없으면 null
  Future<CopingGuide?> getGuideBySymptom(String symptomName);

  /// 모든 증상의 가이드 목록 조회
  ///
  /// 반환: 모든 증상의 가이드 리스트
  Future<List<CopingGuide>> getAllGuides();
}
</file>

<file path="lib/features/coping_guide/domain/repositories/feedback_repository.dart">
import '../entities/guide_feedback.dart';

/// 가이드 피드백 저장 인터페이스
abstract class FeedbackRepository {
  /// 피드백 저장
  ///
  /// [feedback]: 저장할 피드백
  Future<void> saveFeedback(GuideFeedback feedback);

  /// 증상별 피드백 조회
  ///
  /// [symptomName]: 증상 이름
  /// 반환: 해당 증상의 피드백 리스트
  Future<List<GuideFeedback>> getFeedbacksBySymptom(String symptomName);
}
</file>

<file path="lib/features/coping_guide/infrastructure/dtos/guide_feedback_dto.dart">
import 'package:isar/isar.dart';

import '../../domain/entities/guide_feedback.dart';

part 'guide_feedback_dto.g.dart';

/// 가이드 피드백 DTO (Isar 모델)
@Collection()
class GuideFeedbackDto {
  Id id = Isar.autoIncrement;
  late String symptomName;
  late bool helpful;
  late DateTime timestamp;

  /// Entity로 변환
  GuideFeedback toEntity() => GuideFeedback(
        symptomName: symptomName,
        helpful: helpful,
        timestamp: timestamp,
      );

  /// Entity에서 DTO로 생성
  static GuideFeedbackDto fromEntity(GuideFeedback entity) {
    return GuideFeedbackDto()
      ..symptomName = entity.symptomName
      ..helpful = entity.helpful
      ..timestamp = entity.timestamp;
  }
}
</file>

<file path="lib/features/coping_guide/infrastructure/repositories/isar_feedback_repository.dart">
import 'package:isar/isar.dart';

import '../../domain/entities/guide_feedback.dart';
import '../../domain/repositories/feedback_repository.dart';
import '../dtos/guide_feedback_dto.dart';

/// Isar를 통한 피드백 저장 구현체
class IsarFeedbackRepository implements FeedbackRepository {
  final Isar isar;

  IsarFeedbackRepository(this.isar);

  @override
  Future<void> saveFeedback(GuideFeedback feedback) async {
    final dto = GuideFeedbackDto.fromEntity(feedback);
    await isar.writeTxn(() async {
      await isar.guideFeedbackDtos.put(dto);
    });
  }

  @override
  Future<List<GuideFeedback>> getFeedbacksBySymptom(String symptomName) async {
    final dtos = await isar.guideFeedbackDtos
        .filter()
        .symptomNameEqualTo(symptomName)
        .findAll();
    return dtos.map((dto) => dto.toEntity()).toList();
  }
}
</file>

<file path="lib/features/coping_guide/infrastructure/repositories/static_coping_guide_repository.dart">
import '../../domain/entities/coping_guide.dart';
import '../../domain/entities/guide_section.dart';
import '../../domain/repositories/coping_guide_repository.dart';

/// 정적 가이드 데이터를 제공하는 Repository 구현
class StaticCopingGuideRepository implements CopingGuideRepository {
  static const Map<String, CopingGuide> _guides = {
    '메스꺼움': CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '소량씩 자주 식사하고, 생강차나 박하 음료를 마시세요.',
      detailedSections: [
        GuideSection(
          title: '즉시 조치',
          content: '- 천천히 깊게 숨 쉬기\n- 신선한 공기 마시기\n- 생강, 박하 등의 향기 맡기\n- 얼음 조각 천천히 먹기',
        ),
        GuideSection(
          title: '식이 조절',
          content: '- 소량의 음식을 자주 먹기\n- 차갑고 가벼운 음식 선택 (요거트, 과일, 국수)\n- 기름진 음식, 카페인, 자극적인 음식 피하기\n- 수분 섭취 (물, 스포츠음료, 맑은 국)',
        ),
        GuideSection(
          title: '생활 습관',
          content: '- 충분한 휴식 취하기\n- 천천히 움직이기\n- 주사 후 2-3시간 뒤에 식사하기\n- 스트레스 관리하기',
        ),
        GuideSection(
          title: '경과 관찰',
          content: '- 3-5일 후 증상 개선되는지 확인\n- 식사 후 1시간 동안 누워있기\n- 증상 강도나 빈도가 증가하면 의료진 상담\n- 수분 섭취량 추적하기',
        ),
      ],
    ),
    '구토': CopingGuide(
      symptomName: '구토',
      shortGuide: '수분을 조금씩 자주 마시고, 회복 단계별로 천천히 음식을 섭취하세요.',
      detailedSections: [
        GuideSection(
          title: '즉시 조치',
          content: '- 침대에서 휴식\n- 깊게 숨쉬기\n- 냉수로 입헹굼\n- 2시간 동안 음식 피하기',
        ),
        GuideSection(
          title: '식이 조절',
          content: '- 맑은 음료부터 시작 (물, 스포츠음료, 맑은 국)\n- 2-4시간마다 작은 양의 액체 (스푼 한두 개)\n- 6시간 후 고체음식 시작 (크래커, 쌀밥)\n- 자극적이지 않은 부드러운 음식 선택',
        ),
        GuideSection(
          title: '생활 습관',
          content: '- 편한 자세로 누워있기\n- 찬 수건으로 이마와 목 식히기\n- 구토 후 입 헹굼\n- 야한 냄새 피하기',
        ),
        GuideSection(
          title: '경과 관찰',
          content: '- 체온 모니터링\n- 수분 섭취 상태 확인\n- 2-3시간 구토 없이 지나면 진전\n- 지속적인 구토는 의료진 상담 필수',
        ),
      ],
    ),
    '변비': CopingGuide(
      symptomName: '변비',
      shortGuide: '섬유질과 수분 섭취를 늘리고, 신체 활동을 유지하세요.',
      detailedSections: [
        GuideSection(
          title: '즉시 조치',
          content: '- 따뜻한 물 마시기\n- 온찜질 또는 따뜻한 목욕\n- 가벼운 복부 마사지 (시계 방향)\n- 화장실 시간 정하기',
        ),
        GuideSection(
          title: '식이 조절',
          content: '- 수분 섭취 증가 (하루 2-3리터)\n- 섬유질 풍부한 음식 (과일, 채소, 통곡물)\n- 자두, 무화과, 키위, 메론 섭취\n- 아침에 따뜻한 음료 마시기',
        ),
        GuideSection(
          title: '생활 습관',
          content: '- 하루 30분 이상 운동\n- 화장실 가기 좋은 시간 정하기 (보통 아침)\n- 서둘지 않기\n- 규칙적인 일일 스케줄 유지',
        ),
        GuideSection(
          title: '경과 관찰',
          content: '- 2-3일 이내 개선 여부 확인\n- 변의 부드러움 정도 관찰\n- 복부 불편감 모니터링\n- 1주일 이상 지속되면 의료진 상담',
        ),
      ],
    ),
    '설사': CopingGuide(
      symptomName: '설사',
      shortGuide: '수분과 전해질을 보충하고, 소화 부담을 줄이세요.',
      detailedSections: [
        GuideSection(
          title: '즉시 조치',
          content: '- 수분 섭취 (스포츠음료, 이온 음료)\n- 염분과 당분 균형 유지\n- 카페인 피하기\n- 복부 열 가하기',
        ),
        GuideSection(
          title: '식이 조절',
          content: '- BRAT 식단 (바나나, 쌀, 사과, 토스트)\n- 부드럽고 소화 잘 되는 음식\n- 유제품, 자극적인 음식 피하기\n- 수프나 미음 같은 따뜻한 음식',
        ),
        GuideSection(
          title: '생활 습관',
          content: '- 충분한 휴식\n- 위생 관리 철저\n- 손 자주 씻기\n- 스트레스 관리',
        ),
        GuideSection(
          title: '경과 관찰',
          content: '- 24시간마다 수분 섭취 기록\n- 배변 횟수와 형태 추적\n- 복부 경련 정도 모니터링\n- 48시간 이상 지속되면 의료진 상담',
        ),
      ],
    ),
    '복통': CopingGuide(
      symptomName: '복통',
      shortGuide: '온찜질을 하고, 가벼운 식사를 하며, 스트레스를 관리하세요.',
      detailedSections: [
        GuideSection(
          title: '즉시 조치',
          content: '- 따뜻한 물병으로 온찜질\n- 편안한 자세로 누워있기\n- 천천히 깊게 숨 쉬기\n- 복부 마사지 (가볍게)',
        ),
        GuideSection(
          title: '식이 조절',
          content: '- 소량의 가벼운 음식\n- 부드러운 음식 선택\n- 기름진 음식, 자극적인 음식 피하기\n- 따뜻한 음료 (생강차, 민트차)',
        ),
        GuideSection(
          title: '생활 습관',
          content: '- 충분한 휴식\n- 스트레스 관리 (명상, 심호흡)\n- 가벼운 운동 (산책)\n- 규칙적인 일일 생활',
        ),
        GuideSection(
          title: '경과 관찰',
          content: '- 통증 위치와 강도 기록\n- 음식과의 연관성 추적\n- 배변과의 관계 확인\n- 심하거나 지속되면 의료진 상담',
        ),
      ],
    ),
    '두통': CopingGuide(
      symptomName: '두통',
      shortGuide: '충분한 수분을 섭취하고, 휴식을 취하며, 스트레스를 줄이세요.',
      detailedSections: [
        GuideSection(
          title: '즉시 조치',
          content: '- 수분 섭취 (시간당 250ml)\n- 어두운 환경에서 휴식\n- 찬 또는 따뜻한 찜질\n- 목과 어깨 이완 스트레칭',
        ),
        GuideSection(
          title: '식이 조절',
          content: '- 규칙적인 식사\n- 카페인 피하기\n- 알코올 금지\n- 에너지 음료 피하기\n- 철분이 풍부한 음식 섭취',
        ),
        GuideSection(
          title: '생활 습관',
          content: '- 7-9시간 충분한 수면\n- 정기적인 운동\n- 근육 이완 기술\n- 휴식 시간 정하기',
        ),
        GuideSection(
          title: '경과 관찰',
          content: '- 두통 일기 작성\n- 유발 요인 추적\n- 통증 강도와 지속 시간 기록\n- 심하거나 지속되면 의료진 상담',
        ),
      ],
    ),
    '피로': CopingGuide(
      symptomName: '피로',
      shortGuide: '충분한 수면과 영양가 있는 식사를 하고, 활동을 조절하세요.',
      detailedSections: [
        GuideSection(
          title: '즉시 조치',
          content: '- 편안한 수면 환경 조성\n- 낮 시간에 가벼운 휴식\n- 신선한 공기 마시기\n- 명상이나 심호흡',
        ),
        GuideSection(
          title: '식이 조절',
          content: '- 균형 잡힌 영양가 높은 식사\n- 철분이 풍부한 음식 (붉은 육류, 시금치)\n- B 비타민 섭취 (계란, 통곡물)\n- 정크 푸드 피하기',
        ),
        GuideSection(
          title: '생활 습관',
          content: '- 8-10시간 충분한 수면\n- 일과 휴식의 균형\n- 가벼운 운동 (산책, 스트레칭)\n- 취침 시간 정하기',
        ),
        GuideSection(
          title: '경과 관찰',
          content: '- 에너지 수준 추적\n- 수면의 질 모니터링\n- 식사 후 에너지 변화 기록\n- 2주 이상 지속되면 의료진 상담',
        ),
      ],
    ),
  };

  @override
  Future<CopingGuide?> getGuideBySymptom(String symptomName) async {
    return _guides[symptomName];
  }

  @override
  Future<List<CopingGuide>> getAllGuides() async {
    return _guides.values.toList();
  }
}
</file>

<file path="lib/features/coping_guide/presentation/screens/coping_guide_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/notifiers/coping_guide_notifier.dart';
import '../widgets/coping_guide_card.dart';
import 'detailed_guide_screen.dart';

/// 부작용 대처 가이드 탭 화면
class CopingGuideScreen extends ConsumerStatefulWidget {
  const CopingGuideScreen({super.key});

  @override
  ConsumerState<CopingGuideScreen> createState() => _CopingGuideScreenState();
}

class _CopingGuideScreenState extends ConsumerState<CopingGuideScreen> {
  @override
  void initState() {
    super.initState();
    // 가이드 목록 로드
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(copingGuideListNotifierProvider.notifier).loadAllGuides();
    });
  }

  @override
  Widget build(BuildContext context) {
    final guideList = ref.watch(copingGuideListNotifierProvider);

    return Scaffold(
      appBar: AppBar(
        title: Text('부작용 대처 가이드'),
      ),
      body: guideList.when(
        loading: () => Center(child: CircularProgressIndicator()),
        error: (err, stack) => Center(child: Text('오류가 발생했습니다')),
        data: (guides) {
          if (guides.isEmpty) {
            return Center(child: Text('가이드가 없습니다'));
          }

          return ListView.builder(
            itemCount: guides.length,
            itemBuilder: (context, index) {
              final guide = guides[index];
              return CopingGuideCard(
                guide: guide,
                onDetailTap: () {
                  Navigator.of(context).push(
                    MaterialPageRoute(
                      builder: (_) => DetailedGuideScreen(guide: guide),
                    ),
                  );
                },
                onFeedback: (helpful) {
                  ref
                      .read(copingGuideNotifierProvider.notifier)
                      .submitFeedback(guide.symptomName, helpful: helpful);
                },
              );
            },
          );
        },
      ),
    );
  }
}
</file>

<file path="lib/features/coping_guide/presentation/screens/detailed_guide_screen.dart">
import 'package:flutter/material.dart';

import '../../domain/entities/coping_guide.dart';

/// 상세 가이드 화면
class DetailedGuideScreen extends StatelessWidget {
  final CopingGuide guide;

  const DetailedGuideScreen({required this.guide, super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('${guide.symptomName} 대처 가이드'),
      ),
      body: SingleChildScrollView(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              guide.symptomName,
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            SizedBox(height: 16),
            if (guide.detailedSections != null &&
                guide.detailedSections!.isNotEmpty)
              ...guide.detailedSections!.map((section) {
                return Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      section.title,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                    ),
                    SizedBox(height: 8),
                    Text(
                      section.content,
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                    SizedBox(height: 24),
                  ],
                );
              }),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/coping_guide/presentation/widgets/coping_guide_card.dart">
import 'package:flutter/material.dart';

import '../../domain/entities/coping_guide.dart';
import '../../domain/entities/coping_guide_state.dart';
import 'feedback_widget.dart';
import 'severity_warning_banner.dart';

/// 부작용 대처 가이드 카드
class CopingGuideCard extends StatelessWidget {
  final CopingGuide? guide;
  final CopingGuideState? state;
  final VoidCallback? onDetailTap;
  final VoidCallback? onCheckSymptom;
  final Function(bool)? onFeedback;

  const CopingGuideCard({
    this.guide,
    this.state,
    this.onDetailTap,
    this.onCheckSymptom,
    this.onFeedback,
    super.key,
  }) : assert(guide != null || state != null);

  @override
  Widget build(BuildContext context) {
    final currentGuide = state?.guide ?? guide!;
    final showWarning = state?.showSeverityWarning ?? false;

    return Card(
      margin: EdgeInsets.all(16),
      child: Padding(
        padding: EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (showWarning && onCheckSymptom != null) ...[
              SeverityWarningBanner(onCheckSymptom: onCheckSymptom!),
              SizedBox(height: 16),
            ],
            Text(
              '${currentGuide.symptomName} 대처 가이드',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            SizedBox(height: 12),
            Text(
              currentGuide.shortGuide,
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            SizedBox(height: 16),
            Row(
              children: [
                ElevatedButton(
                  onPressed: onDetailTap,
                  child: Text('더 자세한 가이드 보기'),
                ),
              ],
            ),
            SizedBox(height: 16),
            if (onFeedback != null)
              FeedbackWidget(onFeedback: onFeedback!),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/coping_guide/presentation/widgets/feedback_widget.dart">
import 'package:flutter/material.dart';

/// 피드백 위젯 (도움이 되었나요?)
class FeedbackWidget extends StatefulWidget {
  final Function(bool) onFeedback;

  const FeedbackWidget({required this.onFeedback, super.key});

  @override
  State<FeedbackWidget> createState() => _FeedbackWidgetState();
}

class _FeedbackWidgetState extends State<FeedbackWidget> {
  bool? _feedbackGiven;

  @override
  Widget build(BuildContext context) {
    if (_feedbackGiven != null) {
      return Padding(
        padding: EdgeInsets.all(16),
        child: Center(
          child: Text(
            _feedbackGiven! ? '도움이 되어 기쁩니다!' : '더 자세한 가이드 보기',
            style: Theme.of(context).textTheme.bodyLarge,
          ),
        ),
      );
    }

    return Padding(
      padding: EdgeInsets.all(16),
      child: Column(
        children: [
          Text(
            '도움이 되었나요?',
            style: Theme.of(context).textTheme.titleMedium,
          ),
          SizedBox(height: 12),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              ElevatedButton(
                onPressed: () {
                  widget.onFeedback(true);
                  setState(() {
                    _feedbackGiven = true;
                  });
                },
                child: Text('예'),
              ),
              SizedBox(width: 12),
              ElevatedButton(
                onPressed: () {
                  widget.onFeedback(false);
                  setState(() {
                    _feedbackGiven = false;
                  });
                },
                child: Text('아니오'),
              ),
            ],
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/coping_guide/presentation/widgets/severity_warning_banner.dart">
import 'package:flutter/material.dart';

/// 심각도 경고 배너
class SeverityWarningBanner extends StatelessWidget {
  final VoidCallback onCheckSymptom;

  const SeverityWarningBanner({required this.onCheckSymptom, super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.red.shade100,
      padding: EdgeInsets.all(16),
      child: Column(
        children: [
          Row(
            children: [
              Icon(Icons.warning, color: Colors.red),
              SizedBox(width: 12),
              Expanded(
                child: Text(
                  '증상이 심각하거나 지속됩니다',
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: Colors.red.shade900,
                        fontWeight: FontWeight.bold,
                      ),
                ),
              ),
            ],
          ),
          SizedBox(height: 12),
          ElevatedButton(
            onPressed: onCheckSymptom,
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            child: Text('증상 체크하기'),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/dashboard/domain/entities/badge_definition.dart">
import 'package:equatable/equatable.dart';

enum BadgeCategory {
  streak,
  weight,
  dose,
  record,
}

class BadgeDefinition extends Equatable {
  final String id;
  final String name;
  final String description;
  final BadgeCategory category;
  final String? iconUrl;
  final int displayOrder;

  const BadgeDefinition({
    required this.id,
    required this.name,
    required this.description,
    required this.category,
    this.iconUrl,
    required this.displayOrder,
  });

  BadgeDefinition copyWith({
    String? id,
    String? name,
    String? description,
    BadgeCategory? category,
    String? iconUrl,
    int? displayOrder,
  }) {
    return BadgeDefinition(
      id: id ?? this.id,
      name: name ?? this.name,
      description: description ?? this.description,
      category: category ?? this.category,
      iconUrl: iconUrl ?? this.iconUrl,
      displayOrder: displayOrder ?? this.displayOrder,
    );
  }

  @override
  List<Object?> get props =>
      [id, name, description, category, iconUrl, displayOrder];

  @override
  String toString() => 'BadgeDefinition(id: $id, name: $name, category: $category)';
}
</file>

<file path="lib/features/dashboard/domain/entities/dashboard_data.dart">
import 'package:equatable/equatable.dart';
import 'package:n06/features/dashboard/domain/entities/next_schedule.dart';
import 'package:n06/features/dashboard/domain/entities/timeline_event.dart';
import 'package:n06/features/dashboard/domain/entities/user_badge.dart';
import 'package:n06/features/dashboard/domain/entities/weekly_progress.dart';
import 'package:n06/features/dashboard/domain/entities/weekly_summary.dart';

class DashboardData extends Equatable {
  final String userName;
  final int continuousRecordDays;
  final int currentWeek;
  final WeeklyProgress weeklyProgress;
  final NextSchedule nextSchedule;
  final WeeklySummary weeklySummary;
  final List<UserBadge> badges;
  final List<TimelineEvent> timeline;
  final String? insightMessage;

  const DashboardData({
    required this.userName,
    required this.continuousRecordDays,
    required this.currentWeek,
    required this.weeklyProgress,
    required this.nextSchedule,
    required this.weeklySummary,
    required this.badges,
    required this.timeline,
    this.insightMessage,
  });

  DashboardData copyWith({
    String? userName,
    int? continuousRecordDays,
    int? currentWeek,
    WeeklyProgress? weeklyProgress,
    NextSchedule? nextSchedule,
    WeeklySummary? weeklySummary,
    List<UserBadge>? badges,
    List<TimelineEvent>? timeline,
    String? insightMessage,
  }) {
    return DashboardData(
      userName: userName ?? this.userName,
      continuousRecordDays: continuousRecordDays ?? this.continuousRecordDays,
      currentWeek: currentWeek ?? this.currentWeek,
      weeklyProgress: weeklyProgress ?? this.weeklyProgress,
      nextSchedule: nextSchedule ?? this.nextSchedule,
      weeklySummary: weeklySummary ?? this.weeklySummary,
      badges: badges ?? this.badges,
      timeline: timeline ?? this.timeline,
      insightMessage: insightMessage ?? this.insightMessage,
    );
  }

  @override
  List<Object?> get props => [
        userName,
        continuousRecordDays,
        currentWeek,
        weeklyProgress,
        nextSchedule,
        weeklySummary,
        badges,
        timeline,
        insightMessage,
      ];

  @override
  String toString() =>
      'DashboardData(userName: $userName, continuousRecordDays: $continuousRecordDays, currentWeek: $currentWeek)';
}
</file>

<file path="lib/features/dashboard/domain/entities/index.dart">
export 'dashboard_data.dart';
export 'weekly_progress.dart';
export 'next_schedule.dart';
export 'weekly_summary.dart';
export 'timeline_event.dart';
export 'badge_definition.dart';
export 'user_badge.dart';
</file>

<file path="lib/features/dashboard/domain/entities/next_schedule.dart">
import 'package:equatable/equatable.dart';

class NextSchedule extends Equatable {
  final DateTime nextDoseDate;
  final double nextDoseMg;
  final DateTime? nextEscalationDate;
  final DateTime? goalEstimateDate;

  const NextSchedule({
    required this.nextDoseDate,
    required this.nextDoseMg,
    this.nextEscalationDate,
    this.goalEstimateDate,
  });

  NextSchedule copyWith({
    DateTime? nextDoseDate,
    double? nextDoseMg,
    DateTime? nextEscalationDate,
    DateTime? goalEstimateDate,
  }) {
    return NextSchedule(
      nextDoseDate: nextDoseDate ?? this.nextDoseDate,
      nextDoseMg: nextDoseMg ?? this.nextDoseMg,
      nextEscalationDate: nextEscalationDate ?? this.nextEscalationDate,
      goalEstimateDate: goalEstimateDate ?? this.goalEstimateDate,
    );
  }

  @override
  List<Object?> get props =>
      [nextDoseDate, nextDoseMg, nextEscalationDate, goalEstimateDate];

  @override
  String toString() =>
      'NextSchedule(nextDoseDate: $nextDoseDate, nextDoseMg: $nextDoseMg)';
}
</file>

<file path="lib/features/dashboard/domain/entities/timeline_event.dart">
import 'package:equatable/equatable.dart';

enum TimelineEventType {
  treatmentStart,
  escalation,
  weightMilestone,
  badgeAchievement,
}

class TimelineEvent extends Equatable {
  final String id;
  final DateTime dateTime;
  final TimelineEventType eventType;
  final String title;
  final String description;
  final String? metadata; // JSON string for additional data

  const TimelineEvent({
    required this.id,
    required this.dateTime,
    required this.eventType,
    required this.title,
    required this.description,
    this.metadata,
  });

  TimelineEvent copyWith({
    String? id,
    DateTime? dateTime,
    TimelineEventType? eventType,
    String? title,
    String? description,
    String? metadata,
  }) {
    return TimelineEvent(
      id: id ?? this.id,
      dateTime: dateTime ?? this.dateTime,
      eventType: eventType ?? this.eventType,
      title: title ?? this.title,
      description: description ?? this.description,
      metadata: metadata ?? this.metadata,
    );
  }

  @override
  List<Object?> get props =>
      [id, dateTime, eventType, title, description, metadata];

  @override
  String toString() =>
      'TimelineEvent(dateTime: $dateTime, eventType: $eventType, title: $title)';
}
</file>

<file path="lib/features/dashboard/domain/entities/user_badge.dart">
import 'package:equatable/equatable.dart';

enum BadgeStatus {
  locked,
  inProgress,
  achieved,
}

class UserBadge extends Equatable {
  final String id;
  final String userId;
  final String badgeId;
  final BadgeStatus status;
  final int progressPercentage;
  final DateTime? achievedAt;
  final DateTime createdAt;
  final DateTime updatedAt;

  const UserBadge({
    required this.id,
    required this.userId,
    required this.badgeId,
    required this.status,
    required this.progressPercentage,
    this.achievedAt,
    required this.createdAt,
    required this.updatedAt,
  });

  UserBadge copyWith({
    String? id,
    String? userId,
    String? badgeId,
    BadgeStatus? status,
    int? progressPercentage,
    DateTime? achievedAt,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return UserBadge(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      badgeId: badgeId ?? this.badgeId,
      status: status ?? this.status,
      progressPercentage: progressPercentage ?? this.progressPercentage,
      achievedAt: achievedAt ?? this.achievedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  List<Object?> get props => [
        id,
        userId,
        badgeId,
        status,
        progressPercentage,
        achievedAt,
        createdAt,
        updatedAt,
      ];

  @override
  String toString() =>
      'UserBadge(badgeId: $badgeId, status: $status, progress: $progressPercentage%)';
}
</file>

<file path="lib/features/dashboard/domain/entities/weekly_progress.dart">
import 'package:equatable/equatable.dart';

class WeeklyProgress extends Equatable {
  final int doseCompletedCount;
  final int doseTargetCount;
  final double doseRate;
  final int weightRecordCount;
  final int weightTargetCount;
  final double weightRate;
  final int symptomRecordCount;
  final int symptomTargetCount;
  final double symptomRate;

  const WeeklyProgress({
    required this.doseCompletedCount,
    required this.doseTargetCount,
    required this.doseRate,
    required this.weightRecordCount,
    required this.weightTargetCount,
    required this.weightRate,
    required this.symptomRecordCount,
    required this.symptomTargetCount,
    required this.symptomRate,
  });

  WeeklyProgress copyWith({
    int? doseCompletedCount,
    int? doseTargetCount,
    double? doseRate,
    int? weightRecordCount,
    int? weightTargetCount,
    double? weightRate,
    int? symptomRecordCount,
    int? symptomTargetCount,
    double? symptomRate,
  }) {
    return WeeklyProgress(
      doseCompletedCount: doseCompletedCount ?? this.doseCompletedCount,
      doseTargetCount: doseTargetCount ?? this.doseTargetCount,
      doseRate: doseRate ?? this.doseRate,
      weightRecordCount: weightRecordCount ?? this.weightRecordCount,
      weightTargetCount: weightTargetCount ?? this.weightTargetCount,
      weightRate: weightRate ?? this.weightRate,
      symptomRecordCount: symptomRecordCount ?? this.symptomRecordCount,
      symptomTargetCount: symptomTargetCount ?? this.symptomTargetCount,
      symptomRate: symptomRate ?? this.symptomRate,
    );
  }

  @override
  List<Object?> get props => [
        doseCompletedCount,
        doseTargetCount,
        doseRate,
        weightRecordCount,
        weightTargetCount,
        weightRate,
        symptomRecordCount,
        symptomTargetCount,
        symptomRate,
      ];

  @override
  String toString() =>
      'WeeklyProgress(doseRate: $doseRate, weightRate: $weightRate, symptomRate: $symptomRate)';
}
</file>

<file path="lib/features/dashboard/domain/entities/weekly_summary.dart">
import 'package:equatable/equatable.dart';

class WeeklySummary extends Equatable {
  final int doseCompletedCount;
  final double weightChangeKg;
  final int symptomRecordCount;
  final double adherencePercentage;

  const WeeklySummary({
    required this.doseCompletedCount,
    required this.weightChangeKg,
    required this.symptomRecordCount,
    required this.adherencePercentage,
  });

  WeeklySummary copyWith({
    int? doseCompletedCount,
    double? weightChangeKg,
    int? symptomRecordCount,
    double? adherencePercentage,
  }) {
    return WeeklySummary(
      doseCompletedCount: doseCompletedCount ?? this.doseCompletedCount,
      weightChangeKg: weightChangeKg ?? this.weightChangeKg,
      symptomRecordCount: symptomRecordCount ?? this.symptomRecordCount,
      adherencePercentage: adherencePercentage ?? this.adherencePercentage,
    );
  }

  @override
  List<Object?> get props => [
        doseCompletedCount,
        weightChangeKg,
        symptomRecordCount,
        adherencePercentage,
      ];

  @override
  String toString() =>
      'WeeklySummary(doseCount: $doseCompletedCount, weightChange: $weightChangeKg, symptomCount: $symptomRecordCount)';
}
</file>

<file path="lib/features/dashboard/domain/repositories/badge_repository.dart">
import 'package:n06/features/dashboard/domain/entities/badge_definition.dart';
import 'package:n06/features/dashboard/domain/entities/user_badge.dart';

abstract class BadgeRepository {
  /// 모든 뱃지 정의를 조회합니다.
  Future<List<BadgeDefinition>> getBadgeDefinitions();

  /// 사용자의 뱃지 획득 상태를 조회합니다.
  Future<List<UserBadge>> getUserBadges(String userId);

  /// 뱃지 진행도를 업데이트합니다.
  Future<void> updateBadgeProgress(UserBadge badge);

  /// 뱃지를 획득 처리합니다.
  Future<void> achieveBadge(String userId, String badgeId);

  /// 사용자의 모든 뱃지를 초기화합니다.
  Future<void> initializeUserBadges(String userId);
}
</file>

<file path="lib/features/dashboard/domain/usecases/calculate_adherence_usecase.dart">
import 'package:n06/features/tracking/domain/entities/dose_record.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';

class CalculateAdherenceUseCase {
  /// 투여 순응도를 계산합니다.
  /// (실제 완료한 투여 횟수 / 예정된 투여 횟수) × 100
  double execute(
    List<DoseRecord> records,
    List<DoseSchedule> schedules,
  ) {
    // 미래 일정 제외
    final now = DateTime.now();
    final pastSchedules = schedules.where((s) => s.scheduledDate.isBefore(now)).toList();

    if (pastSchedules.isEmpty) {
      return 0.0;
    }

    // 완료된 투여 횟수
    final completedCount = records.where((r) => r.isCompleted).length;

    // 순응도 계산
    final adherence = (completedCount / pastSchedules.length) * 100;
    return adherence.clamp(0.0, 100.0);
  }
}
</file>

<file path="lib/features/dashboard/domain/usecases/calculate_continuous_record_days_usecase.dart">
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';

class CalculateContinuousRecordDaysUseCase {
  /// 마지막 기록부터 현재까지의 연속 기록일을 계산합니다.
  /// 기록 없는 날이 발생하면 0으로 리셋됩니다.
  int execute(List<WeightLog> weights, List<SymptomLog> symptoms) {
    if (weights.isEmpty && symptoms.isEmpty) {
      return 0;
    }

    // 모든 기록 날짜를 수집
    final allDates = <DateTime>{};
    for (final weight in weights) {
      allDates.add(
        DateTime(weight.logDate.year, weight.logDate.month, weight.logDate.day),
      );
    }
    for (final symptom in symptoms) {
      allDates.add(
        DateTime(
          symptom.logDate.year,
          symptom.logDate.month,
          symptom.logDate.day,
        ),
      );
    }

    if (allDates.isEmpty) {
      return 0;
    }

    // 날짜 정렬 (최신순)
    final sortedDates = allDates.toList()..sort((a, b) => b.compareTo(a));

    // 오늘의 자정
    final today = DateTime.now();
    final todayDate = DateTime(today.year, today.month, today.day);

    // 연속 기록일 계산
    int continuousDays = 0;
    for (var i = 0; i < sortedDates.length; i++) {
      final expectedDate = todayDate.subtract(Duration(days: i));
      if (sortedDates[i] == expectedDate) {
        continuousDays++;
      } else {
        break;
      }
    }

    return continuousDays;
  }
}
</file>

<file path="lib/features/dashboard/domain/usecases/calculate_current_week_usecase.dart">
class CalculateCurrentWeekUseCase {
  /// 투여 시작일 기준으로 현재 주차를 계산합니다.
  /// 1주 = 7일 기준으로 계산합니다.
  int execute(DateTime startDate) {
    final now = DateTime.now();
    final difference = now.difference(startDate).inDays;
    return (difference / 7).floor() + 1;
  }
}
</file>

<file path="lib/features/dashboard/domain/usecases/calculate_weekly_progress_usecase.dart">
import 'package:n06/features/dashboard/domain/entities/weekly_progress.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';

class CalculateWeeklyProgressUseCase {
  /// 지난 7일간의 주간 목표 달성률을 계산합니다.
  WeeklyProgress execute({
    required List<DoseRecord> doseRecords,
    required List<WeightLog> weightLogs,
    required List<SymptomLog> symptomLogs,
    required int doseTargetCount,
    required int weightTargetCount,
    required int symptomTargetCount,
  }) {
    final now = DateTime.now();
    final sevenDaysAgo = now.subtract(Duration(days: 7));

    // 지난 7일 내 완료된 투여 기록 카운트
    final doseCompletedCount = doseRecords
        .where((dose) =>
            dose.administeredAt.isAfter(sevenDaysAgo) &&
            dose.administeredAt.isBefore(now.add(Duration(days: 1))) &&
            dose.isCompleted)
        .length;

    // 지난 7일 내 체중 기록 카운트
    final weightRecordCount = weightLogs
        .where((log) =>
            log.logDate.isAfter(sevenDaysAgo) &&
            log.logDate.isBefore(now.add(Duration(days: 1))))
        .length;

    // 지난 7일 내 부작용 기록 카운트
    final symptomRecordCount = symptomLogs
        .where((log) =>
            log.logDate.isAfter(sevenDaysAgo) &&
            log.logDate.isBefore(now.add(Duration(days: 1))))
        .length;

    // 달성률 계산 (0.0 ~ 1.0)
    final doseRate =
        doseTargetCount > 0 ? (doseCompletedCount / doseTargetCount).clamp(0.0, 1.0) : 0.0;
    final weightRate =
        weightTargetCount > 0 ? (weightRecordCount / weightTargetCount).clamp(0.0, 1.0) : 0.0;
    final symptomRate =
        symptomTargetCount > 0 ? (symptomRecordCount / symptomTargetCount).clamp(0.0, 1.0) : 0.0;

    return WeeklyProgress(
      doseCompletedCount: doseCompletedCount,
      doseTargetCount: doseTargetCount,
      doseRate: doseRate,
      weightRecordCount: weightRecordCount,
      weightTargetCount: weightTargetCount,
      weightRate: weightRate,
      symptomRecordCount: symptomRecordCount,
      symptomTargetCount: symptomTargetCount,
      symptomRate: symptomRate,
    );
  }
}
</file>

<file path="lib/features/dashboard/domain/usecases/calculate_weight_goal_estimate_usecase.dart">
import 'package:n06/features/tracking/domain/entities/weight_log.dart';

class CalculateWeightGoalEstimateUseCase {
  /// 최근 4주 체중 감량 추세를 기반으로 목표 체중 도달 예상일을 계산합니다.
  /// 충분한 데이터가 없거나 체중 감량 추세가 없으면 null을 반환합니다.
  DateTime? execute({
    required double currentWeight,
    required double targetWeight,
    required List<WeightLog> weightLogs,
  }) {
    // 이미 목표에 도달한 경우
    if (currentWeight <= targetWeight) {
      return DateTime.now();
    }

    // 최근 4주(28일) 데이터 필터링
    final now = DateTime.now();
    final fourWeeksAgo = now.subtract(Duration(days: 28));
    final recentLogs = weightLogs
        .where((log) => log.logDate.isAfter(fourWeeksAgo) && log.logDate.isBefore(now))
        .toList();

    // 충분한 데이터 없음 (2주 미만)
    if (recentLogs.length < 2) {
      return null;
    }

    // 로그 정렬 (최신순)
    recentLogs.sort((a, b) => b.logDate.compareTo(a.logDate));

    // 첫 번째와 마지막 기록으로 선형 회귀 계산
    final firstLog = recentLogs.first;
    final lastLog = recentLogs.last;

    final weightDifference = lastLog.weightKg - firstLog.weightKg;
    final daysDifference = firstLog.logDate.difference(lastLog.logDate).inDays;

    // 체중 감량 추세 없음
    if (weightDifference >= 0 || daysDifference == 0) {
      return null;
    }

    // 일일 체중 감량량
    final dailyLossRate = weightDifference.abs() / daysDifference;

    // 목표까지 필요한 체중 감량량
    final remainingWeight = currentWeight - targetWeight;

    // 목표까지 필요한 일수
    final daysNeeded = (remainingWeight / dailyLossRate).ceil();

    return now.add(Duration(days: daysNeeded));
  }
}
</file>

<file path="lib/features/dashboard/domain/usecases/index.dart">
export 'calculate_continuous_record_days_usecase.dart';
export 'calculate_current_week_usecase.dart';
export 'calculate_weekly_progress_usecase.dart';
export 'calculate_adherence_usecase.dart';
export 'calculate_weight_goal_estimate_usecase.dart';
export 'verify_badge_conditions_usecase.dart';
</file>

<file path="lib/features/dashboard/infrastructure/dtos/badge_definition_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/dashboard/domain/entities/badge_definition.dart';

part 'badge_definition_dto.g.dart';

@collection
class BadgeDefinitionDto {
  Id? isarId;
  late String id;
  late String name;
  late String description;
  late String category; // enum string: streak, weight, dose, record
  String? iconUrl;
  late int displayOrder;

  BadgeDefinitionDto();

  BadgeDefinition toEntity() {
    return BadgeDefinition(
      id: id,
      name: name,
      description: description,
      category: _stringToCategory(category),
      iconUrl: iconUrl,
      displayOrder: displayOrder,
    );
  }

  factory BadgeDefinitionDto.fromEntity(BadgeDefinition entity) {
    return BadgeDefinitionDto()
      ..id = entity.id
      ..name = entity.name
      ..description = entity.description
      ..category = entity.category.toString().split('.').last
      ..iconUrl = entity.iconUrl
      ..displayOrder = entity.displayOrder;
  }

  static BadgeCategory _stringToCategory(String value) {
    return BadgeCategory.values.firstWhere(
      (e) => e.toString().split('.').last == value,
      orElse: () => BadgeCategory.streak,
    );
  }
}
</file>

<file path="lib/features/dashboard/infrastructure/repositories/isar_badge_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/dashboard/domain/entities/badge_definition.dart';
import 'package:n06/features/dashboard/domain/entities/user_badge.dart';
import 'package:n06/features/dashboard/domain/repositories/badge_repository.dart';
import 'package:n06/features/dashboard/infrastructure/dtos/badge_definition_dto.dart';
import 'package:n06/features/dashboard/infrastructure/dtos/user_badge_dto.dart';

class IsarBadgeRepository implements BadgeRepository {
  final Isar isar;

  IsarBadgeRepository(this.isar);

  @override
  Future<List<BadgeDefinition>> getBadgeDefinitions() async {
    final dtos = await isar.badgeDefinitionDtos.where().findAll();
    return dtos.map((dto) => dto.toEntity()).toList();
  }

  @override
  Future<List<UserBadge>> getUserBadges(String userId) async {
    final dtos = await isar.userBadgeDtos.where().filter().userIdEqualTo(userId).findAll();
    return dtos.map((dto) => dto.toEntity()).toList();
  }

  @override
  Future<void> updateBadgeProgress(UserBadge badge) async {
    final dto = UserBadgeDto.fromEntity(badge);
    await isar.writeTxn(() async {
      await isar.userBadgeDtos.put(dto);
    });
  }

  @override
  Future<void> achieveBadge(String userId, String badgeId) async {
    final badge = await isar.userBadgeDtos
        .where()
        .filter()
        .userIdEqualTo(userId)
        .and()
        .badgeIdEqualTo(badgeId)
        .findFirst();

    if (badge != null) {
      final updated = badge.copyWith(
        status: 'achieved',
        progressPercentage: 100,
        achievedAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );
      await isar.writeTxn(() async {
        await isar.userBadgeDtos.put(updated);
      });
    }
  }

  @override
  Future<void> initializeUserBadges(String userId) async {
    final badgeDefs = await getBadgeDefinitions();
    final now = DateTime.now();

    await isar.writeTxn(() async {
      for (final badgeDef in badgeDefs) {
        final badge = UserBadgeDto()
          ..id = '${userId}_${badgeDef.id}'
          ..userId = userId
          ..badgeId = badgeDef.id
          ..status = 'locked'
          ..progressPercentage = 0
          ..achievedAt = null
          ..createdAt = now
          ..updatedAt = now;

        await isar.userBadgeDtos.put(badge);
      }
    });
  }
}
</file>

<file path="lib/features/dashboard/presentation/widgets/badge_widget.dart">
import 'package:flutter/material.dart';
import 'package:n06/features/dashboard/domain/entities/user_badge.dart';

class BadgeWidget extends StatelessWidget {
  final List<UserBadge> badges;

  const BadgeWidget({
    super.key,
    required this.badges,
  });

  @override
  Widget build(BuildContext context) {
    if (badges.isEmpty) {
      return Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.grey[50],
          borderRadius: BorderRadius.circular(12),
        ),
        child: const Center(
          child: Text(
            '아직 뱃지가 없습니다',
            style: TextStyle(color: Colors.grey),
          ),
        ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          '성취 뱃지',
          style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        Wrap(
          spacing: 12,
          runSpacing: 12,
          children: badges.map((badge) => _BadgeItem(badge: badge)).toList(),
        ),
      ],
    );
  }
}

class _BadgeItem extends StatelessWidget {
  final UserBadge badge;

  const _BadgeItem({required this.badge});

  @override
  Widget build(BuildContext context) {
    final isAchieved = badge.status == BadgeStatus.achieved;
    final isInProgress = badge.status == BadgeStatus.inProgress;

    return Column(
      children: [
        Container(
          width: 80,
          height: 80,
          decoration: BoxDecoration(
            shape: BoxShape.circle,
            color: isAchieved
                ? Colors.amber[100]
                : isInProgress
                    ? Colors.grey[200]
                    : Colors.grey[100],
            border: isAchieved ? Border.all(color: Colors.amber, width: 2) : null,
          ),
          child: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  _getIconForBadge(badge.badgeId),
                  color: isAchieved ? Colors.amber : Colors.grey,
                  size: 32,
                ),
                if (isInProgress) ...[
                  const SizedBox(height: 4),
                  Text(
                    '${badge.progressPercentage}%',
                    style: const TextStyle(fontSize: 10, color: Colors.grey),
                  ),
                ],
              ],
            ),
          ),
        ),
        const SizedBox(height: 8),
        SizedBox(
          width: 80,
          child: Text(
            _getLabelForBadge(badge.badgeId),
            textAlign: TextAlign.center,
            style: const TextStyle(fontSize: 10, fontWeight: FontWeight.w500),
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),
        ),
      ],
    );
  }

  IconData _getIconForBadge(String badgeId) {
    switch (badgeId) {
      case 'streak_7':
        return Icons.local_fire_department;
      case 'streak_30':
        return Icons.whatshot;
      case 'weight_5percent':
        return Icons.trending_down;
      case 'weight_10percent':
        return Icons.scale;
      case 'first_dose':
        return Icons.check_circle;
      default:
        return Icons.emoji_events;
    }
  }

  String _getLabelForBadge(String badgeId) {
    switch (badgeId) {
      case 'streak_7':
        return '7일 연속';
      case 'streak_30':
        return '30일 연속';
      case 'weight_5percent':
        return '5% 감량';
      case 'weight_10percent':
        return '10% 감량';
      case 'first_dose':
        return '첫 투여';
      default:
        return '뱃지';
    }
  }
}
</file>

<file path="lib/features/dashboard/presentation/widgets/greeting_widget.dart">
import 'package:flutter/material.dart';
import 'package:n06/features/dashboard/domain/entities/dashboard_data.dart';

class GreetingWidget extends StatelessWidget {
  final DashboardData dashboardData;

  const GreetingWidget({
    super.key,
    required this.dashboardData,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 0,
      color: Colors.blue[50],
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '안녕하세요, ${dashboardData.userName}님',
              style: const TextStyle(
                fontSize: 24,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 12),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text('연속 기록일', style: TextStyle(fontSize: 12, color: Colors.grey)),
                    Text('${dashboardData.continuousRecordDays}일',
                        style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                  ],
                ),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Text('현재 주차', style: TextStyle(fontSize: 12, color: Colors.grey)),
                    Text('${dashboardData.currentWeek}주차',
                        style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                  ],
                ),
              ],
            ),
            if (dashboardData.insightMessage != null) ...[
              const SizedBox(height: 16),
              Text(
                dashboardData.insightMessage!,
                style: const TextStyle(
                  fontSize: 14,
                  color: Colors.blue,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/dashboard/presentation/widgets/index.dart">
export 'greeting_widget.dart';
export 'weekly_progress_widget.dart';
export 'quick_action_widget.dart';
export 'next_schedule_widget.dart';
export 'weekly_report_widget.dart';
export 'timeline_widget.dart';
export 'badge_widget.dart';
</file>

<file path="lib/features/dashboard/presentation/widgets/next_schedule_widget.dart">
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:n06/features/dashboard/domain/entities/next_schedule.dart';

class NextScheduleWidget extends StatelessWidget {
  final NextSchedule nextSchedule;

  const NextScheduleWidget({
    super.key,
    required this.nextSchedule,
  });

  @override
  Widget build(BuildContext context) {
    final dateFormat = DateFormat('M월 d일 (EEEE)', 'ko_KR');

    return Card(
      elevation: 0,
      color: Colors.orange[50],
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              '다음 예정',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 12),
            _ScheduleItem(
              icon: Icons.calendar_today,
              title: '다음 투여',
              date: dateFormat.format(nextSchedule.nextDoseDate),
              subtitle: '${nextSchedule.nextDoseMg} mg',
            ),
            const SizedBox(height: 12),
            if (nextSchedule.nextEscalationDate != null)
              _ScheduleItem(
                icon: Icons.trending_up,
                title: '다음 증량',
                date: dateFormat.format(nextSchedule.nextEscalationDate!),
              ),
            if (nextSchedule.nextEscalationDate != null) const SizedBox(height: 12),
            if (nextSchedule.goalEstimateDate != null)
              _ScheduleItem(
                icon: Icons.flag,
                title: '목표 달성 예상',
                date: dateFormat.format(nextSchedule.goalEstimateDate!),
              ),
          ],
        ),
      ),
    );
  }
}

class _ScheduleItem extends StatelessWidget {
  final IconData icon;
  final String title;
  final String date;
  final String? subtitle;

  const _ScheduleItem({
    required this.icon,
    required this.title,
    required this.date,
    this.subtitle,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Icon(icon, color: Colors.orange, size: 20),
        const SizedBox(width: 12),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(title, style: const TextStyle(fontSize: 12, color: Colors.grey)),
              const SizedBox(height: 4),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(date, style: const TextStyle(fontWeight: FontWeight.w500)),
                  if (subtitle != null)
                    Text(subtitle!, style: const TextStyle(fontSize: 12, color: Colors.grey)),
                ],
              ),
            ],
          ),
        ),
      ],
    );
  }
}
</file>

<file path="lib/features/dashboard/presentation/widgets/timeline_widget.dart">
import 'package:flutter/material.dart';
import 'package:n06/features/dashboard/domain/entities/timeline_event.dart';

class TimelineWidget extends StatelessWidget {
  final List<TimelineEvent> timeline;

  const TimelineWidget({
    super.key,
    required this.timeline,
  });

  @override
  Widget build(BuildContext context) {
    if (timeline.isEmpty) {
      return Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: Colors.grey[50],
          borderRadius: BorderRadius.circular(12),
        ),
        child: const Center(
          child: Text(
            '아직 이벤트가 없습니다',
            style: TextStyle(color: Colors.grey),
          ),
        ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          '치료 여정',
          style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        ListView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          itemCount: timeline.length,
          itemBuilder: (context, index) {
            final event = timeline[index];
            return _TimelineEventItem(event: event);
          },
        ),
      ],
    );
  }
}

class _TimelineEventItem extends StatelessWidget {
  final TimelineEvent event;

  const _TimelineEventItem({required this.event});

  @override
  Widget build(BuildContext context) {
    final color = _getColorForEventType(event.eventType);

    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Column(
            children: [
              Container(
                width: 12,
                height: 12,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: color,
                ),
              ),
              if (event != event) // For visual connecting line
                Container(
                  width: 2,
                  height: 40,
                  color: Colors.grey[300],
                ),
            ],
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  event.title,
                  style: const TextStyle(fontWeight: FontWeight.w600),
                ),
                const SizedBox(height: 4),
                Text(
                  event.description,
                  style: const TextStyle(fontSize: 12, color: Colors.grey),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Color _getColorForEventType(TimelineEventType type) {
    switch (type) {
      case TimelineEventType.treatmentStart:
        return Colors.blue;
      case TimelineEventType.escalation:
        return Colors.orange;
      case TimelineEventType.weightMilestone:
        return Colors.green;
      case TimelineEventType.badgeAchievement:
        return Colors.amber;
    }
  }
}
</file>

<file path="lib/features/dashboard/presentation/widgets/weekly_progress_widget.dart">
import 'package:flutter/material.dart';
import 'package:n06/features/dashboard/domain/entities/weekly_progress.dart';

class WeeklyProgressWidget extends StatelessWidget {
  final WeeklyProgress weeklyProgress;

  const WeeklyProgressWidget({
    super.key,
    required this.weeklyProgress,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          '주간 목표 진행도',
          style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        _ProgressItem(
          label: '투여',
          completed: weeklyProgress.doseCompletedCount,
          target: weeklyProgress.doseTargetCount,
          rate: weeklyProgress.doseRate,
        ),
        const SizedBox(height: 12),
        _ProgressItem(
          label: '체중 기록',
          completed: weeklyProgress.weightRecordCount,
          target: weeklyProgress.weightTargetCount,
          rate: weeklyProgress.weightRate,
        ),
        const SizedBox(height: 12),
        _ProgressItem(
          label: '부작용 기록',
          completed: weeklyProgress.symptomRecordCount,
          target: weeklyProgress.symptomTargetCount,
          rate: weeklyProgress.symptomRate,
        ),
      ],
    );
  }
}

class _ProgressItem extends StatelessWidget {
  final String label;
  final int completed;
  final int target;
  final double rate;

  const _ProgressItem({
    required this.label,
    required this.completed,
    required this.target,
    required this.rate,
  });

  @override
  Widget build(BuildContext context) {
    final percentage = (rate * 100).toStringAsFixed(0);
    final isCompleted = rate >= 1.0;

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: isCompleted ? Colors.green[50] : Colors.grey[50],
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(label, style: const TextStyle(fontWeight: FontWeight.w500)),
              Text(
                '$completed/$target',
                style: const TextStyle(fontSize: 12, color: Colors.grey),
              ),
            ],
          ),
          const SizedBox(height: 8),
          ClipRRect(
            borderRadius: BorderRadius.circular(4),
            child: LinearProgressIndicator(
              value: rate.clamp(0.0, 1.0),
              minHeight: 8,
              backgroundColor: Colors.grey[200],
              valueColor: AlwaysStoppedAnimation<Color>(
                isCompleted ? Colors.green : Colors.blue,
              ),
            ),
          ),
          const SizedBox(height: 4),
          Text(
            '$percentage%',
            style: const TextStyle(fontSize: 12, color: Colors.grey),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/dashboard/presentation/widgets/weekly_report_widget.dart">
import 'package:flutter/material.dart';
import 'package:n06/features/dashboard/domain/entities/weekly_summary.dart';

class WeeklyReportWidget extends StatelessWidget {
  final WeeklySummary weeklySummary;

  const WeeklyReportWidget({
    super.key,
    required this.weeklySummary,
  });

  @override
  Widget build(BuildContext context) {
    final weightDirection = weeklySummary.weightChangeKg < 0 ? '↓' : '↑';
    final weightColor = weeklySummary.weightChangeKg < 0 ? Colors.green : Colors.red;

    return Card(
      elevation: 0,
      color: Colors.purple[50],
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              '지난주 요약',
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                _ReportItem(
                  label: '투여',
                  value: '${weeklySummary.doseCompletedCount}회',
                  icon: Icons.check_circle,
                  color: Colors.blue,
                ),
                _ReportItem(
                  label: '체중',
                  value: '$weightDirection ${weeklySummary.weightChangeKg.abs().toStringAsFixed(1)}kg',
                  icon: Icons.scale,
                  color: weightColor,
                ),
                _ReportItem(
                  label: '부작용',
                  value: '${weeklySummary.symptomRecordCount}회',
                  icon: Icons.favorite,
                  color: Colors.pink,
                ),
              ],
            ),
            const SizedBox(height: 16),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text(
                    '투여 순응도',
                    style: TextStyle(fontSize: 12, color: Colors.grey),
                  ),
                  Text(
                    '${weeklySummary.adherencePercentage.toStringAsFixed(0)}%',
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _ReportItem extends StatelessWidget {
  final String label;
  final String value;
  final IconData icon;
  final Color color;

  const _ReportItem({
    required this.label,
    required this.value,
    required this.icon,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Icon(icon, color: color, size: 20),
        const SizedBox(height: 4),
        Text(label, style: const TextStyle(fontSize: 10, color: Colors.grey)),
        const SizedBox(height: 4),
        Text(value, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 12)),
      ],
    );
  }
}
</file>

<file path="lib/features/data_sharing/domain/entities/emergency_symptom_check.dart">
import 'package:equatable/equatable.dart';

class EmergencySymptomCheck extends Equatable {
  final String id;
  final String userId;
  final DateTime checkedAt;
  final List<String> checkedSymptoms;

  const EmergencySymptomCheck({
    required this.id,
    required this.userId,
    required this.checkedAt,
    required this.checkedSymptoms,
  });

  EmergencySymptomCheck copyWith({
    String? id,
    String? userId,
    DateTime? checkedAt,
    List<String>? checkedSymptoms,
  }) {
    return EmergencySymptomCheck(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      checkedAt: checkedAt ?? this.checkedAt,
      checkedSymptoms: checkedSymptoms ?? this.checkedSymptoms,
    );
  }

  @override
  List<Object?> get props => [id, userId, checkedAt, checkedSymptoms];

  @override
  String toString() =>
      'EmergencySymptomCheck(id: $id, userId: $userId, checkedAt: $checkedAt, checkedSymptoms: $checkedSymptoms)';
}
</file>

<file path="lib/features/data_sharing/domain/entities/shared_data_report.dart">
import 'package:equatable/equatable.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'emergency_symptom_check.dart';

class SharedDataReport extends Equatable {
  final DateTime dateRangeStart;
  final DateTime dateRangeEnd;
  final List<DoseRecord> doseRecords;
  final List<WeightLog> weightLogs;
  final List<SymptomLog> symptomLogs;
  final List<EmergencySymptomCheck> emergencyChecks;
  final List<DoseSchedule> doseSchedules;

  const SharedDataReport({
    required this.dateRangeStart,
    required this.dateRangeEnd,
    required this.doseRecords,
    required this.weightLogs,
    required this.symptomLogs,
    required this.emergencyChecks,
    required this.doseSchedules,
  });

  /// Calculate adherence rate as percentage (0-100)
  /// Formula: (completed doses / scheduled doses) * 100
  double calculateAdherenceRate() {
    if (doseSchedules.isEmpty) {
      return 0.0;
    }

    // Filter schedules within date range (inclusive)
    final schedulesInRange = doseSchedules.where((schedule) {
      final scheduleDate = schedule.scheduledDate;
      return !scheduleDate.isBefore(dateRangeStart) &&
          !scheduleDate.isAfter(dateRangeEnd);
    }).toList();

    if (schedulesInRange.isEmpty) {
      return 0.0;
    }

    // Count records that match scheduled dates
    int completedCount = 0;
    for (final schedule in schedulesInRange) {
      final hasRecord = doseRecords.any((record) {
        final recordDate = DateTime(
          record.administeredAt.year,
          record.administeredAt.month,
          record.administeredAt.day,
        );
        return recordDate == schedule.scheduledDate;
      });
      if (hasRecord) {
        completedCount++;
      }
    }

    return (completedCount / schedulesInRange.length) * 100;
  }

  /// Get injection site history as a map of site -> count
  Map<String, int> getInjectionSiteHistory() {
    final siteHistory = <String, int>{};

    for (final record in doseRecords) {
      if (record.injectionSite != null) {
        siteHistory[record.injectionSite!] = (siteHistory[record.injectionSite!] ?? 0) + 1;
      }
    }

    return siteHistory;
  }

  /// Get weight logs sorted by date
  List<WeightLog> getWeightLogsSorted() {
    final sorted = List<WeightLog>.from(weightLogs);
    sorted.sort((a, b) => a.logDate.compareTo(b.logDate));
    return sorted;
  }

  /// Get dose records sorted by date
  List<DoseRecord> getDoseRecordsSorted() {
    final sorted = List<DoseRecord>.from(doseRecords);
    sorted.sort((a, b) => a.administeredAt.compareTo(b.administeredAt));
    return sorted;
  }

  /// Get symptom logs sorted by date
  List<SymptomLog> getSymptomLogsSorted() {
    final sorted = List<SymptomLog>.from(symptomLogs);
    sorted.sort((a, b) => a.logDate.compareTo(b.logDate));
    return sorted;
  }

  /// Get emergency checks sorted by date
  List<EmergencySymptomCheck> getEmergencyChecksSorted() {
    final sorted = List<EmergencySymptomCheck>.from(emergencyChecks);
    sorted.sort((a, b) => a.checkedAt.compareTo(b.checkedAt));
    return sorted;
  }

  /// Check if report has any data
  bool hasData() {
    return doseRecords.isNotEmpty ||
        weightLogs.isNotEmpty ||
        symptomLogs.isNotEmpty ||
        emergencyChecks.isNotEmpty;
  }

  SharedDataReport copyWith({
    DateTime? dateRangeStart,
    DateTime? dateRangeEnd,
    List<DoseRecord>? doseRecords,
    List<WeightLog>? weightLogs,
    List<SymptomLog>? symptomLogs,
    List<EmergencySymptomCheck>? emergencyChecks,
    List<DoseSchedule>? doseSchedules,
  }) {
    return SharedDataReport(
      dateRangeStart: dateRangeStart ?? this.dateRangeStart,
      dateRangeEnd: dateRangeEnd ?? this.dateRangeEnd,
      doseRecords: doseRecords ?? this.doseRecords,
      weightLogs: weightLogs ?? this.weightLogs,
      symptomLogs: symptomLogs ?? this.symptomLogs,
      emergencyChecks: emergencyChecks ?? this.emergencyChecks,
      doseSchedules: doseSchedules ?? this.doseSchedules,
    );
  }

  @override
  List<Object?> get props => [
    dateRangeStart,
    dateRangeEnd,
    doseRecords,
    weightLogs,
    symptomLogs,
    emergencyChecks,
    doseSchedules,
  ];

  @override
  String toString() =>
      'SharedDataReport(dateRangeStart: $dateRangeStart, dateRangeEnd: $dateRangeEnd, doseRecords: ${doseRecords.length}, weightLogs: ${weightLogs.length}, symptomLogs: ${symptomLogs.length}, emergencyChecks: ${emergencyChecks.length}, doseSchedules: ${doseSchedules.length})';
}
</file>

<file path="lib/features/data_sharing/domain/repositories/date_range.dart">
enum DateRange {
  lastMonth('최근 1개월', 30),
  lastThreeMonths('최근 3개월', 90),
  allTime('전체 기간', null);

  final String label;
  final int? days;

  const DateRange(this.label, this.days);

  /// Calculate start date based on the range
  DateTime getStartDate(DateTime endDate) {
    if (days == null) {
      // For allTime, return a very old date (epoch)
      return DateTime(1970, 1, 1);
    }
    return endDate.subtract(Duration(days: days!));
  }
}
</file>

<file path="lib/features/data_sharing/domain/repositories/shared_data_repository.dart">
import '../entities/shared_data_report.dart';
import 'date_range.dart';

abstract class SharedDataRepository {
  /// Get shared data report for given date range
  /// Returns SharedDataReport containing all records within the specified range
  Future<SharedDataReport> getReportData(
    String userId,
    DateRange dateRange,
  );
}
</file>

<file path="lib/features/notification/application/notifiers/notification_notifier.dart">
import 'package:flutter/material.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:n06/features/notification/domain/entities/notification_settings.dart';
import 'package:n06/features/notification/domain/repositories/notification_repository.dart';
import 'package:n06/features/notification/domain/services/notification_scheduler.dart';
import 'package:n06/features/notification/infrastructure/repositories/isar_notification_repository.dart';
import 'package:n06/features/notification/infrastructure/services/local_notification_scheduler.dart';
import 'package:n06/features/notification/infrastructure/services/permission_service.dart';
import 'package:n06/features/tracking/application/providers.dart';
import 'package:n06/features/authentication/application/notifiers/auth_notifier.dart';
import 'package:n06/features/coping_guide/application/providers.dart';

part 'notification_notifier.g.dart';

/// Repository Provider
@riverpod
NotificationRepository notificationRepository(
  NotificationRepositoryRef ref,
) {
  final isar = ref.watch(isarProvider);
  return IsarNotificationRepository(isar);
}

/// Scheduler Provider
@riverpod
NotificationScheduler notificationScheduler(
  NotificationSchedulerRef ref,
) {
  return LocalNotificationScheduler(PermissionService());
}

/// Notifier Class
@riverpod
class NotificationNotifier extends _$NotificationNotifier {
  @override
  Future<NotificationSettings> build() async {
    final userId = ref.watch(authNotifierProvider).value?.id;
    if (userId == null) {
      throw Exception('User not authenticated');
    }

    final repository = ref.watch(notificationRepositoryProvider);
    final settings = await repository.getNotificationSettings(userId);

    return settings ??
        NotificationSettings(
          userId: userId,
          notificationTime: const TimeOfDay(hour: 9, minute: 0),
          notificationEnabled: true,
        );
  }

  /// 알림 시간 업데이트
  Future<void> updateNotificationTime(TimeOfDay newTime) async {
    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      final currentState = state.value;
      if (currentState == null) throw Exception('Settings not loaded');

      final updated = currentState.copyWith(notificationTime: newTime);
      final repository = ref.read(notificationRepositoryProvider);
      await repository.saveNotificationSettings(updated);

      // 알림 스케줄 재계산
      await _rescheduleNotifications(updated);

      return updated;
    });
  }

  /// 알림 활성화/비활성화 토글
  Future<void> toggleNotificationEnabled() async {
    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      final currentState = state.value;
      if (currentState == null) throw Exception('Settings not loaded');

      final scheduler = ref.read(notificationSchedulerProvider);
      final newEnabled = !currentState.notificationEnabled;

      if (newEnabled) {
        // 활성화할 때 권한 확인 및 요청
        final hasPermission = await scheduler.checkPermission();
        if (!hasPermission) {
          final granted = await scheduler.requestPermission();
          if (!granted) {
            // 권한이 거부되면 변경하지 않음
            return currentState;
          }
        }
      }

      final updated = currentState.copyWith(notificationEnabled: newEnabled);
      final repository = ref.read(notificationRepositoryProvider);
      await repository.saveNotificationSettings(updated);

      // 알림 스케줄 업데이트
      if (newEnabled) {
        await _rescheduleNotifications(updated);
      } else {
        // 비활성화하면 모든 알림 취소
        await scheduler.cancelAllNotifications();
      }

      return updated;
    });
  }

  /// 알림 스케줄 재계산
  Future<void> _rescheduleNotifications(
    NotificationSettings settings,
  ) async {
    if (!settings.notificationEnabled) return;

    final scheduler = ref.read(notificationSchedulerProvider);
    final medicationRepository = ref.read(medicationRepositoryProvider);
    final userId = settings.userId;

    // 기존 알림 취소
    await scheduler.cancelAllNotifications();

    // 투여 스케줄 조회
    final activePlan = await medicationRepository.getActiveDosagePlan(userId);
    if (activePlan == null) return;

    final schedules =
        await medicationRepository.getDoseSchedules(activePlan.id);

    // 새로운 알림 등록
    if (schedules.isNotEmpty) {
      await scheduler.scheduleNotifications(
        doseSchedules: schedules,
        notificationTime: settings.notificationTime,
      );
    }
  }
}
</file>

<file path="lib/features/notification/application/providers.dart">
// 알림 기능 관련 providers 통합 파일
export 'notifiers/notification_notifier.dart';
</file>

<file path="lib/features/notification/domain/entities/notification_settings.dart">
import 'package:flutter/material.dart';

/// 알림 설정을 나타내는 불변 엔터티
class NotificationSettings {
  final String userId;
  final TimeOfDay notificationTime;
  final bool notificationEnabled;

  NotificationSettings({
    required this.userId,
    required this.notificationTime,
    required this.notificationEnabled,
  });

  /// 일부 필드를 변경한 새 인스턴스 반환 (Immutable Pattern)
  NotificationSettings copyWith({
    String? userId,
    TimeOfDay? notificationTime,
    bool? notificationEnabled,
  }) {
    return NotificationSettings(
      userId: userId ?? this.userId,
      notificationTime: notificationTime ?? this.notificationTime,
      notificationEnabled: notificationEnabled ?? this.notificationEnabled,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is NotificationSettings &&
        other.userId == userId &&
        other.notificationTime.hour == notificationTime.hour &&
        other.notificationTime.minute == notificationTime.minute &&
        other.notificationEnabled == notificationEnabled;
  }

  @override
  int get hashCode {
    return userId.hashCode ^
        notificationTime.hour.hashCode ^
        notificationTime.minute.hashCode ^
        notificationEnabled.hashCode;
  }

  @override
  String toString() {
    return 'NotificationSettings('
        'userId: $userId, '
        'notificationTime: ${notificationTime.hour}:${notificationTime.minute.toString().padLeft(2, '0')}, '
        'notificationEnabled: $notificationEnabled)';
  }
}
</file>

<file path="lib/features/notification/domain/repositories/notification_repository.dart">
import 'package:n06/features/notification/domain/entities/notification_settings.dart';

/// 알림 설정 데이터 접근 계약
abstract class NotificationRepository {
  /// 사용자의 알림 설정 조회
  Future<NotificationSettings?> getNotificationSettings(String userId);

  /// 알림 설정 저장
  Future<void> saveNotificationSettings(NotificationSettings settings);
}
</file>

<file path="lib/features/notification/domain/services/notification_scheduler.dart">
import 'package:flutter/material.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';

/// 알림 스케줄링 계약
abstract class NotificationScheduler {
  /// 알림 권한 확인
  Future<bool> checkPermission();

  /// 알림 권한 요청
  Future<bool> requestPermission();

  /// 투여 스케줄 기반 알림 등록
  Future<void> scheduleNotifications({
    required List<DoseSchedule> doseSchedules,
    required TimeOfDay notificationTime,
  });

  /// 모든 알림 취소
  Future<void> cancelAllNotifications();
}
</file>

<file path="lib/features/notification/infrastructure/dtos/notification_settings_dto.dart">
import 'package:flutter/material.dart';
import 'package:isar/isar.dart';
import 'package:n06/features/notification/domain/entities/notification_settings.dart';

part 'notification_settings_dto.g.dart';

@collection
class NotificationSettingsDto {
  Id id = Isar.autoIncrement;
  late String userId;
  late int notificationHour; // 0-23
  late int notificationMinute; // 0-59
  late bool notificationEnabled;

  /// DTO를 Domain Entity로 변환
  NotificationSettings toEntity() {
    return NotificationSettings(
      userId: userId,
      notificationTime: TimeOfDay(hour: notificationHour, minute: notificationMinute),
      notificationEnabled: notificationEnabled,
    );
  }

  /// Domain Entity를 DTO로 변환
  static NotificationSettingsDto fromEntity(NotificationSettings entity) {
    return NotificationSettingsDto()
      ..userId = entity.userId
      ..notificationHour = entity.notificationTime.hour
      ..notificationMinute = entity.notificationTime.minute
      ..notificationEnabled = entity.notificationEnabled;
  }
}
</file>

<file path="lib/features/notification/infrastructure/repositories/isar_notification_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/notification/domain/entities/notification_settings.dart';
import 'package:n06/features/notification/domain/repositories/notification_repository.dart';
import 'package:n06/features/notification/infrastructure/dtos/notification_settings_dto.dart';

/// Isar 기반 NotificationRepository 구현체
class IsarNotificationRepository implements NotificationRepository {
  final Isar isar;

  IsarNotificationRepository(this.isar);

  @override
  Future<NotificationSettings?> getNotificationSettings(String userId) async {
    final dto = await isar.notificationSettingsDtos
        .filter()
        .userIdEqualTo(userId)
        .findFirst();

    return dto?.toEntity();
  }

  @override
  Future<void> saveNotificationSettings(NotificationSettings settings) async {
    final dto = NotificationSettingsDto.fromEntity(settings);

    // 기존 설정 확인
    final existing = await isar.notificationSettingsDtos
        .filter()
        .userIdEqualTo(settings.userId)
        .findFirst();

    await isar.writeTxn(() async {
      if (existing != null) {
        // 기존 ID 유지하고 업데이트
        dto.id = existing.id;
      }
      await isar.notificationSettingsDtos.put(dto);
    });
  }
}
</file>

<file path="lib/features/onboarding/application/notifiers/onboarding_notifier.dart">
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:uuid/uuid.dart';
import 'package:n06/features/onboarding/domain/entities/dosage_plan.dart';
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/onboarding/domain/entities/weight_log.dart';
import 'package:n06/features/onboarding/domain/value_objects/weight.dart';
import 'package:n06/features/onboarding/domain/value_objects/medication_name.dart';
import 'package:n06/features/onboarding/domain/value_objects/start_date.dart';
import 'package:n06/features/onboarding/domain/entities/escalation_step.dart';
import 'package:n06/features/onboarding/domain/usecases/calculate_weekly_goal_usecase.dart';
import 'package:n06/features/onboarding/domain/usecases/validate_dosage_plan_usecase.dart';
import 'package:n06/features/onboarding/domain/usecases/generate_dose_schedules_usecase.dart';
import 'package:n06/features/onboarding/application/providers.dart';

part 'onboarding_notifier.g.dart';

/// 온보딩 상태 저장 및 데이터 저장 Notifier
@riverpod
class OnboardingNotifier extends _$OnboardingNotifier {
  @override
  Future<void> build() async {}

  /// 온보딩 데이터를 저장한다.
  Future<void> saveOnboardingData({
    required String userId,
    required String name,
    required double currentWeight,
    required double targetWeight,
    int? targetPeriodWeeks,
    required String medicationName,
    required DateTime startDate,
    required int cycleDays,
    required double initialDose,
    List<EscalationStep>? escalationPlan,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final userRepo = ref.read(userRepositoryProvider);
      final profileRepo = ref.read(profileRepositoryProvider);
      final medicationRepo = ref.read(medicationRepositoryProvider);
      final trackingRepo = ref.read(trackingRepositoryProvider);
      final scheduleRepo = ref.read(scheduleRepositoryProvider);
      final txnService = ref.read(transactionServiceProvider);

      // UseCase 인스턴스 생성
      final calculateGoalUseCase = CalculateWeeklyGoalUseCase();
      final validatePlanUseCase = ValidateDosagePlanUseCase();
      final generateSchedulesUseCase = GenerateDoseSchedulesUseCase();

      await txnService.executeInTransaction(() async {
        // 1. 검증
        final currentWeightObj = Weight.create(currentWeight);
        final targetWeightObj = Weight.create(targetWeight);
        final medicationNameObj = MedicationName.create(medicationName);
        final startDateObj = StartDate.create(startDate);

        // 증량 계획 검증
        if (escalationPlan != null) {
          final validation = validatePlanUseCase.execute(escalationPlan);
          if (!validation['isValid']) {
            throw Exception(validation['errors'].join(', '));
          }
        }

        // 2. 투여 계획 생성
        final dosagePlan = DosagePlan(
          id: const Uuid().v4(),
          userId: userId,
          medicationName: medicationNameObj,
          startDate: startDateObj,
          cycleDays: cycleDays,
          initialDoseMg: initialDose,
          escalationPlan: escalationPlan,
          isActive: true,
        );

        // 3. 사용자 프로필 생성 (주간 감량 목표 계산)
        final weeklyGoalResult = calculateGoalUseCase.execute(
          currentWeight: currentWeightObj,
          targetWeight: targetWeightObj,
          periodWeeks: targetPeriodWeeks,
        );

        final userProfile = UserProfile(
          userId: userId,
          targetWeight: targetWeightObj,
          currentWeight: currentWeightObj,
          targetPeriodWeeks: targetPeriodWeeks,
          weeklyLossGoalKg: weeklyGoalResult['weeklyGoal'] as double?,
        );

        // 4. 초기 체중 기록 생성
        final weightLog = WeightLog(
          id: const Uuid().v4(),
          userId: userId,
          logDate: DateTime.now(),
          weight: currentWeightObj,
          createdAt: DateTime.now(),
        );

        // 5. 모든 데이터 저장
        await userRepo.updateUserName(userId, name);
        await profileRepo.saveUserProfile(userProfile);
        await medicationRepo.saveDosagePlan(dosagePlan);
        await trackingRepo.saveWeightLog(weightLog);

        // 6. 투여 스케줄 생성 및 저장
        final schedules = generateSchedulesUseCase.execute(dosagePlan);
        await scheduleRepo.saveAll(schedules);
      });
    });
  }

  /// 저장을 재시도한다.
  Future<void> retrySave({
    required String userId,
    required String name,
    required double currentWeight,
    required double targetWeight,
    int? targetPeriodWeeks,
    required String medicationName,
    required DateTime startDate,
    required int cycleDays,
    required double initialDose,
    List<EscalationStep>? escalationPlan,
  }) async {
    await saveOnboardingData(
      userId: userId,
      name: name,
      currentWeight: currentWeight,
      targetWeight: targetWeight,
      targetPeriodWeeks: targetPeriodWeeks,
      medicationName: medicationName,
      startDate: startDate,
      cycleDays: cycleDays,
      initialDose: initialDose,
      escalationPlan: escalationPlan,
    );
  }
}
</file>

<file path="lib/features/onboarding/domain/entities/dosage_plan.dart">
import 'package:n06/features/onboarding/domain/value_objects/medication_name.dart';
import 'package:n06/features/onboarding/domain/value_objects/start_date.dart';
import 'escalation_step.dart';

/// 투여 계획을 나타내는 Entity
class DosagePlan {
  final String id;
  final String userId;
  final MedicationName medicationName;
  final StartDate startDate;
  final int cycleDays;
  final double initialDoseMg;
  final List<EscalationStep>? escalationPlan;
  final bool isActive;

  /// DosagePlan을 생성한다.
  /// cycleDays와 initialDoseMg는 양수여야 한다.
  DosagePlan({
    required this.id,
    required this.userId,
    required this.medicationName,
    required this.startDate,
    required this.cycleDays,
    required this.initialDoseMg,
    this.escalationPlan,
    this.isActive = true,
  }) {
    if (cycleDays <= 0) {
      throw ArgumentError('주기(cycleDays)는 양수여야 합니다.');
    }
    if (initialDoseMg <= 0) {
      throw ArgumentError('초기 용량(initialDoseMg)은 양수여야 합니다.');
    }
  }

  /// 현재 DosagePlan의 일부 필드를 변경한 새로운 DosagePlan을 반환한다.
  DosagePlan copyWith({
    String? id,
    String? userId,
    MedicationName? medicationName,
    StartDate? startDate,
    int? cycleDays,
    double? initialDoseMg,
    List<EscalationStep>? escalationPlan,
    bool? isActive,
  }) {
    return DosagePlan(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      medicationName: medicationName ?? this.medicationName,
      startDate: startDate ?? this.startDate,
      cycleDays: cycleDays ?? this.cycleDays,
      initialDoseMg: initialDoseMg ?? this.initialDoseMg,
      escalationPlan: escalationPlan ?? this.escalationPlan,
      isActive: isActive ?? this.isActive,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is DosagePlan &&
        other.id == id &&
        other.userId == userId &&
        other.medicationName == medicationName &&
        other.startDate == startDate &&
        other.cycleDays == cycleDays &&
        other.initialDoseMg == initialDoseMg &&
        other.isActive == isActive;
  }

  @override
  int get hashCode =>
      id.hashCode ^
      userId.hashCode ^
      medicationName.hashCode ^
      startDate.hashCode ^
      cycleDays.hashCode ^
      initialDoseMg.hashCode ^
      isActive.hashCode;

  @override
  String toString() =>
      'DosagePlan(id: $id, medicationName: ${medicationName.value}, cycleDays: $cycleDays)';
}
</file>

<file path="lib/features/onboarding/domain/entities/dose_schedule.dart">
/// 투여 스케줄을 나타내는 Entity
class DoseSchedule {
  final String id;
  final String userId;
  final String dosagePlanId;
  final DateTime scheduledDate;
  final double scheduledDoseMg;
  final String? notificationTime;

  /// DoseSchedule을 생성한다.
  /// scheduledDoseMg는 양수여야 한다.
  DoseSchedule({
    required this.id,
    required this.userId,
    required this.dosagePlanId,
    required this.scheduledDate,
    required this.scheduledDoseMg,
    this.notificationTime,
  }) {
    if (scheduledDoseMg <= 0) {
      throw ArgumentError('용량(scheduledDoseMg)은 양수여야 합니다.');
    }
  }

  /// 현재 DoseSchedule의 일부 필드를 변경한 새로운 DoseSchedule을 반환한다.
  DoseSchedule copyWith({
    String? id,
    String? userId,
    String? dosagePlanId,
    DateTime? scheduledDate,
    double? scheduledDoseMg,
    String? notificationTime,
  }) {
    return DoseSchedule(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      dosagePlanId: dosagePlanId ?? this.dosagePlanId,
      scheduledDate: scheduledDate ?? this.scheduledDate,
      scheduledDoseMg: scheduledDoseMg ?? this.scheduledDoseMg,
      notificationTime: notificationTime ?? this.notificationTime,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is DoseSchedule &&
        other.id == id &&
        other.userId == userId &&
        other.dosagePlanId == dosagePlanId &&
        other.scheduledDate == scheduledDate &&
        other.scheduledDoseMg == scheduledDoseMg;
  }

  @override
  int get hashCode =>
      id.hashCode ^
      userId.hashCode ^
      dosagePlanId.hashCode ^
      scheduledDate.hashCode ^
      scheduledDoseMg.hashCode;

  @override
  String toString() =>
      'DoseSchedule(id: $id, scheduledDate: $scheduledDate, doseMg: $scheduledDoseMg)';
}
</file>

<file path="lib/features/onboarding/domain/entities/escalation_step.dart">
/// 증량 계획의 한 단계를 나타내는 Value Object
class EscalationStep {
  final int weeks;
  final double doseMg;

  /// EscalationStep을 생성한다.
  /// weeks와 doseMg는 모두 양수여야 한다.
  EscalationStep({
    required this.weeks,
    required this.doseMg,
  }) {
    if (weeks <= 0) {
      throw ArgumentError('주(weeks)는 양수여야 합니다.');
    }
    if (doseMg <= 0) {
      throw ArgumentError('용량(doseMg)은 양수여야 합니다.');
    }
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is EscalationStep &&
        other.weeks == weeks &&
        other.doseMg == doseMg;
  }

  @override
  int get hashCode => weeks.hashCode ^ doseMg.hashCode;

  @override
  String toString() => 'EscalationStep(weeks: $weeks, doseMg: $doseMg)';
}
</file>

<file path="lib/features/onboarding/domain/entities/user_profile.dart">
import 'package:n06/features/onboarding/domain/value_objects/weight.dart';

/// 사용자 프로필 및 목표를 나타내는 Entity
class UserProfile {
  final String userId;
  final Weight targetWeight;
  final Weight currentWeight;
  final int? targetPeriodWeeks;
  final double? weeklyLossGoalKg;
  final int weeklyWeightRecordGoal;
  final int weeklySymptomRecordGoal;

  /// UserProfile을 생성한다.
  /// weeklyWeightRecordGoal과 weeklySymptomRecordGoal의 기본값은 7이다.
  UserProfile({
    required this.userId,
    required this.targetWeight,
    required this.currentWeight,
    this.targetPeriodWeeks,
    this.weeklyLossGoalKg,
    this.weeklyWeightRecordGoal = 7,
    this.weeklySymptomRecordGoal = 7,
  });

  /// 주간 감량 목표를 계산한다.
  /// targetPeriodWeeks가 null이면 null을 반환한다.
  static double? calculateWeeklyGoal(
    Weight currentWeight,
    Weight targetWeight,
    int? periodWeeks,
  ) {
    if (periodWeeks == null || periodWeeks <= 0) {
      return null;
    }

    final totalWeightLoss = currentWeight.value - targetWeight.value;
    if (totalWeightLoss <= 0) {
      return null;
    }

    return double.parse(
      (totalWeightLoss / periodWeeks).toStringAsFixed(2),
    );
  }

  /// 현재 UserProfile의 일부 필드를 변경한 새로운 UserProfile을 반환한다.
  UserProfile copyWith({
    String? userId,
    Weight? targetWeight,
    Weight? currentWeight,
    int? targetPeriodWeeks,
    double? weeklyLossGoalKg,
    int? weeklyWeightRecordGoal,
    int? weeklySymptomRecordGoal,
  }) {
    return UserProfile(
      userId: userId ?? this.userId,
      targetWeight: targetWeight ?? this.targetWeight,
      currentWeight: currentWeight ?? this.currentWeight,
      targetPeriodWeeks: targetPeriodWeeks ?? this.targetPeriodWeeks,
      weeklyLossGoalKg: weeklyLossGoalKg ?? this.weeklyLossGoalKg,
      weeklyWeightRecordGoal:
          weeklyWeightRecordGoal ?? this.weeklyWeightRecordGoal,
      weeklySymptomRecordGoal:
          weeklySymptomRecordGoal ?? this.weeklySymptomRecordGoal,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is UserProfile &&
        other.userId == userId &&
        other.targetWeight == targetWeight &&
        other.currentWeight == currentWeight &&
        other.targetPeriodWeeks == targetPeriodWeeks &&
        other.weeklyLossGoalKg == weeklyLossGoalKg &&
        other.weeklyWeightRecordGoal == weeklyWeightRecordGoal &&
        other.weeklySymptomRecordGoal == weeklySymptomRecordGoal;
  }

  @override
  int get hashCode =>
      userId.hashCode ^
      targetWeight.hashCode ^
      currentWeight.hashCode ^
      targetPeriodWeeks.hashCode ^
      weeklyLossGoalKg.hashCode ^
      weeklyWeightRecordGoal.hashCode ^
      weeklySymptomRecordGoal.hashCode;

  @override
  String toString() =>
      'UserProfile(userId: $userId, targetWeight: ${targetWeight.value}kg, currentWeight: ${currentWeight.value}kg)';
}
</file>

<file path="lib/features/onboarding/domain/entities/user.dart">
/// 사용자 계정 정보를 나타내는 Entity
class User {
  final String id;
  final String name;
  final DateTime createdAt;

  /// User 엔티티를 생성한다.
  /// id와 name이 비어있으면 ArgumentError를 던진다.
  User({
    required this.id,
    required this.name,
    required this.createdAt,
  }) {
    if (id.isEmpty) {
      throw ArgumentError('id는 비워둘 수 없습니다.');
    }
    if (name.isEmpty) {
      throw ArgumentError('name은 비워둘 수 없습니다.');
    }
  }

  /// 현재 User의 일부 필드를 변경한 새로운 User를 반환한다.
  User copyWith({
    String? id,
    String? name,
    DateTime? createdAt,
  }) {
    return User(
      id: id ?? this.id,
      name: name ?? this.name,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is User &&
        other.id == id &&
        other.name == name &&
        other.createdAt == createdAt;
  }

  @override
  int get hashCode => id.hashCode ^ name.hashCode ^ createdAt.hashCode;

  @override
  String toString() =>
      'User(id: $id, name: $name, createdAt: $createdAt)';
}
</file>

<file path="lib/features/onboarding/domain/entities/weight_log.dart">
import 'package:n06/features/onboarding/domain/value_objects/weight.dart';

/// 체중 기록을 나타내는 Entity
class WeightLog {
  final String id;
  final String userId;
  final DateTime logDate;
  final Weight weight;
  final DateTime createdAt;

  /// WeightLog를 생성한다.
  WeightLog({
    required this.id,
    required this.userId,
    required this.logDate,
    required this.weight,
    required this.createdAt,
  });

  /// 현재 WeightLog의 일부 필드를 변경한 새로운 WeightLog을 반환한다.
  WeightLog copyWith({
    String? id,
    String? userId,
    DateTime? logDate,
    Weight? weight,
    DateTime? createdAt,
  }) {
    return WeightLog(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      logDate: logDate ?? this.logDate,
      weight: weight ?? this.weight,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is WeightLog &&
        other.id == id &&
        other.userId == userId &&
        other.logDate == logDate &&
        other.weight == weight &&
        other.createdAt == createdAt;
  }

  @override
  int get hashCode =>
      id.hashCode ^
      userId.hashCode ^
      logDate.hashCode ^
      weight.hashCode ^
      createdAt.hashCode;

  @override
  String toString() =>
      'WeightLog(id: $id, weight: ${weight.value}kg, logDate: $logDate)';
}
</file>

<file path="lib/features/onboarding/domain/repositories/medication_repository.dart">
import 'package:n06/features/onboarding/domain/entities/dosage_plan.dart';

/// 투여 계획 접근 계약을 정의하는 Repository Interface
abstract class MedicationRepository {
  /// 투여 계획을 저장한다.
  Future<void> saveDosagePlan(DosagePlan plan);

  /// 활성 투여 계획을 조회한다.
  Future<DosagePlan?> getActiveDosagePlan(String userId);

  /// 투여 계획을 업데이트한다.
  Future<void> updateDosagePlan(DosagePlan plan);
}
</file>

<file path="lib/features/onboarding/domain/repositories/profile_repository.dart">
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';

/// 사용자 프로필 접근 계약을 정의하는 Repository Interface
abstract class ProfileRepository {
  /// 사용자 프로필을 저장한다.
  Future<void> saveUserProfile(UserProfile profile);

  /// 사용자 프로필을 조회한다.
  Future<UserProfile?> getUserProfile(String userId);

  /// 사용자 프로필을 업데이트한다.
  Future<void> updateUserProfile(UserProfile profile);
}
</file>

<file path="lib/features/onboarding/domain/repositories/schedule_repository.dart">
import 'package:n06/features/onboarding/domain/entities/dose_schedule.dart';

/// 투여 스케줄 접근 계약을 정의하는 Repository Interface
abstract class ScheduleRepository {
  /// 여러 투여 스케줄을 한 번에 저장한다.
  Future<void> saveAll(List<DoseSchedule> schedules);

  /// 날짜 범위 내의 투여 스케줄을 조회한다.
  Future<List<DoseSchedule>> getSchedulesByDateRange(
    String userId,
    DateTime startDate,
    DateTime endDate,
  );
}
</file>

<file path="lib/features/onboarding/domain/repositories/tracking_repository.dart">
import 'package:n06/features/onboarding/domain/entities/weight_log.dart';

/// 추적 데이터(체중 등) 접근 계약을 정의하는 Repository Interface
abstract class TrackingRepository {
  /// 체중 기록을 저장한다.
  Future<void> saveWeightLog(WeightLog log);

  /// 사용자의 체중 기록을 조회한다.
  Future<List<WeightLog>> getWeightLogs(String userId);
}
</file>

<file path="lib/features/onboarding/domain/repositories/user_repository.dart">
import 'package:n06/features/onboarding/domain/entities/user.dart';

/// 사용자 정보 접근 계약을 정의하는 Repository Interface
abstract class UserRepository {
  /// 사용자명을 업데이트한다.
  Future<void> updateUserName(String userId, String name);

  /// 사용자 정보를 조회한다.
  Future<User?> getUser(String userId);

  /// 사용자 정보를 저장한다.
  Future<void> saveUser(User user);
}
</file>

<file path="lib/features/onboarding/domain/usecases/calculate_weekly_goal_usecase.dart">
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/onboarding/domain/value_objects/weight.dart';

/// 주간 감량 목표를 계산하는 UseCase
class CalculateWeeklyGoalUseCase {
  /// 주간 감량 목표를 계산한다.
  ///
  /// 반환값: {'weeklyGoal': double?, 'hasWarning': bool}
  /// - weeklyGoal: 계산된 주간 감량 목표 (null이면 계산 불가)
  /// - hasWarning: 주간 목표가 1kg을 초과하는 경우 true
  Map<String, dynamic> execute({
    required Weight currentWeight,
    required Weight targetWeight,
    int? periodWeeks,
  }) {
    if (currentWeight.value <= targetWeight.value) {
      throw ArgumentError('현재 체중은 목표 체중보다 커야 합니다.');
    }

    final weeklyGoal = UserProfile.calculateWeeklyGoal(
      currentWeight,
      targetWeight,
      periodWeeks,
    );

    final hasWarning = weeklyGoal != null && weeklyGoal > 1.0;

    return {
      'weeklyGoal': weeklyGoal,
      'hasWarning': hasWarning,
    };
  }
}
</file>

<file path="lib/features/onboarding/domain/usecases/check_onboarding_status_usecase.dart">
import 'package:n06/features/onboarding/domain/repositories/profile_repository.dart';

/// 사용자의 온보딩 완료 여부를 확인하는 UseCase
class CheckOnboardingStatusUseCase {
  final ProfileRepository _profileRepository;

  CheckOnboardingStatusUseCase(this._profileRepository);

  /// 사용자가 온보딩을 완료했는지 확인한다.
  /// - true: 온보딩 완료 (프로필 존재)
  /// - false: 온보딩 미완료 (프로필 없음)
  Future<bool> execute(String userId) async {
    try {
      final profile = await _profileRepository.getUserProfile(userId);
      return profile != null;
    } catch (e) {
      return false;
    }
  }
}
</file>

<file path="lib/features/onboarding/domain/usecases/generate_dose_schedules_usecase.dart">
import 'package:n06/features/onboarding/domain/entities/dosage_plan.dart';
import 'package:n06/features/onboarding/domain/entities/dose_schedule.dart';
import 'package:uuid/uuid.dart';

/// DosagePlan 기반 투여 스케줄을 생성하는 UseCase
class GenerateDoseSchedulesUseCase {
  static const Uuid _uuid = Uuid();

  /// 투여 스케줄을 생성한다.
  ///
  /// [daysToGenerate]: 생성할 날짜 범위 (기본값: 90일)
  List<DoseSchedule> execute(
    DosagePlan dosagePlan, {
    int daysToGenerate = 90,
  }) {
    if (daysToGenerate <= 0) {
      return [];
    }

    final schedules = <DoseSchedule>[];
    var currentDate = dosagePlan.startDate.value;
    var currentDoseMg = dosagePlan.initialDoseMg;
    final endDate = currentDate.add(Duration(days: daysToGenerate));
    var escalationIndex = 0;

    while (currentDate.isBefore(endDate)) {
      // 현재 날짜에서의 용량 결정
      if (dosagePlan.escalationPlan != null && escalationIndex < dosagePlan.escalationPlan!.length) {
        final nextEscalation = dosagePlan.escalationPlan![escalationIndex];
        final escalationDate = dosagePlan.startDate.value
            .add(Duration(days: nextEscalation.weeks * 7));

        if (currentDate.isAtSameMomentAs(escalationDate) || currentDate.isAfter(escalationDate)) {
          currentDoseMg = nextEscalation.doseMg;
          escalationIndex++;
        }
      }

      // 현재 날짜로 스케줄 생성
      schedules.add(
        DoseSchedule(
          id: _uuid.v4(),
          userId: dosagePlan.userId,
          dosagePlanId: dosagePlan.id,
          scheduledDate: currentDate,
          scheduledDoseMg: currentDoseMg,
        ),
      );

      // 다음 투여 날짜로 이동
      currentDate = currentDate.add(Duration(days: dosagePlan.cycleDays));
    }

    return schedules;
  }
}
</file>

<file path="lib/features/onboarding/domain/usecases/validate_dosage_plan_usecase.dart">
import 'package:n06/features/onboarding/domain/entities/escalation_step.dart';

/// 투여 계획의 증량 단계를 검증하는 UseCase
class ValidateDosagePlanUseCase {
  /// 증량 계획이 유효한지 검증한다.
  ///
  /// 반환값: {'isValid': bool, 'errors': List<String>}
  /// - isValid: 증량 계획이 유효한 경우 true
  /// - errors: 유효하지 않은 경우 에러 메시지 리스트
  Map<String, dynamic> execute(List<EscalationStep>? escalationPlan) {
    if (escalationPlan == null || escalationPlan.isEmpty) {
      return {
        'isValid': true,
        'errors': <String>[],
      };
    }

    final errors = <String>[];

    // 용량이 증가하지 않는 경우 검사
    for (int i = 1; i < escalationPlan.length; i++) {
      if (escalationPlan[i].doseMg <= escalationPlan[i - 1].doseMg) {
        errors.add('증량 계획의 용량은 점진적으로 증가해야 합니다.');
        break;
      }
    }

    // 시기가 역순인 경우 검사
    for (int i = 1; i < escalationPlan.length; i++) {
      if (escalationPlan[i].weeks <= escalationPlan[i - 1].weeks) {
        errors.add('증량 계획의 시기는 순차적이어야 합니다.');
        break;
      }
    }

    // 중복 시기 검사 (위 검사에서 이미 포함됨)

    return {
      'isValid': errors.isEmpty,
      'errors': errors,
    };
  }
}
</file>

<file path="lib/features/onboarding/domain/value_objects/medication_name.dart">
import 'package:n06/core/errors/domain_exception.dart';

/// 약물명을 나타내는 Value Object
/// 빈 문자열이나 공백만으로 이루어진 문자열을 허용하지 않는다.
class MedicationName {
  final String value;

  const MedicationName._(this.value);

  /// 주어진 약물명으로 MedicationName을 생성한다.
  /// 빈 문자열이거나 공백만 있으면 DomainException을 던진다.
  factory MedicationName.create(String name) {
    final trimmed = name.trim();
    if (trimmed.isEmpty) {
      throw DomainException(
        message: '약물명은 비워둘 수 없습니다.',
        code: 'INVALID_MEDICATION_NAME',
      );
    }
    return MedicationName._(trimmed);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is MedicationName && other.value == value;
  }

  @override
  int get hashCode => value.hashCode;

  @override
  String toString() => 'MedicationName($value)';
}
</file>

<file path="lib/features/onboarding/domain/value_objects/start_date.dart">
import 'package:n06/core/errors/domain_exception.dart';

/// 투여 시작일을 나타내는 Value Object
/// 30일 이상 과거 날짜는 허용하지 않으며,
/// 7일 이상 과거 날짜는 경고 플래그를 설정한다.
class StartDate {
  final DateTime value;
  final bool hasWarning;

  const StartDate._(this.value, this.hasWarning);

  /// 주어진 날짜로 StartDate를 생성한다.
  /// - 30일 이상 과거: DomainException 발생
  /// - 7~29일 과거: 경고 플래그 설정 (hasWarning = true)
  /// - 현재 이후: 정상 (hasWarning = false)
  factory StartDate.create(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date).inDays;

    if (difference >= 30) {
      throw DomainException(
        message: '시작일은 30일 이상 과거일 수 없습니다.',
        code: 'INVALID_START_DATE',
      );
    }

    final hasWarning = difference >= 7;

    return StartDate._(date, hasWarning);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is StartDate &&
        other.value.year == value.year &&
        other.value.month == value.month &&
        other.value.day == value.day;
  }

  @override
  int get hashCode => value.hashCode;

  @override
  String toString() =>
      'StartDate(${value.year}-${value.month.toString().padLeft(2, '0')}-${value.day.toString().padLeft(2, '0')}, hasWarning: $hasWarning)';
}
</file>

<file path="lib/features/onboarding/domain/value_objects/weight.dart">
import 'package:n06/core/errors/domain_exception.dart';

/// 체중을 나타내는 Value Object
/// 20kg ~ 300kg 범위의 검증을 수행한다.
class Weight {
  final double value;

  const Weight._(this.value);

  /// 주어진 킬로그램 값으로 Weight를 생성한다.
  /// 20kg 미만이거나 300kg을 초과하면 DomainException을 던진다.
  factory Weight.create(double kg) {
    if (kg < 20 || kg > 300) {
      throw DomainException(
        message: '체중은 20kg 이상 300kg 이하여야 합니다.',
        code: 'INVALID_WEIGHT',
      );
    }
    return Weight._(kg);
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;

    return other is Weight && other.value == value;
  }

  @override
  int get hashCode => value.hashCode;

  @override
  String toString() => 'Weight($value kg)';
}
</file>

<file path="lib/features/onboarding/infrastructure/dtos/dosage_plan_dto.dart">
import 'package:isar/isar.dart';
import 'dart:convert';
import 'package:n06/features/onboarding/domain/entities/dosage_plan.dart';
import 'package:n06/features/onboarding/domain/entities/escalation_step.dart';
import 'package:n06/features/onboarding/domain/value_objects/medication_name.dart';
import 'package:n06/features/onboarding/domain/value_objects/start_date.dart';
import 'escalation_step_dto.dart';

part 'dosage_plan_dto.g.dart';

@collection
class DosagePlanDto {
  Id isarId = Isar.autoIncrement;

  late String id;
  late String userId;
  late String medicationName;
  late DateTime startDate;
  late int cycleDays;
  late double initialDoseMg;
  late String? escalationPlanJson;
  late bool isActive;

  /// DTO를 Domain Entity로 변환한다.
  DosagePlan toEntity() {
    final escalationSteps = _parseEscalationPlan(escalationPlanJson);

    return DosagePlan(
      id: id,
      userId: userId,
      medicationName: MedicationName.create(medicationName),
      startDate: StartDate.create(startDate),
      cycleDays: cycleDays,
      initialDoseMg: initialDoseMg,
      escalationPlan: escalationSteps,
      isActive: isActive,
    );
  }

  /// Domain Entity를 DTO로 변환한다.
  static DosagePlanDto fromEntity(DosagePlan entity) {
    final escalationJson = entity.escalationPlan != null
        ? jsonEncode(
            entity.escalationPlan!
                .map((e) => EscalationStepDto.fromEntity(e).toJson())
                .toList(),
          )
        : null;

    return DosagePlanDto()
      ..id = entity.id
      ..userId = entity.userId
      ..medicationName = entity.medicationName.value
      ..startDate = entity.startDate.value
      ..cycleDays = entity.cycleDays
      ..initialDoseMg = entity.initialDoseMg
      ..escalationPlanJson = escalationJson
      ..isActive = entity.isActive;
  }

  /// JSON 문자열을 EscalationStep 리스트로 파싱한다.
  static List<EscalationStep>? _parseEscalationPlan(String? json) {
    if (json == null || json.isEmpty) {
      return null;
    }

    try {
      final List<dynamic> data = jsonDecode(json);
      return data
          .map((item) => EscalationStepDto.fromJson(item as Map<String, dynamic>)
              .toEntity())
          .toList();
    } catch (e) {
      return null;
    }
  }
}
</file>

<file path="lib/features/onboarding/infrastructure/dtos/dose_schedule_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/onboarding/domain/entities/dose_schedule.dart';

part 'dose_schedule_dto.g.dart';

@collection
class DoseScheduleDto {
  Id isarId = Isar.autoIncrement;

  late String id;
  late String userId;
  late String dosagePlanId;
  late DateTime scheduledDate;
  late double scheduledDoseMg;
  late String? notificationTime;

  /// DTO를 Domain Entity로 변환한다.
  DoseSchedule toEntity() {
    return DoseSchedule(
      id: id,
      userId: userId,
      dosagePlanId: dosagePlanId,
      scheduledDate: scheduledDate,
      scheduledDoseMg: scheduledDoseMg,
      notificationTime: notificationTime,
    );
  }

  /// Domain Entity를 DTO로 변환한다.
  static DoseScheduleDto fromEntity(DoseSchedule entity) {
    return DoseScheduleDto()
      ..id = entity.id
      ..userId = entity.userId
      ..dosagePlanId = entity.dosagePlanId
      ..scheduledDate = entity.scheduledDate
      ..scheduledDoseMg = entity.scheduledDoseMg
      ..notificationTime = entity.notificationTime;
  }
}
</file>

<file path="lib/features/onboarding/infrastructure/dtos/escalation_step_dto.dart">
import 'package:n06/features/onboarding/domain/entities/escalation_step.dart';

class EscalationStepDto {
  final int weeks;
  final double doseMg;

  EscalationStepDto({
    required this.weeks,
    required this.doseMg,
  });

  /// DTO를 Domain Entity로 변환한다.
  EscalationStep toEntity() {
    return EscalationStep(
      weeks: weeks,
      doseMg: doseMg,
    );
  }

  /// Domain Entity를 DTO로 변환한다.
  static EscalationStepDto fromEntity(EscalationStep entity) {
    return EscalationStepDto(
      weeks: entity.weeks,
      doseMg: entity.doseMg,
    );
  }

  /// JSON 맵으로 변환한다.
  Map<String, dynamic> toJson() {
    return {
      'weeks': weeks,
      'doseMg': doseMg,
    };
  }

  /// JSON 맵에서 생성한다.
  factory EscalationStepDto.fromJson(Map<String, dynamic> json) {
    return EscalationStepDto(
      weeks: json['weeks'] as int,
      doseMg: json['doseMg'] as double,
    );
  }
}
</file>

<file path="lib/features/onboarding/infrastructure/dtos/user_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/onboarding/domain/entities/user.dart';

part 'user_dto.g.dart';

@collection
class UserDto {
  Id isarId = Isar.autoIncrement;

  late String id;
  late String name;
  late DateTime createdAt;

  /// DTO를 Domain Entity로 변환한다.
  User toEntity() {
    return User(
      id: id,
      name: name,
      createdAt: createdAt,
    );
  }

  /// Domain Entity를 DTO로 변환한다.
  static UserDto fromEntity(User entity) {
    return UserDto()
      ..id = entity.id
      ..name = entity.name
      ..createdAt = entity.createdAt;
  }
}
</file>

<file path="lib/features/onboarding/infrastructure/dtos/user_profile_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/onboarding/domain/value_objects/weight.dart';

part 'user_profile_dto.g.dart';

@collection
class UserProfileDto {
  Id isarId = Isar.autoIncrement;

  late String userId;
  late double targetWeightKg;
  late double currentWeightKg;
  late int? targetPeriodWeeks;
  late double? weeklyLossGoalKg;
  late int weeklyWeightRecordGoal;
  late int weeklySymptomRecordGoal;

  /// DTO를 Domain Entity로 변환한다.
  UserProfile toEntity() {
    return UserProfile(
      userId: userId,
      targetWeight: Weight.create(targetWeightKg),
      currentWeight: Weight.create(currentWeightKg),
      targetPeriodWeeks: targetPeriodWeeks,
      weeklyLossGoalKg: weeklyLossGoalKg,
      weeklyWeightRecordGoal: weeklyWeightRecordGoal,
      weeklySymptomRecordGoal: weeklySymptomRecordGoal,
    );
  }

  /// Domain Entity를 DTO로 변환한다.
  static UserProfileDto fromEntity(UserProfile entity) {
    return UserProfileDto()
      ..userId = entity.userId
      ..targetWeightKg = entity.targetWeight.value
      ..currentWeightKg = entity.currentWeight.value
      ..targetPeriodWeeks = entity.targetPeriodWeeks
      ..weeklyLossGoalKg = entity.weeklyLossGoalKg
      ..weeklyWeightRecordGoal = entity.weeklyWeightRecordGoal
      ..weeklySymptomRecordGoal = entity.weeklySymptomRecordGoal;
  }
}
</file>

<file path="lib/features/onboarding/infrastructure/dtos/weight_log_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/onboarding/domain/entities/weight_log.dart';
import 'package:n06/features/onboarding/domain/value_objects/weight.dart';

part 'weight_log_dto.g.dart';

@collection
class WeightLogDto {
  Id isarId = Isar.autoIncrement;

  late String id;
  late String userId;
  late DateTime logDate;
  late double weightKg;
  late DateTime createdAt;

  /// DTO를 Domain Entity로 변환한다.
  WeightLog toEntity() {
    return WeightLog(
      id: id,
      userId: userId,
      logDate: logDate,
      weight: Weight.create(weightKg),
      createdAt: createdAt,
    );
  }

  /// Domain Entity를 DTO로 변환한다.
  static WeightLogDto fromEntity(WeightLog entity) {
    return WeightLogDto()
      ..id = entity.id
      ..userId = entity.userId
      ..logDate = entity.logDate
      ..weightKg = entity.weight.value
      ..createdAt = entity.createdAt;
  }
}
</file>

<file path="lib/features/onboarding/infrastructure/repositories/isar_medication_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/onboarding/domain/entities/dosage_plan.dart';
import 'package:n06/features/onboarding/domain/repositories/medication_repository.dart';
import 'package:n06/features/onboarding/infrastructure/dtos/dosage_plan_dto.dart';

/// Isar 기반 MedicationRepository 구현
class IsarMedicationRepository implements MedicationRepository {
  final Isar _isar;

  IsarMedicationRepository(this._isar);

  @override
  Future<void> saveDosagePlan(DosagePlan plan) async {
    final dto = DosagePlanDto.fromEntity(plan);
    await _isar.writeTxn(() async {
      await _isar.dosagePlanDtos.put(dto);
    });
  }

  @override
  Future<DosagePlan?> getActiveDosagePlan(String userId) async {
    final dto = await _isar.dosagePlanDtos
        .filter()
        .userIdEqualTo(userId)
        .isActiveEqualTo(true)
        .findFirst();
    return dto?.toEntity();
  }

  @override
  Future<void> updateDosagePlan(DosagePlan plan) async {
    final dto = DosagePlanDto.fromEntity(plan);
    await _isar.writeTxn(() async {
      await _isar.dosagePlanDtos.put(dto);
    });
  }
}
</file>

<file path="lib/features/onboarding/infrastructure/repositories/isar_profile_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/onboarding/domain/repositories/profile_repository.dart';
import 'package:n06/features/onboarding/infrastructure/dtos/user_profile_dto.dart';

/// Isar 기반 ProfileRepository 구현
class IsarProfileRepository implements ProfileRepository {
  final Isar _isar;

  IsarProfileRepository(this._isar);

  @override
  Future<void> saveUserProfile(UserProfile profile) async {
    final dto = UserProfileDto.fromEntity(profile);
    await _isar.writeTxn(() async {
      await _isar.userProfileDtos.put(dto);
    });
  }

  @override
  Future<UserProfile?> getUserProfile(String userId) async {
    final dto = await _isar.userProfileDtos
        .filter()
        .userIdEqualTo(userId)
        .findFirst();
    return dto?.toEntity();
  }

  @override
  Future<void> updateUserProfile(UserProfile profile) async {
    final dto = UserProfileDto.fromEntity(profile);
    await _isar.writeTxn(() async {
      await _isar.userProfileDtos.put(dto);
    });
  }
}
</file>

<file path="lib/features/onboarding/infrastructure/repositories/isar_schedule_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/onboarding/domain/entities/dose_schedule.dart';
import 'package:n06/features/onboarding/domain/repositories/schedule_repository.dart';
import 'package:n06/features/onboarding/infrastructure/dtos/dose_schedule_dto.dart';

/// Isar 기반 ScheduleRepository 구현
class IsarScheduleRepository implements ScheduleRepository {
  final Isar _isar;

  IsarScheduleRepository(this._isar);

  @override
  Future<void> saveAll(List<DoseSchedule> schedules) async {
    final dtos = schedules.map((s) => DoseScheduleDto.fromEntity(s)).toList();
    await _isar.writeTxn(() async {
      await _isar.doseScheduleDtos.putAll(dtos);
    });
  }

  @override
  Future<List<DoseSchedule>> getSchedulesByDateRange(
    String userId,
    DateTime startDate,
    DateTime endDate,
  ) async {
    final dtos = await _isar.doseScheduleDtos
        .filter()
        .userIdEqualTo(userId)
        .scheduledDateBetween(startDate, endDate)
        .findAll();
    return dtos.map((dto) => dto.toEntity()).toList();
  }
}
</file>

<file path="lib/features/onboarding/infrastructure/repositories/isar_tracking_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/onboarding/domain/entities/weight_log.dart';
import 'package:n06/features/onboarding/domain/repositories/tracking_repository.dart';
import 'package:n06/features/onboarding/infrastructure/dtos/weight_log_dto.dart';

/// Isar 기반 TrackingRepository 구현
class IsarTrackingRepository implements TrackingRepository {
  final Isar _isar;

  IsarTrackingRepository(this._isar);

  @override
  Future<void> saveWeightLog(WeightLog log) async {
    final dto = WeightLogDto.fromEntity(log);
    await _isar.writeTxn(() async {
      await _isar.weightLogDtos.put(dto);
    });
  }

  @override
  Future<List<WeightLog>> getWeightLogs(String userId) async {
    final dtos = await _isar.weightLogDtos
        .filter()
        .userIdEqualTo(userId)
        .findAll();
    return dtos.map((dto) => dto.toEntity()).toList();
  }
}
</file>

<file path="lib/features/onboarding/infrastructure/repositories/isar_user_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/onboarding/domain/entities/user.dart';
import 'package:n06/features/onboarding/domain/repositories/user_repository.dart';
import 'package:n06/features/onboarding/infrastructure/dtos/user_dto.dart';

/// Isar 기반 UserRepository 구현
class IsarUserRepository implements UserRepository {
  final Isar _isar;

  IsarUserRepository(this._isar);

  @override
  Future<void> updateUserName(String userId, String name) async {
    final dto = await _isar.userDtos.filter().idEqualTo(userId).findFirst();
    if (dto == null) {
      throw Exception('사용자를 찾을 수 없습니다: $userId');
    }

    await _isar.writeTxn(() async {
      dto.name = name;
      await _isar.userDtos.put(dto);
    });
  }

  @override
  Future<User?> getUser(String userId) async {
    final dto = await _isar.userDtos.filter().idEqualTo(userId).findFirst();
    return dto?.toEntity();
  }

  @override
  Future<void> saveUser(User user) async {
    final dto = UserDto.fromEntity(user);
    await _isar.writeTxn(() async {
      await _isar.userDtos.put(dto);
    });
  }
}
</file>

<file path="lib/features/onboarding/infrastructure/services/transaction_service.dart">
import 'package:isar/isar.dart';

/// Isar 트랜잭션을 관리하는 Service
class TransactionService {
  final Isar _isar;

  TransactionService(this._isar);

  /// 주어진 작업을 트랜잭션으로 실행한다.
  /// 작업 실패 시 자동으로 롤백된다.
  Future<T> executeInTransaction<T>(Future<T> Function() operation) async {
    return await _isar.writeTxn(() async {
      return await operation();
    });
  }
}
</file>

<file path="lib/features/profile/domain/usecases/update_profile_usecase.dart">
import 'package:n06/core/errors/domain_exception.dart';
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/profile/domain/repositories/profile_repository.dart';
import 'package:n06/features/tracking/domain/repositories/tracking_repository.dart';

/// UseCase for updating user profile
///
/// Validates profile data and persists changes through repository
class UpdateProfileUseCase {
  final ProfileRepository profileRepository;
  final TrackingRepository trackingRepository;

  const UpdateProfileUseCase({
    required this.profileRepository,
    required this.trackingRepository,
  });

  /// Execute profile update with validation
  ///
  /// Throws [DomainException] if:
  /// - Target weight is not less than current weight
  Future<void> execute(UserProfile profile) async {
    // Validate that target weight is less than current weight
    if (profile.targetWeight.value >= profile.currentWeight.value) {
      throw DomainException(
        message: '목표 체중은 현재 체중보다 작아야 합니다.',
        code: 'INVALID_TARGET_WEIGHT',
      );
    }

    // Save profile through repository
    await profileRepository.saveUserProfile(profile);
  }
}
</file>

<file path="lib/features/profile/infrastructure/dtos/user_profile_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/onboarding/domain/value_objects/weight.dart';

part 'user_profile_dto.g.dart';

/// User profile DTO for Isar storage
@collection
class UserProfileDto {
  Id? isarId;
  late String userId;
  late double targetWeightValue;
  late double currentWeightValue;
  int? targetPeriodWeeks;
  double? weeklyLossGoalKg;
  late int weeklyWeightRecordGoal;
  late int weeklySymptomRecordGoal;

  UserProfileDto();

  /// Convert DTO to Entity
  UserProfile toEntity() {
    return UserProfile(
      userId: userId,
      targetWeight: Weight.create(targetWeightValue),
      currentWeight: Weight.create(currentWeightValue),
      targetPeriodWeeks: targetPeriodWeeks,
      weeklyLossGoalKg: weeklyLossGoalKg,
      weeklyWeightRecordGoal: weeklyWeightRecordGoal,
      weeklySymptomRecordGoal: weeklySymptomRecordGoal,
    );
  }

  /// Create DTO from Entity
  factory UserProfileDto.fromEntity(UserProfile entity) {
    return UserProfileDto()
      ..userId = entity.userId
      ..targetWeightValue = entity.targetWeight.value
      ..currentWeightValue = entity.currentWeight.value
      ..targetPeriodWeeks = entity.targetPeriodWeeks
      ..weeklyLossGoalKg = entity.weeklyLossGoalKg
      ..weeklyWeightRecordGoal = entity.weeklyWeightRecordGoal
      ..weeklySymptomRecordGoal = entity.weeklySymptomRecordGoal;
  }
}
</file>

<file path="lib/features/profile/presentation/screens/profile_edit_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/profile/application/notifiers/profile_notifier.dart';
import 'package:n06/features/profile/presentation/widgets/profile_edit_form.dart';

/// Screen for editing user profile and goals
class ProfileEditScreen extends ConsumerStatefulWidget {
  const ProfileEditScreen({super.key});

  @override
  ConsumerState<ProfileEditScreen> createState() => _ProfileEditScreenState();
}

class _ProfileEditScreenState extends ConsumerState<ProfileEditScreen> {
  UserProfile? _editedProfile;
  String? _validationError;

  @override
  Widget build(BuildContext context) {
    final profileState = ref.watch(profileNotifierProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('프로필 및 목표 수정'),
        elevation: 0,
      ),
      body: profileState.when(
        loading: () => const Center(
          child: CircularProgressIndicator(),
        ),
        error: (error, stack) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text('오류가 발생했습니다: $error'),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () {
                  ref.invalidate(profileNotifierProvider);
                },
                child: const Text('다시 시도'),
              ),
            ],
          ),
        ),
        data: (profile) {
          if (profile == null) {
            return const Center(
              child: Text('프로필 정보를 찾을 수 없습니다.'),
            );
          }

          return Stack(
            children: [
              ProfileEditForm(
                profile: profile,
                onProfileChanged: (newProfile) {
                  setState(() {
                    _editedProfile = newProfile;
                    _validationError = null;
                  });
                },
              ),
              // Validation error message
              if (_validationError != null)
                Positioned(
                  bottom: 0,
                  left: 0,
                  right: 0,
                  child: Container(
                    color: Colors.red.withValues(alpha: 0.8),
                    padding: const EdgeInsets.all(16),
                    child: Text(
                      _validationError!,
                      style: const TextStyle(color: Colors.white),
                    ),
                  ),
                ),
            ],
          );
        },
      ),
      floatingActionButton: _editedProfile != null
          ? FloatingActionButton(
              onPressed: _handleSave,
              child: const Icon(Icons.check),
            )
          : null,
    );
  }

  void _handleSave() async {
    if (_editedProfile == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('변경사항이 없습니다.')),
      );
      Navigator.pop(context);
      return;
    }

    // Validate
    if (_editedProfile!.targetWeight.value >= _editedProfile!.currentWeight.value) {
      setState(() {
        _validationError = '목표 체중은 현재 체중보다 작아야 합니다.';
      });
      return;
    }

    try {
      // Update profile
      await ref.read(profileNotifierProvider.notifier).updateProfile(_editedProfile!);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('프로필이 저장되었습니다.')),
        );
        Navigator.pop(context);
      }
    } catch (e) {
      setState(() {
        _validationError = '저장 실패: $e';
      });
    }
  }
}
</file>

<file path="lib/features/profile/presentation/widgets/profile_edit_form.dart">
import 'package:flutter/material.dart';
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/onboarding/domain/value_objects/weight.dart';

/// Widget for editing profile information
class ProfileEditForm extends StatefulWidget {
  final UserProfile profile;
  final ValueChanged<UserProfile> onProfileChanged;

  const ProfileEditForm({
    super.key,
    required this.profile,
    required this.onProfileChanged,
  });

  @override
  State<ProfileEditForm> createState() => _ProfileEditFormState();
}

class _ProfileEditFormState extends State<ProfileEditForm> {
  late TextEditingController _nameController;
  late TextEditingController _targetWeightController;
  late TextEditingController _currentWeightController;
  late TextEditingController _targetPeriodController;

  late String _currentName;
  late double _currentTargetWeight;
  late double _currentCurrentWeight;
  late int? _currentTargetPeriod;

  double? _calculatedWeeklyGoal;
  bool _showWeeklyGoalWarning = false;

  @override
  void initState() {
    super.initState();
    _initializeControllers();
  }

  void _initializeControllers() {
    _currentName = widget.profile.userId; // TODO: Get actual name from somewhere
    _currentTargetWeight = widget.profile.targetWeight.value;
    _currentCurrentWeight = widget.profile.currentWeight.value;
    _currentTargetPeriod = widget.profile.targetPeriodWeeks;

    _nameController = TextEditingController(text: _currentName);
    _targetWeightController = TextEditingController(text: _currentTargetWeight.toString());
    _currentWeightController = TextEditingController(text: _currentCurrentWeight.toString());
    _targetPeriodController = TextEditingController(
      text: _currentTargetPeriod?.toString() ?? '',
    );

    _calculateWeeklyGoal();
  }

  void _calculateWeeklyGoal() {
    final targetWeight = double.tryParse(_targetWeightController.text);
    final currentWeight = double.tryParse(_currentWeightController.text);
    final periodWeeks = int.tryParse(_targetPeriodController.text);

    if (targetWeight != null && currentWeight != null && periodWeeks != null && periodWeeks > 0) {
      final weeklyGoal = (currentWeight - targetWeight) / periodWeeks;
      setState(() {
        _calculatedWeeklyGoal = double.parse(weeklyGoal.toStringAsFixed(2));
        _showWeeklyGoalWarning = _calculatedWeeklyGoal! > 1.0;
      });
    } else {
      setState(() {
        _calculatedWeeklyGoal = null;
        _showWeeklyGoalWarning = false;
      });
    }
  }

  void _notifyProfileChanged() {
    final targetWeight = double.tryParse(_targetWeightController.text);
    final currentWeight = double.tryParse(_currentWeightController.text);
    final periodWeeks = int.tryParse(_targetPeriodController.text);

    if (targetWeight != null && currentWeight != null) {
      try {
        final profile = UserProfile(
          userId: widget.profile.userId,
          targetWeight: Weight.create(targetWeight),
          currentWeight: Weight.create(currentWeight),
          targetPeriodWeeks: periodWeeks,
          weeklyLossGoalKg: _calculatedWeeklyGoal,
          weeklyWeightRecordGoal: widget.profile.weeklyWeightRecordGoal,
          weeklySymptomRecordGoal: widget.profile.weeklySymptomRecordGoal,
        );
        widget.onProfileChanged(profile);
      } catch (e) {
        // Validation error handled in parent
      }
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _targetWeightController.dispose();
    _currentWeightController.dispose();
    _targetPeriodController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Name field
          TextField(
            controller: _nameController,
            decoration: const InputDecoration(
              labelText: '이름',
              border: OutlineInputBorder(),
            ),
            onChanged: (_) => _notifyProfileChanged(),
          ),
          const SizedBox(height: 16),

          // Target weight field
          TextField(
            controller: _targetWeightController,
            decoration: const InputDecoration(
              labelText: '목표 체중 (kg)',
              border: OutlineInputBorder(),
            ),
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            onChanged: (_) {
              _calculateWeeklyGoal();
              _notifyProfileChanged();
            },
          ),
          const SizedBox(height: 16),

          // Current weight field
          TextField(
            controller: _currentWeightController,
            decoration: const InputDecoration(
              labelText: '현재 체중 (kg)',
              border: OutlineInputBorder(),
            ),
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            onChanged: (_) {
              _calculateWeeklyGoal();
              _notifyProfileChanged();
            },
          ),
          const SizedBox(height: 16),

          // Target period field
          TextField(
            controller: _targetPeriodController,
            decoration: const InputDecoration(
              labelText: '목표 기간 (주)',
              border: OutlineInputBorder(),
            ),
            keyboardType: TextInputType.number,
            onChanged: (_) {
              _calculateWeeklyGoal();
              _notifyProfileChanged();
            },
          ),
          const SizedBox(height: 16),

          // Weekly goal display
          if (_calculatedWeeklyGoal != null) ...[
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                border: Border.all(
                  color: _showWeeklyGoalWarning ? Colors.orange : Colors.grey,
                ),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    '주간 감량 목표: ${_calculatedWeeklyGoal!.toStringAsFixed(2)}kg',
                    style: Theme.of(context).textTheme.bodyMedium,
                  ),
                  if (_showWeeklyGoalWarning) ...[
                    const SizedBox(height: 8),
                    Row(
                      children: [
                        const Icon(Icons.warning, color: Colors.orange, size: 20),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            '주당 1kg 초과의 감량 목표는 위험할 수 있습니다.',
                            style: Theme.of(context).textTheme.bodySmall?.copyWith(
                              color: Colors.orange,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ],
                ],
              ),
            ),
          ],
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/profile/presentation/widgets/weekly_goal_input_widget.dart">
import 'package:flutter/material.dart';

/// Widget for inputting weekly goal values (0-7)
///
/// Provides real-time validation and error messages for weekly goal inputs.
class WeeklyGoalInputWidget extends StatefulWidget {
  final String label;
  final int initialValue;
  final Function(int) onChanged;

  const WeeklyGoalInputWidget({
    super.key,
    required this.label,
    required this.initialValue,
    required this.onChanged,
  });

  @override
  State<WeeklyGoalInputWidget> createState() => _WeeklyGoalInputWidgetState();
}

class _WeeklyGoalInputWidgetState extends State<WeeklyGoalInputWidget> {
  late TextEditingController _controller;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widget.initialValue.toString());
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  void _validateInput(String value) {
    setState(() {
      if (value.isEmpty) {
        _errorMessage = null;
        return;
      }

      // Check if non-integer
      if (!RegExp(r'^[0-9]+$').hasMatch(value)) {
        _errorMessage = '정수만 입력 가능합니다';
        return;
      }

      final intValue = int.parse(value);

      // Check range
      if (intValue < 0) {
        _errorMessage = '0 이상의 값을 입력하세요';
      } else if (intValue > 7) {
        _errorMessage = '주간 목표는 최대 7회입니다';
      } else {
        _errorMessage = null;
        // Notify parent of valid change
        widget.onChanged(intValue);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return TextField(
      controller: _controller,
      keyboardType: TextInputType.number,
      maxLength: 1,
      decoration: InputDecoration(
        labelText: widget.label,
        hintText: '0~7',
        counterText: '',
        suffixText: '회/주',
        suffixStyle: Theme.of(context).textTheme.bodyMedium,
        errorText: _errorMessage,
        errorBorder: OutlineInputBorder(
          borderSide: BorderSide(color: Colors.red[300]!),
        ),
        focusedErrorBorder: OutlineInputBorder(
          borderSide: BorderSide(color: Colors.red[300]!),
        ),
        border: const OutlineInputBorder(),
        isDense: false,
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 12.0,
          vertical: 12.0,
        ),
      ),
      onChanged: _validateInput,
    );
  }
}
</file>

<file path="lib/features/settings/presentation/widgets/settings_menu_item.dart">
import 'package:flutter/material.dart';

/// Settings menu item widget
class SettingsMenuItem extends StatelessWidget {
  final String title;
  final String subtitle;
  final VoidCallback onTap;

  const SettingsMenuItem({
    required this.title,
    required this.subtitle,
    required this.onTap,
    super.key,
  });

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text(title),
      subtitle: Text(subtitle),
      trailing: const Icon(Icons.chevron_right),
      onTap: onTap,
      contentPadding: const EdgeInsets.symmetric(vertical: 8.0),
    );
  }
}
</file>

<file path="lib/features/tracking/application/notifiers/dose_record_edit_notifier.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/tracking/domain/entities/audit_log.dart';
import 'package:n06/features/tracking/domain/usecases/log_record_change_usecase.dart';
import 'package:n06/features/tracking/application/providers.dart';
import 'package:n06/features/dashboard/application/notifiers/dashboard_notifier.dart';
import 'package:uuid/uuid.dart';

class DoseRecordEditNotifier extends AsyncNotifier<void> {
  late LogRecordChangeUseCase _logUseCase;

  @override
  Future<void> build() async {
    _logUseCase = LogRecordChangeUseCase(
      ref.watch(auditRepositoryProvider),
    );
  }

  Future<void> updateDoseRecord({
    required String recordId,
    required double newDoseMg,
    required String injectionSite,
    String? note,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      // Validate dose is positive
      if (newDoseMg <= 0) {
        throw Exception('투여량은 0보다 커야 합니다');
      }

      final medicationRepo = ref.read(medicationRepositoryProvider);

      // Get original record for audit
      final originalRecord = await medicationRepo.getDoseRecord(recordId);
      if (originalRecord == null) {
        throw Exception('Record not found');
      }

      // Update
      await medicationRepo.updateDoseRecord(
        recordId,
        newDoseMg,
        injectionSite,
        note,
      );

      // Log change
      await _logUseCase.execute(AuditLog(
        id: const Uuid().v4(),
        userId: userId,
        recordId: recordId,
        recordType: 'dose',
        changeType: 'update',
        oldValue: {
          'doseMg': originalRecord.actualDoseMg,
          'injectionSite': originalRecord.injectionSite,
          'note': originalRecord.note,
        },
        newValue: {
          'doseMg': newDoseMg,
          'injectionSite': injectionSite,
          'note': note,
        },
        timestamp: DateTime.now(),
      ));

      // Invalidate dashboard to trigger statistics recalculation
      ref.invalidate(dashboardNotifierProvider);
    });
  }

  Future<void> deleteDoseRecord({
    required String recordId,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final medicationRepo = ref.read(medicationRepositoryProvider);

      // Get original record for audit
      final originalRecord = await medicationRepo.getDoseRecord(recordId);
      if (originalRecord == null) {
        throw Exception('Record not found');
      }

      // Delete (note: schedule is NOT affected)
      await medicationRepo.deleteDoseRecord(recordId);

      // Log deletion
      await _logUseCase.execute(AuditLog(
        id: const Uuid().v4(),
        userId: userId,
        recordId: recordId,
        recordType: 'dose',
        changeType: 'delete',
        oldValue: {
          'doseMg': originalRecord.actualDoseMg,
          'injectionSite': originalRecord.injectionSite,
          'note': originalRecord.note,
          'administeredAt': originalRecord.administeredAt.toIso8601String(),
        },
        newValue: null,
        timestamp: DateTime.now(),
      ));

      // Invalidate dashboard to trigger statistics recalculation
      ref.invalidate(dashboardNotifierProvider);
    });
  }
}
</file>

<file path="lib/features/tracking/application/notifiers/emergency_check_notifier.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:n06/features/tracking/application/providers.dart';
import 'package:n06/features/tracking/domain/entities/emergency_symptom_check.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';

/// F005: 증상 체크 상태 관리 및 비즈니스 로직 orchestration
///
/// 책임:
/// 1. 증상 체크 기록 저장 (BR1-BR4)
/// 2. 자동으로 부작용 기록 생성 (BR2)
/// 3. 증상 체크 이력 조회
/// 4. 트랜잭션 관리 (증상 체크 저장 실패 시 부작용 기록도 롤백)
///
/// 의존성:
/// - EmergencyCheckRepository (F005)
/// - TrackingRepository (F002 - 부작용 기록 저장)
/// - MedicationRepository (F001 - 용량 증량 후 경과일 계산)
class EmergencyCheckNotifier
    extends AutoDisposeAsyncNotifier<List<EmergencySymptomCheck>> {
  @override
  Future<List<EmergencySymptomCheck>> build() async {
    // 초기 로드는 수행하지 않음 (사용자 ID 필요)
    return [];
  }

  /// 증상 체크 저장
  ///
  /// 플로우:
  /// 1. 증상 체크 저장 (emergency_symptom_checks)
  /// 2. 각 증상마다 자동으로 부작용 기록 생성 (BR2)
  ///    - 심각도: 10 (고정)
  ///    - 기록 날짜: checkedAt
  /// 3. 상태 재조회
  ///
  /// 예외 처리:
  /// - 부작용 기록 생성 실패 시, 증상 체크도 롤백하려고 시도
  /// - 상태는 error 상태로 전환
  Future<void> saveEmergencyCheck(
      String userId, EmergencySymptomCheck check) async {
    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      final emergencyCheckRepo =
          ref.read(emergencyCheckRepositoryProvider);
      final trackingRepo = ref.read(trackingRepositoryProvider);

      try {
        // 1. 증상 체크 저장
        await emergencyCheckRepo.saveEmergencyCheck(check);

        // 2. 각 증상마다 부작용 기록 자동 생성 (BR2)
        for (final symptom in check.checkedSymptoms) {
          final symptomLog = SymptomLog(
            id: const Uuid().v4(),
            userId: userId,
            logDate: check.checkedAt,
            symptomName: symptom,
            severity: 10, // 고정값 (BR2)
            daysSinceEscalation: null, // 계산 없음
            isPersistent24h: true, // 응급 증상이므로 24시간 이상 가정
            note: 'Emergency symptom check',
            tags: const [],
            createdAt: DateTime.now(),
          );
          await trackingRepo.saveSymptomLog(symptomLog);
        }

        // 3. 상태 재조회
        final checks = await emergencyCheckRepo.getEmergencyChecks(userId);
        return checks;
      } catch (e) {
        // 실패 시 에러 상태로 전환
        rethrow;
      }
    });
  }

  /// 사용자의 증상 체크 이력 조회
  Future<void> fetchEmergencyChecks(String userId) async {
    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      final repo = ref.read(emergencyCheckRepositoryProvider);
      return await repo.getEmergencyChecks(userId);
    });
  }

  /// 증상 체크 기록 삭제
  Future<void> deleteEmergencyCheck(String id) async {
    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      final repo = ref.read(emergencyCheckRepositoryProvider);
      await repo.deleteEmergencyCheck(id);

      // 상태는 빈 리스트로 재설정 (실제로는 모든 기록을 다시 조회해야 함)
      return state.value ?? [];
    });
  }

  /// 증상 체크 기록 수정
  Future<void> updateEmergencyCheck(EmergencySymptomCheck check) async {
    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      final repo = ref.read(emergencyCheckRepositoryProvider);
      await repo.updateEmergencyCheck(check);

      // 상태는 현재 상태에서 수정된 항목으로 업데이트
      final updatedChecks = state.value ?? [];
      return updatedChecks
          .map((c) => c.id == check.id ? check : c)
          .toList();
    });
  }
}

// Provider가 providers.dart에 정의되어 있음
</file>

<file path="lib/features/tracking/application/notifiers/medication_notifier.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';
import 'package:n06/features/tracking/domain/repositories/medication_repository.dart';
import 'package:n06/features/tracking/domain/usecases/injection_site_rotation_usecase.dart';
import 'package:n06/features/tracking/domain/usecases/missed_dose_analyzer_usecase.dart';
import 'package:n06/features/tracking/domain/usecases/schedule_generator_usecase.dart';
import 'package:n06/features/tracking/infrastructure/services/notification_service.dart';

class MedicationState {
  final AsyncValue<DosagePlan?> activePlan;
  final AsyncValue<List<DoseSchedule>> schedules;
  final AsyncValue<List<DoseRecord>> records;

  const MedicationState({
    required this.activePlan,
    required this.schedules,
    required this.records,
  });

  bool get isLoading =>
      activePlan is AsyncLoading ||
      schedules is AsyncLoading ||
      records is AsyncLoading;

  bool get hasError =>
      activePlan is AsyncError || schedules is AsyncError || records is AsyncError;
}

class MedicationNotifier extends StateNotifier<MedicationState> {
  final MedicationRepository _repository;
  final ScheduleGeneratorUseCase _scheduleGeneratorUseCase;
  final InjectionSiteRotationUseCase _injectionSiteRotationUseCase;
  final MissedDoseAnalyzerUseCase _missedDoseAnalyzerUseCase;
  final NotificationService notificationService;

  late String _userId;

  MedicationNotifier({
    required MedicationRepository repository,
    required ScheduleGeneratorUseCase scheduleGeneratorUseCase,
    required InjectionSiteRotationUseCase injectionSiteRotationUseCase,
    required MissedDoseAnalyzerUseCase missedDoseAnalyzerUseCase,
    required this.notificationService,
  })  : _repository = repository,
        _scheduleGeneratorUseCase = scheduleGeneratorUseCase,
        _injectionSiteRotationUseCase = injectionSiteRotationUseCase,
        _missedDoseAnalyzerUseCase = missedDoseAnalyzerUseCase,
        super(
          const MedicationState(
            activePlan: AsyncValue.loading(),
            schedules: AsyncValue.loading(),
            records: AsyncValue.loading(),
          ),
        );

  /// Initialize notifier with userId
  Future<void> initialize(String userId) async {
    _userId = userId;
    await _loadMedicationData();
  }

  /// Load medication data
  Future<void> _loadMedicationData() async {
    try {
      final plan = await _repository.getActiveDosagePlan(_userId);
      final schedules = plan != null
          ? await _repository.getDoseSchedules(plan.id)
          : <DoseSchedule>[];
      final records =
          plan != null ? await _repository.getDoseRecords(plan.id) : <DoseRecord>[];

      state = MedicationState(
        activePlan: AsyncValue.data(plan),
        schedules: AsyncValue.data(schedules),
        records: AsyncValue.data(records),
      );
    } catch (e, stackTrace) {
      state = MedicationState(
        activePlan: AsyncValue.error(e, stackTrace),
        schedules: AsyncValue.error(e, stackTrace),
        records: AsyncValue.error(e, stackTrace),
      );
    }
  }

  /// Record dose with injection site rotation check
  Future<RotationCheckResult?> recordDose(DoseRecord record) async {
    try {
      // Check if duplicate
      if (await _repository.isDuplicateDoseRecord(
        record.dosagePlanId,
        record.administeredAt,
      )) {
        throw Exception('이미 같은 날짜의 투여 기록이 존재합니다.');
      }

      // Check injection site rotation if site is specified
      RotationCheckResult? rotationResult;
      if (record.injectionSite != null) {
        final recentRecords = await _repository.getRecentDoseRecords(
          record.dosagePlanId,
          30,
        );
        rotationResult = _injectionSiteRotationUseCase.checkRotation(
          record.injectionSite!,
          recentRecords,
        );
      }

      // Save record
      await _repository.saveDoseRecord(record);

      // Reload records
      await _loadMedicationData();

      return rotationResult;
    } catch (e) {
      rethrow;
    }
  }

  /// Update dosage plan and recalculate schedules
  Future<void> updateDosagePlan(DosagePlan newPlan) async {
    try {
      final currentPlan = state.activePlan.valueOrNull;
      if (currentPlan == null) {
        throw Exception('활성 투여 계획이 없습니다.');
      }

      // Save plan change history
      await _repository.savePlanChangeHistory(
        newPlan.id,
        _planToMap(currentPlan),
        _planToMap(newPlan),
      );

      // Update plan
      await _repository.updateDosagePlan(newPlan);

      // Recalculate schedules from change date
      final existingSchedules = state.schedules.valueOrNull ?? [];
      final newSchedules = _scheduleGeneratorUseCase.recalculateSchedulesFrom(
        newPlan,
        DateTime.now(),
        DateTime.now().add(Duration(days: 365)),
        existingSchedules,
      );

      // Delete old schedules from change date and save new ones
      await _repository.deleteDoseSchedulesFrom(newPlan.id, DateTime.now());
      await _repository.saveDoseSchedules(newSchedules);

      // Reload data
      await _loadMedicationData();
    } catch (e) {
      rethrow;
    }
  }

  /// Get missed dose analysis
  MissedDoseAnalysisResult? getMissedDoseAnalysis() {
    final schedules = state.schedules.valueOrNull;
    final records = state.records.valueOrNull;

    if (schedules == null || records == null) {
      return null;
    }

    return _missedDoseAnalyzerUseCase.analyzeMissedDoses(schedules, records);
  }

  /// Delete dose record
  Future<void> deleteDoseRecord(String recordId) async {
    try {
      await _repository.deleteDoseRecord(recordId);
      await _loadMedicationData();
    } catch (e) {
      rethrow;
    }
  }

  /// Get plan change history
  Future<List<dynamic>> getPlanHistory() async {
    try {
      final plan = state.activePlan.valueOrNull;
      if (plan == null) {
        return [];
      }

      return await _repository.getPlanChangeHistory(plan.id);
    } catch (e) {
      rethrow;
    }
  }

  /// Get injection site rotation check
  Future<RotationCheckResult> checkInjectionSiteRotation(
    String newSite,
  ) async {
    try {
      final plan = state.activePlan.valueOrNull;
      if (plan == null) {
        throw Exception('활성 투여 계획이 없습니다.');
      }

      final recentRecords = await _repository.getRecentDoseRecords(
        plan.id,
        30,
      );

      return _injectionSiteRotationUseCase.checkRotation(newSite, recentRecords);
    } catch (e) {
      rethrow;
    }
  }

  /// Convert plan to map for history
  Map<String, dynamic> _planToMap(DosagePlan plan) {
    return {
      'id': plan.id,
      'medicationName': plan.medicationName,
      'startDate': plan.startDate.toIso8601String(),
      'cycleDays': plan.cycleDays,
      'initialDoseMg': plan.initialDoseMg,
      'escalationPlan': plan.escalationPlan
          ?.map((step) => {
                'weeksFromStart': step.weeksFromStart,
                'doseMg': step.doseMg,
              })
          .toList(),
    };
  }
}
</file>

<file path="lib/features/tracking/application/notifiers/symptom_record_edit_notifier.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/tracking/domain/entities/audit_log.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/domain/usecases/validate_symptom_edit_usecase.dart';
import 'package:n06/features/tracking/domain/usecases/log_record_change_usecase.dart';
import 'package:n06/features/tracking/application/providers.dart';
import 'package:n06/features/dashboard/application/notifiers/dashboard_notifier.dart';
import 'package:uuid/uuid.dart';

class SymptomRecordEditNotifier extends AsyncNotifier<void> {
  late ValidateSymptomEditUseCase _validateUseCase;
  late LogRecordChangeUseCase _logUseCase;

  @override
  Future<void> build() async {
    _validateUseCase = ValidateSymptomEditUseCase();
    _logUseCase = LogRecordChangeUseCase(
      ref.watch(auditRepositoryProvider),
    );
  }

  Future<void> updateSymptom({
    required String recordId,
    required SymptomLog updatedLog,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final trackingRepo = ref.read(trackingRepositoryProvider);

      // Validate symptom
      final validation = _validateUseCase.execute(
        severity: updatedLog.severity,
        symptomName: updatedLog.symptomName,
      );
      if (validation.isFailure) {
        throw Exception(validation.error ?? 'Invalid symptom');
      }

      // Get original log for audit
      final originalLog = await trackingRepo.getSymptomLogById(recordId);
      if (originalLog == null) {
        throw Exception('Record not found');
      }

      // Update
      await trackingRepo.updateSymptomLog(recordId, updatedLog);

      // Log change
      await _logUseCase.execute(AuditLog(
        id: const Uuid().v4(),
        userId: updatedLog.userId,
        recordId: recordId,
        recordType: 'symptom',
        changeType: 'update',
        oldValue: {
          'symptomName': originalLog.symptomName,
          'severity': originalLog.severity,
          'tags': originalLog.tags,
          'note': originalLog.note,
        },
        newValue: {
          'symptomName': updatedLog.symptomName,
          'severity': updatedLog.severity,
          'tags': updatedLog.tags,
          'note': updatedLog.note,
        },
        timestamp: DateTime.now(),
      ));

      // Invalidate dashboard to trigger statistics recalculation
      ref.invalidate(dashboardNotifierProvider);
    });
  }

  Future<void> deleteSymptom({
    required String recordId,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final trackingRepo = ref.read(trackingRepositoryProvider);

      // Get original log for audit
      final originalLog = await trackingRepo.getSymptomLogById(recordId);
      if (originalLog == null) {
        throw Exception('Record not found');
      }

      // Delete (cascade: true means related tags and feedback are also deleted)
      await trackingRepo.deleteSymptomLog(recordId, cascade: true);

      // Log deletion
      await _logUseCase.execute(AuditLog(
        id: const Uuid().v4(),
        userId: userId,
        recordId: recordId,
        recordType: 'symptom',
        changeType: 'delete',
        oldValue: {
          'symptomName': originalLog.symptomName,
          'severity': originalLog.severity,
          'tags': originalLog.tags,
          'note': originalLog.note,
          'logDate': originalLog.logDate.toIso8601String(),
        },
        newValue: null,
        timestamp: DateTime.now(),
      ));

      // Invalidate dashboard to trigger statistics recalculation
      ref.invalidate(dashboardNotifierProvider);
    });
  }
}
</file>

<file path="lib/features/tracking/application/notifiers/tracking_notifier.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/domain/repositories/tracking_repository.dart';

class TrackingState {
  final AsyncValue<List<WeightLog>> weights;
  final AsyncValue<List<SymptomLog>> symptoms;

  const TrackingState({
    required this.weights,
    required this.symptoms,
  });

  TrackingState copyWith({
    AsyncValue<List<WeightLog>>? weights,
    AsyncValue<List<SymptomLog>>? symptoms,
  }) {
    return TrackingState(
      weights: weights ?? this.weights,
      symptoms: symptoms ?? this.symptoms,
    );
  }
}

class TrackingNotifier extends StateNotifier<AsyncValue<TrackingState>> {
  final TrackingRepository _repository;
  final String? _userId;

  TrackingNotifier({
    required TrackingRepository repository,
    String? userId,
  })  : _repository = repository,
        _userId = userId,
        super(const AsyncValue.loading()) {
    _init();
  }

  void _init() async {
    // userId가 없으면 초기 상태 설정
    if (_userId == null) {
      state = const AsyncValue.data(TrackingState(
        weights: AsyncValue.data([]),
        symptoms: AsyncValue.data([]),
      ));
      return;
    }

    // userId가 있으면 데이터 로드
    final userId = _userId;
    final result = await AsyncValue.guard(() async {
      final weights = await _repository.getWeightLogs(userId);
      final symptoms = await _repository.getSymptomLogs(userId);

      return TrackingState(
        weights: AsyncValue.data(weights),
        symptoms: AsyncValue.data(symptoms),
      );
    });

    state = result;
  }

  // 체중 기록 저장
  Future<void> saveWeightLog(WeightLog log) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await _repository.saveWeightLog(log);

      final userId = _userId;
      if (userId != null) {
        final weights = await _repository.getWeightLogs(userId);
        final currentState = state.asData!.value;

        return currentState.copyWith(
          weights: AsyncValue.data(weights),
        );
      }

      return state.asData!.value;
    });
  }

  // 증상 기록 저장
  Future<void> saveSymptomLog(SymptomLog log) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await _repository.saveSymptomLog(log);

      if (_userId != null) {
        final symptoms = await _repository.getSymptomLogs(_userId);
        final currentState = state.asData!.value;

        return currentState.copyWith(
          symptoms: AsyncValue.data(symptoms),
        );
      }

      return state.asData!.value;
    });
  }

  // 체중 기록 삭제
  Future<void> deleteWeightLog(String id) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await _repository.deleteWeightLog(id);

      if (_userId != null) {
        final weights = await _repository.getWeightLogs(_userId);
        final currentState = state.asData!.value;

        return currentState.copyWith(
          weights: AsyncValue.data(weights),
        );
      }

      return state.asData!.value;
    });
  }

  // 증상 기록 삭제
  Future<void> deleteSymptomLog(String id) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await _repository.deleteSymptomLog(id);

      if (_userId != null) {
        final symptoms = await _repository.getSymptomLogs(_userId);
        final currentState = state.asData!.value;

        return currentState.copyWith(
          symptoms: AsyncValue.data(symptoms),
        );
      }

      return state.asData!.value;
    });
  }

  // 체중 기록 업데이트
  Future<void> updateWeightLog(String id, double newWeight) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await _repository.updateWeightLog(id, newWeight);

      if (_userId != null) {
        final weights = await _repository.getWeightLogs(_userId);
        final currentState = state.asData!.value;

        return currentState.copyWith(
          weights: AsyncValue.data(weights),
        );
      }

      return state.asData!.value;
    });
  }

  // 증상 기록 업데이트
  Future<void> updateSymptomLog(String id, SymptomLog updatedLog) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      await _repository.updateSymptomLog(id, updatedLog);

      if (_userId != null) {
        final symptoms = await _repository.getSymptomLogs(_userId);
        final currentState = state.asData!.value;

        return currentState.copyWith(
          symptoms: AsyncValue.data(symptoms),
        );
      }

      return state.asData!.value;
    });
  }

  // 특정 날짜의 체중 기록 확인
  Future<bool> hasWeightLogOnDate(String userId, DateTime date) async {
    final existing = await _repository.getWeightLog(userId, date);
    return existing != null;
  }

  // 특정 날짜의 체중 기록 조회
  Future<WeightLog?> getWeightLog(String userId, DateTime date) async {
    return await _repository.getWeightLog(userId, date);
  }

  // 최근 증량일 조회
  Future<DateTime?> getLatestDoseEscalationDate(String userId) async {
    return await _repository.getLatestDoseEscalationDate(userId);
  }
}
</file>

<file path="lib/features/tracking/application/usecases/update_dosage_plan_usecase.dart">
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';
import 'package:n06/features/tracking/domain/repositories/medication_repository.dart';
import 'package:n06/features/tracking/domain/usecases/analyze_plan_change_impact_usecase.dart';
import 'package:n06/features/tracking/domain/usecases/recalculate_dose_schedule_usecase.dart';
import 'package:n06/features/tracking/domain/usecases/validate_dosage_plan_usecase.dart';

/// Result of updating a dosage plan
class UpdateDosagePlanResult {
  final bool isSuccess;
  final String? errorMessage;
  final PlanChangeImpact? impact;

  const UpdateDosagePlanResult({
    required this.isSuccess,
    this.errorMessage,
    this.impact,
  });

  factory UpdateDosagePlanResult.success({required PlanChangeImpact impact}) {
    return UpdateDosagePlanResult(isSuccess: true, impact: impact);
  }

  factory UpdateDosagePlanResult.failure(String message) {
    return UpdateDosagePlanResult(isSuccess: false, errorMessage: message);
  }
}

/// Orchestrates the dosage plan update workflow:
/// 1. Validate the new plan
/// 2. Analyze impact of changes
/// 3. Save plan and change history
/// 4. Recalculate schedules
/// 5. Delete future schedules and save new ones
class UpdateDosagePlanUseCase {
  final MedicationRepository medicationRepository;
  final ValidateDosagePlanUseCase validateUseCase;
  final AnalyzePlanChangeImpactUseCase analyzeImpactUseCase;
  final RecalculateDoseScheduleUseCase recalculateScheduleUseCase;

  UpdateDosagePlanUseCase({
    required this.medicationRepository,
    required this.validateUseCase,
    required this.analyzeImpactUseCase,
    required this.recalculateScheduleUseCase,
  });

  /// Execute the complete update workflow
  Future<UpdateDosagePlanResult> execute({
    required DosagePlan oldPlan,
    required DosagePlan newPlan,
  }) async {
    try {
      // Step 1: Validate new plan
      final validation = validateUseCase.validate(newPlan);
      if (!validation.isValid) {
        return UpdateDosagePlanResult.failure(
          validation.errorMessage ?? '투여 계획이 유효하지 않습니다',
        );
      }

      // Step 2: Analyze impact
      final impact = analyzeImpactUseCase.execute(
        oldPlan: oldPlan,
        newPlan: newPlan,
        fromDate: DateTime.now(),
      );

      // Step 3: Early exit if no changes
      if (!impact.hasChanges) {
        return UpdateDosagePlanResult.success(impact: impact);
      }

      // Step 4: Save plan and change history in transaction
      final oldPlanMap = _serializePlan(oldPlan);
      final newPlanMap = _serializePlan(newPlan);

      await medicationRepository.updateDosagePlan(newPlan);
      await medicationRepository.savePlanChangeHistory(
        oldPlan.id,
        oldPlanMap,
        newPlanMap,
      );

      // Step 5: Recalculate and update schedules
      await medicationRepository.deleteDoseSchedulesFrom(
        newPlan.id,
        DateTime.now(),
      );

      final newSchedules = recalculateScheduleUseCase.execute(
        newPlan,
        fromDate: DateTime.now(),
      );

      await medicationRepository.saveDoseSchedules(newSchedules);

      return UpdateDosagePlanResult.success(impact: impact);
    } catch (e) {
      return UpdateDosagePlanResult.failure(
        '투여 계획 업데이트 중 오류가 발생했습니다: $e',
      );
    }
  }

  /// Serialize plan to map for history tracking
  Map<String, dynamic> _serializePlan(DosagePlan plan) {
    return {
      'medicationName': plan.medicationName,
      'startDate': plan.startDate.toIso8601String(),
      'cycleDays': plan.cycleDays,
      'initialDoseMg': plan.initialDoseMg,
      'escalationPlan': plan.escalationPlan?.map((step) => {
            'weeksFromStart': step.weeksFromStart,
            'doseMg': step.doseMg,
          }).toList(),
    };
  }
}
</file>

<file path="lib/features/tracking/domain/entities/audit_log.dart">
import 'package:equatable/equatable.dart';

class AuditLog extends Equatable {
  final String id;
  final String userId;
  final String recordId;
  final String recordType; // 'weight', 'symptom', 'dose'
  final String changeType; // 'create', 'update', 'delete'
  final Map<String, dynamic>? oldValue;
  final Map<String, dynamic>? newValue;
  final DateTime timestamp;

  const AuditLog({
    required this.id,
    required this.userId,
    required this.recordId,
    required this.recordType,
    required this.changeType,
    this.oldValue,
    this.newValue,
    required this.timestamp,
  });

  @override
  List<Object?> get props => [
    id,
    userId,
    recordId,
    recordType,
    changeType,
    oldValue,
    newValue,
    timestamp,
  ];
}
</file>

<file path="lib/features/tracking/domain/entities/dose_record.dart">
import 'package:equatable/equatable.dart';

const List<String> validInjectionSites = ['abdomen', 'thigh', 'arm'];

class DoseRecord extends Equatable {
  final String id;
  final String? doseScheduleId;
  final String dosagePlanId;
  final DateTime administeredAt;
  final double actualDoseMg;
  final String? injectionSite; // abdomen, thigh, arm
  final bool isCompleted;
  final String? note;
  final DateTime createdAt;

  DoseRecord({
    required this.id,
    this.doseScheduleId,
    required this.dosagePlanId,
    required this.administeredAt,
    required this.actualDoseMg,
    this.injectionSite,
    this.isCompleted = true,
    this.note,
    DateTime? createdAt,
  }) : createdAt = createdAt ?? DateTime.now() {
    _validate();
  }

  void _validate() {
    // Validate administered date is not in future
    if (administeredAt.isAfter(DateTime.now())) {
      throw ArgumentError('Administered date cannot be in the future');
    }

    // Validate actual dose
    if (actualDoseMg < 0) {
      throw ArgumentError('Actual dose cannot be negative');
    }

    // Validate injection site if provided
    if (injectionSite != null && !validInjectionSites.contains(injectionSite)) {
      throw ArgumentError(
        'Invalid injection site. Must be one of: ${validInjectionSites.join(", ")}',
      );
    }
  }

  /// Calculate days since administration
  int daysSinceAdministration() {
    final now = DateTime.now();
    return now.difference(administeredAt).inDays;
  }

  @override
  List<Object?> get props => [
    id,
    doseScheduleId,
    dosagePlanId,
    administeredAt,
    actualDoseMg,
    injectionSite,
    isCompleted,
    note,
    createdAt,
  ];

  DoseRecord copyWith({
    String? id,
    String? doseScheduleId,
    String? dosagePlanId,
    DateTime? administeredAt,
    double? actualDoseMg,
    String? injectionSite,
    bool? isCompleted,
    String? note,
    DateTime? createdAt,
  }) {
    return DoseRecord(
      id: id ?? this.id,
      doseScheduleId: doseScheduleId ?? this.doseScheduleId,
      dosagePlanId: dosagePlanId ?? this.dosagePlanId,
      administeredAt: administeredAt ?? this.administeredAt,
      actualDoseMg: actualDoseMg ?? this.actualDoseMg,
      injectionSite: injectionSite ?? this.injectionSite,
      isCompleted: isCompleted ?? this.isCompleted,
      note: note ?? this.note,
      createdAt: createdAt ?? this.createdAt,
    );
  }
}
</file>

<file path="lib/features/tracking/domain/entities/emergency_symptom_check.dart">
import 'package:equatable/equatable.dart';

/// F005: 증상 체크 기록의 비즈니스 모델
///
/// 사용자가 긴급 증상 체크리스트에서 선택한 증상 정보를 나타냅니다.
/// - 체크 일시 (checkedAt)
/// - 선택된 증상 목록 (checkedSymptoms)
class EmergencySymptomCheck extends Equatable {
  /// 고유 식별자
  final String id;

  /// 사용자 ID
  final String userId;

  /// 증상 체크 일시 (timezone 포함)
  final DateTime checkedAt;

  /// 선택된 증상 목록
  final List<String> checkedSymptoms;

  const EmergencySymptomCheck({
    required this.id,
    required this.userId,
    required this.checkedAt,
    required this.checkedSymptoms,
  });

  /// 필드 수정하여 새로운 인스턴스 생성 (불변성 보장)
  EmergencySymptomCheck copyWith({
    String? id,
    String? userId,
    DateTime? checkedAt,
    List<String>? checkedSymptoms,
  }) {
    return EmergencySymptomCheck(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      checkedAt: checkedAt ?? this.checkedAt,
      checkedSymptoms: checkedSymptoms ?? this.checkedSymptoms,
    );
  }

  @override
  List<Object?> get props => [id, userId, checkedAt, checkedSymptoms];

  @override
  String toString() =>
      'EmergencySymptomCheck(id: $id, userId: $userId, checkedAt: $checkedAt, checkedSymptoms: $checkedSymptoms)';
}
</file>

<file path="lib/features/tracking/domain/entities/plan_change_history.dart">
import 'package:equatable/equatable.dart';

class PlanChangeHistory extends Equatable {
  final String id;
  final String dosagePlanId;
  final DateTime changedAt;
  final Map<String, dynamic> oldPlan;
  final Map<String, dynamic> newPlan;

  const PlanChangeHistory({
    required this.id,
    required this.dosagePlanId,
    required this.changedAt,
    required this.oldPlan,
    required this.newPlan,
  });

  @override
  List<Object?> get props => [
    id,
    dosagePlanId,
    changedAt,
    oldPlan,
    newPlan,
  ];

  PlanChangeHistory copyWith({
    String? id,
    String? dosagePlanId,
    DateTime? changedAt,
    Map<String, dynamic>? oldPlan,
    Map<String, dynamic>? newPlan,
  }) {
    return PlanChangeHistory(
      id: id ?? this.id,
      dosagePlanId: dosagePlanId ?? this.dosagePlanId,
      changedAt: changedAt ?? this.changedAt,
      oldPlan: oldPlan ?? this.oldPlan,
      newPlan: newPlan ?? this.newPlan,
    );
  }
}
</file>

<file path="lib/features/tracking/domain/entities/symptom_log.dart">
import 'package:equatable/equatable.dart';

class SymptomLog extends Equatable {
  final String id;
  final String userId;
  final DateTime logDate;
  final String symptomName;
  final int severity; // 1-10
  final int? daysSinceEscalation;
  final bool? isPersistent24h;
  final String? note;
  final List<String> tags;
  final DateTime? createdAt;

  const SymptomLog({
    required this.id,
    required this.userId,
    required this.logDate,
    required this.symptomName,
    required this.severity,
    this.daysSinceEscalation,
    this.isPersistent24h,
    this.note,
    this.tags = const [],
    this.createdAt,
  }) : assert(severity >= 1 && severity <= 10, 'Severity must be between 1 and 10');

  SymptomLog copyWith({
    String? id,
    String? userId,
    DateTime? logDate,
    String? symptomName,
    int? severity,
    int? daysSinceEscalation,
    bool? isPersistent24h,
    String? note,
    List<String>? tags,
    DateTime? createdAt,
  }) {
    return SymptomLog(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      logDate: logDate ?? this.logDate,
      symptomName: symptomName ?? this.symptomName,
      severity: severity ?? this.severity,
      daysSinceEscalation: daysSinceEscalation ?? this.daysSinceEscalation,
      isPersistent24h: isPersistent24h ?? this.isPersistent24h,
      note: note ?? this.note,
      tags: tags ?? this.tags,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  List<Object?> get props => [
        id,
        userId,
        logDate,
        symptomName,
        severity,
        daysSinceEscalation,
        isPersistent24h,
        note,
        tags,
        createdAt,
      ];

  @override
  String toString() =>
      'SymptomLog(id: $id, userId: $userId, logDate: $logDate, symptomName: $symptomName, severity: $severity, daysSinceEscalation: $daysSinceEscalation, isPersistent24h: $isPersistent24h, tags: $tags, note: $note, createdAt: $createdAt)';
}
</file>

<file path="lib/features/tracking/domain/entities/validation_result.dart">
import 'package:equatable/equatable.dart';

class ValidationResult extends Equatable {
  final bool isSuccess;
  final bool isFailure;
  final bool isConflict;
  final String? error;
  final String? warning;
  final String? existingRecordId;

  const ValidationResult({
    required this.isSuccess,
    this.isFailure = false,
    this.isConflict = false,
    this.error,
    this.warning,
    this.existingRecordId,
  });

  factory ValidationResult.success({String? warning}) {
    return ValidationResult(
      isSuccess: true,
      warning: warning,
    );
  }

  factory ValidationResult.error(String message) {
    return ValidationResult(
      isSuccess: false,
      isFailure: true,
      error: message,
    );
  }

  factory ValidationResult.conflict({required String existingRecordId}) {
    return ValidationResult(
      isSuccess: false,
      isConflict: true,
      existingRecordId: existingRecordId,
    );
  }

  @override
  List<Object?> get props => [isSuccess, isFailure, isConflict, error, warning, existingRecordId];
}
</file>

<file path="lib/features/tracking/domain/entities/weight_log.dart">
import 'package:equatable/equatable.dart';

class WeightLog extends Equatable {
  final String id;
  final String userId;
  final DateTime logDate;
  final double weightKg;
  final DateTime createdAt;

  const WeightLog({
    required this.id,
    required this.userId,
    required this.logDate,
    required this.weightKg,
    required this.createdAt,
  });

  WeightLog copyWith({
    String? id,
    String? userId,
    DateTime? logDate,
    double? weightKg,
    DateTime? createdAt,
  }) {
    return WeightLog(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      logDate: logDate ?? this.logDate,
      weightKg: weightKg ?? this.weightKg,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  List<Object?> get props => [id, userId, logDate, weightKg, createdAt];

  @override
  String toString() =>
      'WeightLog(id: $id, userId: $userId, logDate: $logDate, weightKg: $weightKg, createdAt: $createdAt)';
}
</file>

<file path="lib/features/tracking/domain/repositories/audit_repository.dart">
import 'package:n06/features/tracking/domain/entities/audit_log.dart';

abstract class AuditRepository {
  Future<void> logChange(AuditLog log);
  Future<List<AuditLog>> getChangeLogs(String userId, String recordId);
}
</file>

<file path="lib/features/tracking/domain/repositories/dosage_plan_repository.dart">
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';
import 'package:n06/features/tracking/domain/entities/plan_change_history.dart';

/// Repository interface for DosagePlan persistence
///
/// Defines the contract for dosage plan data access operations.
/// Implementations must handle Isar or Supabase storage.
abstract class DosagePlanRepository {
  /// Get the active dosage plan for a specific user
  ///
  /// Returns the first plan where [isActive] is true for the given [userId].
  /// Returns null if no active plan exists.
  Future<DosagePlan?> getActiveDosagePlan(String userId);

  /// Get a specific dosage plan by ID
  ///
  /// Returns the plan with the given [planId], or null if not found.
  Future<DosagePlan?> getDosagePlan(String planId);

  /// Save a new dosage plan
  ///
  /// Inserts a new plan into storage.
  /// The plan should not exist yet (use update for existing plans).
  Future<void> saveDosagePlan(DosagePlan plan);

  /// Update an existing dosage plan
  ///
  /// Updates all fields of the plan with the given ID.
  /// The plan must already exist in storage.
  Future<void> updateDosagePlan(DosagePlan plan);

  /// Get change history for a specific plan
  ///
  /// Returns all historical changes for the given [planId],
  /// ordered by most recent first.
  Future<List<PlanChangeHistory>> getPlanChangeHistory(String planId);

  /// Save a plan change history record
  ///
  /// Records a change to the plan for audit trail purposes.
  /// Typically called together with [updateDosagePlan] in a transaction.
  Future<void> savePlanChangeHistory(PlanChangeHistory history);

  /// Update plan and save history in a single transaction
  ///
  /// Ensures atomicity: both operations succeed or both are rolled back.
  /// This is critical for data integrity when plan changes are recorded.
  Future<void> updatePlanWithHistory(
    DosagePlan plan,
    PlanChangeHistory history,
  );

  /// Watch active dosage plan for real-time updates
  ///
  /// Returns a stream that emits updates whenever the active plan changes.
  /// Useful for keeping UI in sync with database changes.
  Stream<DosagePlan?> watchActiveDosagePlan(String userId);
}
</file>

<file path="lib/features/tracking/domain/repositories/dose_schedule_repository.dart">
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';

/// Repository interface for DoseSchedule persistence
///
/// Defines the contract for dose schedule data access operations.
/// Implementations must handle Isar or Supabase storage.
abstract class DoseScheduleRepository {
  /// Get all schedules for a specific dosage plan
  ///
  /// Returns a list of schedules for the given [dosagePlanId],
  /// typically ordered by scheduled date.
  Future<List<DoseSchedule>> getSchedulesByPlanId(String dosagePlanId);

  /// Save multiple schedules in a batch operation
  ///
  /// Efficiently inserts multiple schedules at once.
  /// Useful after dosage plan changes require recalculation.
  Future<void> saveBatchSchedules(List<DoseSchedule> schedules);

  /// Delete all schedules after a specific date for a plan
  ///
  /// Removes future schedules from [fromDate] onwards for [dosagePlanId].
  /// Used during plan updates to clear outdated schedules.
  /// Past schedules are preserved to maintain historical accuracy.
  Future<void> deleteFutureSchedules(
    String dosagePlanId,
    DateTime fromDate,
  );

  /// Watch schedules for real-time updates
  ///
  /// Returns a stream that emits updates whenever schedules change
  /// for the given [dosagePlanId].
  /// Useful for keeping schedule views in sync.
  Stream<List<DoseSchedule>> watchSchedulesByPlanId(String dosagePlanId);
}
</file>

<file path="lib/features/tracking/domain/repositories/emergency_check_repository.dart">
import 'package:n06/features/tracking/domain/entities/emergency_symptom_check.dart';

/// F005: 증상 체크 데이터 접근 계약 인터페이스
///
/// Domain Layer에서 정의하는 Repository Interface는
/// Infrastructure Layer의 구현체로 대체됩니다 (Repository Pattern).
/// Phase 1에서 Supabase로 전환될 때도 Interface는 유지되고,
/// 구현체만 IsarEmergencyCheckRepository → SupabaseEmergencyCheckRepository로 변경됩니다.
abstract class EmergencyCheckRepository {
  /// 증상 체크 정보 저장 또는 생성
  Future<void> saveEmergencyCheck(EmergencySymptomCheck check);

  /// 사용자의 증상 체크 이력 조회 (최신순 정렬)
  Future<List<EmergencySymptomCheck>> getEmergencyChecks(String userId);

  /// 증상 체크 기록 삭제
  Future<void> deleteEmergencyCheck(String id);

  /// 증상 체크 기록 수정 (업데이트)
  Future<void> updateEmergencyCheck(EmergencySymptomCheck check);
}
</file>

<file path="lib/features/tracking/domain/usecases/index.dart">
export 'validate_weight_edit_usecase.dart';
export 'validate_symptom_edit_usecase.dart';
export 'validate_date_unique_constraint_usecase.dart';
export 'log_record_change_usecase.dart';
export 'analyze_plan_change_impact_usecase.dart';
export 'recalculate_dose_schedule_usecase.dart';
export 'injection_site_rotation_usecase.dart';
export 'validate_dosage_plan_usecase.dart';
export 'schedule_generator_usecase.dart';
export 'missed_dose_analyzer_usecase.dart';
export 'dose_notification_usecase.dart';
</file>

<file path="lib/features/tracking/domain/usecases/injection_site_rotation_usecase.dart">
import 'package:n06/features/tracking/domain/entities/dose_record.dart';

class RotationCheckResult {
  final bool needsWarning;
  final String message;
  final int daysSinceLastUse;

  RotationCheckResult({
    required this.needsWarning,
    required this.message,
    required this.daysSinceLastUse,
  });
}

class InjectionSiteRotationUseCase {
  static const int minimumDaysInterval = 7;
  static const int historyDays = 30;

  /// Check if new injection site needs warning based on recent records
  RotationCheckResult checkRotation(
    String newSite,
    List<DoseRecord> recentRecords,
  ) {
    // Find most recent record with same site
    DoseRecord? lastSameSiteRecord;
    for (final record in recentRecords) {
      if (record.injectionSite == newSite) {
        if (lastSameSiteRecord == null ||
            record.administeredAt.isAfter(lastSameSiteRecord.administeredAt)) {
          lastSameSiteRecord = record;
        }
      }
    }

    if (lastSameSiteRecord == null) {
      return RotationCheckResult(
        needsWarning: false,
        message: '',
        daysSinceLastUse: 0,
      );
    }

    final now = DateTime.now();
    final daysSince = now.difference(lastSameSiteRecord.administeredAt).inDays;

    if (daysSince < minimumDaysInterval) {
      return RotationCheckResult(
        needsWarning: true,
        message:
            '동일 부위를 $daysSince일 전에 사용했습니다. 최소 7일 간격을 권장합니다.',
        daysSinceLastUse: daysSince,
      );
    }

    return RotationCheckResult(
      needsWarning: false,
      message: '',
      daysSinceLastUse: daysSince,
    );
  }

  /// Get site usage history for visualization (last 30 days)
  List<Map<String, dynamic>> getSiteHistory(List<DoseRecord> records) {
    final now = DateTime.now();
    final thirtyDaysAgo = now.subtract(Duration(days: historyDays));

    final recentRecords = records
        .where((r) => r.administeredAt.isAfter(thirtyDaysAgo))
        .toList()
      ..sort((a, b) => b.administeredAt.compareTo(a.administeredAt));

    final history = <Map<String, dynamic>>[];

    for (final record in recentRecords) {
      history.add({
        'site': record.injectionSite,
        'date': record.administeredAt,
        'daysAgo': now.difference(record.administeredAt).inDays,
      });
    }

    return history;
  }

  /// Get list of unique sites used in last 30 days
  List<String> getSiteHistoryList(List<DoseRecord> records) {
    final now = DateTime.now();
    final thirtyDaysAgo = now.subtract(Duration(days: historyDays));

    final recentRecords = records.where((r) =>
        r.administeredAt.isAfter(thirtyDaysAgo) &&
        r.injectionSite != null);

    final sites = <String>{};
    for (final record in recentRecords) {
      if (record.injectionSite != null) {
        sites.add(record.injectionSite!);
      }
    }

    return sites.toList();
  }
}
</file>

<file path="lib/features/tracking/domain/usecases/log_record_change_usecase.dart">
import 'package:n06/features/tracking/domain/entities/audit_log.dart';
import 'package:n06/features/tracking/domain/repositories/audit_repository.dart';

class LogRecordChangeUseCase {
  final AuditRepository repository;

  LogRecordChangeUseCase(this.repository);

  Future<void> execute(AuditLog log) async {
    await repository.logChange(log);
  }
}
</file>

<file path="lib/features/tracking/domain/usecases/missed_dose_analyzer_usecase.dart">
import 'package:n06/features/tracking/domain/entities/dose_record.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';

enum GuidanceType {
  immediateAdministration, // 5일 이내
  waitForNext, // 5-7일
  expertConsultation, // 7일 이상
}

class MissedDose {
  final DoseSchedule schedule;
  final int daysElapsed;
  final String message;

  MissedDose({
    required this.schedule,
    required this.daysElapsed,
    required this.message,
  });
}

class MissedDoseAnalysisResult {
  final List<MissedDose> missedDoses;
  final GuidanceType guidanceType;
  final bool requiresExpertConsultation;
  final String guidanceMessage;

  MissedDoseAnalysisResult({
    required this.missedDoses,
    required this.guidanceType,
    required this.requiresExpertConsultation,
    required this.guidanceMessage,
  });
}

class MissedDoseAnalyzerUseCase {
  /// Analyze missed doses from schedules and records
  MissedDoseAnalysisResult analyzeMissedDoses(
    List<DoseSchedule> schedules,
    List<DoseRecord> records,
  ) {
    final completedScheduleIds = _getCompletedScheduleIds(records);
    final now = DateTime.now();
    final missedDoses = <MissedDose>[];
    bool hasLongMissed = false;
    int maxDaysElapsed = 0;

    for (final schedule in schedules) {
      // Only check past schedules
      if (schedule.scheduledDate.isAfter(now)) {
        continue;
      }

      // Check if this schedule has a corresponding record
      if (!completedScheduleIds.contains(schedule.id)) {
        final daysElapsed = now.difference(schedule.scheduledDate).inDays;
        final message = _generateMissedDoseMessage(daysElapsed);

        missedDoses.add(MissedDose(
          schedule: schedule,
          daysElapsed: daysElapsed,
          message: message,
        ));

        if (daysElapsed >= 7) {
          hasLongMissed = true;
        }
        maxDaysElapsed = daysElapsed > maxDaysElapsed ? daysElapsed : maxDaysElapsed;
      }
    }

    // Sort by days elapsed (most recent first)
    missedDoses.sort((a, b) => b.daysElapsed.compareTo(a.daysElapsed));

    // Determine guidance type
    GuidanceType guidanceType;
    String guidanceMessage;

    if (missedDoses.isEmpty) {
      guidanceType = GuidanceType.waitForNext;
      guidanceMessage = '';
    } else if (maxDaysElapsed >= 7) {
      guidanceType = GuidanceType.expertConsultation;
      guidanceMessage = '의료진과 상담이 필요합니다.';
    } else if (maxDaysElapsed >= 5) {
      guidanceType = GuidanceType.waitForNext;
      guidanceMessage = '다음 예정일까지 대기하세요.';
    } else {
      guidanceType = GuidanceType.immediateAdministration;
      guidanceMessage = '즉시 투여하세요.';
    }

    return MissedDoseAnalysisResult(
      missedDoses: missedDoses,
      guidanceType: guidanceType,
      requiresExpertConsultation: hasLongMissed,
      guidanceMessage: guidanceMessage,
    );
  }

  /// Get set of completed schedule IDs
  Set<String> _getCompletedScheduleIds(List<DoseRecord> records) {
    final ids = <String>{};
    for (final record in records) {
      if (record.doseScheduleId != null && record.isCompleted) {
        ids.add(record.doseScheduleId!);
      }
    }
    return ids;
  }

  /// Generate message for missed dose
  String _generateMissedDoseMessage(int daysElapsed) {
    if (daysElapsed < 1) {
      return '오늘 투여 예정입니다.';
    } else if (daysElapsed < 5) {
      return '$daysElapsed일 경과 - 즉시 투여하세요.';
    } else if (daysElapsed < 7) {
      return '$daysElapsed일 경과 - 다음 예정일까지 대기하세요.';
    } else {
      return '$daysElapsed일 경과 - 의료진 상담 필요.';
    }
  }
}
</file>

<file path="lib/features/tracking/domain/usecases/recalculate_dose_schedule_usecase.dart">
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';
import 'package:uuid/uuid.dart';

/// UseCase to recalculate dose schedules based on updated dosage plan
/// Generates new schedules for the future, preserving past records
class RecalculateDoseScheduleUseCase {
  static const _uuid = Uuid();

  /// Execute schedule recalculation
  /// Returns list of DoseSchedule for the future (after current date)
  List<DoseSchedule> execute(
    DosagePlan plan, {
    DateTime? fromDate,
    int? generationDays = 365,
  }) {
    final startDate = fromDate ?? DateTime.now();
    final schedules = <DoseSchedule>[];

    // Generate schedules starting from startDate
    DateTime currentDate = DateTime(startDate.year, startDate.month, startDate.day);
    DateTime endDate = currentDate.add(Duration(days: generationDays ?? 365));

    // Align to first dose date if plan start is in the future
    if (plan.startDate.isAfter(currentDate)) {
      currentDate = DateTime(plan.startDate.year, plan.startDate.month, plan.startDate.day);
    }

    // Generate schedules
    while (currentDate.isBefore(endDate) || currentDate.isAtSameMomentAs(endDate)) {
      final weeksElapsed = _calculateWeeksElapsed(plan.startDate, currentDate);
      final dose = plan.getCurrentDose(weeksElapsed: weeksElapsed);

      final schedule = DoseSchedule(
        id: _uuid.v4(),
        dosagePlanId: plan.id,
        scheduledDate: currentDate,
        scheduledDoseMg: dose,
      );

      schedules.add(schedule);

      // Move to next dose date
      currentDate = currentDate.add(Duration(days: plan.cycleDays));
    }

    return schedules;
  }

  /// Calculate weeks elapsed since plan start date
  int _calculateWeeksElapsed(DateTime startDate, DateTime currentDate) {
    final difference = currentDate.difference(startDate);
    return (difference.inDays / 7).floor();
  }
}
</file>

<file path="lib/features/tracking/domain/usecases/validate_date_unique_constraint_usecase.dart">
import 'package:n06/features/tracking/domain/entities/validation_result.dart';
import 'package:n06/features/tracking/domain/repositories/tracking_repository.dart';

class ValidateDateUniqueConstraintUseCase {
  final TrackingRepository repository;

  ValidateDateUniqueConstraintUseCase(this.repository);

  Future<ValidationResult> execute({
    required String userId,
    required DateTime date,
    String? editingRecordId,
  }) async {
    // Check if date is in the future
    if (date.isAfter(DateTime.now())) {
      return ValidationResult.error('미래 날짜는 선택할 수 없습니다');
    }

    // Normalize date to remove time component
    final normalizedDate = DateTime(date.year, date.month, date.day);
    final normalizedNow = DateTime.now();
    final normalizedToday = DateTime(normalizedNow.year, normalizedNow.month, normalizedNow.day);

    if (normalizedDate.isAfter(normalizedToday)) {
      return ValidationResult.error('미래 날짜는 선택할 수 없습니다');
    }

    // Check for existing weight log on this date
    final existing = await repository.getWeightLog(userId, normalizedDate);

    if (existing != null) {
      // If editing the same record, allow it
      if (editingRecordId != null && existing.id == editingRecordId) {
        return ValidationResult.success();
      }

      // Otherwise, it's a conflict
      return ValidationResult.conflict(existingRecordId: existing.id);
    }

    return ValidationResult.success();
  }
}
</file>

<file path="lib/features/tracking/domain/usecases/validate_dosage_plan_usecase.dart">
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';

class ValidationResult {
  final bool isValid;
  final String? errorMessage;

  const ValidationResult({
    required this.isValid,
    this.errorMessage,
  });

  factory ValidationResult.success() {
    return const ValidationResult(isValid: true);
  }

  factory ValidationResult.failure(String message) {
    return ValidationResult(isValid: false, errorMessage: message);
  }
}

class ValidateDosagePlanUseCase {
  ValidationResult validate(DosagePlan plan) {
    // Validate medication name
    if (plan.medicationName.trim().isEmpty) {
      return ValidationResult.failure('약물명을 입력하세요');
    }

    // Validate cycle days
    if (plan.cycleDays < 1) {
      return ValidationResult.failure('투여 주기는 1일 이상이어야 합니다');
    }

    // Validate initial dose
    if (plan.initialDoseMg <= 0) {
      return ValidationResult.failure('초기 용량은 0보다 커야 합니다');
    }

    // Validate escalation plan
    if (plan.escalationPlan != null && plan.escalationPlan!.isNotEmpty) {
      final escalationValidation = validateEscalationPlan(
        plan.initialDoseMg,
        plan.escalationPlan!,
      );
      if (!escalationValidation.isValid) {
        return escalationValidation;
      }
    }

    return ValidationResult.success();
  }

  /// Validate medication name
  ValidationResult validateMedicationName(String name) {
    if (name.trim().isEmpty) {
      return ValidationResult.failure('약물명을 입력하세요');
    }
    return ValidationResult.success();
  }

  /// Validate cycle days
  ValidationResult validateCycleDays(int cycleDays) {
    if (cycleDays < 1) {
      return ValidationResult.failure('투여 주기는 1일 이상이어야 합니다');
    }
    return ValidationResult.success();
  }

  /// Validate initial dose
  ValidationResult validateInitialDose(double dose) {
    if (dose <= 0) {
      return ValidationResult.failure('초기 용량은 0보다 커야 합니다');
    }
    return ValidationResult.success();
  }

  /// Validate escalation plan
  ValidationResult validateEscalationPlan(
    double initialDose,
    List<EscalationStep> escalationPlan,
  ) {
    double previousDose = initialDose;
    int previousWeeks = 0;

    for (final step in escalationPlan) {
      // Check dose is strictly increasing
      if (step.doseMg <= previousDose) {
        return ValidationResult.failure(
          '증량 계획의 용량은 증가해야 합니다 (현재: ${step.doseMg}mg, 이전: ${previousDose}mg)',
        );
      }

      // Check weeks are in increasing order
      if (step.weeksFromStart <= previousWeeks) {
        return ValidationResult.failure(
          '증량 계획은 시간 순서대로 입력해주세요',
        );
      }

      previousDose = step.doseMg;
      previousWeeks = step.weeksFromStart;
    }

    return ValidationResult.success();
  }
}
</file>

<file path="lib/features/tracking/domain/usecases/validate_symptom_edit_usecase.dart">
import 'package:n06/features/tracking/domain/entities/validation_result.dart';

class ValidateSymptomEditUseCase {
  static const List<String> validSymptoms = [
    '메스꺼움',
    '구토',
    '변비',
    '설사',
    '복통',
    '두통',
    '피로'
  ];

  ValidationResult execute({required int severity, required String symptomName}) {
    // Check if symptom name is empty
    if (symptomName.isEmpty) {
      return ValidationResult.error('증상명을 입력해주세요');
    }

    // Check if severity is within valid range
    if (severity < 1 || severity > 10) {
      return ValidationResult.error('심각도는 1-10 사이의 값이어야 합니다');
    }

    return ValidationResult.success();
  }
}
</file>

<file path="lib/features/tracking/domain/usecases/validate_weight_edit_usecase.dart">
import 'package:n06/features/tracking/domain/entities/validation_result.dart';

class ValidateWeightEditUseCase {
  static const double minWeight = 20.0;
  static const double maxWeight = 300.0;
  static const double warningLowThreshold = 30.0;
  static const double warningHighThreshold = 200.0;

  ValidationResult execute(double weight) {
    // Check if weight is negative or zero
    if (weight <= 0) {
      return ValidationResult.error('체중은 0보다 커야 합니다');
    }

    // Check if weight is below minimum
    if (weight < minWeight) {
      return ValidationResult.error('체중은 ${minWeight}kg 이상이어야 합니다');
    }

    // Check if weight is above maximum
    if (weight > maxWeight) {
      return ValidationResult.error('체중은 ${maxWeight}kg 이하여야 합니다');
    }

    // Check for warning - too low
    if (weight < warningLowThreshold) {
      return ValidationResult.success(warning: '비정상적으로 낮은 체중입니다. 입력값을 다시 확인해주세요.');
    }

    // Check for warning - too high
    if (weight > warningHighThreshold) {
      return ValidationResult.success(warning: '비정상적으로 높은 체중입니다. 입력값을 다시 확인해주세요.');
    }

    return ValidationResult.success();
  }
}
</file>

<file path="lib/features/tracking/infrastructure/dtos/dose_record_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';

part 'dose_record_dto.g.dart';

@collection
class DoseRecordDto {
  Id? id = Isar.autoIncrement;
  late String recordId; // UUID
  late String? doseScheduleId;
  late String dosagePlanId;
  late DateTime administeredAt;
  late double actualDoseMg;
  late String? injectionSite; // abdomen, thigh, arm
  late bool isCompleted;
  late String? note;
  late DateTime createdAt;

  @Index()
  late DateTime indexedDate; // For efficient date-based queries

  DoseRecordDto();

  DoseRecordDto.fromEntity(DoseRecord entity) {
    recordId = entity.id;
    doseScheduleId = entity.doseScheduleId;
    dosagePlanId = entity.dosagePlanId;
    administeredAt = entity.administeredAt;
    actualDoseMg = entity.actualDoseMg;
    injectionSite = entity.injectionSite;
    isCompleted = entity.isCompleted;
    note = entity.note;
    createdAt = entity.createdAt;
    indexedDate = DateTime(
      entity.administeredAt.year,
      entity.administeredAt.month,
      entity.administeredAt.day,
    );
  }

  DoseRecord toEntity() {
    return DoseRecord(
      id: recordId,
      doseScheduleId: doseScheduleId,
      dosagePlanId: dosagePlanId,
      administeredAt: administeredAt,
      actualDoseMg: actualDoseMg,
      injectionSite: injectionSite,
      isCompleted: isCompleted,
      note: note,
      createdAt: createdAt,
    );
  }
}
</file>

<file path="lib/features/tracking/infrastructure/dtos/emergency_symptom_check_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/tracking/domain/entities/emergency_symptom_check.dart';

part 'emergency_symptom_check_dto.g.dart';

/// F005: Isar를 위한 증상 체크 DTO (Data Transfer Object)
///
/// Isar의 컬렉션으로 등록되며, Domain Entity와 DB 사이의 변환을 담당합니다.
/// - Isar의 자동 증가 ID를 사용합니다.
/// - checkedSymptoms는 PostgreSQL jsonb에 해당하므로 List<String>으로 매핑합니다.
/// - Phase 1 전환 시 Supabase에서는 jsonb 타입으로 직접 사용합니다.
@collection
class EmergencySymptomCheckDto {
  /// Isar 자동 증가 ID
  Id id = Isar.autoIncrement;

  /// 사용자 ID (인덱싱: 사용자별 조회 최적화)
  @Index()
  late String userId;

  /// 증상 체크 일시 (인덱싱: 시간순 정렬 최적화)
  @Index()
  late DateTime checkedAt;

  /// 선택된 증상 목록
  late List<String> checkedSymptoms;

  /// Unnamed constructor (Isar 요구사항)
  EmergencySymptomCheckDto();

  /// Domain Entity로 변환
  EmergencySymptomCheck toEntity() {
    return EmergencySymptomCheck(
      id: id.toString(),
      userId: userId,
      checkedAt: checkedAt,
      checkedSymptoms: checkedSymptoms,
    );
  }

  /// Domain Entity로부터 생성
  factory EmergencySymptomCheckDto.fromEntity(
    EmergencySymptomCheck entity,
  ) {
    return EmergencySymptomCheckDto()
      ..userId = entity.userId
      ..checkedAt = entity.checkedAt
      ..checkedSymptoms = entity.checkedSymptoms;
  }
}
</file>

<file path="lib/features/tracking/infrastructure/dtos/symptom_context_tag_dto.dart">
import 'package:isar/isar.dart';

part 'symptom_context_tag_dto.g.dart';

@collection
class SymptomContextTagDto {
  Id id = Isar.autoIncrement;
  late int symptomLogIsarId;
  late String tagName;

  SymptomContextTagDto();

  @override
  String toString() => 'SymptomContextTagDto(id: $id, symptomLogIsarId: $symptomLogIsarId, tagName: $tagName)';
}
</file>

<file path="lib/features/tracking/infrastructure/dtos/symptom_log_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';

part 'symptom_log_dto.g.dart';

@collection
class SymptomLogDto {
  Id id = Isar.autoIncrement;
  late String userId;
  late DateTime logDate;
  late String symptomName;
  late int severity; // 1-10
  late int? daysSinceEscalation;
  late bool? isPersistent24h;
  late String? note;
  late DateTime? createdAt;

  SymptomLogDto();

  SymptomLog toEntity({required List<String> tags}) {
    return SymptomLog(
      id: id.toString(),
      userId: userId,
      logDate: logDate,
      symptomName: symptomName,
      severity: severity,
      daysSinceEscalation: daysSinceEscalation,
      isPersistent24h: isPersistent24h,
      note: note,
      tags: tags,
      createdAt: createdAt,
    );
  }

  factory SymptomLogDto.fromEntity(SymptomLog entity) {
    return SymptomLogDto()
      ..userId = entity.userId
      ..logDate = entity.logDate
      ..symptomName = entity.symptomName
      ..severity = entity.severity
      ..daysSinceEscalation = entity.daysSinceEscalation
      ..isPersistent24h = entity.isPersistent24h
      ..note = entity.note
      ..createdAt = entity.createdAt;
  }

  @override
  String toString() =>
      'SymptomLogDto(id: $id, userId: $userId, logDate: $logDate, symptomName: $symptomName, severity: $severity, daysSinceEscalation: $daysSinceEscalation, isPersistent24h: $isPersistent24h, note: $note, createdAt: $createdAt)';
}
</file>

<file path="lib/features/tracking/infrastructure/dtos/weight_log_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';

part 'weight_log_dto.g.dart';

@collection
class WeightLogDto {
  Id id = Isar.autoIncrement;
  late String userId;
  late DateTime logDate;
  late double weightKg;
  late DateTime createdAt;

  WeightLogDto();

  WeightLog toEntity() {
    return WeightLog(
      id: id.toString(),
      userId: userId,
      logDate: logDate,
      weightKg: weightKg,
      createdAt: createdAt,
    );
  }

  factory WeightLogDto.fromEntity(WeightLog entity) {
    return WeightLogDto()
      ..userId = entity.userId
      ..logDate = entity.logDate
      ..weightKg = entity.weightKg
      ..createdAt = entity.createdAt;
  }

  @override
  String toString() =>
      'WeightLogDto(id: $id, userId: $userId, logDate: $logDate, weightKg: $weightKg, createdAt: $createdAt)';
}
</file>

<file path="lib/features/tracking/infrastructure/repositories/isar_dosage_plan_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';
import 'package:n06/features/tracking/domain/entities/plan_change_history.dart';
import 'package:n06/features/tracking/domain/repositories/dosage_plan_repository.dart';
import 'package:n06/features/tracking/infrastructure/dtos/dosage_plan_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/plan_change_history_dto.dart';

/// Isar-based implementation of DosagePlanRepository
///
/// Provides persistent storage and retrieval of dosage plans and their change history
/// using the local Isar database.
class IsarDosagePlanRepository implements DosagePlanRepository {
  final Isar isar;

  IsarDosagePlanRepository(this.isar);

  @override
  Future<DosagePlan?> getActiveDosagePlan(String userId) async {
    final dto = await isar.dosagePlanDtos
        .filter()
        .userIdEqualTo(userId)
        .isActiveEqualTo(true)
        .findFirst();

    return dto?.toEntity();
  }

  @override
  Future<DosagePlan?> getDosagePlan(String planId) async {
    final dto = await isar.dosagePlanDtos
        .filter()
        .planIdEqualTo(planId)
        .findFirst();

    return dto?.toEntity();
  }

  @override
  Future<void> saveDosagePlan(DosagePlan plan) async {
    final dto = DosagePlanDto.fromEntity(plan);
    await isar.writeTxn(() => isar.dosagePlanDtos.put(dto));
  }

  @override
  Future<void> updateDosagePlan(DosagePlan plan) async {
    final dto = DosagePlanDto.fromEntity(plan);
    await isar.writeTxn(() => isar.dosagePlanDtos.put(dto));
  }

  @override
  Future<List<PlanChangeHistory>> getPlanChangeHistory(String planId) async {
    final dtos = await isar.planChangeHistoryDtos
        .filter()
        .dosagePlanIdEqualTo(planId)
        .sortByIndexedChangedAtDesc()
        .findAll();

    return dtos.map((dto) => dto.toEntity()).toList();
  }

  @override
  Future<void> savePlanChangeHistory(PlanChangeHistory history) async {
    final dto = PlanChangeHistoryDto.fromEntity(history);
    await isar.writeTxn(() => isar.planChangeHistoryDtos.put(dto));
  }

  @override
  Future<void> updatePlanWithHistory(
    DosagePlan plan,
    PlanChangeHistory history,
  ) async {
    final planDto = DosagePlanDto.fromEntity(plan);
    final historyDto = PlanChangeHistoryDto.fromEntity(history);

    await isar.writeTxn(() async {
      await isar.dosagePlanDtos.put(planDto);
      await isar.planChangeHistoryDtos.put(historyDto);
    });
  }

  @override
  Stream<DosagePlan?> watchActiveDosagePlan(String userId) {
    return isar.dosagePlanDtos
        .filter()
        .userIdEqualTo(userId)
        .isActiveEqualTo(true)
        .watch(fireImmediately: true)
        .map((dtos) => dtos.isNotEmpty ? dtos.first.toEntity() : null);
  }
}
</file>

<file path="lib/features/tracking/infrastructure/repositories/isar_dose_schedule_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';
import 'package:n06/features/tracking/domain/repositories/dose_schedule_repository.dart';
import 'package:n06/features/tracking/infrastructure/dtos/dose_schedule_dto.dart';

/// Isar-based implementation of DoseScheduleRepository
///
/// Provides persistent storage and retrieval of dose schedules
/// using the local Isar database.
class IsarDoseScheduleRepository implements DoseScheduleRepository {
  final Isar isar;

  IsarDoseScheduleRepository(this.isar);

  @override
  Future<List<DoseSchedule>> getSchedulesByPlanId(String dosagePlanId) async {
    final dtos = await isar.doseScheduleDtos
        .filter()
        .dosagePlanIdEqualTo(dosagePlanId)
        .findAll();

    return dtos.map((dto) => dto.toEntity()).toList();
  }

  @override
  Future<void> saveBatchSchedules(List<DoseSchedule> schedules) async {
    final dtos =
        schedules.map((schedule) => DoseScheduleDto.fromEntity(schedule)).toList();

    await isar.writeTxn(() => isar.doseScheduleDtos.putAll(dtos));
  }

  @override
  Future<void> deleteFutureSchedules(
    String dosagePlanId,
    DateTime fromDate,
  ) async {
    await isar.writeTxn(() async {
      final dtos = await isar.doseScheduleDtos
          .filter()
          .dosagePlanIdEqualTo(dosagePlanId)
          .scheduledDateGreaterThan(fromDate)
          .findAll();

      await isar.doseScheduleDtos.deleteAll(dtos.map((dto) => dto.id!).toList());
    });
  }

  @override
  Stream<List<DoseSchedule>> watchSchedulesByPlanId(String dosagePlanId) {
    return isar.doseScheduleDtos
        .filter()
        .dosagePlanIdEqualTo(dosagePlanId)
        .watch(fireImmediately: true)
        .map((dtos) => dtos.map((dto) => dto.toEntity()).toList());
  }
}
</file>

<file path="lib/features/tracking/infrastructure/repositories/isar_emergency_check_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/tracking/domain/entities/emergency_symptom_check.dart';
import 'package:n06/features/tracking/domain/repositories/emergency_check_repository.dart';
import 'package:n06/features/tracking/infrastructure/dtos/emergency_symptom_check_dto.dart';

/// F005: Isar를 사용한 EmergencyCheckRepository 구현체
///
/// Phase 0: Isar 로컬 DB 사용
/// Phase 1: SupabaseEmergencyCheckRepository로 대체됨
/// (Repository Pattern으로 Implementation만 교체됨, Interface는 유지)
class IsarEmergencyCheckRepository implements EmergencyCheckRepository {
  final Isar _isar;

  IsarEmergencyCheckRepository(this._isar);

  @override
  Future<void> saveEmergencyCheck(EmergencySymptomCheck check) async {
    final dto = EmergencySymptomCheckDto.fromEntity(check);
    await _isar.writeTxn(() async {
      await _isar.emergencySymptomCheckDtos.put(dto);
    });
  }

  @override
  Future<List<EmergencySymptomCheck>> getEmergencyChecks(String userId) async {
    final dtos = await _isar.emergencySymptomCheckDtos
        .where()
        .userIdEqualTo(userId)
        .sortByCheckedAtDesc()
        .findAll();

    return dtos.map((dto) => dto.toEntity()).toList();
  }

  @override
  Future<void> deleteEmergencyCheck(String id) async {
    final isarId = int.tryParse(id);
    if (isarId == null) return;

    await _isar.writeTxn(() async {
      await _isar.emergencySymptomCheckDtos.delete(isarId);
    });
  }

  @override
  Future<void> updateEmergencyCheck(EmergencySymptomCheck check) async {
    final isarId = int.tryParse(check.id);
    if (isarId == null) return;

    final dto = EmergencySymptomCheckDto.fromEntity(check);
    dto.id = isarId;

    await _isar.writeTxn(() async {
      await _isar.emergencySymptomCheckDtos.put(dto);
    });
  }
}
</file>

<file path="lib/features/tracking/presentation/screens/weight_record_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/application/providers.dart';
import 'package:n06/features/tracking/presentation/widgets/date_selection_widget.dart';
import 'package:n06/features/tracking/presentation/widgets/input_validation_widget.dart';

/// F002: 체중 기록 화면
///
/// 사용자가 체중을 기록할 수 있는 화면입니다.
/// 날짜 선택, 체중 입력, 중복 확인, 저장 기능을 제공합니다.
class WeightRecordScreen extends ConsumerStatefulWidget {
  const WeightRecordScreen({super.key});

  @override
  ConsumerState<WeightRecordScreen> createState() => _WeightRecordScreenState();
}

class _WeightRecordScreenState extends ConsumerState<WeightRecordScreen> {
  late DateTime selectedDate;
  late TextEditingController _weightController;
  bool isLoading = false;

  @override
  void initState() {
    super.initState();
    // 오늘 날짜로 초기화
    final now = DateTime.now();
    selectedDate = DateTime(now.year, now.month, now.day);
    _weightController = TextEditingController();
  }

  @override
  void dispose() {
    _weightController.dispose();
    super.dispose();
  }

  void _handleDateSelected(DateTime date) {
    setState(() {
      selectedDate = date;
    });
  }

  Future<void> _handleSave() async {
    // 입력값 검증
    final weight = double.tryParse(_weightController.text);
    if (weight == null || weight < 20 || weight > 300) {
      _showErrorDialog('체중은 20kg 이상 300kg 이하여야 합니다');
      return;
    }

    setState(() => isLoading = true);

    try {
      final userId = _getCurrentUserId(); // 실제 구현에서는 AuthNotifier에서 가져올 것
      final notifier = ref.read(trackingNotifierProvider.notifier);

      // 중복 기록 확인
      final hasExisting = await notifier.hasWeightLogOnDate(userId, selectedDate);

      if (!mounted) return;

      if (hasExisting) {
        // 중복 확인 다이얼로그 표시
        final shouldOverwrite = await _showConfirmDialog(
          '이미 기록이 있습니다.',
          '${selectedDate.year}년 ${selectedDate.month}월 ${selectedDate.day}일의 체중 기록이 이미 존재합니다.\n덮어쓰시겠어요?',
        );

        if (!shouldOverwrite) {
          setState(() => isLoading = false);
          return;
        }

        // 기존 기록 조회 후 업데이트
        final existing = await notifier.getWeightLog(userId, selectedDate);
        if (existing != null && mounted) {
          await notifier.updateWeightLog(existing.id, weight);
        }
      } else {
        // 새로운 기록 저장
        final newLog = WeightLog(
          id: const Uuid().v4(),
          userId: userId,
          logDate: selectedDate,
          weightKg: weight,
          createdAt: DateTime.now(),
        );

        await notifier.saveWeightLog(newLog);
      }

      if (!mounted) return;

      // 성공 메시지 표시
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('체중이 기록되었습니다'),
          duration: Duration(seconds: 2),
        ),
      );

      // 홈 화면으로 이동
      Navigator.of(context).pop();
    } catch (e) {
      if (mounted) {
        _showErrorDialog('저장 중 오류가 발생했습니다: $e');
      }
    } finally {
      if (mounted) {
        setState(() => isLoading = false);
      }
    }
  }

  void _showErrorDialog(String message) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('오류'),
        content: Text(message),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('확인'),
          ),
        ],
      ),
    );
  }

  Future<bool> _showConfirmDialog(String title, String message) async {
    final result = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(title),
        content: Text(message),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('취소'),
          ),
          TextButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: const Text('확인'),
          ),
        ],
      ),
    );
    return result ?? false;
  }

  // 현재 사용자 ID 조회 (실제 구현에서는 AuthNotifier에서 가져올 것)
  String _getCurrentUserId() {
    // TODO: AuthNotifier에서 현재 사용자 ID 가져오기
    return 'current-user-id';
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('체중 기록'),
        elevation: 0,
      ),
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // 날짜 선택 섹션
              const SizedBox(height: 8),
              const Text(
                '날짜 선택',
                style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 12),
              DateSelectionWidget(
                initialDate: selectedDate,
                onDateSelected: _handleDateSelected,
              ),

              // 체중 입력 섹션
              const SizedBox(height: 24),
              const Text(
                '체중 입력',
                style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 12),
              InputValidationWidget(
                fieldName: '체중',
                onChanged: (_) {
                  setState(() {});
                },
                label: '체중 (kg)',
                hint: '예: 75.5',
                keyboardType: const TextInputType.numberWithOptions(
                  decimal: true,
                  signed: false,
                ),
              ),

              // 저장 버튼
              const SizedBox(height: 32),
              SizedBox(
                width: double.infinity,
                height: 48,
                child: ElevatedButton(
                  onPressed: isLoading ? null : _handleSave,
                  child: isLoading
                      ? const SizedBox(
                          height: 24,
                          width: 24,
                          child: CircularProgressIndicator(
                            valueColor:
                                AlwaysStoppedAnimation<Color>(Colors.white),
                            strokeWidth: 2,
                          ),
                        )
                      : const Text('저장'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/tracking/presentation/widgets/coping_guide_widget.dart">
import 'package:flutter/material.dart';

/// F004: 부작용 대처 가이드 위젯
///
/// 선택된 증상에 대한 간단한 대처 가이드를 표시합니다.
/// 사용자가 도움이 되었는지 피드백할 수 있습니다.
class CopingGuideWidget extends StatefulWidget {
  /// 증상명
  final String symptomName;

  /// 증상의 심각도 (1-10)
  final int severity;

  /// 위젯이 닫힐 때 호출되는 콜백
  final VoidCallback? onClose;

  const CopingGuideWidget({
    super.key,
    required this.symptomName,
    required this.severity,
    this.onClose,
  });

  @override
  State<CopingGuideWidget> createState() => _CopingGuideWidgetState();
}

class _CopingGuideWidgetState extends State<CopingGuideWidget> {
  bool? _feedbackGiven;

  /// 증상별 대처 가이드 (간단 버전)
  static const Map<String, Map<String, String>> _guides = {
    '메스꺼움': {
      'title': '메스꺼움 대처 가이드',
      'content': '''
        1. 식사 방법
        - 작은 양을 자주 먹기
        - 차가운 음식이나 음료 섭취하기
        - 기름진 음식 피하기

        2. 도움이 되는 음료
        - 생강차
        - 레몬물
        - 맑은 국물

        3. 주사 타이밍 조정
        - 저녁 시간에 투여하면 수면 중 증상 경험 가능
        - 의료진과 상담하여 타이밍 조정

        4. 일상 관리
        - 신선한 공기 마시기
        - 천천히 움직이기
        - 얼굴에 찬 수건 대기
      ''',
    },
    '구토': {
      'title': '구토 대처 가이드',
      'content': '''
        1. 응급 대응
        - 탈수 방지를 위해 수분 천천히 섭취
        - 전해질 음료 (물+소금+설탕) 마시기

        2. 식사 재개 순서
        - 처음: 물, 얼음 조각
        - 2-4시간 후: 맑은 국물, 스포츠 음료
        - 8시간 후: 우동, 미음 등 소화하기 쉬운 음식
        - 24시간 후: 일반 음식 (기름진 음식 제외)

        3. 약 복용
        - 복용한 약이 섭취되지 않았을 수 있으므로 의료진에 상담

        4. 의료진 상담 필요
        - 24시간 이상 계속되는 경우
        - 탈수 증상이 있는 경우
      ''',
    },
    '변비': {
      'title': '변비 대처 가이드',
      'content': '''
        1. 식이 조절
        - 식이섬유 섭취 (채소, 과일, 통곡물)
        - 자두, 무화과 등 도움이 되는 음식
        - 유제품 대신 비유제품 선택

        2. 수분 섭취
        - 하루 8-10잔 물 마시기
        - 따뜻한 물이 더 효과적

        3. 신체 활동
        - 가벼운 운동 (산책, 스트레칭)
        - 규칙적인 활동으로 장 운동 촉진

        4. 배변 습관 개선
        - 매일 정해진 시간에 화장실 가기
        - 충분한 시간 가지기
        - 필요시 의료진과 상담 가능 약물 사용
      ''',
    },
    '설사': {
      'title': '설사 대처 가이드',
      'content': '''
        1. 수분 및 전해질 관리
        - 깨끗한 물 자주 마시기
        - 스포츠 음료, 국물 섭취
        - 전해질 보충 (나트륨, 칼륨)

        2. 식이 조절
        - 기름진 음식, 유제품, 고지방 피하기
        - 흰 쌀밥, 삶은 계란, 닭가슴살 섭취
        - 섬유질 많은 음식 처음에 피하기

        3. 약물 고려
        - 로페라마이드(이모디움) 등 사용 가능
        - 의료진과 상담 필수

        4. 의료진 상담
        - 48시간 이상 지속되는 경우
        - 심한 복통이 동반되는 경우
      ''',
    },
    '복통': {
      'title': '복통 대처 가이드',
      'content': '''
        1. 즉각적인 완화
        - 따뜻한 수건으로 복부 찜질
        - 좌식 또는 누운 자세 취하기
        - 천천히 깊게 숨쉬기

        2. 식이 조절
        - 소화하기 쉬운 음식 섭취
        - 자극적인 음식 (카페인, 기름진 음식) 피하기
        - 작은 양을 자주 먹기

        3. 스트레스 관리
        - 명상, 요가 시도
        - 규칙적인 휴식
        - 스트레스 유발 상황 피하기

        4. 의료진 상담
        - 심한 복통이 있는 경우
        - 계속되는 경우
      ''',
    },
    '두통': {
      'title': '두통 대처 가이드',
      'content': '''
        1. 수분 섭취
        - 물 자주 마시기 (탈수 방지)
        - 카페인 섭취 조절

        2. 휴식 방법
        - 조용한 어두운 곳에서 쉬기
        - 30분 정도 눈을 감고 있기
        - 편안한 자세 취하기

        3. 물리적 완화
        - 목, 어깨 마사지
        - 따뜻한 샤워
        - 냉찜질 또는 온찜질

        4. 일상 관리
        - 규칙적인 수면
        - 규칙적인 식사
        - 스트레스 관리
      ''',
    },
    '피로': {
      'title': '피로 대처 가이드',
      'content': '''
        1. 휴식 및 회복
        - 충분한 수면 (7-9시간)
        - 낮 시간에 짧은 휴식 (15-30분)
        - 부드러운 스트레칭

        2. 영양 관리
        - 균형잡힌 식단
        - 철분, 비타민B 섭취
        - 규칙적인 식사

        3. 활동량 조절
        - 과로하지 않기
        - 힘이 들 때는 쉬기
        - 가벼운 활동은 도움이 될 수 있음

        4. 언제 의료진 상담
        - 2주 이상 심한 피로
        - 다른 증상과 함께 나타나는 경우
      ''',
    },
  };

  String _getGuideContent() {
    final guide = _guides[widget.symptomName];
    if (guide != null) {
      return guide['content'] ?? '';
    }
    return '전문 의료진과 상담하세요.';
  }

  String _getGuideTitle() {
    final guide = _guides[widget.symptomName];
    if (guide != null) {
      return guide['title'] ?? '대처 가이드';
    }
    return '${widget.symptomName} 대처 가이드';
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // 헤더
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.blue.shade50,
              borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  _getGuideTitle(),
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  '심각도: ${widget.severity}/10',
                  style: TextStyle(
                    fontSize: 12,
                    color: Colors.grey.shade600,
                  ),
                ),
              ],
            ),
          ),

          // 가이드 내용
          Flexible(
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(16),
              child: Text(
                _getGuideContent(),
                style: const TextStyle(
                  fontSize: 14,
                  height: 1.6,
                ),
              ),
            ),
          ),

          // 피드백 섹션
          Container(
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: Colors.grey.shade100,
              border: Border(
                top: BorderSide(color: Colors.grey.shade300),
              ),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text(
                  '도움이 되었나요?',
                  style: TextStyle(
                    fontSize: 14,
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 12),
                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton(
                        onPressed: () {
                          setState(() => _feedbackGiven = false);
                        },
                        style: OutlinedButton.styleFrom(
                          backgroundColor: _feedbackGiven == false
                              ? Colors.grey.shade300
                              : Colors.white,
                        ),
                        child: const Text('아니오'),
                      ),
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: ElevatedButton(
                        onPressed: () {
                          setState(() => _feedbackGiven = true);
                        },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: _feedbackGiven == true
                              ? Colors.green
                              : Colors.grey,
                        ),
                        child: const Text(
                          '예',
                          style: TextStyle(color: Colors.white),
                        ),
                      ),
                    ),
                  ],
                ),
                if (_feedbackGiven == true) ...[
                  const SizedBox(height: 12),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.green.shade50,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Text(
                      '피드백해주셔서 감사합니다!',
                      style: TextStyle(
                        color: Colors.green,
                        fontSize: 13,
                      ),
                    ),
                  ),
                ],
                const SizedBox(height: 12),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton(
                    onPressed: () {
                      widget.onClose?.call();
                      Navigator.of(context).pop();
                    },
                    child: const Text('닫기'),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/tracking/presentation/widgets/date_selection_widget.dart">
import 'package:flutter/material.dart';

/// 날짜 선택 위젯
///
/// 빠른 선택 버튼("오늘", "어제", "2일 전")과 캘린더 피커를 제공합니다.
/// 미래 날짜 선택은 불가능합니다.
class DateSelectionWidget extends StatefulWidget {
  /// 초기 선택된 날짜
  final DateTime? initialDate;

  /// 날짜가 선택되었을 때 호출되는 콜백
  final ValueChanged<DateTime> onDateSelected;

  const DateSelectionWidget({
    super.key,
    this.initialDate,
    required this.onDateSelected,
  });

  @override
  State<DateSelectionWidget> createState() => _DateSelectionWidgetState();
}

class _DateSelectionWidgetState extends State<DateSelectionWidget> {
  late DateTime selectedDate;

  @override
  void initState() {
    super.initState();
    selectedDate = widget.initialDate ?? _today();
  }

  DateTime _today() {
    final now = DateTime.now();
    return DateTime(now.year, now.month, now.day);
  }

  DateTime _yesterday() {
    final yesterday = DateTime.now().subtract(const Duration(days: 1));
    return DateTime(yesterday.year, yesterday.month, yesterday.day);
  }

  DateTime _twoDaysAgo() {
    final twoDaysAgo = DateTime.now().subtract(const Duration(days: 2));
    return DateTime(twoDaysAgo.year, twoDaysAgo.month, twoDaysAgo.day);
  }

  void _selectQuickDate(DateTime date) {
    setState(() {
      selectedDate = date;
    });
    widget.onDateSelected(date);
  }

  Future<void> _openCalendar() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: selectedDate,
      firstDate: DateTime(2020),
      lastDate: _today(), // 미래 날짜 선택 불가
      builder: (context, child) {
        return Theme(
          data: Theme.of(context).copyWith(
            colorScheme: ColorScheme.light(
              primary: Theme.of(context).primaryColor,
            ),
          ),
          child: child!,
        );
      },
    );

    if (picked != null) {
      setState(() {
        selectedDate = picked;
      });
      widget.onDateSelected(picked);
    }
  }

  String _formatDate(DateTime date) {
    return '${date.year}년 ${date.month}월 ${date.day}일';
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // 빠른 선택 버튼
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 16),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _QuickDateButton(
                label: '오늘',
                onPressed: () => _selectQuickDate(_today()),
              ),
              _QuickDateButton(
                label: '어제',
                onPressed: () => _selectQuickDate(_yesterday()),
              ),
              _QuickDateButton(
                label: '2일 전',
                onPressed: () => _selectQuickDate(_twoDaysAgo()),
              ),
            ],
          ),
        ),

        // 캘린더 선택 버튼
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 8),
          child: ElevatedButton.icon(
            onPressed: _openCalendar,
            icon: const Icon(Icons.calendar_today),
            label: Text(_formatDate(selectedDate)),
            style: ElevatedButton.styleFrom(
              minimumSize: const Size(double.infinity, 48),
            ),
          ),
        ),
      ],
    );
  }
}

/// 빠른 선택 버튼 (오늘, 어제, 2일 전)
class _QuickDateButton extends StatelessWidget {
  final String label;
  final VoidCallback onPressed;

  const _QuickDateButton({
    required this.label,
    required this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    return Flexible(
      child: OutlinedButton(
        onPressed: onPressed,
        style: OutlinedButton.styleFrom(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 12),
        ),
        child: Text(label),
      ),
    );
  }
}
</file>

<file path="lib/features/tracking/presentation/widgets/input_validation_widget.dart">
import 'package:flutter/material.dart';

/// 입력값 검증 위젯
///
/// 체중 입력값을 실시간으로 검증하고,
/// 에러/성공 상태를 시각적으로 표시합니다.
class InputValidationWidget extends StatefulWidget {
  /// 입력된 값
  final String? initialValue;

  /// 입력 필드의 이름 (예: "체중")
  final String fieldName;

  /// 입력값 변경 시 호출되는 콜백
  final ValueChanged<String> onChanged;

  /// 입력 필드의 라벨
  final String label;

  /// 입력 필드의 힌트
  final String? hint;

  /// 키보드 타입 (기본값: decimal)
  final TextInputType keyboardType;

  const InputValidationWidget({
    super.key,
    this.initialValue,
    required this.fieldName,
    required this.onChanged,
    required this.label,
    this.hint,
    this.keyboardType = const TextInputType.numberWithOptions(
      decimal: true,
      signed: false,
    ),
  });

  @override
  State<InputValidationWidget> createState() => _InputValidationWidgetState();
}

class _InputValidationWidgetState extends State<InputValidationWidget> {
  late TextEditingController _controller;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widget.initialValue ?? '');
    _controller.addListener(() {
      widget.onChanged(_controller.text);
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  /// 입력값 검증
  /// 반환값: (isValid, errorMessage)
  (bool, String?) _validate(String value) {
    if (value.isEmpty) {
      return (false, null); // 빈 값은 에러 메시지 없이 그냥 유효하지 않음
    }

    final weight = double.tryParse(value);
    if (weight == null) {
      return (false, '숫자를 입력하세요');
    }

    if (weight < 20) {
      return (false, '20kg 이상이어야 합니다');
    }

    if (weight > 300) {
      return (false, '300kg 이하여야 합니다');
    }

    return (true, null);
  }

  @override
  Widget build(BuildContext context) {
    final (isValid, errorMessage) = _validate(_controller.text);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Expanded(
              child: TextField(
                controller: _controller,
                keyboardType: widget.keyboardType,
                decoration: InputDecoration(
                  labelText: widget.label,
                  hintText: widget.hint,
                  border: OutlineInputBorder(
                    borderSide: BorderSide(
                      color: _controller.text.isEmpty
                          ? Colors.grey
                          : isValid
                              ? Colors.green
                              : Colors.red,
                    ),
                  ),
                  focusedBorder: OutlineInputBorder(
                    borderSide: BorderSide(
                      color: _controller.text.isEmpty
                          ? Theme.of(context).primaryColor
                          : isValid
                              ? Colors.green
                              : Colors.red,
                      width: 2,
                    ),
                  ),
                  contentPadding: const EdgeInsets.all(12),
                ),
              ),
            ),
            const SizedBox(width: 8),
            if (_controller.text.isNotEmpty)
              isValid
                  ? const Icon(Icons.check, color: Colors.green, size: 24)
                  : const Icon(Icons.close, color: Colors.red, size: 24),
          ],
        ),
        if (errorMessage != null) ...[
          const SizedBox(height: 8),
          Text(
            errorMessage,
            style: const TextStyle(color: Colors.red, fontSize: 12),
          ),
        ],
      ],
    );
  }
}
</file>

<file path="linux/flutter/CMakeLists.txt">
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.10)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.

# Serves the same purpose as list(TRANSFORM ... PREPEND ...),
# which isn't available in 3.10.
function(list_prepend LIST_NAME PREFIX)
    set(NEW_LIST "")
    foreach(element ${${LIST_NAME}})
        list(APPEND NEW_LIST "${PREFIX}${element}")
    endforeach(element)
    set(${LIST_NAME} "${NEW_LIST}" PARENT_SCOPE)
endfunction()

# === Flutter Library ===
# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)
pkg_check_modules(GLIB REQUIRED IMPORTED_TARGET glib-2.0)
pkg_check_modules(GIO REQUIRED IMPORTED_TARGET gio-2.0)

set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/libflutter_linux_gtk.so")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/lib/libapp.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "fl_basic_message_channel.h"
  "fl_binary_codec.h"
  "fl_binary_messenger.h"
  "fl_dart_project.h"
  "fl_engine.h"
  "fl_json_message_codec.h"
  "fl_json_method_codec.h"
  "fl_message_codec.h"
  "fl_method_call.h"
  "fl_method_channel.h"
  "fl_method_codec.h"
  "fl_method_response.h"
  "fl_plugin_registrar.h"
  "fl_plugin_registry.h"
  "fl_standard_message_codec.h"
  "fl_standard_method_codec.h"
  "fl_string_codec.h"
  "fl_value.h"
  "fl_view.h"
  "flutter_linux.h"
)
list_prepend(FLUTTER_LIBRARY_HEADERS "${EPHEMERAL_DIR}/flutter_linux/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}")
target_link_libraries(flutter INTERFACE
  PkgConfig::GTK
  PkgConfig::GLIB
  PkgConfig::GIO
)
add_dependencies(flutter flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CMAKE_CURRENT_BINARY_DIR}/_phony_
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.sh"
      ${FLUTTER_TARGET_PLATFORM} ${CMAKE_BUILD_TYPE}
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
)
</file>

<file path="linux/runner/CMakeLists.txt">
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME}
  "main.cc"
  "my_application.cc"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the application ID.
add_definitions(-DAPPLICATION_ID="${APPLICATION_ID}")

# Add dependency libraries. Add any application-specific dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter)
target_link_libraries(${BINARY_NAME} PRIVATE PkgConfig::GTK)

target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")
</file>

<file path="linux/runner/main.cc">
#include "my_application.h"

int main(int argc, char** argv) {
  g_autoptr(MyApplication) app = my_application_new();
  return g_application_run(G_APPLICATION(app), argc, argv);
}
</file>

<file path="linux/runner/my_application.cc">
#include "my_application.h"

#include <flutter_linux/flutter_linux.h>
#ifdef GDK_WINDOWING_X11
#include <gdk/gdkx.h>
#endif

#include "flutter/generated_plugin_registrant.h"

struct _MyApplication {
  GtkApplication parent_instance;
  char** dart_entrypoint_arguments;
};

G_DEFINE_TYPE(MyApplication, my_application, GTK_TYPE_APPLICATION)

// Called when first Flutter frame received.
static void first_frame_cb(MyApplication* self, FlView *view)
{
  gtk_widget_show(gtk_widget_get_toplevel(GTK_WIDGET(view)));
}

// Implements GApplication::activate.
static void my_application_activate(GApplication* application) {
  MyApplication* self = MY_APPLICATION(application);
  GtkWindow* window =
      GTK_WINDOW(gtk_application_window_new(GTK_APPLICATION(application)));

  // Use a header bar when running in GNOME as this is the common style used
  // by applications and is the setup most users will be using (e.g. Ubuntu
  // desktop).
  // If running on X and not using GNOME then just use a traditional title bar
  // in case the window manager does more exotic layout, e.g. tiling.
  // If running on Wayland assume the header bar will work (may need changing
  // if future cases occur).
  gboolean use_header_bar = TRUE;
#ifdef GDK_WINDOWING_X11
  GdkScreen* screen = gtk_window_get_screen(window);
  if (GDK_IS_X11_SCREEN(screen)) {
    const gchar* wm_name = gdk_x11_screen_get_window_manager_name(screen);
    if (g_strcmp0(wm_name, "GNOME Shell") != 0) {
      use_header_bar = FALSE;
    }
  }
#endif
  if (use_header_bar) {
    GtkHeaderBar* header_bar = GTK_HEADER_BAR(gtk_header_bar_new());
    gtk_widget_show(GTK_WIDGET(header_bar));
    gtk_header_bar_set_title(header_bar, "n06");
    gtk_header_bar_set_show_close_button(header_bar, TRUE);
    gtk_window_set_titlebar(window, GTK_WIDGET(header_bar));
  } else {
    gtk_window_set_title(window, "n06");
  }

  gtk_window_set_default_size(window, 1280, 720);

  g_autoptr(FlDartProject) project = fl_dart_project_new();
  fl_dart_project_set_dart_entrypoint_arguments(project, self->dart_entrypoint_arguments);

  FlView* view = fl_view_new(project);
  GdkRGBA background_color;
  // Background defaults to black, override it here if necessary, e.g. #00000000 for transparent.
  gdk_rgba_parse(&background_color, "#000000");
  fl_view_set_background_color(view, &background_color);
  gtk_widget_show(GTK_WIDGET(view));
  gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(view));

  // Show the window when Flutter renders.
  // Requires the view to be realized so we can start rendering.
  g_signal_connect_swapped(view, "first-frame", G_CALLBACK(first_frame_cb), self);
  gtk_widget_realize(GTK_WIDGET(view));

  fl_register_plugins(FL_PLUGIN_REGISTRY(view));

  gtk_widget_grab_focus(GTK_WIDGET(view));
}

// Implements GApplication::local_command_line.
static gboolean my_application_local_command_line(GApplication* application, gchar*** arguments, int* exit_status) {
  MyApplication* self = MY_APPLICATION(application);
  // Strip out the first argument as it is the binary name.
  self->dart_entrypoint_arguments = g_strdupv(*arguments + 1);

  g_autoptr(GError) error = nullptr;
  if (!g_application_register(application, nullptr, &error)) {
     g_warning("Failed to register: %s", error->message);
     *exit_status = 1;
     return TRUE;
  }

  g_application_activate(application);
  *exit_status = 0;

  return TRUE;
}

// Implements GApplication::startup.
static void my_application_startup(GApplication* application) {
  //MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application startup.

  G_APPLICATION_CLASS(my_application_parent_class)->startup(application);
}

// Implements GApplication::shutdown.
static void my_application_shutdown(GApplication* application) {
  //MyApplication* self = MY_APPLICATION(object);

  // Perform any actions required at application shutdown.

  G_APPLICATION_CLASS(my_application_parent_class)->shutdown(application);
}

// Implements GObject::dispose.
static void my_application_dispose(GObject* object) {
  MyApplication* self = MY_APPLICATION(object);
  g_clear_pointer(&self->dart_entrypoint_arguments, g_strfreev);
  G_OBJECT_CLASS(my_application_parent_class)->dispose(object);
}

static void my_application_class_init(MyApplicationClass* klass) {
  G_APPLICATION_CLASS(klass)->activate = my_application_activate;
  G_APPLICATION_CLASS(klass)->local_command_line = my_application_local_command_line;
  G_APPLICATION_CLASS(klass)->startup = my_application_startup;
  G_APPLICATION_CLASS(klass)->shutdown = my_application_shutdown;
  G_OBJECT_CLASS(klass)->dispose = my_application_dispose;
}

static void my_application_init(MyApplication* self) {}

MyApplication* my_application_new() {
  // Set the program name to the application ID, which helps various systems
  // like GTK and desktop environments map this running application to its
  // corresponding .desktop file. This ensures better integration by allowing
  // the application to be recognized beyond its binary name.
  g_set_prgname(APPLICATION_ID);

  return MY_APPLICATION(g_object_new(my_application_get_type(),
                                     "application-id", APPLICATION_ID,
                                     "flags", G_APPLICATION_NON_UNIQUE,
                                     nullptr));
}
</file>

<file path="linux/runner/my_application.h">
#ifndef FLUTTER_MY_APPLICATION_H_
#define FLUTTER_MY_APPLICATION_H_

#include <gtk/gtk.h>

G_DECLARE_FINAL_TYPE(MyApplication, my_application, MY, APPLICATION,
                     GtkApplication)

/**
 * my_application_new:
 *
 * Creates a new Flutter-based application.
 *
 * Returns: a new #MyApplication.
 */
MyApplication* my_application_new();

#endif  // FLUTTER_MY_APPLICATION_H_
</file>

<file path="linux/.gitignore">
flutter/ephemeral
</file>

<file path="linux/CMakeLists.txt">
# Project-level configuration.
cmake_minimum_required(VERSION 3.13)
project(runner LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "n06")
# The unique GTK application identifier for this application. See:
# https://wiki.gnome.org/HowDoI/ChooseApplicationID
set(APPLICATION_ID "com.glp1.n06")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(SET CMP0063 NEW)

# Load bundled libraries from the lib/ directory relative to the binary.
set(CMAKE_INSTALL_RPATH "$ORIGIN/lib")

# Root filesystem for cross-building.
if(FLUTTER_TARGET_PLATFORM_SYSROOT)
  set(CMAKE_SYSROOT ${FLUTTER_TARGET_PLATFORM_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH ${CMAKE_SYSROOT})
  set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
  set(CMAKE_FIND_ROOT_PATH_MODE_PACKAGE ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
  set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
endif()

# Define build configuration options.
if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
  set(CMAKE_BUILD_TYPE "Debug" CACHE
    STRING "Flutter build mode" FORCE)
  set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
    "Debug" "Profile" "Release")
endif()

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_14)
  target_compile_options(${TARGET} PRIVATE -Wall -Werror)
  target_compile_options(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:-O3>")
  target_compile_definitions(${TARGET} PRIVATE "$<$<NOT:$<CONFIG:Debug>>:NDEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# System-level dependencies.
find_package(PkgConfig REQUIRED)
pkg_check_modules(GTK REQUIRED IMPORTED_TARGET gtk+-3.0)

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)

# Only the install-generated bundle's copy of the executable will launch
# correctly, since the resources must in the right relative locations. To avoid
# people trying to run the unbundled copy, put it in a subdirectory instead of
# the default top-level location.
set_target_properties(${BINARY_NAME}
  PROPERTIES
  RUNTIME_OUTPUT_DIRECTORY "${CMAKE_BINARY_DIR}/intermediates_do_not_run"
)


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# By default, "installing" just makes a relocatable bundle in the build
# directory.
set(BUILD_BUNDLE_DIR "${PROJECT_BINARY_DIR}/bundle")
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

# Start with a clean build bundle directory every time.
install(CODE "
  file(REMOVE_RECURSE \"${BUILD_BUNDLE_DIR}/\")
  " COMPONENT Runtime)

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}/lib")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

foreach(bundled_library ${PLUGIN_BUNDLED_LIBRARIES})
  install(FILES "${bundled_library}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endforeach(bundled_library)

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/linux/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
if(NOT CMAKE_BUILD_TYPE MATCHES "Debug")
  install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()
</file>

<file path="macos/Runner/Assets.xcassets/AppIcon.appiconset/Contents.json">
{
  "images" : [
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_16.png",
      "scale" : "1x"
    },
    {
      "size" : "16x16",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "2x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_32.png",
      "scale" : "1x"
    },
    {
      "size" : "32x32",
      "idiom" : "mac",
      "filename" : "app_icon_64.png",
      "scale" : "2x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_128.png",
      "scale" : "1x"
    },
    {
      "size" : "128x128",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "2x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_256.png",
      "scale" : "1x"
    },
    {
      "size" : "256x256",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "2x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_512.png",
      "scale" : "1x"
    },
    {
      "size" : "512x512",
      "idiom" : "mac",
      "filename" : "app_icon_1024.png",
      "scale" : "2x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
</file>

<file path="macos/Runner/Base.lproj/MainMenu.xib">
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="14490.70" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <deployment identifier="macosx"/>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="14490.70"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="NSApplication">
            <connections>
                <outlet property="delegate" destination="Voe-Tx-rLC" id="GzC-gU-4Uq"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application" customClass="NSObject"/>
        <customObject id="Voe-Tx-rLC" customClass="AppDelegate" customModule="Runner" customModuleProvider="target">
            <connections>
                <outlet property="applicationMenu" destination="uQy-DD-JDr" id="XBo-yE-nKs"/>
                <outlet property="mainFlutterWindow" destination="QvC-M9-y7g" id="gIp-Ho-8D9"/>
            </connections>
        </customObject>
        <customObject id="YLy-65-1bz" customClass="NSFontManager"/>
        <menu title="Main Menu" systemMenu="main" id="AYu-sK-qS6">
            <items>
                <menuItem title="APP_NAME" id="1Xt-HY-uBw">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="APP_NAME" systemMenu="apple" id="uQy-DD-JDr">
                        <items>
                            <menuItem title="About APP_NAME" id="5kV-Vb-QxS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="orderFrontStandardAboutPanel:" target="-1" id="Exp-CZ-Vem"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="VOq-y0-SEH"/>
                            <menuItem title="Preferences…" keyEquivalent="," id="BOF-NM-1cW"/>
                            <menuItem isSeparatorItem="YES" id="wFC-TO-SCJ"/>
                            <menuItem title="Services" id="NMo-om-nkz">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Services" systemMenu="services" id="hz9-B4-Xy5"/>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="4je-JR-u6R"/>
                            <menuItem title="Hide APP_NAME" keyEquivalent="h" id="Olw-nP-bQN">
                                <connections>
                                    <action selector="hide:" target="-1" id="PnN-Uc-m68"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Hide Others" keyEquivalent="h" id="Vdr-fp-XzO">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="hideOtherApplications:" target="-1" id="VT4-aY-XCT"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Show All" id="Kd2-mp-pUS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="unhideAllApplications:" target="-1" id="Dhg-Le-xox"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="kCx-OE-vgT"/>
                            <menuItem title="Quit APP_NAME" keyEquivalent="q" id="4sb-4s-VLi">
                                <connections>
                                    <action selector="terminate:" target="-1" id="Te7-pn-YzF"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Edit" id="5QF-Oa-p0T">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Edit" id="W48-6f-4Dl">
                        <items>
                            <menuItem title="Undo" keyEquivalent="z" id="dRJ-4n-Yzg">
                                <connections>
                                    <action selector="undo:" target="-1" id="M6e-cu-g7V"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Redo" keyEquivalent="Z" id="6dh-zS-Vam">
                                <connections>
                                    <action selector="redo:" target="-1" id="oIA-Rs-6OD"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="WRV-NI-Exz"/>
                            <menuItem title="Cut" keyEquivalent="x" id="uRl-iY-unG">
                                <connections>
                                    <action selector="cut:" target="-1" id="YJe-68-I9s"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Copy" keyEquivalent="c" id="x3v-GG-iWU">
                                <connections>
                                    <action selector="copy:" target="-1" id="G1f-GL-Joy"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste" keyEquivalent="v" id="gVA-U4-sdL">
                                <connections>
                                    <action selector="paste:" target="-1" id="UvS-8e-Qdg"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste and Match Style" keyEquivalent="V" id="WeT-3V-zwk">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="pasteAsPlainText:" target="-1" id="cEh-KX-wJQ"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Delete" id="pa3-QI-u2k">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="delete:" target="-1" id="0Mk-Ml-PaM"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Select All" keyEquivalent="a" id="Ruw-6m-B2m">
                                <connections>
                                    <action selector="selectAll:" target="-1" id="VNm-Mi-diN"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="uyl-h8-XO2"/>
                            <menuItem title="Find" id="4EN-yA-p0u">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Find" id="1b7-l0-nxx">
                                    <items>
                                        <menuItem title="Find…" tag="1" keyEquivalent="f" id="Xz5-n4-O0W">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="cD7-Qs-BN4"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find and Replace…" tag="12" keyEquivalent="f" id="YEy-JH-Tfz">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="WD3-Gg-5AJ"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Next" tag="2" keyEquivalent="g" id="q09-fT-Sye">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="NDo-RZ-v9R"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Previous" tag="3" keyEquivalent="G" id="OwM-mh-QMV">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="HOh-sY-3ay"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Use Selection for Find" tag="7" keyEquivalent="e" id="buJ-ug-pKt">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="U76-nv-p5D"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Jump to Selection" keyEquivalent="j" id="S0p-oC-mLd">
                                            <connections>
                                                <action selector="centerSelectionInVisibleArea:" target="-1" id="IOG-6D-g5B"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Spelling and Grammar" id="Dv1-io-Yv7">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Spelling" id="3IN-sU-3Bg">
                                    <items>
                                        <menuItem title="Show Spelling and Grammar" keyEquivalent=":" id="HFo-cy-zxI">
                                            <connections>
                                                <action selector="showGuessPanel:" target="-1" id="vFj-Ks-hy3"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Document Now" keyEquivalent=";" id="hz2-CU-CR7">
                                            <connections>
                                                <action selector="checkSpelling:" target="-1" id="fz7-VC-reM"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="bNw-od-mp5"/>
                                        <menuItem title="Check Spelling While Typing" id="rbD-Rh-wIN">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleContinuousSpellChecking:" target="-1" id="7w6-Qz-0kB"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Grammar With Spelling" id="mK6-2p-4JG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleGrammarChecking:" target="-1" id="muD-Qn-j4w"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Correct Spelling Automatically" id="78Y-hA-62v">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticSpellingCorrection:" target="-1" id="2lM-Qi-WAP"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Substitutions" id="9ic-FL-obx">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Substitutions" id="FeM-D8-WVr">
                                    <items>
                                        <menuItem title="Show Substitutions" id="z6F-FW-3nz">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="orderFrontSubstitutionsPanel:" target="-1" id="oku-mr-iSq"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="gPx-C9-uUO"/>
                                        <menuItem title="Smart Copy/Paste" id="9yt-4B-nSM">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleSmartInsertDelete:" target="-1" id="3IJ-Se-DZD"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Quotes" id="hQb-2v-fYv">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticQuoteSubstitution:" target="-1" id="ptq-xd-QOA"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Dashes" id="rgM-f4-ycn">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDashSubstitution:" target="-1" id="oCt-pO-9gS"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Links" id="cwL-P1-jid">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticLinkDetection:" target="-1" id="Gip-E3-Fov"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Data Detectors" id="tRr-pd-1PS">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDataDetection:" target="-1" id="R1I-Nq-Kbl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Text Replacement" id="HFQ-gK-NFA">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticTextReplacement:" target="-1" id="DvP-Fe-Py6"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Transformations" id="2oI-Rn-ZJC">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Transformations" id="c8a-y6-VQd">
                                    <items>
                                        <menuItem title="Make Upper Case" id="vmV-6d-7jI">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="uppercaseWord:" target="-1" id="sPh-Tk-edu"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Make Lower Case" id="d9M-CD-aMd">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="lowercaseWord:" target="-1" id="iUZ-b5-hil"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Capitalize" id="UEZ-Bs-lqG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="capitalizeWord:" target="-1" id="26H-TL-nsh"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Speech" id="xrE-MZ-jX0">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Speech" id="3rS-ZA-NoH">
                                    <items>
                                        <menuItem title="Start Speaking" id="Ynk-f8-cLZ">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="startSpeaking:" target="-1" id="654-Ng-kyl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Stop Speaking" id="Oyz-dy-DGm">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="stopSpeaking:" target="-1" id="dX8-6p-jy9"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="View" id="H8h-7b-M4v">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="View" id="HyV-fh-RgO">
                        <items>
                            <menuItem title="Enter Full Screen" keyEquivalent="f" id="4J7-dP-txa">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleFullScreen:" target="-1" id="dU3-MA-1Rq"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Window" id="aUF-d1-5bR">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Window" systemMenu="window" id="Td7-aD-5lo">
                        <items>
                            <menuItem title="Minimize" keyEquivalent="m" id="OY7-WF-poV">
                                <connections>
                                    <action selector="performMiniaturize:" target="-1" id="VwT-WD-YPe"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Zoom" id="R4o-n2-Eq4">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="performZoom:" target="-1" id="DIl-cC-cCs"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="eu3-7i-yIM"/>
                            <menuItem title="Bring All to Front" id="LE2-aR-0XJ">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="arrangeInFront:" target="-1" id="DRN-fu-gQh"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Help" id="EPT-qC-fAb">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Help" systemMenu="help" id="rJ0-wn-3NY"/>
                </menuItem>
            </items>
            <point key="canvasLocation" x="142" y="-258"/>
        </menu>
        <window title="APP_NAME" allowsToolTipsWhenApplicationIsInactive="NO" autorecalculatesKeyViewLoop="NO" releasedWhenClosed="NO" animationBehavior="default" id="QvC-M9-y7g" customClass="MainFlutterWindow" customModule="Runner" customModuleProvider="target">
            <windowStyleMask key="styleMask" titled="YES" closable="YES" miniaturizable="YES" resizable="YES"/>
            <rect key="contentRect" x="335" y="390" width="800" height="600"/>
            <rect key="screenRect" x="0.0" y="0.0" width="2560" height="1577"/>
            <view key="contentView" wantsLayer="YES" id="EiT-Mj-1SZ">
                <rect key="frame" x="0.0" y="0.0" width="800" height="600"/>
                <autoresizingMask key="autoresizingMask"/>
            </view>
        </window>
    </objects>
</document>
</file>

<file path="macos/Runner/Configs/AppInfo.xcconfig">
// Application-level settings for the Runner target.
//
// This may be replaced with something auto-generated from metadata (e.g., pubspec.yaml) in the
// future. If not, the values below would default to using the project name when this becomes a
// 'flutter create' template.

// The application's name. By default this is also the title of the Flutter window.
PRODUCT_NAME = n06

// The application's bundle identifier
PRODUCT_BUNDLE_IDENTIFIER = com.glp1.n06

// The copyright displayed in application information
PRODUCT_COPYRIGHT = Copyright © 2025 com.glp1. All rights reserved.
</file>

<file path="macos/Runner/Configs/Debug.xcconfig">
#include "../../Flutter/Flutter-Debug.xcconfig"
#include "Warnings.xcconfig"
</file>

<file path="macos/Runner/Configs/Release.xcconfig">
#include "../../Flutter/Flutter-Release.xcconfig"
#include "Warnings.xcconfig"
</file>

<file path="macos/Runner/Configs/Warnings.xcconfig">
WARNING_CFLAGS = -Wall -Wconditional-uninitialized -Wnullable-to-nonnull-conversion -Wmissing-method-return-type -Woverlength-strings
GCC_WARN_UNDECLARED_SELECTOR = YES
CLANG_UNDEFINED_BEHAVIOR_SANITIZER_NULLABILITY = YES
CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE
CLANG_WARN__DUPLICATE_METHOD_MATCH = YES
CLANG_WARN_PRAGMA_PACK = YES
CLANG_WARN_STRICT_PROTOTYPES = YES
CLANG_WARN_COMMA = YES
GCC_WARN_STRICT_SELECTOR_MATCH = YES
CLANG_WARN_OBJC_REPEATED_USE_OF_WEAK = YES
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES
GCC_WARN_SHADOW = YES
CLANG_WARN_UNREACHABLE_CODE = YES
</file>

<file path="macos/Runner/AppDelegate.swift">
import Cocoa
import FlutterMacOS

@main
class AppDelegate: FlutterAppDelegate {
  override func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
    return true
  }

  override func applicationSupportsSecureRestorableState(_ app: NSApplication) -> Bool {
    return true
  }
}
</file>

<file path="macos/Runner/DebugProfile.entitlements">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.cs.allow-jit</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
</dict>
</plist>
</file>

<file path="macos/Runner/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIconFile</key>
	<string></string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>$(PRODUCT_NAME)</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSMinimumSystemVersion</key>
	<string>$(MACOSX_DEPLOYMENT_TARGET)</string>
	<key>NSHumanReadableCopyright</key>
	<string>$(PRODUCT_COPYRIGHT)</string>
	<key>NSMainNibFile</key>
	<string>MainMenu</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
</dict>
</plist>
</file>

<file path="macos/Runner/MainFlutterWindow.swift">
import Cocoa
import FlutterMacOS

class MainFlutterWindow: NSWindow {
  override func awakeFromNib() {
    let flutterViewController = FlutterViewController()
    let windowFrame = self.frame
    self.contentViewController = flutterViewController
    self.setFrame(windowFrame, display: true)

    RegisterGeneratedPlugins(registry: flutterViewController)

    super.awakeFromNib()
  }
}
</file>

<file path="macos/Runner/Release.entitlements">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
</dict>
</plist>
</file>

<file path="macos/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>
</file>

<file path="macos/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme">
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1510"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "33CC10EC2044A3C60003C045"
               BuildableName = "n06.app"
               BlueprintName = "Runner"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "n06.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "331C80D4294CF70F00263BE5"
               BuildableName = "RunnerTests.xctest"
               BlueprintName = "RunnerTests"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      enableGPUValidationMode = "1"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "n06.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Profile"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "33CC10EC2044A3C60003C045"
            BuildableName = "n06.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>
</file>

<file path="macos/Runner.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>
</file>

<file path="macos/RunnerTests/RunnerTests.swift">
import Cocoa
import FlutterMacOS
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}
</file>

<file path="macos/.gitignore">
# Flutter-related
**/Flutter/ephemeral/
**/Pods/

# Xcode-related
**/dgph
**/xcuserdata/
</file>

<file path="macos/Podfile">
platform :osx, '10.15'

# CocoaPods analytics sends network stats synchronously affecting flutter build latency.
ENV['COCOAPODS_DISABLE_STATS'] = 'true'

project 'Runner', {
  'Debug' => :debug,
  'Profile' => :release,
  'Release' => :release,
}

def flutter_root
  generated_xcode_build_settings_path = File.expand_path(File.join('..', 'Flutter', 'ephemeral', 'Flutter-Generated.xcconfig'), __FILE__)
  unless File.exist?(generated_xcode_build_settings_path)
    raise "#{generated_xcode_build_settings_path} must exist. If you're running pod install manually, make sure \"flutter pub get\" is executed first"
  end

  File.foreach(generated_xcode_build_settings_path) do |line|
    matches = line.match(/FLUTTER_ROOT\=(.*)/)
    return matches[1].strip if matches
  end
  raise "FLUTTER_ROOT not found in #{generated_xcode_build_settings_path}. Try deleting Flutter-Generated.xcconfig, then run \"flutter pub get\""
end

require File.expand_path(File.join('packages', 'flutter_tools', 'bin', 'podhelper'), flutter_root)

flutter_macos_podfile_setup

target 'Runner' do
  use_frameworks!

  flutter_install_all_macos_pods File.dirname(File.realpath(__FILE__))
  target 'RunnerTests' do
    inherit! :search_paths
  end
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    flutter_additional_macos_build_settings(target)
  end
end
</file>

<file path="macos/Podfile.lock">
PODS:
  - CocoaAsyncSocket (7.6.5)
  - Firebase/Analytics (10.25.0):
    - Firebase/Core
  - Firebase/Core (10.25.0):
    - Firebase/CoreOnly
    - FirebaseAnalytics (~> 10.25.0)
  - Firebase/CoreOnly (10.25.0):
    - FirebaseCore (= 10.25.0)
  - Firebase/Crashlytics (10.25.0):
    - Firebase/CoreOnly
    - FirebaseCrashlytics (~> 10.25.0)
  - firebase_analytics (10.10.7):
    - Firebase/Analytics (= 10.25.0)
    - firebase_core
    - FlutterMacOS
  - firebase_core (2.32.0):
    - Firebase/CoreOnly (~> 10.25.0)
    - FlutterMacOS
  - firebase_crashlytics (3.5.7):
    - Firebase/CoreOnly (~> 10.25.0)
    - Firebase/Crashlytics (~> 10.25.0)
    - firebase_core
    - FlutterMacOS
  - FirebaseAnalytics (10.25.0):
    - FirebaseAnalytics/AdIdSupport (= 10.25.0)
    - FirebaseCore (~> 10.0)
    - FirebaseInstallations (~> 10.0)
    - GoogleUtilities/AppDelegateSwizzler (~> 7.11)
    - GoogleUtilities/MethodSwizzler (~> 7.11)
    - GoogleUtilities/Network (~> 7.11)
    - "GoogleUtilities/NSData+zlib (~> 7.11)"
    - nanopb (< 2.30911.0, >= 2.30908.0)
  - FirebaseAnalytics/AdIdSupport (10.25.0):
    - FirebaseCore (~> 10.0)
    - FirebaseInstallations (~> 10.0)
    - GoogleAppMeasurement (= 10.25.0)
    - GoogleUtilities/AppDelegateSwizzler (~> 7.11)
    - GoogleUtilities/MethodSwizzler (~> 7.11)
    - GoogleUtilities/Network (~> 7.11)
    - "GoogleUtilities/NSData+zlib (~> 7.11)"
    - nanopb (< 2.30911.0, >= 2.30908.0)
  - FirebaseCore (10.25.0):
    - FirebaseCoreInternal (~> 10.0)
    - GoogleUtilities/Environment (~> 7.12)
    - GoogleUtilities/Logger (~> 7.12)
  - FirebaseCoreExtension (10.29.0):
    - FirebaseCore (~> 10.0)
  - FirebaseCoreInternal (10.29.0):
    - "GoogleUtilities/NSData+zlib (~> 7.8)"
  - FirebaseCrashlytics (10.25.0):
    - FirebaseCore (~> 10.5)
    - FirebaseInstallations (~> 10.0)
    - FirebaseRemoteConfigInterop (~> 10.23)
    - FirebaseSessions (~> 10.5)
    - GoogleDataTransport (~> 9.2)
    - GoogleUtilities/Environment (~> 7.8)
    - nanopb (< 2.30911.0, >= 2.30908.0)
    - PromisesObjC (~> 2.1)
  - FirebaseInstallations (10.29.0):
    - FirebaseCore (~> 10.0)
    - GoogleUtilities/Environment (~> 7.8)
    - GoogleUtilities/UserDefaults (~> 7.8)
    - PromisesObjC (~> 2.1)
  - FirebaseRemoteConfigInterop (10.29.0)
  - FirebaseSessions (10.29.0):
    - FirebaseCore (~> 10.5)
    - FirebaseCoreExtension (~> 10.0)
    - FirebaseInstallations (~> 10.0)
    - GoogleDataTransport (~> 9.2)
    - GoogleUtilities/Environment (~> 7.13)
    - GoogleUtilities/UserDefaults (~> 7.13)
    - nanopb (< 2.30911.0, >= 2.30908.0)
    - PromisesSwift (~> 2.1)
  - flutter_local_notifications (0.0.1):
    - FlutterMacOS
  - flutter_secure_storage_macos (6.1.3):
    - FlutterMacOS
  - FlutterMacOS (1.0.0)
  - GoogleAppMeasurement (10.25.0):
    - GoogleAppMeasurement/AdIdSupport (= 10.25.0)
    - GoogleUtilities/AppDelegateSwizzler (~> 7.11)
    - GoogleUtilities/MethodSwizzler (~> 7.11)
    - GoogleUtilities/Network (~> 7.11)
    - "GoogleUtilities/NSData+zlib (~> 7.11)"
    - nanopb (< 2.30911.0, >= 2.30908.0)
  - GoogleAppMeasurement/AdIdSupport (10.25.0):
    - GoogleAppMeasurement/WithoutAdIdSupport (= 10.25.0)
    - GoogleUtilities/AppDelegateSwizzler (~> 7.11)
    - GoogleUtilities/MethodSwizzler (~> 7.11)
    - GoogleUtilities/Network (~> 7.11)
    - "GoogleUtilities/NSData+zlib (~> 7.11)"
    - nanopb (< 2.30911.0, >= 2.30908.0)
  - GoogleAppMeasurement/WithoutAdIdSupport (10.25.0):
    - GoogleUtilities/AppDelegateSwizzler (~> 7.11)
    - GoogleUtilities/MethodSwizzler (~> 7.11)
    - GoogleUtilities/Network (~> 7.11)
    - "GoogleUtilities/NSData+zlib (~> 7.11)"
    - nanopb (< 2.30911.0, >= 2.30908.0)
  - GoogleDataTransport (9.4.1):
    - GoogleUtilities/Environment (~> 7.7)
    - nanopb (< 2.30911.0, >= 2.30908.0)
    - PromisesObjC (< 3.0, >= 1.2)
  - GoogleUtilities/AppDelegateSwizzler (7.13.3):
    - GoogleUtilities/Environment
    - GoogleUtilities/Logger
    - GoogleUtilities/Network
    - GoogleUtilities/Privacy
  - GoogleUtilities/Environment (7.13.3):
    - GoogleUtilities/Privacy
    - PromisesObjC (< 3.0, >= 1.2)
  - GoogleUtilities/Logger (7.13.3):
    - GoogleUtilities/Environment
    - GoogleUtilities/Privacy
  - GoogleUtilities/MethodSwizzler (7.13.3):
    - GoogleUtilities/Logger
    - GoogleUtilities/Privacy
  - GoogleUtilities/Network (7.13.3):
    - GoogleUtilities/Logger
    - "GoogleUtilities/NSData+zlib"
    - GoogleUtilities/Privacy
    - GoogleUtilities/Reachability
  - "GoogleUtilities/NSData+zlib (7.13.3)":
    - GoogleUtilities/Privacy
  - GoogleUtilities/Privacy (7.13.3)
  - GoogleUtilities/Reachability (7.13.3):
    - GoogleUtilities/Logger
    - GoogleUtilities/Privacy
  - GoogleUtilities/UserDefaults (7.13.3):
    - GoogleUtilities/Logger
    - GoogleUtilities/Privacy
  - isar_flutter_libs (1.0.0):
    - FlutterMacOS
  - nanopb (2.30910.0):
    - nanopb/decode (= 2.30910.0)
    - nanopb/encode (= 2.30910.0)
  - nanopb/decode (2.30910.0)
  - nanopb/encode (2.30910.0)
  - path_provider_foundation (0.0.1):
    - Flutter
    - FlutterMacOS
  - patrol (0.0.1):
    - CocoaAsyncSocket (~> 7.6)
    - Flutter
    - FlutterMacOS
  - PromisesObjC (2.4.0)
  - PromisesSwift (2.4.0):
    - PromisesObjC (= 2.4.0)
  - shared_preferences_foundation (0.0.1):
    - Flutter
    - FlutterMacOS
  - webview_flutter_wkwebview (0.0.1):
    - Flutter
    - FlutterMacOS

DEPENDENCIES:
  - firebase_analytics (from `Flutter/ephemeral/.symlinks/plugins/firebase_analytics/macos`)
  - firebase_core (from `Flutter/ephemeral/.symlinks/plugins/firebase_core/macos`)
  - firebase_crashlytics (from `Flutter/ephemeral/.symlinks/plugins/firebase_crashlytics/macos`)
  - flutter_local_notifications (from `Flutter/ephemeral/.symlinks/plugins/flutter_local_notifications/macos`)
  - flutter_secure_storage_macos (from `Flutter/ephemeral/.symlinks/plugins/flutter_secure_storage_macos/macos`)
  - FlutterMacOS (from `Flutter/ephemeral`)
  - isar_flutter_libs (from `Flutter/ephemeral/.symlinks/plugins/isar_flutter_libs/macos`)
  - path_provider_foundation (from `Flutter/ephemeral/.symlinks/plugins/path_provider_foundation/darwin`)
  - patrol (from `Flutter/ephemeral/.symlinks/plugins/patrol/darwin`)
  - shared_preferences_foundation (from `Flutter/ephemeral/.symlinks/plugins/shared_preferences_foundation/darwin`)
  - webview_flutter_wkwebview (from `Flutter/ephemeral/.symlinks/plugins/webview_flutter_wkwebview/darwin`)

SPEC REPOS:
  trunk:
    - CocoaAsyncSocket
    - Firebase
    - FirebaseAnalytics
    - FirebaseCore
    - FirebaseCoreExtension
    - FirebaseCoreInternal
    - FirebaseCrashlytics
    - FirebaseInstallations
    - FirebaseRemoteConfigInterop
    - FirebaseSessions
    - GoogleAppMeasurement
    - GoogleDataTransport
    - GoogleUtilities
    - nanopb
    - PromisesObjC
    - PromisesSwift

EXTERNAL SOURCES:
  firebase_analytics:
    :path: Flutter/ephemeral/.symlinks/plugins/firebase_analytics/macos
  firebase_core:
    :path: Flutter/ephemeral/.symlinks/plugins/firebase_core/macos
  firebase_crashlytics:
    :path: Flutter/ephemeral/.symlinks/plugins/firebase_crashlytics/macos
  flutter_local_notifications:
    :path: Flutter/ephemeral/.symlinks/plugins/flutter_local_notifications/macos
  flutter_secure_storage_macos:
    :path: Flutter/ephemeral/.symlinks/plugins/flutter_secure_storage_macos/macos
  FlutterMacOS:
    :path: Flutter/ephemeral
  isar_flutter_libs:
    :path: Flutter/ephemeral/.symlinks/plugins/isar_flutter_libs/macos
  path_provider_foundation:
    :path: Flutter/ephemeral/.symlinks/plugins/path_provider_foundation/darwin
  patrol:
    :path: Flutter/ephemeral/.symlinks/plugins/patrol/darwin
  shared_preferences_foundation:
    :path: Flutter/ephemeral/.symlinks/plugins/shared_preferences_foundation/darwin
  webview_flutter_wkwebview:
    :path: Flutter/ephemeral/.symlinks/plugins/webview_flutter_wkwebview/darwin

SPEC CHECKSUMS:
  CocoaAsyncSocket: 065fd1e645c7abab64f7a6a2007a48038fdc6a99
  Firebase: 0312a2352584f782ea56f66d91606891d4607f06
  firebase_analytics: 5125a2f5b999a7756e3ff165805529163883fb4a
  firebase_core: e324fc945c2abe77065357fd9c8dd6853d8a88a5
  firebase_crashlytics: 6bdf31e8b0bdd8fc4371b2744d39c3b3248f6259
  FirebaseAnalytics: ec00fe8b93b41dc6fe4a28784b8e51da0647a248
  FirebaseCore: 7ec4d0484817f12c3373955bc87762d96842d483
  FirebaseCoreExtension: 705ca5b14bf71d2564a0ddc677df1fc86ffa600f
  FirebaseCoreInternal: df84dd300b561c27d5571684f389bf60b0a5c934
  FirebaseCrashlytics: 4b96efb0ce73b38b2a85e8b8bd1bd8f63f09d015
  FirebaseInstallations: 913cf60d0400ebd5d6b63a28b290372ab44590dd
  FirebaseRemoteConfigInterop: 6efda51fb5e2f15b16585197e26eaa09574e8a4d
  FirebaseSessions: dbd14adac65ce996228652c1fc3a3f576bdf3ecc
  flutter_local_notifications: 453432cd6399a07d072885bc7828fb2307868856
  flutter_secure_storage_macos: 7f45e30f838cf2659862a4e4e3ee1c347c2b3b54
  FlutterMacOS: d0db08ddef1a9af05a5ec4b724367152bb0500b1
  GoogleAppMeasurement: 9abf64b682732fed36da827aa2a68f0221fd2356
  GoogleDataTransport: 6c09b596d841063d76d4288cc2d2f42cc36e1e2a
  GoogleUtilities: ea963c370a38a8069cc5f7ba4ca849a60b6d7d15
  isar_flutter_libs: a65381780401f81ad6bf3f2e7cd0de5698fb98c4
  nanopb: 438bc412db1928dac798aa6fd75726007be04262
  path_provider_foundation: bb55f6dbba17d0dccd6737fe6f7f34fbd0376880
  patrol: 5df5d241d7f95f0df12a6906bbf45acb43a1e537
  PromisesObjC: f5707f49cb48b9636751c5b2e7d227e43fba9f47
  PromisesSwift: 9d77319bbe72ebf6d872900551f7eeba9bce2851
  shared_preferences_foundation: 7036424c3d8ec98dfe75ff1667cb0cd531ec82bb
  webview_flutter_wkwebview: 8ebf4fded22593026f7dbff1fbff31ea98573c8d

PODFILE CHECKSUM: 54d867c82ac51cbd61b565781b9fada492027009

COCOAPODS: 1.16.2
</file>

<file path="test/core/services/secure_storage_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:mocktail/mocktail.dart';
import 'package:n06/core/services/secure_storage_service.dart';

class MockFlutterSecureStorage extends Mock implements FlutterSecureStorage {}

void main() {
  late MockFlutterSecureStorage mockStorage;
  late SecureStorageService service;

  setUp(() {
    mockStorage = MockFlutterSecureStorage();
    service = SecureStorageService(storage: mockStorage);
  });

  group('SecureStorageService', () {
    group('saveAccessToken', () {
      test('should save access token with expiry time', () async {
        // Arrange
        const token = 'test_access_token';
        final expiresAt = DateTime(2025, 1, 1, 12, 0, 0);

        when(() => mockStorage.write(key: any(named: 'key'), value: any(named: 'value')))
            .thenAnswer((_) async => {});

        // Act
        await service.saveAccessToken(token, expiresAt);

        // Assert
        verify(() => mockStorage.write(key: 'ACCESS_TOKEN', value: token)).called(1);
        verify(() => mockStorage.write(
              key: 'ACCESS_TOKEN_EXPIRES_AT',
              value: expiresAt.toIso8601String(),
            )).called(1);
      });
    });

    group('getAccessToken', () {
      test('should return access token if valid', () async {
        // Arrange
        const token = 'test_access_token';
        final expiresAt = DateTime.now().add(const Duration(hours: 1));

        when(() => mockStorage.read(key: 'ACCESS_TOKEN'))
            .thenAnswer((_) async => token);
        when(() => mockStorage.read(key: 'ACCESS_TOKEN_EXPIRES_AT'))
            .thenAnswer((_) async => expiresAt.toIso8601String());

        // Act
        final result = await service.getAccessToken();

        // Assert
        expect(result, token);
      });

      test('should return null when no token exists', () async {
        // Arrange
        when(() => mockStorage.read(key: any(named: 'key')))
            .thenAnswer((_) async => null);

        // Act
        final result = await service.getAccessToken();

        // Assert
        expect(result, isNull);
      });

      test('should return null for expired token', () async {
        // Arrange
        const token = 'test_access_token';
        final expiredTime = DateTime.now().subtract(const Duration(hours: 1));

        when(() => mockStorage.read(key: 'ACCESS_TOKEN'))
            .thenAnswer((_) async => token);
        when(() => mockStorage.read(key: 'ACCESS_TOKEN_EXPIRES_AT'))
            .thenAnswer((_) async => expiredTime.toIso8601String());

        // Act
        final result = await service.getAccessToken();

        // Assert
        expect(result, isNull);
      });
    });

    group('isAccessTokenExpired', () {
      test('should return true when token is expired', () async {
        // Arrange
        final expiredTime = DateTime.now().subtract(const Duration(hours: 1));

        when(() => mockStorage.read(key: 'ACCESS_TOKEN_EXPIRES_AT'))
            .thenAnswer((_) async => expiredTime.toIso8601String());

        // Act
        final result = await service.isAccessTokenExpired();

        // Assert
        expect(result, true);
      });

      test('should return false when token is still valid', () async {
        // Arrange
        final validTime = DateTime.now().add(const Duration(hours: 1));

        when(() => mockStorage.read(key: 'ACCESS_TOKEN_EXPIRES_AT'))
            .thenAnswer((_) async => validTime.toIso8601String());

        // Act
        final result = await service.isAccessTokenExpired();

        // Assert
        expect(result, false);
      });

      test('should return true when no expiry time exists', () async {
        // Arrange
        when(() => mockStorage.read(key: 'ACCESS_TOKEN_EXPIRES_AT'))
            .thenAnswer((_) async => null);

        // Act
        final result = await service.isAccessTokenExpired();

        // Assert
        expect(result, true);
      });
    });

    group('saveRefreshToken', () {
      test('should save refresh token securely', () async {
        // Arrange
        const token = 'test_refresh_token';

        when(() => mockStorage.write(key: any(named: 'key'), value: any(named: 'value')))
            .thenAnswer((_) async => {});

        // Act
        await service.saveRefreshToken(token);

        // Assert
        verify(() => mockStorage.write(key: 'REFRESH_TOKEN', value: token)).called(1);
      });
    });

    group('getRefreshToken', () {
      test('should return refresh token', () async {
        // Arrange
        const token = 'test_refresh_token';

        when(() => mockStorage.read(key: 'REFRESH_TOKEN'))
            .thenAnswer((_) async => token);

        // Act
        final result = await service.getRefreshToken();

        // Assert
        expect(result, token);
      });

      test('should return null when no refresh token exists', () async {
        // Arrange
        when(() => mockStorage.read(key: 'REFRESH_TOKEN'))
            .thenAnswer((_) async => null);

        // Act
        final result = await service.getRefreshToken();

        // Assert
        expect(result, isNull);
      });
    });

    group('deleteAllTokens', () {
      test('should delete all tokens on logout', () async {
        // Arrange
        when(() => mockStorage.delete(key: any(named: 'key')))
            .thenAnswer((_) async => {});

        // Act
        await service.deleteAllTokens();

        // Assert
        verify(() => mockStorage.delete(key: 'ACCESS_TOKEN')).called(1);
        verify(() => mockStorage.delete(key: 'ACCESS_TOKEN_EXPIRES_AT')).called(1);
        verify(() => mockStorage.delete(key: 'REFRESH_TOKEN')).called(1);
      });
    });
  });
}
</file>

<file path="test/fakes/fake_medication_repository.dart">
import 'dart:async';
import 'fake_repository_base.dart';

// TODO: Import actual domain interfaces when they are created
// import 'package:n06/features/tracking/domain/repositories/medication_repository.dart';
// import 'package:n06/features/tracking/domain/entities/dose.dart';

/// Fake implementation of MedicationRepository for testing
///
/// This is a template. Update with actual interface when domain layer is implemented.
///
/// Example usage:
/// ```dart
/// test('should save dose', () async {
///   final repo = FakeMedicationRepository();
///   final dose = Dose(id: 1, doseMg: 0.25, administeredAt: DateTime.now());
///
///   await repo.saveDose(dose);
///
///   expect(await repo.watchDoses().first, contains(dose));
///   repo.dispose();
/// });
/// ```
class FakeMedicationRepository extends FakeRepositoryBase {
  // In-memory storage
  final List<Map<String, dynamic>> _doses = [];
  final List<Map<String, dynamic>> _schedules = [];

  // Simulated errors for testing
  Exception? _nextException;
  bool _shouldDelayOperations = false;
  Duration _operationDelay = const Duration(milliseconds: 100);

  /// Get all doses
  Future<List<Map<String, dynamic>>> getDoses() async {
    _checkException();
    await _simulateDelay();
    return List.from(_doses);
  }

  /// Watch doses as a stream
  Stream<List<Map<String, dynamic>>> watchDoses() {
    return watchData<List<Map<String, dynamic>>>(
      () => List.from(_doses),
      key: 'doses',
    );
  }

  /// Save a new dose
  Future<void> saveDose(Map<String, dynamic> dose) async {
    _checkException();
    await _simulateDelay();

    _doses.add(dose);
    notifyListeners<List<Map<String, dynamic>>>(
      List.from(_doses),
      key: 'doses',
    );
  }

  /// Delete a dose by id
  Future<void> deleteDose(int id) async {
    _checkException();
    await _simulateDelay();

    _doses.removeWhere((dose) => dose['id'] == id);
    notifyListeners<List<Map<String, dynamic>>>(
      List.from(_doses),
      key: 'doses',
    );
  }

  /// Get all schedules
  Future<List<Map<String, dynamic>>> getSchedules() async {
    _checkException();
    await _simulateDelay();
    return List.from(_schedules);
  }

  /// Save schedules
  Future<void> saveSchedules(List<Map<String, dynamic>> schedules) async {
    _checkException();
    await _simulateDelay();

    _schedules.clear();
    _schedules.addAll(schedules);
  }

  /// Clear all data
  void clear() {
    _doses.clear();
    _schedules.clear();
    notifyListeners<List<Map<String, dynamic>>>([], key: 'doses');
  }

  // Test utilities

  /// Simulate an exception on next operation
  void throwOnNextOperation(Exception exception) {
    _nextException = exception;
  }

  /// Enable operation delays (for testing loading states)
  void enableDelays({Duration? delay}) {
    _shouldDelayOperations = true;
    if (delay != null) {
      _operationDelay = delay;
    }
  }

  /// Disable operation delays
  void disableDelays() {
    _shouldDelayOperations = false;
  }

  void _checkException() {
    if (_nextException != null) {
      final exception = _nextException!;
      _nextException = null;
      throw exception;
    }
  }

  Future<void> _simulateDelay() async {
    if (_shouldDelayOperations) {
      await Future.delayed(_operationDelay);
    }
  }
}
</file>

<file path="test/fakes/fake_repository_base.dart">
import 'dart:async';

/// Base class for fake repositories
///
/// Provides common functionality for in-memory repositories
/// used in testing.
///
/// Usage:
/// ```dart
/// class FakeMedicationRepository extends FakeRepositoryBase
///     implements MedicationRepository {
///   final List<Dose> _doses = [];
///
///   @override
///   Stream<List<Dose>> watchDoses() {
///     return watchData<List<Dose>>(() => List.from(_doses));
///   }
/// }
/// ```
abstract class FakeRepositoryBase {
  final _streamControllers = <String, StreamController>{};
  bool _disposed = false;

  /// Watch data changes with a broadcast stream
  ///
  /// [key] - Unique identifier for the stream
  /// [dataGetter] - Function that returns the current data
  Stream<T> watchData<T>(T Function() dataGetter, {String? key}) {
    final streamKey = key ?? T.toString();

    if (!_streamControllers.containsKey(streamKey)) {
      _streamControllers[streamKey] = StreamController<T>.broadcast();
    }

    final controller = _streamControllers[streamKey] as StreamController<T>;

    // Emit initial data
    if (!controller.isClosed) {
      controller.add(dataGetter());
    }

    return controller.stream;
  }

  /// Notify listeners of data change
  ///
  /// [key] - Unique identifier for the stream
  /// [data] - Updated data to emit
  void notifyListeners<T>(T data, {String? key}) {
    if (_disposed) return;

    final streamKey = key ?? T.toString();

    if (_streamControllers.containsKey(streamKey)) {
      final controller = _streamControllers[streamKey] as StreamController<T>;
      if (!controller.isClosed) {
        controller.add(data);
      }
    }
  }

  /// Clean up resources
  void dispose() {
    _disposed = true;
    for (final controller in _streamControllers.values) {
      if (!controller.isClosed) {
        controller.close();
      }
    }
    _streamControllers.clear();
  }

  /// Check if repository is disposed
  bool get isDisposed => _disposed;
}
</file>

<file path="test/features/authentication/domain/entities/consent_record_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/authentication/domain/entities/consent_record.dart';

void main() {
  group('ConsentRecord Entity', () {
    final testDate = DateTime(2025, 1, 1);

    test('should create ConsentRecord with agreement flags', () {
      // Arrange & Act
      final consent = ConsentRecord(
        id: 'consent123',
        userId: 'user123',
        termsOfService: true,
        privacyPolicy: true,
        agreedAt: testDate,
      );

      // Assert
      expect(consent.id, 'consent123');
      expect(consent.userId, 'user123');
      expect(consent.termsOfService, true);
      expect(consent.privacyPolicy, true);
      expect(consent.agreedAt, testDate);
    });

    test('should allow partial consent (false flags)', () {
      // Arrange & Act
      final consent = ConsentRecord(
        id: 'consent124',
        userId: 'user124',
        termsOfService: true,
        privacyPolicy: false,
        agreedAt: testDate,
      );

      // Assert
      expect(consent.termsOfService, true);
      expect(consent.privacyPolicy, false);
    });

    test('should record agreedAt timestamp', () {
      // Arrange
      final agreedTime = DateTime.now();

      // Act
      final consent = ConsentRecord(
        id: 'consent125',
        userId: 'user125',
        termsOfService: true,
        privacyPolicy: true,
        agreedAt: agreedTime,
      );

      // Assert
      expect(consent.agreedAt, agreedTime);
    });

    test('should support copyWith for immutability', () {
      // Arrange
      final consent = ConsentRecord(
        id: 'consent126',
        userId: 'user126',
        termsOfService: false,
        privacyPolicy: false,
        agreedAt: testDate,
      );

      // Act
      final updated = consent.copyWith(
        termsOfService: true,
        privacyPolicy: true,
      );

      // Assert
      expect(updated.id, 'consent126');
      expect(updated.userId, 'user126');
      expect(updated.termsOfService, true);
      expect(updated.privacyPolicy, true);
    });

    test('should support equality comparison', () {
      // Arrange
      final consent1 = ConsentRecord(
        id: 'consent127',
        userId: 'user127',
        termsOfService: true,
        privacyPolicy: true,
        agreedAt: testDate,
      );

      final consent2 = ConsentRecord(
        id: 'consent127',
        userId: 'user127',
        termsOfService: true,
        privacyPolicy: true,
        agreedAt: testDate,
      );

      final consent3 = ConsentRecord(
        id: 'consent128',
        userId: 'user128',
        termsOfService: false,
        privacyPolicy: false,
        agreedAt: testDate,
      );

      // Assert
      expect(consent1, equals(consent2));
      expect(consent1, isNot(equals(consent3)));
    });
  });
}
</file>

<file path="test/features/authentication/domain/entities/user_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/authentication/domain/entities/user.dart';

void main() {
  group('User Entity', () {
    final testDate = DateTime(2025, 1, 1);

    test('should create User with all required fields', () {
      // Arrange & Act
      final user = User(
        id: 'user123',
        oauthProvider: 'kakao',
        oauthUserId: 'kakao_123',
        name: '홍길동',
        email: 'test@example.com',
        lastLoginAt: testDate,
      );

      // Assert
      expect(user.id, 'user123');
      expect(user.oauthProvider, 'kakao');
      expect(user.oauthUserId, 'kakao_123');
      expect(user.name, '홍길동');
      expect(user.email, 'test@example.com');
      expect(user.lastLoginAt, testDate);
    });

    test('should create User with optional profileImageUrl', () {
      // Arrange & Act
      final user = User(
        id: 'user123',
        oauthProvider: 'naver',
        oauthUserId: 'naver_123',
        name: '김철수',
        email: 'test@naver.com',
        profileImageUrl: 'https://example.com/image.jpg',
        lastLoginAt: testDate,
      );

      // Assert
      expect(user.profileImageUrl, 'https://example.com/image.jpg');
    });

    test('should create User with null profileImageUrl', () {
      // Arrange & Act
      final user = User(
        id: 'user123',
        oauthProvider: 'kakao',
        oauthUserId: 'kakao_123',
        name: '홍길동',
        email: 'test@example.com',
        lastLoginAt: testDate,
      );

      // Assert
      expect(user.profileImageUrl, isNull);
    });

    test('should support copyWith for immutability', () {
      // Arrange
      final user = User(
        id: 'user123',
        oauthProvider: 'kakao',
        oauthUserId: 'kakao_123',
        name: '홍길동',
        email: 'test@example.com',
        lastLoginAt: testDate,
      );

      // Act
      final updatedUser = user.copyWith(
        name: '홍길순',
        profileImageUrl: 'https://example.com/new.jpg',
      );

      // Assert
      expect(updatedUser.id, 'user123');
      expect(updatedUser.name, '홍길순');
      expect(updatedUser.profileImageUrl, 'https://example.com/new.jpg');
      expect(updatedUser.email, 'test@example.com');
    });

    test('should support equality comparison', () {
      // Arrange
      final user1 = User(
        id: 'user123',
        oauthProvider: 'kakao',
        oauthUserId: 'kakao_123',
        name: '홍길동',
        email: 'test@example.com',
        lastLoginAt: testDate,
      );

      final user2 = User(
        id: 'user123',
        oauthProvider: 'kakao',
        oauthUserId: 'kakao_123',
        name: '홍길동',
        email: 'test@example.com',
        lastLoginAt: testDate,
      );

      final user3 = User(
        id: 'user456',
        oauthProvider: 'naver',
        oauthUserId: 'naver_456',
        name: '김철수',
        email: 'other@example.com',
        lastLoginAt: testDate,
      );

      // Assert
      expect(user1, equals(user2));
      expect(user1, isNot(equals(user3)));
    });

    test('should have same hashCode for equal users', () {
      // Arrange
      final user1 = User(
        id: 'user123',
        oauthProvider: 'kakao',
        oauthUserId: 'kakao_123',
        name: '홍길동',
        email: 'test@example.com',
        lastLoginAt: testDate,
      );

      final user2 = User(
        id: 'user123',
        oauthProvider: 'kakao',
        oauthUserId: 'kakao_123',
        name: '홍길동',
        email: 'test@example.com',
        lastLoginAt: testDate,
      );

      // Assert
      expect(user1.hashCode, equals(user2.hashCode));
    });
  });
}
</file>

<file path="test/features/authentication/domain/repositories/secure_storage_repository_test.dart">
import 'package:flutter_test/flutter_test.dart';

void main() {
  group('SecureStorageRepository Interface', () {
    test('should define clearTokens method', () {
      // This test verifies that the interface exists
      // The actual implementation will be tested separately
      expect(true, true);
    });

    test('should define getAccessToken method', () {
      expect(true, true);
    });

    test('should define getRefreshToken method', () {
      expect(true, true);
    });

    test('should define getTokenExpiresAt method', () {
      expect(true, true);
    });
  });
}
</file>

<file path="test/features/authentication/domain/usecases/logout_usecase_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:n06/features/authentication/domain/repositories/auth_repository.dart';
import 'package:n06/features/authentication/domain/repositories/secure_storage_repository.dart';
import 'package:n06/features/authentication/domain/usecases/logout_usecase.dart';

class MockSecureStorageRepository extends Mock
    implements SecureStorageRepository {}

class MockAuthRepository extends Mock implements AuthRepository {}

void main() {
  late MockSecureStorageRepository mockStorageRepo;
  late MockAuthRepository mockAuthRepo;
  late LogoutUseCase useCase;

  setUp(() {
    mockStorageRepo = MockSecureStorageRepository();
    mockAuthRepo = MockAuthRepository();
    useCase = LogoutUseCase(
      storageRepository: mockStorageRepo,
      authRepository: mockAuthRepo,
    );
  });

  group('LogoutUseCase', () {
    group('execute', () {
      test('should clear tokens from secure storage', () async {
        // Arrange
        when(() => mockStorageRepo.clearTokens()).thenAnswer(
          (_) => Future.value(),
        );
        when(() => mockAuthRepo.logout()).thenAnswer(
          (_) => Future.value(),
        );

        // Act
        await useCase.execute();

        // Assert
        verify(() => mockStorageRepo.clearTokens()).called(1);
      });

      test('should clear session from auth repository', () async {
        // Arrange
        when(() => mockStorageRepo.clearTokens()).thenAnswer(
          (_) => Future.value(),
        );
        when(() => mockAuthRepo.logout()).thenAnswer(
          (_) => Future.value(),
        );

        // Act
        await useCase.execute();

        // Assert
        verify(() => mockAuthRepo.logout()).called(1);
      });

      test('should call clearTokens before logout', () async {
        // Arrange
        final callOrder = <String>[];

        when(() => mockStorageRepo.clearTokens()).thenAnswer((_) {
          callOrder.add('clearTokens');
          return Future.value();
        });

        when(() => mockAuthRepo.logout()).thenAnswer((_) {
          callOrder.add('logout');
          return Future.value();
        });

        // Act
        await useCase.execute();

        // Assert
        expect(callOrder[0], 'clearTokens');
        expect(callOrder[1], 'logout');
      });

      test('should retry token deletion up to 3 times on failure', () async {
        // Arrange
        var attempt = 0;
        when(() => mockStorageRepo.clearTokens()).thenAnswer((_) {
          attempt++;
          if (attempt < 3) {
            throw Exception('Storage error');
          }
          return Future.value();
        });

        when(() => mockAuthRepo.logout()).thenAnswer(
          (_) => Future.value(),
        );

        // Act
        await useCase.execute();

        // Assert
        expect(attempt, 3);
      });

      test('should clear session even if token deletion fails after 3 retries',
          () async {
        // Arrange
        when(() => mockStorageRepo.clearTokens()).thenThrow(
          Exception('Storage error'),
        );

        when(() => mockAuthRepo.logout()).thenAnswer(
          (_) => Future.value(),
        );

        // Act
        await useCase.execute();

        // Assert
        verify(() => mockAuthRepo.logout()).called(1);
      });

      test('should clear all tokens without touching Isar database', () async {
        // Arrange
        when(() => mockStorageRepo.clearTokens()).thenAnswer(
          (_) => Future.value(),
        );
        when(() => mockAuthRepo.logout()).thenAnswer(
          (_) => Future.value(),
        );

        // Act
        await useCase.execute();

        // Assert
        // Verify that only storageRepository.clearTokens and authRepository.logout are called
        verify(() => mockStorageRepo.clearTokens()).called(1);
        verify(() => mockAuthRepo.logout()).called(1);
        verifyNoMoreInteractions(mockStorageRepo);
        verifyNoMoreInteractions(mockAuthRepo);
      });

      test('should complete successfully when all operations succeed', () async {
        // Arrange
        when(() => mockStorageRepo.clearTokens()).thenAnswer(
          (_) => Future.value(),
        );
        when(() => mockAuthRepo.logout()).thenAnswer(
          (_) => Future.value(),
        );

        // Act & Assert
        expect(useCase.execute(), completes);
      });

      test('should throw exception if logout fails after tokens are cleared',
          () async {
        // Arrange
        when(() => mockStorageRepo.clearTokens()).thenAnswer(
          (_) => Future.value(),
        );
        when(() => mockAuthRepo.logout()).thenThrow(
          Exception('Logout error'),
        );

        // Act & Assert
        expect(() => useCase.execute(), throwsException);
      });

      test('should handle network errors gracefully', () async {
        // Arrange
        when(() => mockStorageRepo.clearTokens()).thenAnswer(
          (_) => Future.value(),
        );
        when(() => mockAuthRepo.logout()).thenThrow(
          Exception('Network error'),
        );

        // Act & Assert
        expect(() => useCase.execute(), throwsException);
      });

      test('should succeed if token clearing fails but logout succeeds',
          () async {
        // Arrange
        var attempt = 0;
        when(() => mockStorageRepo.clearTokens()).thenAnswer((_) {
          attempt++;
          if (attempt < 3) {
            throw Exception('Storage error');
          }
          return Future.value();
        });

        when(() => mockAuthRepo.logout()).thenAnswer(
          (_) => Future.value(),
        );

        // Act & Assert
        expect(useCase.execute(), completes);
      });
    });
  });
}
</file>

<file path="test/features/authentication/infrastructure/datasources/kakao_auth_datasource_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/authentication/infrastructure/datasources/kakao_auth_datasource.dart';

// Note: These tests are integration-style tests that verify the data source logic.
// Actual SDK calls would be mocked or tested in integration tests with real SDK.

void main() {
  group('KakaoAuthDataSource', () {
    late KakaoAuthDataSource dataSource;

    setUp(() {
      dataSource = KakaoAuthDataSource();
    });

    group('login', () {
      test('should define login method that returns OAuthToken', () {
        // This test verifies the method signature exists
        expect(dataSource.login, isA<Function>());
      });

      test('should define logout method', () {
        // This test verifies the method signature exists
        expect(dataSource.logout, isA<Function>());
      });

      test('should define getUser method that returns User', () {
        // This test verifies the method signature exists
        expect(dataSource.getUser, isA<Function>());
      });

      test('should define isTokenValid method that returns bool', () {
        // This test verifies the method signature exists
        expect(dataSource.isTokenValid, isA<Function>());
      });
    });

    group('implementation details', () {
      test('should have correct method signatures', () {
        // Verify that the class implements the expected interface
        expect(dataSource, isA<KakaoAuthDataSource>());
      });
    });
  });
}
</file>

<file path="test/features/authentication/infrastructure/datasources/naver_auth_datasource_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/authentication/infrastructure/datasources/naver_auth_datasource.dart';

void main() {
  group('NaverAuthDataSource', () {
    late NaverAuthDataSource dataSource;

    setUp(() {
      dataSource = NaverAuthDataSource();
    });

    group('method signatures', () {
      test('should define login method', () {
        expect(dataSource.login, isA<Function>());
      });

      test('should define logout method', () {
        expect(dataSource.logout, isA<Function>());
      });

      test('should define getUser method', () {
        expect(dataSource.getUser, isA<Function>());
      });

      test('should define getCurrentToken method', () {
        expect(dataSource.getCurrentToken, isA<Function>());
      });
    });

    group('implementation', () {
      test('should be instance of NaverAuthDataSource', () {
        expect(dataSource, isA<NaverAuthDataSource>());
      });
    });
  });
}
</file>

<file path="test/features/authentication/infrastructure/dtos/consent_record_dto_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/authentication/domain/entities/consent_record.dart';
import 'package:n06/features/authentication/infrastructure/dtos/consent_record_dto.dart';

void main() {
  group('ConsentRecordDto', () {
    group('toEntity', () {
      test('should convert ConsentRecordDto to ConsentRecord entity', () {
        // Arrange
        final dto = ConsentRecordDto()
          ..id = 123
          ..userId = 'user123'
          ..termsOfService = true
          ..privacyPolicy = true
          ..agreedAt = DateTime(2025, 1, 1);

        // Act
        final entity = dto.toEntity();

        // Assert
        expect(entity.id, '123');
        expect(entity.userId, 'user123');
        expect(entity.termsOfService, true);
        expect(entity.privacyPolicy, true);
        expect(entity.agreedAt, DateTime(2025, 1, 1));
      });

      test('should allow partial consent (false flags)', () {
        // Arrange
        final dto = ConsentRecordDto()
          ..id = 456
          ..userId = 'user123'
          ..termsOfService = true
          ..privacyPolicy = false
          ..agreedAt = DateTime(2025, 1, 1);

        // Act
        final entity = dto.toEntity();

        // Assert
        expect(entity.termsOfService, true);
        expect(entity.privacyPolicy, false);
      });
    });

    group('fromEntity', () {
      test('should convert ConsentRecord entity to ConsentRecordDto', () {
        // Arrange
        final entity = ConsentRecord(
          id: '789',
          userId: 'user123',
          termsOfService: true,
          privacyPolicy: true,
          agreedAt: DateTime(2025, 1, 1),
        );

        // Act
        final dto = ConsentRecordDto.fromEntity(entity);

        // Assert
        expect(dto.id, 789);
        expect(dto.userId, 'user123');
        expect(dto.termsOfService, true);
        expect(dto.privacyPolicy, true);
        expect(dto.agreedAt, DateTime(2025, 1, 1));
      });

      test('should allow partial consent (false flags)', () {
        // Arrange
        final entity = ConsentRecord(
          id: '999',
          userId: 'user123',
          termsOfService: true,
          privacyPolicy: false,
          agreedAt: DateTime(2025, 1, 1),
        );

        // Act
        final dto = ConsentRecordDto.fromEntity(entity);

        // Assert
        expect(dto.id, 999);
        expect(dto.termsOfService, true);
        expect(dto.privacyPolicy, false);
      });
    });
  });
}
</file>

<file path="test/features/authentication/infrastructure/dtos/user_dto_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/authentication/domain/entities/user.dart';
import 'package:n06/features/authentication/infrastructure/dtos/user_dto.dart';

void main() {
  group('UserDto', () {
    group('toEntity', () {
      test('should convert UserDto to User entity', () {
        // Arrange
        final dto = UserDto()
          ..id = 123
          ..oauthProvider = 'kakao'
          ..oauthUserId = 'kakao_123'
          ..name = '홍길동'
          ..email = 'test@example.com'
          ..profileImageUrl = 'https://example.com/image.jpg'
          ..lastLoginAt = DateTime(2025, 1, 1);

        // Act
        final entity = dto.toEntity();

        // Assert
        expect(entity.id, '123');
        expect(entity.oauthProvider, 'kakao');
        expect(entity.oauthUserId, 'kakao_123');
        expect(entity.name, '홍길동');
        expect(entity.email, 'test@example.com');
        expect(entity.profileImageUrl, 'https://example.com/image.jpg');
        expect(entity.lastLoginAt, DateTime(2025, 1, 1));
      });

      test('should handle null profileImageUrl', () {
        // Arrange
        final dto = UserDto()
          ..id = 123
          ..oauthProvider = 'kakao'
          ..oauthUserId = 'kakao_123'
          ..name = '홍길동'
          ..email = 'test@example.com'
          ..profileImageUrl = null
          ..lastLoginAt = DateTime(2025, 1, 1);

        // Act
        final entity = dto.toEntity();

        // Assert
        expect(entity.profileImageUrl, isNull);
      });
    });

    group('fromEntity', () {
      test('should convert User entity to UserDto', () {
        // Arrange
        final entity = User(
          id: '123',
          oauthProvider: 'kakao',
          oauthUserId: 'kakao_123',
          name: '홍길동',
          email: 'test@example.com',
          profileImageUrl: 'https://example.com/image.jpg',
          lastLoginAt: DateTime(2025, 1, 1),
        );

        // Act
        final dto = UserDto.fromEntity(entity);

        // Assert
        expect(dto.id, 123);
        expect(dto.oauthProvider, 'kakao');
        expect(dto.oauthUserId, 'kakao_123');
        expect(dto.name, '홍길동');
        expect(dto.email, 'test@example.com');
        expect(dto.profileImageUrl, 'https://example.com/image.jpg');
        expect(dto.lastLoginAt, DateTime(2025, 1, 1));
      });

      test('should handle null profileImageUrl', () {
        // Arrange
        final entity = User(
          id: '456',
          oauthProvider: 'kakao',
          oauthUserId: 'kakao_123',
          name: '홍길동',
          email: 'test@example.com',
          profileImageUrl: null,
          lastLoginAt: DateTime(2025, 1, 1),
        );

        // Act
        final dto = UserDto.fromEntity(entity);

        // Assert
        expect(dto.id, 456);
        expect(dto.profileImageUrl, isNull);
      });
    });
  });
}
</file>

<file path="test/features/authentication/infrastructure/repositories/flutter_secure_storage_repository_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:n06/features/authentication/infrastructure/repositories/flutter_secure_storage_repository.dart';

class MockFlutterSecureStorage extends Mock implements FlutterSecureStorage {}

void main() {
  late MockFlutterSecureStorage mockStorage;
  late FlutterSecureStorageRepository repository;

  setUp(() {
    mockStorage = MockFlutterSecureStorage();
    repository = FlutterSecureStorageRepository(mockStorage);
  });

  group('FlutterSecureStorageRepository', () {
    group('clearTokens', () {
      test('should delete accessToken when clearTokens is called', () async {
        // Arrange
        when(() => mockStorage.delete(key: 'ACCESS_TOKEN')).thenAnswer(
          (_) => Future.value(),
        );
        when(() => mockStorage.delete(key: 'REFRESH_TOKEN')).thenAnswer(
          (_) => Future.value(),
        );
        when(() => mockStorage.delete(key: 'TOKEN_EXPIRES_AT')).thenAnswer(
          (_) => Future.value(),
        );

        // Act
        await repository.clearTokens();

        // Assert
        verify(() => mockStorage.delete(key: 'ACCESS_TOKEN')).called(1);
      });

      test('should delete refreshToken when clearTokens is called', () async {
        // Arrange
        when(() => mockStorage.delete(key: 'ACCESS_TOKEN')).thenAnswer(
          (_) => Future.value(),
        );
        when(() => mockStorage.delete(key: 'REFRESH_TOKEN')).thenAnswer(
          (_) => Future.value(),
        );
        when(() => mockStorage.delete(key: 'TOKEN_EXPIRES_AT')).thenAnswer(
          (_) => Future.value(),
        );

        // Act
        await repository.clearTokens();

        // Assert
        verify(() => mockStorage.delete(key: 'REFRESH_TOKEN')).called(1);
      });

      test('should delete tokenExpiresAt when clearTokens is called', () async {
        // Arrange
        when(() => mockStorage.delete(key: 'ACCESS_TOKEN')).thenAnswer(
          (_) => Future.value(),
        );
        when(() => mockStorage.delete(key: 'REFRESH_TOKEN')).thenAnswer(
          (_) => Future.value(),
        );
        when(() => mockStorage.delete(key: 'TOKEN_EXPIRES_AT')).thenAnswer(
          (_) => Future.value(),
        );

        // Act
        await repository.clearTokens();

        // Assert
        verify(() => mockStorage.delete(key: 'TOKEN_EXPIRES_AT')).called(1);
      });

      test('should throw exception when delete fails', () async {
        // Arrange
        when(() => mockStorage.delete(key: any(named: 'key'))).thenThrow(
          Exception('Storage access error'),
        );

        // Act & Assert
        expect(
          () => repository.clearTokens(),
          throwsException,
        );
      });

      test('should delete all tokens in correct order', () async {
        // Arrange
        final callOrder = <String>[];

        when(() => mockStorage.delete(key: 'ACCESS_TOKEN')).thenAnswer((_) {
          callOrder.add('ACCESS_TOKEN');
          return Future.value();
        });

        when(() => mockStorage.delete(key: 'REFRESH_TOKEN')).thenAnswer((_) {
          callOrder.add('REFRESH_TOKEN');
          return Future.value();
        });

        when(() => mockStorage.delete(key: 'TOKEN_EXPIRES_AT')).thenAnswer((_) {
          callOrder.add('TOKEN_EXPIRES_AT');
          return Future.value();
        });

        // Act
        await repository.clearTokens();

        // Assert
        expect(callOrder.length, 3);
        expect(callOrder.contains('ACCESS_TOKEN'), true);
        expect(callOrder.contains('REFRESH_TOKEN'), true);
        expect(callOrder.contains('TOKEN_EXPIRES_AT'), true);
      });
    });

    group('getAccessToken', () {
      test('should return access token when it exists and is valid', () async {
        // Arrange
        const token = 'test_token_123';
        when(() => mockStorage.read(key: 'ACCESS_TOKEN')).thenAnswer(
          (_) => Future.value(token),
        );
        when(() => mockStorage.read(key: 'TOKEN_EXPIRES_AT')).thenAnswer(
          (_) => Future.value(
            DateTime.now().add(const Duration(hours: 1)).toIso8601String(),
          ),
        );

        // Act
        final result = await repository.getAccessToken();

        // Assert
        expect(result, token);
      });

      test('should return null when token does not exist', () async {
        // Arrange
        when(() => mockStorage.read(key: 'ACCESS_TOKEN')).thenAnswer(
          (_) => Future.value(null),
        );

        // Act
        final result = await repository.getAccessToken();

        // Assert
        expect(result, null);
      });

      test('should return null when token is expired', () async {
        // Arrange
        const token = 'test_token_123';
        when(() => mockStorage.read(key: 'ACCESS_TOKEN')).thenAnswer(
          (_) => Future.value(token),
        );
        when(() => mockStorage.read(key: 'TOKEN_EXPIRES_AT')).thenAnswer(
          (_) => Future.value(
            DateTime.now().subtract(const Duration(hours: 1)).toIso8601String(),
          ),
        );

        // Act
        final result = await repository.getAccessToken();

        // Assert
        expect(result, null);
      });
    });

    group('getRefreshToken', () {
      test('should return refresh token when it exists', () async {
        // Arrange
        const token = 'refresh_token_123';
        when(() => mockStorage.read(key: 'REFRESH_TOKEN')).thenAnswer(
          (_) => Future.value(token),
        );

        // Act
        final result = await repository.getRefreshToken();

        // Assert
        expect(result, token);
      });

      test('should return null when refresh token does not exist', () async {
        // Arrange
        when(() => mockStorage.read(key: 'REFRESH_TOKEN')).thenAnswer(
          (_) => Future.value(null),
        );

        // Act
        final result = await repository.getRefreshToken();

        // Assert
        expect(result, null);
      });
    });

    group('isAccessTokenExpired', () {
      test('should return false when token is not expired', () async {
        // Arrange
        when(() => mockStorage.read(key: 'TOKEN_EXPIRES_AT')).thenAnswer(
          (_) => Future.value(
            DateTime.now().add(const Duration(hours: 1)).toIso8601String(),
          ),
        );

        // Act
        final result = await repository.isAccessTokenExpired();

        // Assert
        expect(result, false);
      });

      test('should return true when token is expired', () async {
        // Arrange
        when(() => mockStorage.read(key: 'TOKEN_EXPIRES_AT')).thenAnswer(
          (_) => Future.value(
            DateTime.now().subtract(const Duration(hours: 1)).toIso8601String(),
          ),
        );

        // Act
        final result = await repository.isAccessTokenExpired();

        // Assert
        expect(result, true);
      });

      test('should return true when expiry time does not exist', () async {
        // Arrange
        when(() => mockStorage.read(key: 'TOKEN_EXPIRES_AT')).thenAnswer(
          (_) => Future.value(null),
        );

        // Act
        final result = await repository.isAccessTokenExpired();

        // Assert
        expect(result, true);
      });
    });

    group('saveAccessToken', () {
      test('should save access token with expiry time', () async {
        // Arrange
        const token = 'new_token_123';
        final expiresAt = DateTime.now().add(const Duration(hours: 2));

        when(() => mockStorage.write(
          key: 'ACCESS_TOKEN',
          value: token,
        )).thenAnswer((_) => Future.value());

        when(() => mockStorage.write(
          key: 'TOKEN_EXPIRES_AT',
          value: any(named: 'value'),
        )).thenAnswer((_) => Future.value());

        // Act
        await repository.saveAccessToken(token, expiresAt);

        // Assert
        verify(() => mockStorage.write(
          key: 'ACCESS_TOKEN',
          value: token,
        )).called(1);

        verify(() => mockStorage.write(
          key: 'TOKEN_EXPIRES_AT',
          value: any(named: 'value'),
        )).called(1);
      });
    });

    group('saveRefreshToken', () {
      test('should save refresh token', () async {
        // Arrange
        const token = 'refresh_token_123';

        when(() => mockStorage.write(
          key: 'REFRESH_TOKEN',
          value: token,
        )).thenAnswer((_) => Future.value());

        // Act
        await repository.saveRefreshToken(token);

        // Assert
        verify(() => mockStorage.write(
          key: 'REFRESH_TOKEN',
          value: token,
        )).called(1);
      });
    });

    group('getTokenExpiresAt', () {
      test('should return expiry time when it exists', () async {
        // Arrange
        final expiresAt = DateTime.now().add(const Duration(hours: 1));
        when(() => mockStorage.read(key: 'TOKEN_EXPIRES_AT')).thenAnswer(
          (_) => Future.value(expiresAt.toIso8601String()),
        );

        // Act
        final result = await repository.getTokenExpiresAt();

        // Assert
        expect(result, isNotNull);
        expect(result!.difference(expiresAt).inSeconds.abs(), lessThan(1));
      });

      test('should return null when expiry time does not exist', () async {
        // Arrange
        when(() => mockStorage.read(key: 'TOKEN_EXPIRES_AT')).thenAnswer(
          (_) => Future.value(null),
        );

        // Act
        final result = await repository.getTokenExpiresAt();

        // Assert
        expect(result, null);
      });
    });
  });
}
</file>

<file path="test/features/authentication/presentation/widgets/logout_confirm_dialog_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/authentication/presentation/widgets/logout_confirm_dialog.dart';

void main() {
  group('LogoutConfirmDialog', () {
    testWidgets('should display confirmation message', (WidgetTester tester) async {
      // Arrange
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: Center(
              child: LogoutConfirmDialog(
                onConfirm: () {},
              ),
            ),
          ),
        ),
      );

      // Act & Assert
      expect(find.text('로그아웃하시겠습니까?'), findsOneWidget);
    });

    testWidgets('should display title', (WidgetTester tester) async {
      // Arrange
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: Center(
              child: LogoutConfirmDialog(
                onConfirm: () {},
              ),
            ),
          ),
        ),
      );

      // Act & Assert
      expect(find.text('로그아웃'), findsOneWidget);
    });

    testWidgets('should display confirm button', (WidgetTester tester) async {
      // Arrange
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: Center(
              child: LogoutConfirmDialog(
                onConfirm: () {},
              ),
            ),
          ),
        ),
      );

      // Act & Assert
      expect(find.text('확인'), findsOneWidget);
    });

    testWidgets('should display cancel button', (WidgetTester tester) async {
      // Arrange
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: Center(
              child: LogoutConfirmDialog(
                onConfirm: () {},
              ),
            ),
          ),
        ),
      );

      // Act & Assert
      expect(find.text('취소'), findsOneWidget);
    });

    testWidgets('should call onConfirm when confirm button tapped',
        (WidgetTester tester) async {
      // Arrange
      bool confirmCalled = false;
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: Center(
              child: LogoutConfirmDialog(
                onConfirm: () {
                  confirmCalled = true;
                },
              ),
            ),
          ),
        ),
      );

      // Act
      await tester.tap(find.text('확인'));
      await tester.pumpAndSettle();

      // Assert
      expect(confirmCalled, true);
    });

    testWidgets('should pop dialog when cancel button tapped',
        (WidgetTester tester) async {
      // Arrange
      bool cancelCalled = false;
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: Center(
              child: LogoutConfirmDialog(
                onConfirm: () {},
                onCancel: () {
                  cancelCalled = true;
                },
              ),
            ),
          ),
        ),
      );

      // Act
      await tester.tap(find.text('취소'));
      await tester.pumpAndSettle();

      // Assert
      expect(cancelCalled, true);
    });

    testWidgets('should not call onConfirm when cancel is tapped',
        (WidgetTester tester) async {
      // Arrange
      bool confirmCalled = false;
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: Center(
              child: LogoutConfirmDialog(
                onConfirm: () {
                  confirmCalled = true;
                },
              ),
            ),
          ),
        ),
      );

      // Act
      await tester.tap(find.text('취소'));
      await tester.pumpAndSettle();

      // Assert
      expect(confirmCalled, false);
    });
  });
}
</file>

<file path="test/features/coping_guide/application/notifiers/coping_guide_notifier_test.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:n06/features/coping_guide/application/notifiers/coping_guide_notifier.dart';
import 'package:n06/features/coping_guide/application/providers.dart';
import 'package:n06/features/coping_guide/domain/entities/coping_guide.dart';
import 'package:n06/features/coping_guide/domain/entities/guide_feedback.dart';
import 'package:n06/features/coping_guide/domain/repositories/coping_guide_repository.dart';
import 'package:n06/features/coping_guide/domain/repositories/feedback_repository.dart';

class MockCopingGuideRepository extends Mock implements CopingGuideRepository {}

class MockFeedbackRepository extends Mock implements FeedbackRepository {}

class FakeGuideFeedback extends Fake implements GuideFeedback {
  @override
  final String symptomName = '메스꺼움';

  @override
  final bool helpful = true;

  @override
  final DateTime timestamp = DateTime.now();
}

void main() {
  setUpAll(() {
    registerFallbackValue(FakeGuideFeedback());
  });
  group('CopingGuideNotifier', () {
    late ProviderContainer container;
    late MockCopingGuideRepository mockGuideRepo;
    late MockFeedbackRepository mockFeedbackRepo;

    setUp(() {
      mockGuideRepo = MockCopingGuideRepository();
      mockFeedbackRepo = MockFeedbackRepository();

      container = ProviderContainer(
        overrides: [
          copingGuideRepositoryProvider.overrideWithValue(mockGuideRepo),
          feedbackRepositoryProvider.overrideWithValue(mockFeedbackRepo),
        ],
      );
    });

    tearDown(() {
      container.dispose();
    });

    test('증상명으로 가이드 조회 성공', () async {
      // Arrange
      final expectedGuide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '소량씩 자주 식사하세요',
      );
      when(() => mockGuideRepo.getGuideBySymptom('메스꺼움'))
          .thenAnswer((_) async => expectedGuide);

      // Act
      final notifier = container.read(copingGuideNotifierProvider.notifier);
      await notifier.getGuideBySymptom('메스꺼움');

      // Assert
      final state = container.read(copingGuideNotifierProvider);
      expect(state.value!.guide, expectedGuide);
      verify(() => mockGuideRepo.getGuideBySymptom('메스꺼움')).called(1);
    });

    test('등록되지 않은 증상은 기본 가이드 반환', () async {
      // Arrange
      when(() => mockGuideRepo.getGuideBySymptom('알 수 없는 증상'))
          .thenAnswer((_) async => null);

      // Act
      final notifier = container.read(copingGuideNotifierProvider.notifier);
      await notifier.getGuideBySymptom('알 수 없는 증상');

      // Assert
      final state = container.read(copingGuideNotifierProvider);
      expect(state.value, isNotNull);
      expect(state.value!.guide.symptomName, '일반');
      expect(state.value!.guide.shortGuide, contains('전문가'));
    });

    test('모든 가이드 목록 조회', () async {
      // Arrange
      final expectedGuides = [
        CopingGuide(symptomName: '메스꺼움', shortGuide: '...'),
        CopingGuide(symptomName: '구토', shortGuide: '...'),
      ];
      when(() => mockGuideRepo.getAllGuides())
          .thenAnswer((_) async => expectedGuides);

      // Act
      final notifier = container.read(copingGuideListNotifierProvider.notifier);
      await notifier.loadAllGuides();

      // Assert
      final state = container.read(copingGuideListNotifierProvider);
      expect(state.value, expectedGuides);
      expect(state.value!.length, 2);
    });

    test('심각도 7-10점, 24시간 이상 지속 시 경고 플래그 활성화', () async {
      // Arrange
      final expectedGuide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '소량씩 자주 식사하세요',
      );
      when(() => mockGuideRepo.getGuideBySymptom('메스꺼움'))
          .thenAnswer((_) async => expectedGuide);

      // Act
      final notifier = container.read(copingGuideNotifierProvider.notifier);
      await notifier.checkSeverityAndGuide('메스꺼움', 8, true);

      // Assert
      final state = container.read(copingGuideNotifierProvider);
      expect(state.value!.guide, expectedGuide);
      expect(state.value!.showSeverityWarning, isTrue);
    });

    test('심각도 6점 이하는 경고 플래그 비활성화', () async {
      // Arrange
      final expectedGuide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '소량씩 자주 식사하세요',
      );
      when(() => mockGuideRepo.getGuideBySymptom('메스꺼움'))
          .thenAnswer((_) async => expectedGuide);

      // Act
      final notifier = container.read(copingGuideNotifierProvider.notifier);
      await notifier.checkSeverityAndGuide('메스꺼움', 5, true);

      // Assert
      final state = container.read(copingGuideNotifierProvider);
      expect(state.value!.showSeverityWarning, isFalse);
    });

    test('24시간 미만 지속은 경고 플래그 비활성화', () async {
      // Arrange
      final expectedGuide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '소량씩 자주 식사하세요',
      );
      when(() => mockGuideRepo.getGuideBySymptom('메스꺼움'))
          .thenAnswer((_) async => expectedGuide);

      // Act
      final notifier = container.read(copingGuideNotifierProvider.notifier);
      await notifier.checkSeverityAndGuide('메스꺼움', 8, false);

      // Assert
      final state = container.read(copingGuideNotifierProvider);
      expect(state.value!.showSeverityWarning, isFalse);
    });

    test('피드백 제출 및 저장', () async {
      // Arrange
      when(() => mockFeedbackRepo.saveFeedback(any()))
          .thenAnswer((_) async => {});

      // Act
      final notifier = container.read(copingGuideNotifierProvider.notifier);
      await notifier.submitFeedback('메스꺼움', helpful: true);

      // Assert
      verify(() => mockFeedbackRepo.saveFeedback(any())).called(1);
    });
  });
}
</file>

<file path="test/features/coping_guide/domain/entities/coping_guide_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/coping_guide/domain/entities/coping_guide.dart';
import 'package:n06/features/coping_guide/domain/entities/guide_section.dart';
import 'package:n06/features/coping_guide/domain/entities/guide_feedback.dart';
import 'package:n06/features/coping_guide/domain/entities/coping_guide_state.dart';

void main() {
  group('CopingGuide', () {
    test('증상명과 간단 가이드로 생성 가능', () {
      // Arrange & Act
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '소량씩 자주 식사하세요',
      );

      // Assert
      expect(guide.symptomName, '메스꺼움');
      expect(guide.shortGuide, '소량씩 자주 식사하세요');
    });

    test('상세 가이드 섹션 리스트를 포함할 수 있음', () {
      // Arrange
      final sections = [
        GuideSection(title: '즉시 조치', content: '물 마시기'),
        GuideSection(title: '식이 조절', content: '기름진 음식 피하기'),
      ];

      // Act
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '소량씩 자주 식사하세요',
        detailedSections: sections,
      );

      // Assert
      expect(guide.detailedSections, sections);
      expect(guide.detailedSections?.length, 2);
    });

    test('equality 비교 가능', () {
      // Arrange
      final guide1 = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '소량씩 자주 식사하세요',
      );
      final guide2 = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '소량씩 자주 식사하세요',
      );

      // Assert
      expect(guide1, guide2);
    });
  });

  group('GuideSection', () {
    test('제목과 내용으로 생성 가능', () {
      // Arrange & Act
      final section = GuideSection(
        title: '즉시 조치',
        content: '물을 천천히 마시세요',
      );

      // Assert
      expect(section.title, '즉시 조치');
      expect(section.content, '물을 천천히 마시세요');
    });

    test('equality 비교 가능', () {
      // Arrange
      final section1 = GuideSection(
        title: '즉시 조치',
        content: '물을 천천히 마시세요',
      );
      final section2 = GuideSection(
        title: '즉시 조치',
        content: '물을 천천히 마시세요',
      );

      // Assert
      expect(section1, section2);
    });
  });

  group('GuideFeedback', () {
    test('증상명, 도움 여부, 타임스탬프로 생성 가능', () {
      // Arrange
      final timestamp = DateTime(2025, 1, 1);

      // Act
      final feedback = GuideFeedback(
        symptomName: '메스꺼움',
        helpful: true,
        timestamp: timestamp,
      );

      // Assert
      expect(feedback.symptomName, '메스꺼움');
      expect(feedback.helpful, isTrue);
      expect(feedback.timestamp, timestamp);
    });

    test('equality 비교 가능', () {
      // Arrange
      final timestamp = DateTime(2025, 1, 1);
      final feedback1 = GuideFeedback(
        symptomName: '메스꺼움',
        helpful: true,
        timestamp: timestamp,
      );
      final feedback2 = GuideFeedback(
        symptomName: '메스꺼움',
        helpful: true,
        timestamp: timestamp,
      );

      // Assert
      expect(feedback1, feedback2);
    });
  });

  group('CopingGuideState', () {
    test('가이드와 심각도 경고 플래그로 생성 가능', () {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '소량씩 자주 식사하세요',
      );

      // Act
      final state = CopingGuideState(
        guide: guide,
        showSeverityWarning: true,
      );

      // Assert
      expect(state.guide, guide);
      expect(state.showSeverityWarning, isTrue);
    });

    test('기본값: showSeverityWarning은 false', () {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '소량씩 자주 식사하세요',
      );

      // Act
      final state = CopingGuideState(guide: guide);

      // Assert
      expect(state.showSeverityWarning, isFalse);
    });

    test('equality 비교 가능', () {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '소량씩 자주 식사하세요',
      );
      final state1 = CopingGuideState(
        guide: guide,
        showSeverityWarning: true,
      );
      final state2 = CopingGuideState(
        guide: guide,
        showSeverityWarning: true,
      );

      // Assert
      expect(state1, state2);
    });
  });
}
</file>

<file path="test/features/coping_guide/infrastructure/dtos/guide_feedback_dto_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/coping_guide/domain/entities/guide_feedback.dart';
import 'package:n06/features/coping_guide/infrastructure/dtos/guide_feedback_dto.dart';

void main() {
  group('GuideFeedbackDto', () {
    test('Entity에서 DTO로 변환', () {
      // Arrange
      final entity = GuideFeedback(
        symptomName: '메스꺼움',
        helpful: true,
        timestamp: DateTime(2025, 1, 1),
      );

      // Act
      final dto = GuideFeedbackDto.fromEntity(entity);

      // Assert
      expect(dto.symptomName, entity.symptomName);
      expect(dto.helpful, entity.helpful);
      expect(dto.timestamp, entity.timestamp);
    });

    test('DTO에서 Entity로 변환', () {
      // Arrange
      final timestamp = DateTime(2025, 1, 1);
      final dto = GuideFeedbackDto()
        ..symptomName = '메스꺼움'
        ..helpful = true
        ..timestamp = timestamp;

      // Act
      final entity = dto.toEntity();

      // Assert
      expect(entity.symptomName, dto.symptomName);
      expect(entity.helpful, dto.helpful);
      expect(entity.timestamp, dto.timestamp);
    });

    test('양방향 변환 후 원래 값 유지', () {
      // Arrange
      final originalEntity = GuideFeedback(
        symptomName: '구토',
        helpful: false,
        timestamp: DateTime(2025, 1, 2),
      );

      // Act
      final dto = GuideFeedbackDto.fromEntity(originalEntity);
      final reconstructedEntity = dto.toEntity();

      // Assert
      expect(reconstructedEntity.symptomName, originalEntity.symptomName);
      expect(reconstructedEntity.helpful, originalEntity.helpful);
      expect(reconstructedEntity.timestamp, originalEntity.timestamp);
    });
  });
}
</file>

<file path="test/features/coping_guide/infrastructure/repositories/isar_feedback_repository_test.dart">
import 'dart:io';

import 'package:flutter_test/flutter_test.dart';
import 'package:isar/isar.dart';
import 'package:n06/features/coping_guide/domain/entities/guide_feedback.dart';
import 'package:n06/features/coping_guide/infrastructure/dtos/guide_feedback_dto.dart';
import 'package:n06/features/coping_guide/infrastructure/repositories/isar_feedback_repository.dart';

void main() {
  group('IsarFeedbackRepository', () {
    late Isar isar;
    late IsarFeedbackRepository repository;

    setUpAll(() {
      TestWidgetsFlutterBinding.ensureInitialized();
    });

    setUp(() async {
      final dir = Directory.systemTemp.createTempSync('isar_test_');
      isar = await Isar.open(
        [GuideFeedbackDtoSchema],
        directory: dir.path,
        name: 'test_feedback_${DateTime.now().millisecondsSinceEpoch}',
      );
      repository = IsarFeedbackRepository(isar);
    });

    tearDown(() async {
      await isar.close(deleteFromDisk: true);
    });

    test('피드백 저장 성공', () async {
      // Arrange
      final feedback = GuideFeedback(
        symptomName: '메스꺼움',
        helpful: true,
        timestamp: DateTime.now(),
      );

      // Act
      await repository.saveFeedback(feedback);

      // Assert
      final saved = await repository.getFeedbacksBySymptom('메스꺼움');
      expect(saved.length, 1);
      expect(saved.first.symptomName, '메스꺼움');
      expect(saved.first.helpful, isTrue);
    });

    test('증상별 피드백 조회', () async {
      // Arrange
      final feedback1 = GuideFeedback(
        symptomName: '메스꺼움',
        helpful: true,
        timestamp: DateTime.now(),
      );
      final feedback2 = GuideFeedback(
        symptomName: '구토',
        helpful: false,
        timestamp: DateTime.now(),
      );
      await repository.saveFeedback(feedback1);
      await repository.saveFeedback(feedback2);

      // Act
      final result = await repository.getFeedbacksBySymptom('메스꺼움');

      // Assert
      expect(result.length, 1);
      expect(result.first.symptomName, '메스꺼움');
    });

    test('같은 증상 여러 피드백 저장', () async {
      // Arrange
      final feedback1 = GuideFeedback(
        symptomName: '메스꺼움',
        helpful: true,
        timestamp: DateTime.now(),
      );
      final feedback2 = GuideFeedback(
        symptomName: '메스꺼움',
        helpful: false,
        timestamp: DateTime.now().add(Duration(hours: 1)),
      );

      // Act
      await repository.saveFeedback(feedback1);
      await repository.saveFeedback(feedback2);

      // Assert
      final result = await repository.getFeedbacksBySymptom('메스꺼움');
      expect(result.length, 2);
    });

    test('등록되지 않은 증상은 빈 리스트 반환', () async {
      // Act
      final result = await repository.getFeedbacksBySymptom('알 수 없는 증상');

      // Assert
      expect(result, isEmpty);
    });
  });
}
</file>

<file path="test/features/coping_guide/infrastructure/repositories/static_coping_guide_repository_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/coping_guide/infrastructure/repositories/static_coping_guide_repository.dart';

void main() {
  group('StaticCopingGuideRepository', () {
    late StaticCopingGuideRepository repository;

    setUp(() {
      repository = StaticCopingGuideRepository();
    });

    test('메스꺼움 증상의 가이드를 반환', () async {
      // Act
      final result = await repository.getGuideBySymptom('메스꺼움');

      // Assert
      expect(result, isNotNull);
      expect(result!.symptomName, '메스꺼움');
      expect(result.shortGuide, isNotEmpty);
      expect(result.detailedSections, isNotEmpty);
    });

    test('모든 7가지 증상의 가이드를 반환', () async {
      // Arrange
      final expectedSymptoms = ['메스꺼움', '구토', '변비', '설사', '복통', '두통', '피로'];

      // Act
      final result = await repository.getAllGuides();

      // Assert
      expect(result.length, 7);
      for (var symptom in expectedSymptoms) {
        expect(result.any((g) => g.symptomName == symptom), isTrue);
      }
    });

    test('등록되지 않은 증상은 null 반환', () async {
      // Act
      final result = await repository.getGuideBySymptom('알 수 없는 증상');

      // Assert
      expect(result, isNull);
    });

    test('각 가이드는 4가지 섹션을 포함', () async {
      // Act
      final guides = await repository.getAllGuides();

      // Assert
      for (var guide in guides) {
        expect(guide.detailedSections, isNotNull);
        expect(guide.detailedSections!.length, 4);
      }
    });

    test('섹션은 정해진 순서: 즉시조치, 식이조절, 생활습관, 경과관찰', () async {
      // Act
      final guide = await repository.getGuideBySymptom('메스꺼움');

      // Assert
      expect(guide!.detailedSections![0].title, '즉시 조치');
      expect(guide.detailedSections![1].title, '식이 조절');
      expect(guide.detailedSections![2].title, '생활 습관');
      expect(guide.detailedSections![3].title, '경과 관찰');
    });

    test('가이드 데이터는 긍정적인 톤으로 작성됨', () async {
      // Act
      final guides = await repository.getAllGuides();

      // Assert
      for (var guide in guides) {
        expect(guide.shortGuide, isNot(contains('위험')));
        expect(guide.shortGuide, isNot(contains('심각')));
      }
    });
  });
}
</file>

<file path="test/features/coping_guide/presentation/screens/coping_guide_screen_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/coping_guide/presentation/screens/coping_guide_screen.dart';

void main() {
  group('CopingGuideScreen', () {
    testWidgets('위젯이 생성 가능함', (WidgetTester tester) async {
      // Test that the widget can be instantiated
      const screen = CopingGuideScreen();
      expect(screen, isNotNull);
    });
  });
}
</file>

<file path="test/features/coping_guide/presentation/screens/detailed_guide_screen_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/coping_guide/domain/entities/coping_guide.dart';
import 'package:n06/features/coping_guide/domain/entities/guide_section.dart';
import 'package:n06/features/coping_guide/presentation/screens/detailed_guide_screen.dart';

void main() {
  group('DetailedGuideScreen', () {
    testWidgets('증상명을 제목으로 표시', (WidgetTester tester) async {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '...',
        detailedSections: [],
      );

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: DetailedGuideScreen(guide: guide),
        ),
      );

      // Assert
      expect(find.text('메스꺼움 대처 가이드'), findsOneWidget);
    });

    testWidgets('4가지 섹션을 순서대로 표시', (WidgetTester tester) async {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '...',
        detailedSections: [
          GuideSection(title: '즉시 조치', content: '물 마시기'),
          GuideSection(title: '식이 조절', content: '기름진 음식 피하기'),
          GuideSection(title: '생활 습관', content: '충분한 휴식'),
          GuideSection(title: '경과 관찰', content: '3일 후에도 지속 시 상담'),
        ],
      );

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: DetailedGuideScreen(guide: guide),
        ),
      );

      // Assert
      expect(find.text('즉시 조치'), findsOneWidget);
      expect(find.text('식이 조절'), findsOneWidget);
      expect(find.text('생활 습관'), findsOneWidget);
      expect(find.text('경과 관찰'), findsOneWidget);
    });

    testWidgets('섹션 내용 표시', (WidgetTester tester) async {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '...',
        detailedSections: [
          GuideSection(title: '즉시 조치', content: '물 마시기'),
          GuideSection(title: '식이 조절', content: '기름진 음식 피하기'),
          GuideSection(title: '생활 습관', content: '충분한 휴식'),
          GuideSection(title: '경과 관찰', content: '3일 후에도 지속 시 상담'),
        ],
      );

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: DetailedGuideScreen(guide: guide),
        ),
      );

      // Assert
      expect(find.text('물 마시기'), findsOneWidget);
      expect(find.text('기름진 음식 피하기'), findsOneWidget);
      expect(find.text('충분한 휴식'), findsOneWidget);
      expect(find.text('3일 후에도 지속 시 상담'), findsOneWidget);
    });

    testWidgets('빈 섹션 처리', (WidgetTester tester) async {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '...',
        detailedSections: [],
      );

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: DetailedGuideScreen(guide: guide),
        ),
      );

      // Assert
      expect(find.byType(SingleChildScrollView), findsOneWidget);
    });

    testWidgets('Scaffold가 표시됨', (WidgetTester tester) async {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '...',
        detailedSections: [],
      );

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: DetailedGuideScreen(guide: guide),
        ),
      );

      // Assert
      expect(find.byType(Scaffold), findsOneWidget);
    });

    testWidgets('AppBar가 표시됨', (WidgetTester tester) async {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '...',
        detailedSections: [],
      );

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: DetailedGuideScreen(guide: guide),
        ),
      );

      // Assert
      expect(find.byType(AppBar), findsOneWidget);
    });

    testWidgets('많은 섹션 처리 시 스크롤 가능', (WidgetTester tester) async {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '...',
        detailedSections: List.generate(
          10,
          (i) => GuideSection(title: '섹션 $i', content: '내용 ' * 50),
        ),
      );

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: DetailedGuideScreen(guide: guide),
        ),
      );

      // Assert
      expect(find.byType(SingleChildScrollView), findsOneWidget);
    });
  });
}
</file>

<file path="test/features/coping_guide/presentation/widgets/coping_guide_card_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/coping_guide/domain/entities/coping_guide.dart';
import 'package:n06/features/coping_guide/domain/entities/coping_guide_state.dart';
import 'package:n06/features/coping_guide/presentation/widgets/coping_guide_card.dart';

void main() {
  group('CopingGuideCard', () {
    testWidgets('증상명과 간단 가이드 표시', (WidgetTester tester) async {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '소량씩 자주 식사하세요',
      );

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: CopingGuideCard(guide: guide),
          ),
        ),
      );

      // Assert
      expect(find.text('메스꺼움 대처 가이드'), findsOneWidget);
      expect(find.text('소량씩 자주 식사하세요'), findsOneWidget);
    });

    testWidgets('"더 자세한 가이드 보기" 버튼 표시', (WidgetTester tester) async {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '...',
      );

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: CopingGuideCard(guide: guide),
          ),
        ),
      );

      // Assert
      expect(find.text('더 자세한 가이드 보기'), findsOneWidget);
    });

    testWidgets('피드백 위젯 표시', (WidgetTester tester) async {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '...',
      );

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: CopingGuideCard(
              guide: guide,
              onFeedback: (helpful) {},
            ),
          ),
        ),
      );

      // Assert
      expect(find.text('도움이 되었나요?'), findsOneWidget);
      expect(find.text('예'), findsOneWidget);
      expect(find.text('아니오'), findsOneWidget);
    });

    testWidgets('"더 자세한 가이드 보기" 탭 시 콜백 호출', (WidgetTester tester) async {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '...',
      );
      bool navigated = false;

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: CopingGuideCard(
              guide: guide,
              onDetailTap: () => navigated = true,
            ),
          ),
        ),
      );
      await tester.tap(find.text('더 자세한 가이드 보기'));
      await tester.pumpAndSettle();

      // Assert
      expect(navigated, isTrue);
    });

    testWidgets('심각도 경고 플래그 활성화 시 경고 배너 표시', (WidgetTester tester) async {
      // Arrange
      final state = CopingGuideState(
        guide: CopingGuide(
          symptomName: '메스꺼움',
          shortGuide: '...',
        ),
        showSeverityWarning: true,
      );

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: CopingGuideCard(
              state: state,
              onCheckSymptom: () {},
            ),
          ),
        ),
      );

      // Assert
      expect(find.text('증상이 심각하거나 지속됩니다'), findsOneWidget);
      expect(find.text('증상 체크하기'), findsOneWidget);
    });

    testWidgets('경고 배너 미활성화 시 배너 미표시', (WidgetTester tester) async {
      // Arrange
      final state = CopingGuideState(
        guide: CopingGuide(
          symptomName: '메스꺼움',
          shortGuide: '...',
        ),
        showSeverityWarning: false,
      );

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: CopingGuideCard(state: state),
          ),
        ),
      );

      // Assert
      expect(find.text('증상이 심각하거나 지속됩니다'), findsNothing);
      expect(find.text('증상 체크하기'), findsNothing);
    });

    testWidgets('경고 배너의 "증상 체크하기" 버튼 탭 시 콜백 호출', (WidgetTester tester) async {
      // Arrange
      final state = CopingGuideState(
        guide: CopingGuide(
          symptomName: '메스꺼움',
          shortGuide: '...',
        ),
        showSeverityWarning: true,
      );
      bool navigatedToF005 = false;

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: CopingGuideCard(
              state: state,
              onCheckSymptom: () => navigatedToF005 = true,
            ),
          ),
        ),
      );
      await tester.tap(find.text('증상 체크하기'));
      await tester.pumpAndSettle();

      // Assert
      expect(navigatedToF005, isTrue);
    });

    testWidgets('카드가 주요 콘텐츠로 렌더링됨', (WidgetTester tester) async {
      // Arrange
      final guide = CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '...',
      );

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: CopingGuideCard(guide: guide),
          ),
        ),
      );

      // Assert
      expect(find.byType(Card), findsOneWidget);
    });
  });
}
</file>

<file path="test/features/coping_guide/presentation/widgets/feedback_widget_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/coping_guide/presentation/widgets/feedback_widget.dart';

void main() {
  group('FeedbackWidget', () {
    testWidgets('"도움이 되었나요?" 텍스트 표시', (WidgetTester tester) async {
      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FeedbackWidget(
              onFeedback: (helpful) {},
            ),
          ),
        ),
      );

      // Assert
      expect(find.text('도움이 되었나요?'), findsOneWidget);
    });

    testWidgets('"예", "아니오" 버튼 표시', (WidgetTester tester) async {
      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FeedbackWidget(
              onFeedback: (helpful) {},
            ),
          ),
        ),
      );

      // Assert
      expect(find.text('예'), findsOneWidget);
      expect(find.text('아니오'), findsOneWidget);
    });

    testWidgets('"예" 탭 시 콜백 호출 및 감사 메시지 표시', (WidgetTester tester) async {
      // Arrange
      bool? callbackResult;

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FeedbackWidget(
              onFeedback: (helpful) => callbackResult = helpful,
            ),
          ),
        ),
      );
      await tester.tap(find.text('예'));
      await tester.pumpAndSettle();

      // Assert
      expect(callbackResult, isTrue);
      expect(find.text('도움이 되어 기쁩니다!'), findsOneWidget);
    });

    testWidgets('"아니오" 탭 시 추가 옵션 표시', (WidgetTester tester) async {
      // Arrange
      bool? callbackResult;

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FeedbackWidget(
              onFeedback: (helpful) => callbackResult = helpful,
            ),
          ),
        ),
      );
      await tester.tap(find.text('아니오'));
      await tester.pumpAndSettle();

      // Assert
      expect(callbackResult, isFalse);
      expect(find.text('더 자세한 가이드 보기'), findsOneWidget);
    });

    testWidgets('초기 상태에서 버튼만 표시', (WidgetTester tester) async {
      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FeedbackWidget(
              onFeedback: (helpful) {},
            ),
          ),
        ),
      );

      // Assert
      expect(find.byType(ElevatedButton), findsWidgets);
      expect(find.text('도움이 되어 기쁩니다!'), findsNothing);
      expect(find.text('더 자세한 가이드 보기'), findsNothing);
    });

    testWidgets('"예" 선택 후 다시 상호작용 불가능 확인', (WidgetTester tester) async {
      // Arrange
      int callCount = 0;

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: FeedbackWidget(
              onFeedback: (helpful) => callCount++,
            ),
          ),
        ),
      );
      await tester.tap(find.text('예'));
      await tester.pumpAndSettle();

      // 버튼이 비활성화되었는지 확인
      expect(callCount, 1);
    });
  });
}
</file>

<file path="test/features/coping_guide/presentation/widgets/severity_warning_banner_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/coping_guide/presentation/widgets/severity_warning_banner.dart';

void main() {
  group('SeverityWarningBanner', () {
    testWidgets('경고 메시지 텍스트 표시', (WidgetTester tester) async {
      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: SeverityWarningBanner(
              onCheckSymptom: () {},
            ),
          ),
        ),
      );

      // Assert
      expect(find.text('증상이 심각하거나 지속됩니다'), findsOneWidget);
    });

    testWidgets('"증상 체크하기" 버튼 표시', (WidgetTester tester) async {
      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: SeverityWarningBanner(
              onCheckSymptom: () {},
            ),
          ),
        ),
      );

      // Assert
      expect(find.text('증상 체크하기'), findsOneWidget);
    });

    testWidgets('"증상 체크하기" 버튼 탭 시 콜백 호출', (WidgetTester tester) async {
      // Arrange
      bool called = false;

      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: SeverityWarningBanner(
              onCheckSymptom: () => called = true,
            ),
          ),
        ),
      );
      await tester.tap(find.text('증상 체크하기'));
      await tester.pumpAndSettle();

      // Assert
      expect(called, isTrue);
    });

    testWidgets('배너가 빨간색 배경으로 렌더링됨', (WidgetTester tester) async {
      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: SeverityWarningBanner(
              onCheckSymptom: () {},
            ),
          ),
        ),
      );

      // Assert
      expect(find.byType(Container), findsWidgets);
    });

    testWidgets('경고 아이콘 표시', (WidgetTester tester) async {
      // Act
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: SeverityWarningBanner(
              onCheckSymptom: () {},
            ),
          ),
        ),
      );

      // Assert
      expect(find.byIcon(Icons.warning), findsOneWidget);
    });
  });
}
</file>

<file path="test/features/dashboard/domain/usecases/calculate_continuous_record_days_usecase_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/dashboard/domain/usecases/calculate_continuous_record_days_usecase.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';

void main() {
  group('CalculateContinuousRecordDaysUseCase', () {
    late CalculateContinuousRecordDaysUseCase useCase;

    setUp(() {
      useCase = CalculateContinuousRecordDaysUseCase();
    });

    test('should return 0 when no records exist', () {
      final result = useCase.execute([], []);
      expect(result, 0);
    });

    test('should return 1 when only today has record', () {
      final today = DateTime.now();
      final weights = [
        WeightLog(
          id: '1',
          userId: 'user1',
          logDate: today,
          weightKg: 70.0,
          createdAt: today,
        ),
      ];

      final result = useCase.execute(weights, []);
      expect(result, 1);
    });

    test('should return 7 when continuous 7 days record exist', () {
      final today = DateTime.now();
      final weights = List.generate(
        7,
        (i) => WeightLog(
          id: '$i',
          userId: 'user1',
          logDate: today.subtract(Duration(days: i)),
          weightKg: 70.0 - i,
          createdAt: today,
        ),
      );

      final result = useCase.execute(weights, []);
      expect(result, 7);
    });

    test('should reset to 0 when gap exists in records', () {
      final today = DateTime.now();
      final weights = [
        WeightLog(
          id: '1',
          userId: 'user1',
          logDate: today,
          weightKg: 70.0,
          createdAt: today,
        ),
        WeightLog(
          id: '2',
          userId: 'user1',
          logDate: today.subtract(Duration(days: 2)),
          weightKg: 71.0,
          createdAt: today,
        ),
      ];

      final result = useCase.execute(weights, []);
      expect(result, 1);
    });

    test('should handle mixed weight and symptom logs', () {
      final today = DateTime.now();
      final weights = [
        WeightLog(
          id: '1',
          userId: 'user1',
          logDate: today,
          weightKg: 70.0,
          createdAt: today,
        ),
        WeightLog(
          id: '2',
          userId: 'user1',
          logDate: today.subtract(Duration(days: 2)),
          weightKg: 71.0,
          createdAt: today,
        ),
      ];

      final symptoms = [
        SymptomLog(
          id: '3',
          userId: 'user1',
          logDate: today.subtract(Duration(days: 1)),
          symptomName: '메스꺼움',
          severity: 5,
        ),
      ];

      final result = useCase.execute(weights, symptoms);
      // Should have: today (weight), yesterday (symptom), day-2 (weight) = 3 consecutive days
      expect(result, 3);
    });

    test('should handle duplicate logs on same date', () {
      final today = DateTime.now();
      final weights = [
        WeightLog(
          id: '1',
          userId: 'user1',
          logDate: today,
          weightKg: 70.0,
          createdAt: today,
        ),
        WeightLog(
          id: '2',
          userId: 'user1',
          logDate: today,
          weightKg: 71.0,
          createdAt: today,
        ),
      ];

      final result = useCase.execute(weights, []);
      expect(result, 1);
    });
  });
}
</file>

<file path="test/features/data_sharing/domain/entities/shared_data_report_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/data_sharing/domain/entities/shared_data_report.dart';
import 'package:n06/features/data_sharing/domain/entities/emergency_symptom_check.dart';

void main() {
  group('SharedDataReport', () {
    late DateTime startDate;
    late DateTime endDate;

    setUp(() {
      startDate = DateTime(2024, 1, 1);
      endDate = DateTime(2024, 1, 31);
    });

    test('should create SharedDataReport with all required fields', () {
      // Arrange
      const doseRecords = <DoseRecord>[];
      const weightLogs = <WeightLog>[];
      const symptomLogs = <SymptomLog>[];
      const emergencyChecks = <EmergencySymptomCheck>[];
      const doseSchedules = <DoseSchedule>[];

      // Act
      final report = SharedDataReport(
        dateRangeStart: startDate,
        dateRangeEnd: endDate,
        doseRecords: doseRecords,
        weightLogs: weightLogs,
        symptomLogs: symptomLogs,
        emergencyChecks: emergencyChecks,
        doseSchedules: doseSchedules,
      );

      // Assert
      expect(report.dateRangeStart, startDate);
      expect(report.dateRangeEnd, endDate);
      expect(report.doseRecords, doseRecords);
      expect(report.weightLogs, weightLogs);
      expect(report.symptomLogs, symptomLogs);
      expect(report.emergencyChecks, emergencyChecks);
      expect(report.doseSchedules, doseSchedules);
    });

    test('should calculate adherence rate correctly with perfect adherence', () {
      // Arrange - 5 scheduled, 5 completed
      final schedules = [
        DoseSchedule(
          id: '1',
          dosagePlanId: 'plan1',
          scheduledDate: DateTime(2024, 1, 1),
          scheduledDoseMg: 0.25,
        ),
        DoseSchedule(
          id: '2',
          dosagePlanId: 'plan1',
          scheduledDate: DateTime(2024, 1, 8),
          scheduledDoseMg: 0.25,
        ),
        DoseSchedule(
          id: '3',
          dosagePlanId: 'plan1',
          scheduledDate: DateTime(2024, 1, 15),
          scheduledDoseMg: 0.5,
        ),
        DoseSchedule(
          id: '4',
          dosagePlanId: 'plan1',
          scheduledDate: DateTime(2024, 1, 22),
          scheduledDoseMg: 0.5,
        ),
        DoseSchedule(
          id: '5',
          dosagePlanId: 'plan1',
          scheduledDate: DateTime(2024, 1, 29),
          scheduledDoseMg: 0.5,
        ),
      ];

      final records = [
        DoseRecord(
          id: 'r1',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2024, 1, 1, 10, 0),
          actualDoseMg: 0.25,
          isCompleted: true,
        ),
        DoseRecord(
          id: 'r2',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2024, 1, 8, 10, 0),
          actualDoseMg: 0.25,
          isCompleted: true,
        ),
        DoseRecord(
          id: 'r3',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2024, 1, 15, 10, 0),
          actualDoseMg: 0.5,
          isCompleted: true,
        ),
        DoseRecord(
          id: 'r4',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2024, 1, 22, 10, 0),
          actualDoseMg: 0.5,
          isCompleted: true,
        ),
        DoseRecord(
          id: 'r5',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2024, 1, 29, 10, 0),
          actualDoseMg: 0.5,
          isCompleted: true,
        ),
      ];

      // Act
      final report = SharedDataReport(
        dateRangeStart: startDate,
        dateRangeEnd: endDate,
        doseRecords: records,
        weightLogs: const [],
        symptomLogs: const [],
        emergencyChecks: const [],
        doseSchedules: schedules,
      );

      // Assert
      final adherenceRate = report.calculateAdherenceRate();
      expect(adherenceRate, 100.0);
    });

    test('should calculate adherence rate correctly with 80% adherence', () {
      // Arrange - 5 scheduled, 4 completed
      final schedules = [
        DoseSchedule(
          id: '1',
          dosagePlanId: 'plan1',
          scheduledDate: DateTime(2024, 1, 1),
          scheduledDoseMg: 0.25,
        ),
        DoseSchedule(
          id: '2',
          dosagePlanId: 'plan1',
          scheduledDate: DateTime(2024, 1, 8),
          scheduledDoseMg: 0.25,
        ),
        DoseSchedule(
          id: '3',
          dosagePlanId: 'plan1',
          scheduledDate: DateTime(2024, 1, 15),
          scheduledDoseMg: 0.5,
        ),
        DoseSchedule(
          id: '4',
          dosagePlanId: 'plan1',
          scheduledDate: DateTime(2024, 1, 22),
          scheduledDoseMg: 0.5,
        ),
        DoseSchedule(
          id: '5',
          dosagePlanId: 'plan1',
          scheduledDate: DateTime(2024, 1, 29),
          scheduledDoseMg: 0.5,
        ),
      ];

      final records = [
        DoseRecord(
          id: 'r1',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2024, 1, 1, 10, 0),
          actualDoseMg: 0.25,
          isCompleted: true,
        ),
        DoseRecord(
          id: 'r2',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2024, 1, 8, 10, 0),
          actualDoseMg: 0.25,
          isCompleted: true,
        ),
        DoseRecord(
          id: 'r3',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2024, 1, 15, 10, 0),
          actualDoseMg: 0.5,
          isCompleted: true,
        ),
        DoseRecord(
          id: 'r4',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2024, 1, 22, 10, 0),
          actualDoseMg: 0.5,
          isCompleted: true,
        ),
        // Missing r5 for 2024-01-29
      ];

      // Act
      final report = SharedDataReport(
        dateRangeStart: startDate,
        dateRangeEnd: endDate,
        doseRecords: records,
        weightLogs: const [],
        symptomLogs: const [],
        emergencyChecks: const [],
        doseSchedules: schedules,
      );

      // Assert
      final adherenceRate = report.calculateAdherenceRate();
      expect(adherenceRate, 80.0);
    });

    test('should return 0 adherence rate when no schedules exist', () {
      // Arrange
      final records = [
        DoseRecord(
          id: 'r1',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2024, 1, 1, 10, 0),
          actualDoseMg: 0.25,
          isCompleted: true,
        ),
      ];

      // Act
      final report = SharedDataReport(
        dateRangeStart: startDate,
        dateRangeEnd: endDate,
        doseRecords: records,
        weightLogs: const [],
        symptomLogs: const [],
        emergencyChecks: const [],
        doseSchedules: const [],
      );

      // Assert
      final adherenceRate = report.calculateAdherenceRate();
      expect(adherenceRate, 0.0);
    });

    test('should aggregate injection site history correctly', () {
      // Arrange
      final records = [
        DoseRecord(
          id: 'r1',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2024, 1, 1, 10, 0),
          actualDoseMg: 0.25,
          injectionSite: 'abdomen',
          isCompleted: true,
        ),
        DoseRecord(
          id: 'r2',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2024, 1, 8, 10, 0),
          actualDoseMg: 0.25,
          injectionSite: 'thigh',
          isCompleted: true,
        ),
        DoseRecord(
          id: 'r3',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2024, 1, 15, 10, 0),
          actualDoseMg: 0.5,
          injectionSite: 'arm',
          isCompleted: true,
        ),
        DoseRecord(
          id: 'r4',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2024, 1, 22, 10, 0),
          actualDoseMg: 0.5,
          injectionSite: 'abdomen',
          isCompleted: true,
        ),
      ];

      // Act
      final report = SharedDataReport(
        dateRangeStart: startDate,
        dateRangeEnd: endDate,
        doseRecords: records,
        weightLogs: const [],
        symptomLogs: const [],
        emergencyChecks: const [],
        doseSchedules: const [],
      );

      final siteHistory = report.getInjectionSiteHistory();

      // Assert
      expect(siteHistory['abdomen'], 2);
      expect(siteHistory['thigh'], 1);
      expect(siteHistory['arm'], 1);
    });

    test('should handle empty data lists gracefully', () {
      // Act
      final report = SharedDataReport(
        dateRangeStart: startDate,
        dateRangeEnd: endDate,
        doseRecords: const [],
        weightLogs: const [],
        symptomLogs: const [],
        emergencyChecks: const [],
        doseSchedules: const [],
      );

      // Assert
      expect(report.doseRecords, isEmpty);
      expect(report.weightLogs, isEmpty);
      expect(report.symptomLogs, isEmpty);
      expect(report.emergencyChecks, isEmpty);
      expect(report.doseSchedules, isEmpty);
      expect(report.calculateAdherenceRate(), 0.0);
      expect(report.getInjectionSiteHistory(), isEmpty);
    });

    test('should support value equality with Equatable', () {
      // Arrange
      final report1 = SharedDataReport(
        dateRangeStart: startDate,
        dateRangeEnd: endDate,
        doseRecords: const [],
        weightLogs: const [],
        symptomLogs: const [],
        emergencyChecks: const [],
        doseSchedules: const [],
      );

      final report2 = SharedDataReport(
        dateRangeStart: startDate,
        dateRangeEnd: endDate,
        doseRecords: const [],
        weightLogs: const [],
        symptomLogs: const [],
        emergencyChecks: const [],
        doseSchedules: const [],
      );

      // Assert
      expect(report1, report2);
    });

    test('should provide copyWith functionality', () {
      // Arrange
      final report = SharedDataReport(
        dateRangeStart: startDate,
        dateRangeEnd: endDate,
        doseRecords: const [],
        weightLogs: const [],
        symptomLogs: const [],
        emergencyChecks: const [],
        doseSchedules: const [],
      );

      final newEndDate = DateTime(2024, 2, 28);

      // Act
      final updatedReport = report.copyWith(dateRangeEnd: newEndDate);

      // Assert
      expect(updatedReport.dateRangeEnd, newEndDate);
      expect(updatedReport.dateRangeStart, startDate);
      expect(report.dateRangeEnd, endDate); // Original unchanged
    });
  });
}
</file>

<file path="test/features/notification/domain/entities/notification_settings_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/notification/domain/entities/notification_settings.dart';

void main() {
  group('NotificationSettings', () {
    test('should create NotificationSettings with default values', () {
      // Arrange & Act
      final settings = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );

      // Assert
      expect(settings.userId, 'user123');
      expect(settings.notificationTime.hour, 9);
      expect(settings.notificationTime.minute, 0);
      expect(settings.notificationEnabled, true);
    });

    test('should create NotificationSettings with disabled state', () {
      // Arrange & Act
      final settings = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 21, minute: 30),
        notificationEnabled: false,
      );

      // Assert
      expect(settings.notificationEnabled, false);
    });

    test('should support copyWith for immutability', () {
      // Arrange
      final original = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );

      // Act
      final updated = original.copyWith(
        notificationTime: const TimeOfDay(hour: 21, minute: 0),
      );

      // Assert
      expect(updated.notificationTime.hour, 21);
      expect(updated.notificationEnabled, true);
      expect(updated.userId, 'user123');
    });

    test('should support copyWith with multiple fields', () {
      // Arrange
      final original = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );

      // Act
      final updated = original.copyWith(
        notificationTime: const TimeOfDay(hour: 14, minute: 30),
        notificationEnabled: false,
      );

      // Assert
      expect(updated.notificationTime.hour, 14);
      expect(updated.notificationTime.minute, 30);
      expect(updated.notificationEnabled, false);
    });

    test('should support equality comparison', () {
      // Arrange
      final settings1 = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );
      final settings2 = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );

      // Assert
      expect(settings1, equals(settings2));
    });

    test('should not be equal when userId differs', () {
      // Arrange
      final settings1 = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );
      final settings2 = NotificationSettings(
        userId: 'user456',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );

      // Assert
      expect(settings1, isNot(equals(settings2)));
    });

    test('should not be equal when notificationTime differs', () {
      // Arrange
      final settings1 = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );
      final settings2 = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 10, minute: 0),
        notificationEnabled: true,
      );

      // Assert
      expect(settings1, isNot(equals(settings2)));
    });

    test('should not be equal when notificationEnabled differs', () {
      // Arrange
      final settings1 = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );
      final settings2 = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: false,
      );

      // Assert
      expect(settings1, isNot(equals(settings2)));
    });
  });
}
</file>

<file path="test/features/notification/domain/repositories/notification_repository_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:n06/features/notification/domain/entities/notification_settings.dart';
import 'package:n06/features/notification/domain/repositories/notification_repository.dart';

class MockNotificationRepository extends Mock implements NotificationRepository {}

void main() {
  group('NotificationRepository Interface', () {
    late MockNotificationRepository mockRepository;

    setUp(() {
      mockRepository = MockNotificationRepository();
    });

    test('should define getNotificationSettings method', () async {
      // Arrange
      final mockSettings = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );
      when(mockRepository.getNotificationSettings('user123'))
          .thenAnswer((_) async => mockSettings);

      // Act
      final settings = await mockRepository.getNotificationSettings('user123');

      // Assert
      expect(settings, isA<NotificationSettings>());
      expect(settings!.userId, 'user123');
      verify(mockRepository.getNotificationSettings('user123')).called(1);
    });

    test('should define saveNotificationSettings method', () async {
      // Arrange
      final mockSettings = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );
      when(mockRepository.saveNotificationSettings(mockSettings))
          .thenAnswer((_) async => {});

      // Act
      await mockRepository.saveNotificationSettings(mockSettings);

      // Assert
      verify(mockRepository.saveNotificationSettings(mockSettings)).called(1);
    });

    test('should return null when settings not found', () async {
      // Arrange
      when(mockRepository.getNotificationSettings('nonexistent'))
          .thenAnswer((_) async => null);

      // Act
      final settings =
          await mockRepository.getNotificationSettings('nonexistent');

      // Assert
      expect(settings, isNull);
    });
  });
}
</file>

<file path="test/features/notification/infrastructure/dtos/notification_settings_dto_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/notification/domain/entities/notification_settings.dart';
import 'package:n06/features/notification/infrastructure/dtos/notification_settings_dto.dart';

void main() {
  group('NotificationSettingsDto', () {
    test('should convert NotificationSettingsDto to NotificationSettings entity',
        () {
      // Arrange
      final dto = NotificationSettingsDto()
        ..userId = 'user123'
        ..notificationHour = 9
        ..notificationMinute = 0
        ..notificationEnabled = true;

      // Act
      final entity = dto.toEntity();

      // Assert
      expect(entity.userId, 'user123');
      expect(entity.notificationTime.hour, 9);
      expect(entity.notificationTime.minute, 0);
      expect(entity.notificationEnabled, true);
    });

    test('should convert NotificationSettings entity to NotificationSettingsDto',
        () {
      // Arrange
      final entity = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 21, minute: 30),
        notificationEnabled: false,
      );

      // Act
      final dto = NotificationSettingsDto.fromEntity(entity);

      // Assert
      expect(dto.userId, 'user123');
      expect(dto.notificationHour, 21);
      expect(dto.notificationMinute, 30);
      expect(dto.notificationEnabled, false);
    });

    test('should handle midnight time (00:00)', () {
      // Arrange
      final entity = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 0, minute: 0),
        notificationEnabled: true,
      );

      // Act
      final dto = NotificationSettingsDto.fromEntity(entity);
      final convertedEntity = dto.toEntity();

      // Assert
      expect(convertedEntity.notificationTime.hour, 0);
      expect(convertedEntity.notificationTime.minute, 0);
    });

    test('should handle end of day time (23:59)', () {
      // Arrange
      final entity = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 23, minute: 59),
        notificationEnabled: true,
      );

      // Act
      final dto = NotificationSettingsDto.fromEntity(entity);
      final convertedEntity = dto.toEntity();

      // Assert
      expect(convertedEntity.notificationTime.hour, 23);
      expect(convertedEntity.notificationTime.minute, 59);
    });

    test('should round-trip conversion preserve all values', () {
      // Arrange
      final original = NotificationSettings(
        userId: 'user456',
        notificationTime: const TimeOfDay(hour: 14, minute: 45),
        notificationEnabled: false,
      );

      // Act
      final dto = NotificationSettingsDto.fromEntity(original);
      final restored = dto.toEntity();

      // Assert
      expect(restored, equals(original));
    });
  });
}
</file>

<file path="test/features/notification/infrastructure/services/local_notification_scheduler_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:n06/features/notification/infrastructure/services/local_notification_scheduler.dart';
import 'package:n06/features/notification/infrastructure/services/permission_service.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';

class MockPermissionService extends Mock implements PermissionService {}

void main() {
  group('LocalNotificationScheduler', () {
    late LocalNotificationScheduler scheduler;
    late MockPermissionService mockPermissionService;

    setUp(() async {
      mockPermissionService = MockPermissionService();
      scheduler = LocalNotificationScheduler(mockPermissionService);
      await scheduler.initialize();
    });

    test('should initialize notification plugin', () async {
      // Assert
      expect(scheduler.isInitialized, true);
    });

    test('should check notification permission via PermissionService', () async {
      // Arrange
      when(mockPermissionService.checkPermission())
          .thenAnswer((_) async => true);
      final checkerScheduler =
          LocalNotificationScheduler(mockPermissionService);

      // Act
      final hasPermission = await checkerScheduler.checkPermission();

      // Assert
      expect(hasPermission, true);
      verify(mockPermissionService.checkPermission()).called(1);
    });

    test('should request notification permission via PermissionService', () async {
      // Arrange
      when(mockPermissionService.requestPermission())
          .thenAnswer((_) async => true);
      final requesterScheduler =
          LocalNotificationScheduler(mockPermissionService);

      // Act
      final granted = await requesterScheduler.requestPermission();

      // Assert
      expect(granted, true);
      verify(mockPermissionService.requestPermission()).called(1);
    });

    test('should schedule notifications for dose schedules', () async {
      // Arrange
      final doseSchedules = [
        DoseSchedule(
          id: 'schedule1',
          dosagePlanId: 'plan1',
          scheduledDate: DateTime.now().add(const Duration(days: 1)),
          scheduledDoseMg: 0.5,
        ),
        DoseSchedule(
          id: 'schedule2',
          dosagePlanId: 'plan1',
          scheduledDate: DateTime.now().add(const Duration(days: 8)),
          scheduledDoseMg: 1.0,
        ),
      ];

      // Act
      await scheduler.scheduleNotifications(
        doseSchedules: doseSchedules,
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
      );

      // Assert
      final pendingNotifications = await scheduler.getPendingNotifications();
      expect(pendingNotifications.length, 2);
    });

    test('should cancel all notifications', () async {
      // Arrange
      final doseSchedule = DoseSchedule(
        id: 'schedule1',
        dosagePlanId: 'plan1',
        scheduledDate: DateTime.now().add(const Duration(days: 1)),
        scheduledDoseMg: 0.5,
      );
      await scheduler.scheduleNotifications(
        doseSchedules: [doseSchedule],
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
      );

      // Act
      await scheduler.cancelAllNotifications();

      // Assert
      final pendingNotifications = await scheduler.getPendingNotifications();
      expect(pendingNotifications, isEmpty);
    });

    test('should not schedule notification for past dates', () async {
      // Arrange
      final pastSchedule = DoseSchedule(
        id: 'schedule1',
        dosagePlanId: 'plan1',
        scheduledDate: DateTime.now().subtract(const Duration(days: 1)),
        scheduledDoseMg: 0.5,
      );

      // Act
      await scheduler.scheduleNotifications(
        doseSchedules: [pastSchedule],
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
      );

      // Assert
      final pendingNotifications = await scheduler.getPendingNotifications();
      expect(pendingNotifications, isEmpty);
    });

    test('should schedule only one notification per date', () async {
      // Arrange
      final sameDate = DateTime.now().add(const Duration(days: 1));
      final doseSchedules = [
        DoseSchedule(
          id: 'schedule1',
          dosagePlanId: 'plan1',
          scheduledDate: sameDate,
          scheduledDoseMg: 0.5,
        ),
        DoseSchedule(
          id: 'schedule2',
          dosagePlanId: 'plan1',
          scheduledDate: sameDate,
          scheduledDoseMg: 0.5,
        ),
      ];

      // Act
      await scheduler.scheduleNotifications(
        doseSchedules: doseSchedules,
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
      );

      // Assert
      final pendingNotifications = await scheduler.getPendingNotifications();
      expect(pendingNotifications.length, 1);
    });
  });
}
</file>

<file path="test/features/notification/infrastructure/services/permission_service_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:n06/features/notification/infrastructure/services/permission_service.dart';

class MockPermissionHandler extends Mock {
  Future<PermissionStatus> request() async => PermissionStatus.granted;
  Future<PermissionStatus> status() async => PermissionStatus.granted;
  Future<bool> openAppSettings() async => true;
}

void main() {
  group('PermissionService', () {
    late PermissionService service;

    setUp(() {
      service = PermissionService();
    });

    test('should return true when notification permission is granted', () async {
      // Note: This is a basic test structure
      // Actual implementation will depend on permission_handler

      // Arrange & Act
      final hasPermission = await service.checkPermission();

      // Assert
      expect(hasPermission, isA<bool>());
    });

    test('should attempt to request permission', () async {
      // Arrange & Act
      final granted = await service.requestPermission();

      // Assert
      expect(granted, isA<bool>());
    });

    test('should open app settings', () async {
      // Arrange & Act & Assert
      await expectLater(
        service.openAppSettings(),
        completes,
      );
    });
  });
}
</file>

<file path="test/features/onboarding/domain/entities/user_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/onboarding/domain/entities/user.dart';

void main() {
  group('User Entity', () {
    test('should create User with all required fields', () {
      // Arrange
      const id = 'user123';
      const name = 'John Doe';
      final createdAt = DateTime(2025, 1, 1);

      // Act
      final user = User(
        id: id,
        name: name,
        createdAt: createdAt,
      );

      // Assert
      expect(user.id, id);
      expect(user.name, name);
      expect(user.createdAt, createdAt);
    });

    test('should throw ArgumentError when id is empty', () {
      // Arrange
      const emptyId = '';
      const name = 'John Doe';
      final createdAt = DateTime(2025, 1, 1);

      // Act & Assert
      expect(
        () => User(
          id: emptyId,
          name: name,
          createdAt: createdAt,
        ),
        throwsArgumentError,
      );
    });

    test('should throw ArgumentError when name is empty', () {
      // Arrange
      const id = 'user123';
      const emptyName = '';
      final createdAt = DateTime(2025, 1, 1);

      // Act & Assert
      expect(
        () => User(
          id: id,
          name: emptyName,
          createdAt: createdAt,
        ),
        throwsArgumentError,
      );
    });

    test('should support equality', () {
      // Arrange
      const id = 'user123';
      const name = 'John Doe';
      final createdAt = DateTime(2025, 1, 1);

      // Act
      final user1 = User(
        id: id,
        name: name,
        createdAt: createdAt,
      );
      final user2 = User(
        id: id,
        name: name,
        createdAt: createdAt,
      );

      // Assert
      expect(user1, user2);
    });

    test('should support copyWith', () {
      // Arrange
      final user = User(
        id: 'user123',
        name: 'John Doe',
        createdAt: DateTime(2025, 1, 1),
      );
      const newName = 'Jane Doe';

      // Act
      final updatedUser = user.copyWith(name: newName);

      // Assert
      expect(updatedUser.id, user.id);
      expect(updatedUser.name, newName);
      expect(updatedUser.createdAt, user.createdAt);
    });

    test('should have meaningful toString', () {
      // Arrange
      final user = User(
        id: 'user123',
        name: 'John Doe',
        createdAt: DateTime(2025, 1, 1),
      );

      // Act & Assert
      expect(user.toString(), contains('John Doe'));
      expect(user.toString(), contains('user123'));
    });
  });
}
</file>

<file path="test/features/onboarding/domain/value_objects/medication_name_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/onboarding/domain/value_objects/medication_name.dart';
import 'package:n06/core/errors/domain_exception.dart';

void main() {
  group('MedicationName Value Object', () {
    test('should create MedicationName with valid name', () {
      // Arrange
      const validName = 'Ozempic';

      // Act
      final name = MedicationName.create(validName);

      // Assert
      expect(name.value, validName);
    });

    test('should throw ValidationError when name is empty', () {
      // Arrange
      const emptyName = '';

      // Act & Assert
      expect(
        () => MedicationName.create(emptyName),
        throwsA(isA<DomainException>()),
      );
    });

    test('should throw ValidationError when name is only whitespace', () {
      // Arrange
      const whitespaceName = '   ';

      // Act & Assert
      expect(
        () => MedicationName.create(whitespaceName),
        throwsA(isA<DomainException>()),
      );
    });

    test('should support equality', () {
      // Arrange
      const name = 'Saxenda';

      // Act
      final name1 = MedicationName.create(name);
      final name2 = MedicationName.create(name);

      // Assert
      expect(name1, name2);
    });

    test('should trim whitespace', () {
      // Arrange
      const nameWithWhitespace = '  Mounjaro  ';

      // Act
      final name = MedicationName.create(nameWithWhitespace);

      // Assert
      expect(name.value, 'Mounjaro');
    });

    test('should have meaningful toString', () {
      // Arrange
      const medicationName = 'Ozempic';

      // Act
      final name = MedicationName.create(medicationName);

      // Assert
      expect(name.toString(), contains('Ozempic'));
    });
  });
}
</file>

<file path="test/features/onboarding/domain/value_objects/start_date_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/onboarding/domain/value_objects/start_date.dart';
import 'package:n06/core/errors/domain_exception.dart';

void main() {
  group('StartDate Value Object', () {
    test('should create StartDate with current date', () {
      // Arrange
      final now = DateTime.now();

      // Act
      final startDate = StartDate.create(now);

      // Assert
      expect(startDate.value.year, now.year);
      expect(startDate.value.month, now.month);
      expect(startDate.value.day, now.day);
    });

    test('should create StartDate with future date', () {
      // Arrange
      final futureDate = DateTime.now().add(const Duration(days: 10));

      // Act
      final startDate = StartDate.create(futureDate);

      // Assert
      expect(startDate.value, futureDate);
    });

    test('should allow date between 7 days in the past with warning flag', () {
      // Arrange
      final pastDate = DateTime.now().subtract(const Duration(days: 10));

      // Act
      final startDate = StartDate.create(pastDate);

      // Assert
      expect(startDate.value, pastDate);
      expect(startDate.hasWarning, true);
    });

    test('should throw DomainException when date is 30 or more days in past', () {
      // Arrange
      final oldDate = DateTime.now().subtract(const Duration(days: 30));

      // Act & Assert
      expect(
        () => StartDate.create(oldDate),
        throwsA(isA<DomainException>()),
      );
    });

    test('should not have warning flag for recent dates', () {
      // Arrange
      final recentDate = DateTime.now().subtract(const Duration(days: 2));

      // Act
      final startDate = StartDate.create(recentDate);

      // Assert
      expect(startDate.hasWarning, false);
    });

    test('should support equality', () {
      // Arrange
      final date = DateTime.now();

      // Act
      final startDate1 = StartDate.create(date);
      final startDate2 = StartDate.create(date);

      // Assert
      expect(startDate1, startDate2);
    });

    test('should have meaningful toString', () {
      // Arrange
      final date = DateTime.now();

      // Act
      final startDate = StartDate.create(date);

      // Assert
      expect(startDate.toString(), isNotEmpty);
    });
  });
}
</file>

<file path="test/features/onboarding/domain/value_objects/weight_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/onboarding/domain/value_objects/weight.dart';
import 'package:n06/core/errors/domain_exception.dart';

void main() {
  group('Weight Value Object', () {
    test('should create Weight with valid kg value', () {
      // Arrange
      const validKg = 70.5;

      // Act
      final weight = Weight.create(validKg);

      // Assert
      expect(weight.value, validKg);
    });

    test('should throw ValidationError when kg < 20', () {
      // Arrange
      const invalidKg = 19.9;

      // Act & Assert
      expect(
        () => Weight.create(invalidKg),
        throwsA(isA<DomainException>()),
      );
    });

    test('should throw ValidationError when kg > 300', () {
      // Arrange
      const invalidKg = 300.1;

      // Act & Assert
      expect(
        () => Weight.create(invalidKg),
        throwsA(isA<DomainException>()),
      );
    });

    test('should allow boundary value 20kg', () {
      // Arrange
      const boundaryKg = 20.0;

      // Act
      final weight = Weight.create(boundaryKg);

      // Assert
      expect(weight.value, boundaryKg);
    });

    test('should allow boundary value 300kg', () {
      // Arrange
      const boundaryKg = 300.0;

      // Act
      final weight = Weight.create(boundaryKg);

      // Assert
      expect(weight.value, boundaryKg);
    });

    test('should support equality', () {
      // Arrange
      const kg = 75.0;

      // Act
      final weight1 = Weight.create(kg);
      final weight2 = Weight.create(kg);

      // Assert
      expect(weight1, weight2);
    });

    test('should have meaningful toString', () {
      // Arrange
      const kg = 70.5;

      // Act
      final weight = Weight.create(kg);

      // Assert
      expect(weight.toString(), contains('70.5'));
    });
  });
}
</file>

<file path="test/features/profile/application/notifiers/profile_notifier_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/onboarding/domain/value_objects/weight.dart';
import 'package:n06/features/profile/domain/repositories/profile_repository.dart';
import 'package:n06/features/profile/application/notifiers/profile_notifier.dart';

class MockProfileRepository extends Mock implements ProfileRepository {}

void main() {
  group('ProfileNotifier', () {
    test('build should load profile successfully', () async {
      // Arrange
      final mockRepository = MockProfileRepository();
      final profile = UserProfile(
        userId: 'user1',
        targetWeight: Weight.create(70.0),
        currentWeight: Weight.create(80.0),
        targetPeriodWeeks: 10,
        weeklyLossGoalKg: 1.0,
      );

      when(() => mockRepository.getUserProfile('user1'))
          .thenAnswer((_) async => profile);

      // Act
      final container = ProviderContainer(
        overrides: [
          profileRepositoryProvider.overrideWithValue(mockRepository),
        ],
      );

      final result = await container.read(profileNotifierProvider.future);

      // Assert
      expect(result, isNotNull);
      expect(result!.userId, 'user1');
      expect(result.targetWeight.value, 70.0);
    });

    test('updateProfile should update profile successfully', () async {
      // Arrange
      final mockRepository = MockProfileRepository();
      final profile = UserProfile(
        userId: 'user1',
        targetWeight: Weight.create(70.0),
        currentWeight: Weight.create(80.0),
        targetPeriodWeeks: 10,
        weeklyLossGoalKg: 1.0,
      );

      when(() => mockRepository.saveUserProfile(profile))
          .thenAnswer((_) async {});

      final container = ProviderContainer(
        overrides: [
          profileRepositoryProvider.overrideWithValue(mockRepository),
        ],
      );

      // Act
      final notifier = container.read(profileNotifierProvider.notifier);
      await notifier.updateProfile(profile);

      // Assert
      verify(() => mockRepository.saveUserProfile(profile)).called(1);
    });

    test('updateProfile should throw exception on repository error', () async {
      // Arrange
      final mockRepository = MockProfileRepository();
      final profile = UserProfile(
        userId: 'user1',
        targetWeight: Weight.create(70.0),
        currentWeight: Weight.create(80.0),
        targetPeriodWeeks: 10,
      );

      final exception = Exception('Database error');
      when(() => mockRepository.saveUserProfile(profile))
          .thenThrow(exception);

      final container = ProviderContainer(
        overrides: [
          profileRepositoryProvider.overrideWithValue(mockRepository),
        ],
      );

      // Act
      final notifier = container.read(profileNotifierProvider.notifier);
      await notifier.updateProfile(profile);

      // Assert
      expect(container.read(profileNotifierProvider), isA<AsyncValue>());
    });
  });
}
</file>

<file path="test/features/profile/application/notifiers/profile_notifier_update_weekly_goals_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:riverpod/riverpod.dart';
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/onboarding/domain/value_objects/weight.dart';
import 'package:n06/features/profile/application/notifiers/profile_notifier.dart';
import 'package:n06/features/profile/domain/repositories/profile_repository.dart';

/// Simple mock ProfileRepository for testing
class _MockProfileRepository implements ProfileRepository {
  UserProfile? _mockProfile;
  bool _shouldThrowOnUpdate = false;

  void setMockProfile(UserProfile profile) {
    _mockProfile = profile;
  }

  void setShouldThrowOnUpdate(bool value) {
    _shouldThrowOnUpdate = value;
  }

  @override
  Future<UserProfile> getUserProfile(String userId) async {
    if (_mockProfile == null) {
      throw Exception('Profile not found');
    }
    return _mockProfile!;
  }

  @override
  Future<void> saveUserProfile(UserProfile profile) async {
    _mockProfile = profile;
  }

  @override
  Stream<UserProfile> watchUserProfile(String userId) {
    if (_mockProfile == null) {
      throw Exception('Profile not found');
    }
    return Stream.value(_mockProfile!);
  }

  @override
  Future<void> updateWeeklyGoals(
    String userId,
    int weeklyWeightRecordGoal,
    int weeklySymptomRecordGoal,
  ) async {
    if (_shouldThrowOnUpdate) {
      throw Exception('DB error');
    }
    if (_mockProfile == null) {
      throw Exception('Profile not found');
    }
    // Update the mock profile
    _mockProfile = _mockProfile!.copyWith(
      weeklyWeightRecordGoal: weeklyWeightRecordGoal,
      weeklySymptomRecordGoal: weeklySymptomRecordGoal,
    );
  }
}

void main() {
  group('ProfileNotifier.updateWeeklyGoals', () {
    late ProviderContainer container;
    late _MockProfileRepository mockRepository;

    setUp(() {
      mockRepository = _MockProfileRepository();

      // Create provider override for testing
      container = ProviderContainer(
        overrides: [
          profileRepositoryProvider.overrideWithValue(mockRepository),
        ],
      );
    });

    tearDown(() {
      container.dispose();
    });

    test('주간 목표 업데이트 성공', () async {
      // Arrange
      const userId = 'test-user-001';
      final originalProfile = UserProfile(
        userId: userId,
        targetWeight: Weight.create(60.0),
        currentWeight: Weight.create(70.0),
        weeklyWeightRecordGoal: 7,
        weeklySymptomRecordGoal: 7,
      );

      mockRepository.setMockProfile(originalProfile);

      // Initialize notifier with original profile
      final notifier = container.read(profileNotifierProvider.notifier);
      await container.read(profileNotifierProvider.future);

      // Act
      await notifier.updateWeeklyGoals(5, 3);

      // Assert
      final state = container.read(profileNotifierProvider);
      expect(state.value?.weeklyWeightRecordGoal, equals(5));
      expect(state.value?.weeklySymptomRecordGoal, equals(3));
    });

    test('주간 목표 업데이트 실패 시 에러 상태', () async {
      // Arrange
      const userId = 'test-user-002';
      final profile = UserProfile(
        userId: userId,
        targetWeight: Weight.create(60.0),
        currentWeight: Weight.create(70.0),
        weeklyWeightRecordGoal: 7,
        weeklySymptomRecordGoal: 7,
      );

      mockRepository.setMockProfile(profile);
      mockRepository.setShouldThrowOnUpdate(true);

      // Initialize notifier
      final notifier = container.read(profileNotifierProvider.notifier);
      await container.read(profileNotifierProvider.future);

      // Act
      await notifier.updateWeeklyGoals(5, 3);

      // Assert
      final state = container.read(profileNotifierProvider);
      expect(state.hasError, isTrue);
    });

    test('주간 목표 0 업데이트 허용', () async {
      // Arrange
      const userId = 'test-user-003';
      final originalProfile = UserProfile(
        userId: userId,
        targetWeight: Weight.create(60.0),
        currentWeight: Weight.create(70.0),
        weeklyWeightRecordGoal: 7,
        weeklySymptomRecordGoal: 7,
      );

      mockRepository.setMockProfile(originalProfile);

      final notifier = container.read(profileNotifierProvider.notifier);
      await container.read(profileNotifierProvider.future);

      // Act
      await notifier.updateWeeklyGoals(0, 7);

      // Assert
      final state = container.read(profileNotifierProvider);
      expect(state.value?.weeklyWeightRecordGoal, equals(0));
    });

    test('프로필이 로드되지 않았을 때 예외 발생', () async {
      // Arrange - Don't set mock profile
      final notifier = container.read(profileNotifierProvider.notifier);

      // Act & Assert
      expect(
        () => notifier.updateWeeklyGoals(5, 3),
        throwsException,
      );
    });

    test('여러 번의 목표 업데이트', () async {
      // Arrange
      const userId = 'test-user-004';
      final originalProfile = UserProfile(
        userId: userId,
        targetWeight: Weight.create(60.0),
        currentWeight: Weight.create(70.0),
        weeklyWeightRecordGoal: 7,
        weeklySymptomRecordGoal: 7,
      );

      mockRepository.setMockProfile(originalProfile);

      final notifier = container.read(profileNotifierProvider.notifier);
      await container.read(profileNotifierProvider.future);

      // Act - First update
      await notifier.updateWeeklyGoals(5, 3);

      var state = container.read(profileNotifierProvider);
      expect(state.value?.weeklyWeightRecordGoal, equals(5));
      expect(state.value?.weeklySymptomRecordGoal, equals(3));

      // Act - Second update
      await notifier.updateWeeklyGoals(2, 4);

      // Assert
      state = container.read(profileNotifierProvider);
      expect(state.value?.weeklyWeightRecordGoal, equals(2));
      expect(state.value?.weeklySymptomRecordGoal, equals(4));
    });
  });
}
</file>

<file path="test/features/profile/domain/entities/user_profile_weekly_goals_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/onboarding/domain/value_objects/weight.dart';

void main() {
  group('UserProfile Entity - Weekly Goals Validation', () {
    late Weight targetWeight;
    late Weight currentWeight;

    setUp(() {
      targetWeight = Weight.create(60.0);
      currentWeight = Weight.create(70.0);
    });

    group('주간 목표 범위 검증 (0~7)', () {
      test('유효한 주간 체중 기록 목표로 생성 성공', () {
        // Arrange & Act
        final profile = UserProfile(
          userId: 'test-user-001',
          targetWeight: targetWeight,
          currentWeight: currentWeight,
          weeklyWeightRecordGoal: 5,
          weeklySymptomRecordGoal: 3,
        );

        // Assert
        expect(profile.weeklyWeightRecordGoal, equals(5));
        expect(profile.weeklySymptomRecordGoal, equals(3));
      });

      test('주간 체중 기록 목표 0은 허용', () {
        // Arrange & Act
        final profile = UserProfile(
          userId: 'test-user-001',
          targetWeight: targetWeight,
          currentWeight: currentWeight,
          weeklyWeightRecordGoal: 0,
          weeklySymptomRecordGoal: 7,
        );

        // Assert
        expect(profile.weeklyWeightRecordGoal, equals(0));
      });

      test('주간 부작용 기록 목표 0은 허용', () {
        // Arrange & Act
        final profile = UserProfile(
          userId: 'test-user-001',
          targetWeight: targetWeight,
          currentWeight: currentWeight,
          weeklyWeightRecordGoal: 7,
          weeklySymptomRecordGoal: 0,
        );

        // Assert
        expect(profile.weeklySymptomRecordGoal, equals(0));
      });

      test('주간 체중 기록 목표 기본값 7', () {
        // Arrange & Act
        final profile = UserProfile(
          userId: 'test-user-001',
          targetWeight: targetWeight,
          currentWeight: currentWeight,
        );

        // Assert
        expect(profile.weeklyWeightRecordGoal, equals(7));
      });

      test('주간 부작용 기록 목표 기본값 7', () {
        // Arrange & Act
        final profile = UserProfile(
          userId: 'test-user-001',
          targetWeight: targetWeight,
          currentWeight: currentWeight,
        );

        // Assert
        expect(profile.weeklySymptomRecordGoal, equals(7));
      });
    });

    group('copyWith 메서드로 주간 목표 변경', () {
      test('주간 체중 기록 목표만 변경', () {
        // Arrange
        final originalProfile = UserProfile(
          userId: 'test-user-001',
          targetWeight: targetWeight,
          currentWeight: currentWeight,
          weeklyWeightRecordGoal: 7,
          weeklySymptomRecordGoal: 7,
        );

        // Act
        final updatedProfile = originalProfile.copyWith(
          weeklyWeightRecordGoal: 5,
        );

        // Assert
        expect(updatedProfile.weeklyWeightRecordGoal, equals(5));
        expect(updatedProfile.weeklySymptomRecordGoal, equals(7));
        expect(updatedProfile.userId, equals(originalProfile.userId));
      });

      test('주간 부작용 기록 목표만 변경', () {
        // Arrange
        final originalProfile = UserProfile(
          userId: 'test-user-001',
          targetWeight: targetWeight,
          currentWeight: currentWeight,
          weeklyWeightRecordGoal: 7,
          weeklySymptomRecordGoal: 7,
        );

        // Act
        final updatedProfile = originalProfile.copyWith(
          weeklySymptomRecordGoal: 3,
        );

        // Assert
        expect(updatedProfile.weeklyWeightRecordGoal, equals(7));
        expect(updatedProfile.weeklySymptomRecordGoal, equals(3));
        expect(updatedProfile.userId, equals(originalProfile.userId));
      });

      test('두 주간 목표 동시 변경', () {
        // Arrange
        final originalProfile = UserProfile(
          userId: 'test-user-001',
          targetWeight: targetWeight,
          currentWeight: currentWeight,
          weeklyWeightRecordGoal: 7,
          weeklySymptomRecordGoal: 7,
        );

        // Act
        final updatedProfile = originalProfile.copyWith(
          weeklyWeightRecordGoal: 4,
          weeklySymptomRecordGoal: 2,
        );

        // Assert
        expect(updatedProfile.weeklyWeightRecordGoal, equals(4));
        expect(updatedProfile.weeklySymptomRecordGoal, equals(2));
      });

      test('copyWith에서 null 전달 시 기존 값 유지', () {
        // Arrange
        final originalProfile = UserProfile(
          userId: 'test-user-001',
          targetWeight: targetWeight,
          currentWeight: currentWeight,
          weeklyWeightRecordGoal: 5,
          weeklySymptomRecordGoal: 3,
        );

        // Act
        final updatedProfile = originalProfile.copyWith();

        // Assert
        expect(updatedProfile.weeklyWeightRecordGoal, equals(5));
        expect(updatedProfile.weeklySymptomRecordGoal, equals(3));
      });
    });

    group('주간 목표 동등성 검증 (== 연산)', () {
      test('주간 목표가 다르면 다른 Profile로 판단', () {
        // Arrange
        final profile1 = UserProfile(
          userId: 'test-user-001',
          targetWeight: targetWeight,
          currentWeight: currentWeight,
          weeklyWeightRecordGoal: 7,
          weeklySymptomRecordGoal: 7,
        );

        final profile2 = UserProfile(
          userId: 'test-user-001',
          targetWeight: targetWeight,
          currentWeight: currentWeight,
          weeklyWeightRecordGoal: 5,
          weeklySymptomRecordGoal: 3,
        );

        // Assert
        expect(profile1, isNot(equals(profile2)));
      });

      test('주간 목표가 같으면 같은 Profile로 판단', () {
        // Arrange
        final profile1 = UserProfile(
          userId: 'test-user-001',
          targetWeight: targetWeight,
          currentWeight: currentWeight,
          weeklyWeightRecordGoal: 5,
          weeklySymptomRecordGoal: 3,
        );

        final profile2 = UserProfile(
          userId: 'test-user-001',
          targetWeight: targetWeight,
          currentWeight: currentWeight,
          weeklyWeightRecordGoal: 5,
          weeklySymptomRecordGoal: 3,
        );

        // Assert
        expect(profile1, equals(profile2));
      });
    });
  });
}
</file>

<file path="test/features/profile/domain/usecases/update_profile_usecase_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:n06/core/errors/domain_exception.dart';
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/onboarding/domain/value_objects/weight.dart';
import 'package:n06/features/profile/domain/repositories/profile_repository.dart';
import 'package:n06/features/profile/domain/usecases/update_profile_usecase.dart';
import 'package:n06/features/tracking/domain/repositories/tracking_repository.dart';

class MockProfileRepository extends Mock implements ProfileRepository {}

class MockTrackingRepository extends Mock implements TrackingRepository {}

void main() {
  late MockProfileRepository mockProfileRepository;
  late MockTrackingRepository mockTrackingRepository;
  late UpdateProfileUseCase usecase;

  setUp(() {
    mockProfileRepository = MockProfileRepository();
    mockTrackingRepository = MockTrackingRepository();
    usecase = UpdateProfileUseCase(
      profileRepository: mockProfileRepository,
      trackingRepository: mockTrackingRepository,
    );
  });

  group('UpdateProfileUseCase', () {
    group('execute', () {
      test('should update profile successfully with valid data', () async {
        // Arrange
        final profile = UserProfile(
          userId: 'user1',
          targetWeight: Weight.create(70.0),
          currentWeight: Weight.create(80.0),
          targetPeriodWeeks: 10,
          weeklyLossGoalKg: 1.0,
          weeklyWeightRecordGoal: 7,
          weeklySymptomRecordGoal: 7,
        );

        when(() => mockProfileRepository.saveUserProfile(profile))
            .thenAnswer((_) async {});

        // Act
        await usecase.execute(profile);

        // Assert
        verify(() => mockProfileRepository.saveUserProfile(profile)).called(1);
      });

      test('should throw DomainException when target weight is greater than current weight',
          () async {
        // Arrange
        final profile = UserProfile(
          userId: 'user1',
          targetWeight: Weight.create(90.0),
          currentWeight: Weight.create(80.0),
          targetPeriodWeeks: 10,
        );

        // Act & Assert
        expect(
          () => usecase.execute(profile),
          throwsA(isA<DomainException>()),
        );
      });

      test('should throw DomainException when target weight is equal to current weight',
          () async {
        // Arrange
        final profile = UserProfile(
          userId: 'user1',
          targetWeight: Weight.create(80.0),
          currentWeight: Weight.create(80.0),
          targetPeriodWeeks: 10,
        );

        // Act & Assert
        expect(
          () => usecase.execute(profile),
          throwsA(isA<DomainException>()),
        );
      });

      test('should accept profile with null target period weeks', () async {
        // Arrange
        final profile = UserProfile(
          userId: 'user1',
          targetWeight: Weight.create(70.0),
          currentWeight: Weight.create(80.0),
          targetPeriodWeeks: null,
          weeklyLossGoalKg: null,
          weeklyWeightRecordGoal: 7,
          weeklySymptomRecordGoal: 7,
        );

        when(() => mockProfileRepository.saveUserProfile(profile))
            .thenAnswer((_) async {});

        // Act
        await usecase.execute(profile);

        // Assert
        verify(() => mockProfileRepository.saveUserProfile(profile)).called(1);
      });

      test('should propagate repository exception', () async {
        // Arrange
        final profile = UserProfile(
          userId: 'user1',
          targetWeight: Weight.create(70.0),
          currentWeight: Weight.create(80.0),
          targetPeriodWeeks: 10,
        );

        final exception = Exception('Database error');
        when(() => mockProfileRepository.saveUserProfile(profile))
            .thenThrow(exception);

        // Act & Assert
        expect(
          () => usecase.execute(profile),
          throwsException,
        );
      });

      test('should detect weight mismatch with recent weight log', () async {
        // Arrange
        final profile = UserProfile(
          userId: 'user1',
          targetWeight: Weight.create(70.0),
          currentWeight: Weight.create(80.0),
          targetPeriodWeeks: 10,
        );

        // Assume latest weight log has different value
        // This test verifies the warning is returned
        when(() => mockProfileRepository.saveUserProfile(profile))
            .thenAnswer((_) async {});

        // Act
        await usecase.execute(profile);

        // Assert
        verify(() => mockProfileRepository.saveUserProfile(profile)).called(1);
      });
    });
  });
}
</file>

<file path="test/features/settings/presentation/settings_screen_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/settings/presentation/widgets/settings_menu_item.dart';

void main() {
  group('SettingsScreen Widget Tests', () {
    testWidgets('SettingsMenuItem should display title and subtitle',
        (WidgetTester tester) async {
      // Arrange
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: SettingsMenuItem(
              title: 'Test Title',
              subtitle: 'Test Subtitle',
              onTap: () {},
            ),
          ),
        ),
      );

      // Assert
      expect(find.text('Test Title'), findsOneWidget);
      expect(find.text('Test Subtitle'), findsOneWidget);
      expect(find.byIcon(Icons.chevron_right), findsOneWidget);
    });

    testWidgets('SettingsMenuItem should be tappable', (WidgetTester tester) async {
      // Arrange
      bool tapped = false;
      await tester.pumpWidget(
        MaterialApp(
          home: Scaffold(
            body: SettingsMenuItem(
              title: 'Test Title',
              subtitle: 'Test Subtitle',
              onTap: () => tapped = true,
            ),
          ),
        ),
      );

      // Act
      await tester.tap(find.byType(ListTile));

      // Assert
      expect(tapped, isTrue);
    });
  });
}
</file>

<file path="test/features/tracking/application/notifiers/emergency_check_notifier_test.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:n06/features/tracking/application/providers.dart';
import 'package:n06/features/tracking/domain/entities/emergency_symptom_check.dart';
import 'package:n06/features/tracking/domain/repositories/emergency_check_repository.dart';
import 'package:n06/features/tracking/domain/repositories/tracking_repository.dart';

class MockEmergencyCheckRepository extends Mock
    implements EmergencyCheckRepository {}

class MockTrackingRepository extends Mock implements TrackingRepository {}

void main() {
  group('EmergencyCheckNotifier', () {
    late MockEmergencyCheckRepository mockEmergencyCheckRepository;
    late MockTrackingRepository mockTrackingRepository;
    late ProviderContainer container;

    setUp(() {
      mockEmergencyCheckRepository = MockEmergencyCheckRepository();
      mockTrackingRepository = MockTrackingRepository();
    });

    test('초기 상태는 loading', () async {
      // Arrange
      when(() => mockEmergencyCheckRepository.getEmergencyChecks(any()))
          .thenAnswer((_) async => []);

      container = ProviderContainer(
        overrides: [
          emergencyCheckRepositoryProvider
              .overrideWithValue(mockEmergencyCheckRepository),
        ],
      );

      // Act
      final state = container.read(emergencyCheckNotifierProvider);

      // Assert
      expect(state, isA<AsyncLoading>());
    });

    test('증상 체크 저장 성공 시, 상태 갱신', () async {
      // Arrange
      final check = EmergencySymptomCheck(
        id: 'test-id',
        userId: 'user-123',
        checkedAt: DateTime.now(),
        checkedSymptoms: ['증상1'],
      );

      when(() => mockEmergencyCheckRepository.saveEmergencyCheck(check))
          .thenAnswer((_) async => {});
      when(() => mockTrackingRepository.saveSymptomLog(any()))
          .thenAnswer((_) async => {});
      when(() => mockEmergencyCheckRepository.getEmergencyChecks('user-123'))
          .thenAnswer((_) async => [check]);

      container = ProviderContainer(
        overrides: [
          emergencyCheckRepositoryProvider
              .overrideWithValue(mockEmergencyCheckRepository),
          trackingRepositoryProvider.overrideWithValue(mockTrackingRepository),
        ],
      );

      // Act
      final notifier = container.read(emergencyCheckNotifierProvider.notifier);
      await notifier.saveEmergencyCheck('user-123', check);

      // Assert
      verify(() => mockEmergencyCheckRepository.saveEmergencyCheck(check))
          .called(1);
    });
  });
}
</file>

<file path="test/features/tracking/application/notifiers/tracking_notifier_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/domain/repositories/tracking_repository.dart';

class MockTrackingRepository extends Mock implements TrackingRepository {}

void main() {
  group('TrackingNotifier', () {
    late MockTrackingRepository mockRepository;

    setUp(() {
      mockRepository = MockTrackingRepository();
    });

    // TC-TN-01: 체중 기록 저장
    test('should save WeightLog', () async {
      // Arrange
      final log = WeightLog(
        id: 'wl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        weightKg: 75.5,
        createdAt: DateTime.now(),
      );

      when(() => mockRepository.saveWeightLog(any()))
          .thenAnswer((_) async => {});

      // Act
      await mockRepository.saveWeightLog(log);

      // Assert
      verify(() => mockRepository.saveWeightLog(log)).called(1);
    });

    // TC-TN-02: 중복 체중 기록 확인
    test('should check for existing weight log on date', () async {
      // Arrange
      final existingLog = WeightLog(
        id: 'wl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        weightKg: 75.5,
        createdAt: DateTime.now(),
      );

      when(() => mockRepository.getWeightLog('user-001', DateTime(2025, 11, 7)))
          .thenAnswer((_) async => existingLog);

      // Act
      final result = await mockRepository.getWeightLog('user-001', DateTime(2025, 11, 7));

      // Assert
      expect(result, isNotNull);
      expect(result!.weightKg, 75.5);
      verify(() => mockRepository.getWeightLog('user-001', DateTime(2025, 11, 7))).called(1);
    });

    // TC-TN-03: 중복 없는 날짜 확인
    test('should return null when no weight log exists on date', () async {
      // Arrange
      when(() => mockRepository.getWeightLog('user-001', DateTime(2025, 11, 7)))
          .thenAnswer((_) async => null);

      // Act
      final result = await mockRepository.getWeightLog('user-001', DateTime(2025, 11, 7));

      // Assert
      expect(result, isNull);
    });

    // TC-TN-04: 증상 기록 저장
    test('should save SymptomLog', () async {
      // Arrange
      final log = SymptomLog(
        id: 'sl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        symptomName: '메스꺼움',
        severity: 4,
      );

      when(() => mockRepository.saveSymptomLog(any()))
          .thenAnswer((_) async => {});

      // Act
      await mockRepository.saveSymptomLog(log);

      // Assert
      verify(() => mockRepository.saveSymptomLog(log)).called(1);
    });

    // TC-TN-05: 기록 삭제
    test('should delete WeightLog', () async {
      // Arrange
      when(() => mockRepository.deleteWeightLog('wl-001'))
          .thenAnswer((_) async => {});

      // Act
      await mockRepository.deleteWeightLog('wl-001');

      // Assert
      verify(() => mockRepository.deleteWeightLog('wl-001')).called(1);
    });

    // TC-TN-06: 기록 업데이트
    test('should update WeightLog', () async {
      // Arrange
      when(() => mockRepository.updateWeightLog('wl-001', 74.8))
          .thenAnswer((_) async => {});

      // Act
      await mockRepository.updateWeightLog('wl-001', 74.8);

      // Assert
      verify(() => mockRepository.updateWeightLog('wl-001', 74.8)).called(1);
    });

    // TC-TN-07: 증상 기록 업데이트
    test('should update SymptomLog', () async {
      // Arrange
      final log = SymptomLog(
        id: 'sl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        symptomName: '메스꺼움',
        severity: 7,
      );

      when(() => mockRepository.updateSymptomLog('sl-001', any()))
          .thenAnswer((_) async => {});

      // Act
      await mockRepository.updateSymptomLog('sl-001', log);

      // Assert
      verify(() => mockRepository.updateSymptomLog('sl-001', any())).called(1);
    });

    // TC-TN-08: 여러 기록 조회
    test('should get multiple weight logs', () async {
      // Arrange
      final logs = [
        WeightLog(
          id: 'wl-001',
          userId: 'user-001',
          logDate: DateTime(2025, 11, 7),
          weightKg: 75.5,
          createdAt: DateTime.now(),
        ),
        WeightLog(
          id: 'wl-002',
          userId: 'user-001',
          logDate: DateTime(2025, 11, 6),
          weightKg: 76.0,
          createdAt: DateTime.now(),
        ),
      ];

      when(() => mockRepository.getWeightLogs('user-001'))
          .thenAnswer((_) async => logs);

      // Act
      final result = await mockRepository.getWeightLogs('user-001');

      // Assert
      expect(result.length, 2);
      verify(() => mockRepository.getWeightLogs('user-001')).called(1);
    });

    // TC-TN-09: 증상 기록 삭제
    test('should delete SymptomLog', () async {
      // Arrange
      when(() => mockRepository.deleteSymptomLog('sl-001'))
          .thenAnswer((_) async => {});

      // Act
      await mockRepository.deleteSymptomLog('sl-001');

      // Assert
      verify(() => mockRepository.deleteSymptomLog('sl-001')).called(1);
    });

    // TC-TN-10: 태그 기반 조회
    test('should get symptom logs by tag', () async {
      // Arrange
      final logs = [
        SymptomLog(
          id: 'sl-001',
          userId: 'user-001',
          logDate: DateTime(2025, 11, 7),
          symptomName: '메스꺼움',
          severity: 4,
          tags: const ['기름진음식'],
        ),
      ];

      when(() => mockRepository.getSymptomLogsByTag('기름진음식'))
          .thenAnswer((_) async => logs);

      // Act
      final result = await mockRepository.getSymptomLogsByTag('기름진음식');

      // Assert
      expect(result.length, 1);
      verify(() => mockRepository.getSymptomLogsByTag('기름진음식')).called(1);
    });
  });
}
</file>

<file path="test/features/tracking/domain/entities/dose_record_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';

void main() {
  group('DoseRecord', () {
    test('should create dose record with required fields', () {
      final record = DoseRecord(
        id: 'record-1',
        dosagePlanId: 'plan-1',
        administeredAt: DateTime(2025, 1, 8, 10, 0),
        actualDoseMg: 0.25,
        isCompleted: true,
      );

      expect(record.id, 'record-1');
      expect(record.dosagePlanId, 'plan-1');
      expect(record.actualDoseMg, 0.25);
      expect(record.isCompleted, true);
    });

    test('should throw exception when administered date is in future', () {
      expect(
        () => DoseRecord(
          id: 'record-1',
          dosagePlanId: 'plan-1',
          administeredAt: DateTime.now().add(Duration(hours: 1)),
          actualDoseMg: 0.25,
        ),
        throwsArgumentError,
      );
    });

    test('should throw exception when actual dose is negative', () {
      expect(
        () => DoseRecord(
          id: 'record-1',
          dosagePlanId: 'plan-1',
          administeredAt: DateTime.now(),
          actualDoseMg: -0.25,
        ),
        throwsArgumentError,
      );
    });

    test('should throw exception for invalid injection site', () {
      expect(
        () => DoseRecord(
          id: 'record-1',
          dosagePlanId: 'plan-1',
          administeredAt: DateTime.now(),
          actualDoseMg: 0.25,
          injectionSite: 'invalid_site',
        ),
        throwsArgumentError,
      );
    });

    test('should validate valid injection sites', () {
      final abdomen = DoseRecord(
        id: 'record-1',
        dosagePlanId: 'plan-1',
        administeredAt: DateTime.now(),
        actualDoseMg: 0.25,
        injectionSite: 'abdomen',
      );
      expect(abdomen.injectionSite, 'abdomen');

      final thigh = DoseRecord(
        id: 'record-2',
        dosagePlanId: 'plan-1',
        administeredAt: DateTime.now(),
        actualDoseMg: 0.25,
        injectionSite: 'thigh',
      );
      expect(thigh.injectionSite, 'thigh');

      final arm = DoseRecord(
        id: 'record-3',
        dosagePlanId: 'plan-1',
        administeredAt: DateTime.now(),
        actualDoseMg: 0.25,
        injectionSite: 'arm',
      );
      expect(arm.injectionSite, 'arm');
    });

    group('state checking', () {
      test('should detect if record is completed', () {
        final record = DoseRecord(
          id: 'record-1',
          dosagePlanId: 'plan-1',
          administeredAt: DateTime.now(),
          actualDoseMg: 0.25,
          isCompleted: true,
        );

        expect(record.isCompleted, true);
      });

      test('should calculate days since administration', () {
        final record = DoseRecord(
          id: 'record-1',
          dosagePlanId: 'plan-1',
          administeredAt: DateTime.now().subtract(Duration(days: 3)),
          actualDoseMg: 0.25,
        );

        expect(record.daysSinceAdministration(), 3);
      });
    });

    group('copyWith', () {
      test('should copy record with updated fields', () {
        final original = DoseRecord(
          id: 'record-1',
          dosagePlanId: 'plan-1',
          administeredAt: DateTime(2025, 1, 8, 10, 0),
          actualDoseMg: 0.25,
        );

        final updated = original.copyWith(
          injectionSite: 'abdomen',
          note: 'Left abdomen',
        );

        expect(updated.id, original.id);
        expect(updated.actualDoseMg, original.actualDoseMg);
        expect(updated.injectionSite, 'abdomen');
        expect(updated.note, 'Left abdomen');
      });
    });
  });
}
</file>

<file path="test/features/tracking/domain/entities/dose_schedule_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';

void main() {
  group('DoseSchedule', () {
    test('should create dose schedule with valid data', () {
      final schedule = DoseSchedule(
        id: 'schedule-1',
        dosagePlanId: 'plan-1',
        scheduledDate: DateTime(2025, 1, 8),
        scheduledDoseMg: 0.25,
      );

      expect(schedule.id, 'schedule-1');
      expect(schedule.dosagePlanId, 'plan-1');
      expect(schedule.scheduledDoseMg, 0.25);
    });

    group('date comparisons', () {
      test('should detect if schedule is overdue', () {
        final schedule = DoseSchedule(
          id: 'schedule-1',
          dosagePlanId: 'plan-1',
          scheduledDate: DateTime.now().subtract(Duration(days: 1)),
          scheduledDoseMg: 0.25,
        );

        expect(schedule.isOverdue(), true);
      });

      test('should detect if schedule is today', () {
        final today = DateTime.now();
        final schedule = DoseSchedule(
          id: 'schedule-1',
          dosagePlanId: 'plan-1',
          scheduledDate: DateTime(today.year, today.month, today.day),
          scheduledDoseMg: 0.25,
        );

        expect(schedule.isToday(), true);
      });

      test('should detect if schedule is upcoming', () {
        final schedule = DoseSchedule(
          id: 'schedule-1',
          dosagePlanId: 'plan-1',
          scheduledDate: DateTime.now().add(Duration(days: 1)),
          scheduledDoseMg: 0.25,
        );

        expect(schedule.isUpcoming(), true);
      });

      test('should calculate days until scheduled date', () {
        final schedule = DoseSchedule(
          id: 'schedule-1',
          dosagePlanId: 'plan-1',
          scheduledDate: DateTime.now().add(Duration(days: 5)),
          scheduledDoseMg: 0.25,
        );

        final daysUntil = schedule.daysUntil();
        expect(daysUntil, 5);
      });

      test('should handle negative days (overdue)', () {
        final schedule = DoseSchedule(
          id: 'schedule-1',
          dosagePlanId: 'plan-1',
          scheduledDate: DateTime.now().subtract(Duration(days: 3)),
          scheduledDoseMg: 0.25,
        );

        final daysUntil = schedule.daysUntil();
        expect(daysUntil, -3);
      });
    });

    group('copyWith', () {
      test('should copy schedule with updated fields', () {
        final original = DoseSchedule(
          id: 'schedule-1',
          dosagePlanId: 'plan-1',
          scheduledDate: DateTime(2025, 1, 8),
          scheduledDoseMg: 0.25,
        );

        final updated = original.copyWith(
          scheduledDoseMg: 0.5,
        );

        expect(updated.id, original.id);
        expect(updated.dosagePlanId, original.dosagePlanId);
        expect(updated.scheduledDoseMg, 0.5);
      });
    });
  });
}
</file>

<file path="test/features/tracking/domain/entities/emergency_symptom_check_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/emergency_symptom_check.dart';

void main() {
  group('EmergencySymptomCheck Entity', () {
    test('주어진 필수 필드로 생성 시, 올바른 인스턴스 반환', () {
      // Arrange
      final id = 'test-id';
      final userId = 'user-123';
      final checkedAt = DateTime(2025, 1, 1, 10, 0);
      final symptoms = ['24시간 이상 계속 구토'];

      // Act
      final entity = EmergencySymptomCheck(
        id: id,
        userId: userId,
        checkedAt: checkedAt,
        checkedSymptoms: symptoms,
      );

      // Assert
      expect(entity.id, id);
      expect(entity.userId, userId);
      expect(entity.checkedAt, checkedAt);
      expect(entity.checkedSymptoms, symptoms);
    });

    test('여러 증상 선택 시, 모든 증상 포함', () {
      // Arrange
      final symptoms = [
        '24시간 이상 계속 구토',
        '물이나 음식을 전혀 삼킬 수 없어요'
      ];

      // Act
      final entity = EmergencySymptomCheck(
        id: 'test-id',
        userId: 'user-123',
        checkedAt: DateTime.now(),
        checkedSymptoms: symptoms,
      );

      // Assert
      expect(entity.checkedSymptoms.length, 2);
      expect(entity.checkedSymptoms, containsAll(symptoms));
    });

    test('빈 증상 리스트로 생성 시, 예외 발생하지 않음', () {
      // Arrange & Act
      final entity = EmergencySymptomCheck(
        id: 'test-id',
        userId: 'user-123',
        checkedAt: DateTime.now(),
        checkedSymptoms: [],
      );

      // Assert
      expect(entity.checkedSymptoms, isEmpty);
    });

    test('동일한 필드로 생성된 두 인스턴스는 동등', () {
      // Arrange
      final id = 'test-id';
      final userId = 'user-123';
      final checkedAt = DateTime(2025, 1, 1);
      final symptoms = ['24시간 이상 계속 구토'];

      // Act
      final entity1 = EmergencySymptomCheck(
        id: id,
        userId: userId,
        checkedAt: checkedAt,
        checkedSymptoms: symptoms,
      );
      final entity2 = EmergencySymptomCheck(
        id: id,
        userId: userId,
        checkedAt: checkedAt,
        checkedSymptoms: symptoms,
      );

      // Assert
      expect(entity1, equals(entity2));
      expect(entity1.hashCode, equals(entity2.hashCode));
    });

    test('copyWith 메서드로 필드 수정 시, 새로운 인스턴스 생성', () {
      // Arrange
      final original = EmergencySymptomCheck(
        id: 'test-id',
        userId: 'user-123',
        checkedAt: DateTime(2025, 1, 1),
        checkedSymptoms: ['증상1'],
      );

      // Act
      final updated = original.copyWith(
        checkedSymptoms: ['증상1', '증상2'],
      );

      // Assert
      expect(updated.id, original.id);
      expect(updated.userId, original.userId);
      expect(updated.checkedAt, original.checkedAt);
      expect(updated.checkedSymptoms.length, 2);
      expect(original.checkedSymptoms.length, 1);
    });
  });
}
</file>

<file path="test/features/tracking/domain/entities/symptom_log_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';

void main() {
  group('SymptomLog Entity', () {
    // TC-SL-01: 정상 생성 (경증, 심각도 1-6점)
    test('should create SymptomLog with severity 1-6', () {
      // Arrange & Act
      final symptomLog = SymptomLog(
        id: 'sl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        symptomName: '메스꺼움',
        severity: 4,
        daysSinceEscalation: 3,
        tags: const ['기름진음식', '과식'],
      );

      // Assert
      expect(symptomLog.severity, 4);
      expect(symptomLog.isPersistent24h, isNull);
      expect(symptomLog.tags.length, 2);
    });

    // TC-SL-02: 중증 생성 (심각도 7-10점, 24시간 지속)
    test('should create SymptomLog with severity 7-10 and persistent flag', () {
      // Arrange & Act
      final symptomLog = SymptomLog(
        id: 'sl-002',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        symptomName: '구토',
        severity: 9,
        daysSinceEscalation: 5,
        isPersistent24h: true,
      );

      // Assert
      expect(symptomLog.severity, 9);
      expect(symptomLog.isPersistent24h, isTrue);
    });

    // TC-SL-03: 심각도 범위 검증 (1-10)
    test('should throw exception for invalid severity (0)', () {
      // Act & Assert
      expect(
        () => SymptomLog(
          id: 'sl-003',
          userId: 'user-001',
          logDate: DateTime.now(),
          symptomName: '메스꺼움',
          severity: 0,
        ),
        throwsA(isA<ArgumentError>()),
      );
    });

    // TC-SL-03-b: 심각도 범위 검증 (1-10)
    test('should throw exception for invalid severity (11)', () {
      // Act & Assert
      expect(
        () => SymptomLog(
          id: 'sl-003',
          userId: 'user-001',
          logDate: DateTime.now(),
          symptomName: '메스꺼움',
          severity: 11,
        ),
        throwsA(isA<ArgumentError>()),
      );
    });

    // TC-SL-04: 경과일 미계산 (증량 이력 없음)
    test('should allow null daysSinceEscalation', () {
      // Arrange & Act
      final symptomLog = SymptomLog(
        id: 'sl-004',
        userId: 'user-001',
        logDate: DateTime.now(),
        symptomName: '복통',
        severity: 3,
        daysSinceEscalation: null,
      );

      // Assert
      expect(symptomLog.daysSinceEscalation, isNull);
    });

    // TC-SL-05: copyWith 정상 동작
    test('should copy SymptomLog with updated severity', () {
      // Arrange
      final original = SymptomLog(
        id: 'sl-005',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        symptomName: '메스꺼움',
        severity: 4,
      );

      // Act
      final updated = original.copyWith(severity: 7, isPersistent24h: true);

      // Assert
      expect(updated.severity, 7);
      expect(updated.isPersistent24h, isTrue);
      expect(updated.id, original.id);
      expect(updated.userId, original.userId);
    });

    // TC-SL-06: Equality 비교
    test('should compare two SymptomLog entities correctly', () {
      // Arrange
      final now = DateTime.now();
      final log1 = SymptomLog(
        id: 'sl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        symptomName: '메스꺼움',
        severity: 4,
        createdAt: now,
      );
      final log2 = SymptomLog(
        id: 'sl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        symptomName: '메스꺼움',
        severity: 4,
        createdAt: now,
      );

      // Act & Assert
      expect(log1 == log2, isTrue);
    });

    // TC-SL-07: 기본 태그 빈 리스트
    test('should have empty tags by default', () {
      // Arrange & Act
      final symptomLog = SymptomLog(
        id: 'sl-007',
        userId: 'user-001',
        logDate: DateTime.now(),
        symptomName: '두통',
        severity: 5,
      );

      // Assert
      expect(symptomLog.tags, isEmpty);
    });

    // TC-SL-08: toString 메서드 존재
    test('should have toString method', () {
      // Arrange
      final log = SymptomLog(
        id: 'sl-008',
        userId: 'user-001',
        logDate: DateTime.now(),
        symptomName: '피로',
        severity: 3,
      );

      // Act
      final str = log.toString();

      // Assert
      expect(str, isNotEmpty);
      expect(str, contains('SymptomLog'));
    });
  });
}
</file>

<file path="test/features/tracking/domain/entities/weight_log_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';

void main() {
  group('WeightLog Entity', () {
    // TC-WL-01: 정상 생성
    test('should create WeightLog with valid data', () {
      // Arrange
      final id = 'wl-001';
      final userId = 'user-001';
      final logDate = DateTime(2025, 11, 7);
      final weightKg = 75.5;
      final createdAt = DateTime.now();

      // Act
      final weightLog = WeightLog(
        id: id,
        userId: userId,
        logDate: logDate,
        weightKg: weightKg,
        createdAt: createdAt,
      );

      // Assert
      expect(weightLog.id, id);
      expect(weightLog.userId, userId);
      expect(weightLog.logDate, logDate);
      expect(weightLog.weightKg, weightKg);
      expect(weightLog.createdAt, createdAt);
    });

    // TC-WL-02: copyWith 정상 동작
    test('should copy WeightLog with updated weightKg', () {
      // Arrange
      final original = WeightLog(
        id: 'wl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        weightKg: 75.5,
        createdAt: DateTime.now(),
      );

      // Act
      final updated = original.copyWith(weightKg: 74.8);

      // Assert
      expect(updated.weightKg, 74.8);
      expect(updated.id, original.id);
      expect(updated.userId, original.userId);
      expect(updated.logDate, original.logDate);
      expect(updated.createdAt, original.createdAt);
    });

    // TC-WL-03: Equality 비교
    test('should compare two WeightLog entities correctly', () {
      // Arrange
      final now = DateTime.now();
      final log1 = WeightLog(
        id: 'wl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        weightKg: 75.5,
        createdAt: now,
      );
      final log2 = WeightLog(
        id: 'wl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        weightKg: 75.5,
        createdAt: now,
      );

      // Act & Assert
      expect(log1 == log2, isTrue);
    });

    // TC-WL-04: toString 메서드 존재
    test('should have toString method', () {
      // Arrange
      final log = WeightLog(
        id: 'wl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        weightKg: 75.5,
        createdAt: DateTime.now(),
      );

      // Act
      final str = log.toString();

      // Assert
      expect(str, isNotEmpty);
      expect(str, contains('WeightLog'));
    });
  });
}
</file>

<file path="test/features/tracking/domain/repositories/emergency_check_repository_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import 'package:n06/features/tracking/domain/entities/emergency_symptom_check.dart';
import 'package:n06/features/tracking/domain/repositories/emergency_check_repository.dart';

class MockEmergencyCheckRepository extends Mock
    implements EmergencyCheckRepository {}

void main() {
  group('EmergencyCheckRepository Interface', () {
    late MockEmergencyCheckRepository mockRepository;

    setUp(() {
      mockRepository = MockEmergencyCheckRepository();
    });

    test('saveEmergencyCheck 호출 시, Future<void> 반환', () async {
      // Arrange
      final check = EmergencySymptomCheck(
        id: 'test-id',
        userId: 'user-123',
        checkedAt: DateTime.now(),
        checkedSymptoms: ['증상1'],
      );
      when(() => mockRepository.saveEmergencyCheck(check))
          .thenAnswer((_) async => {});

      // Act
      await mockRepository.saveEmergencyCheck(check);

      // Assert
      verify(() => mockRepository.saveEmergencyCheck(check)).called(1);
    });

    test('getEmergencyChecks 호출 시, List<EmergencySymptomCheck> 반환', () async {
      // Arrange
      final checks = [
        EmergencySymptomCheck(
          id: '1',
          userId: 'user-123',
          checkedAt: DateTime.now(),
          checkedSymptoms: ['증상1'],
        ),
      ];
      when(() => mockRepository.getEmergencyChecks('user-123'))
          .thenAnswer((_) async => checks);

      // Act
      final result = await mockRepository.getEmergencyChecks('user-123');

      // Assert
      expect(result, checks);
      verify(() => mockRepository.getEmergencyChecks('user-123')).called(1);
    });

    test('deleteEmergencyCheck 호출 시, Future<void> 반환', () async {
      // Arrange
      when(() => mockRepository.deleteEmergencyCheck('test-id'))
          .thenAnswer((_) async => {});

      // Act
      await mockRepository.deleteEmergencyCheck('test-id');

      // Assert
      verify(() => mockRepository.deleteEmergencyCheck('test-id')).called(1);
    });

    test('updateEmergencyCheck 호출 시, Future<void> 반환', () async {
      // Arrange
      final check = EmergencySymptomCheck(
        id: 'test-id',
        userId: 'user-123',
        checkedAt: DateTime.now(),
        checkedSymptoms: ['증상1'],
      );
      when(() => mockRepository.updateEmergencyCheck(check))
          .thenAnswer((_) async => {});

      // Act
      await mockRepository.updateEmergencyCheck(check);

      // Assert
      verify(() => mockRepository.updateEmergencyCheck(check)).called(1);
    });
  });
}
</file>

<file path="test/features/tracking/domain/usecases/analyze_plan_change_impact_usecase_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';
import 'package:n06/features/tracking/domain/usecases/analyze_plan_change_impact_usecase.dart';

void main() {
  group('AnalyzePlanChangeImpactUseCase', () {
    late AnalyzePlanChangeImpactUseCase useCase;

    setUp(() {
      useCase = AnalyzePlanChangeImpactUseCase();
    });

    test('should detect no changes when plans are identical', () {
      // Arrange
      final plan = DosagePlan(
        id: 'plan-1',
        userId: 'user-1',
        medicationName: 'Ozempic',
        startDate: DateTime(2025, 1, 1),
        cycleDays: 7,
        initialDoseMg: 0.25,
      );

      // Act
      final impact = useCase.execute(
        oldPlan: plan,
        newPlan: plan,
        fromDate: DateTime.now(),
      );

      // Assert
      expect(impact.hasChanges, false);
      expect(impact.changedFields.isEmpty, true);
      expect(impact.affectedScheduleCount, 0);
    });

    test('should detect medication name change', () {
      // Arrange
      final oldPlan = DosagePlan(
        id: 'plan-1',
        userId: 'user-1',
        medicationName: 'Ozempic',
        startDate: DateTime(2025, 1, 1),
        cycleDays: 7,
        initialDoseMg: 0.25,
      );
      final newPlan = oldPlan.copyWith(medicationName: 'Wegovy');

      // Act
      final impact = useCase.execute(
        oldPlan: oldPlan,
        newPlan: newPlan,
        fromDate: DateTime.now(),
      );

      // Assert
      expect(impact.hasChanges, true);
      expect(impact.changedFields, contains('medicationName'));
    });

    test('should detect start date change', () {
      // Arrange
      final oldPlan = DosagePlan(
        id: 'plan-1',
        userId: 'user-1',
        medicationName: 'Ozempic',
        startDate: DateTime(2025, 1, 1),
        cycleDays: 7,
        initialDoseMg: 0.25,
      );
      final newPlan = oldPlan.copyWith(startDate: DateTime(2025, 1, 15));

      // Act
      final impact = useCase.execute(
        oldPlan: oldPlan,
        newPlan: newPlan,
        fromDate: DateTime.now(),
      );

      // Assert
      expect(impact.hasChanges, true);
      expect(impact.changedFields, contains('startDate'));
    });

    test('should detect cycle days change', () {
      // Arrange
      final oldPlan = DosagePlan(
        id: 'plan-1',
        userId: 'user-1',
        medicationName: 'Ozempic',
        startDate: DateTime(2025, 1, 1),
        cycleDays: 7,
        initialDoseMg: 0.25,
      );
      final newPlan = oldPlan.copyWith(cycleDays: 14);

      // Act
      final impact = useCase.execute(
        oldPlan: oldPlan,
        newPlan: newPlan,
        fromDate: DateTime.now(),
      );

      // Assert
      expect(impact.hasChanges, true);
      expect(impact.changedFields, contains('cycleDays'));
    });

    test('should detect initial dose change', () {
      // Arrange
      final oldPlan = DosagePlan(
        id: 'plan-1',
        userId: 'user-1',
        medicationName: 'Ozempic',
        startDate: DateTime(2025, 1, 1),
        cycleDays: 7,
        initialDoseMg: 0.25,
      );
      final newPlan = oldPlan.copyWith(initialDoseMg: 0.5);

      // Act
      final impact = useCase.execute(
        oldPlan: oldPlan,
        newPlan: newPlan,
        fromDate: DateTime.now(),
      );

      // Assert
      expect(impact.hasChanges, true);
      expect(impact.changedFields, contains('initialDoseMg'));
    });

    test('should detect escalation plan change', () {
      // Arrange
      final oldPlan = DosagePlan(
        id: 'plan-1',
        userId: 'user-1',
        medicationName: 'Ozempic',
        startDate: DateTime(2025, 1, 1),
        cycleDays: 7,
        initialDoseMg: 0.25,
        escalationPlan: [
          const EscalationStep(weeksFromStart: 4, doseMg: 0.5),
        ],
      );
      final newPlan = oldPlan.copyWith(
        escalationPlan: [
          const EscalationStep(weeksFromStart: 4, doseMg: 1.0),
        ],
      );

      // Act
      final impact = useCase.execute(
        oldPlan: oldPlan,
        newPlan: newPlan,
        fromDate: DateTime.now(),
      );

      // Assert
      expect(impact.hasChanges, true);
      expect(impact.changedFields, contains('escalationPlan'));
      expect(impact.hasEscalationChange, true);
    });

    test('should calculate affected schedule count', () {
      // Arrange
      final oldPlan = DosagePlan(
        id: 'plan-1',
        userId: 'user-1',
        medicationName: 'Ozempic',
        startDate: DateTime(2025, 1, 1),
        cycleDays: 7,
        initialDoseMg: 0.25,
      );
      final newPlan = oldPlan.copyWith(cycleDays: 14);

      // Act
      final impact = useCase.execute(
        oldPlan: oldPlan,
        newPlan: newPlan,
        fromDate: DateTime.now(),
      );

      // Assert
      expect(impact.affectedScheduleCount, greaterThan(0));
    });

    test('should generate warning for significant dose change', () {
      // Arrange
      final oldPlan = DosagePlan(
        id: 'plan-1',
        userId: 'user-1',
        medicationName: 'Ozempic',
        startDate: DateTime(2025, 1, 1),
        cycleDays: 7,
        initialDoseMg: 0.25,
      );
      final newPlan = oldPlan.copyWith(initialDoseMg: 0.6); // > 20% increase

      // Act
      final impact = useCase.execute(
        oldPlan: oldPlan,
        newPlan: newPlan,
        fromDate: DateTime.now(),
      );

      // Assert
      expect(impact.warningMessage, isNotNull);
      expect(impact.warningMessage, contains('용량'));
    });

    test('should detect multiple changes', () {
      // Arrange
      final oldPlan = DosagePlan(
        id: 'plan-1',
        userId: 'user-1',
        medicationName: 'Ozempic',
        startDate: DateTime(2025, 1, 1),
        cycleDays: 7,
        initialDoseMg: 0.25,
      );
      final newPlan = oldPlan.copyWith(
        medicationName: 'Wegovy',
        cycleDays: 14,
        initialDoseMg: 0.5,
      );

      // Act
      final impact = useCase.execute(
        oldPlan: oldPlan,
        newPlan: newPlan,
        fromDate: DateTime.now(),
      );

      // Assert
      expect(impact.changedFields.length, 3);
      expect(impact.changedFields, contains('medicationName'));
      expect(impact.changedFields, contains('cycleDays'));
      expect(impact.changedFields, contains('initialDoseMg'));
    });
  });
}
</file>

<file path="test/features/tracking/domain/usecases/recalculate_dose_schedule_usecase_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';
import 'package:n06/features/tracking/domain/usecases/recalculate_dose_schedule_usecase.dart';

void main() {
  group('RecalculateDoseScheduleUseCase', () {
    late RecalculateDoseScheduleUseCase useCase;

    setUp(() {
      useCase = RecalculateDoseScheduleUseCase();
    });

    test('should generate schedules with correct cycle', () {
      // Arrange
      final startDate = DateTime(2025, 1, 1);
      final plan = DosagePlan(
        id: 'plan-1',
        userId: 'user-1',
        medicationName: 'Ozempic',
        startDate: startDate,
        cycleDays: 7,
        initialDoseMg: 0.25,
      );

      // Act
      final schedules = useCase.execute(plan, fromDate: startDate);

      // Assert
      expect(schedules.isNotEmpty, true);
      expect(schedules[0].scheduledDate, startDate);
      expect(schedules[0].scheduledDoseMg, 0.25);
      expect(schedules[1].scheduledDate, startDate.add(Duration(days: 7)));
    });

    test('should apply escalation plan to schedules', () {
      // Arrange
      final startDate = DateTime(2025, 1, 1);
      final escalationPlan = [
        const EscalationStep(weeksFromStart: 4, doseMg: 0.5),
        const EscalationStep(weeksFromStart: 8, doseMg: 1.0),
      ];
      final plan = DosagePlan(
        id: 'plan-1',
        userId: 'user-1',
        medicationName: 'Ozempic',
        startDate: startDate,
        cycleDays: 7,
        initialDoseMg: 0.25,
        escalationPlan: escalationPlan,
      );

      // Act
      final schedules = useCase.execute(plan, fromDate: startDate, generationDays: 70);

      // Assert - Check that we have schedules with escalation
      expect(schedules.length, greaterThan(0));
      expect(schedules[0].scheduledDoseMg, 0.25);
      // Check that we have multiple different doses (showing escalation is applied)
      final doses = schedules.map((s) => s.scheduledDoseMg).toSet();
      expect(doses.length, greaterThan(1), reason: 'Should have different doses due to escalation');
    });

    test('should only generate schedules after fromDate', () {
      // Arrange
      final startDate = DateTime(2025, 1, 1);
      final fromDate = DateTime(2025, 1, 15);
      final plan = DosagePlan(
        id: 'plan-1',
        userId: 'user-1',
        medicationName: 'Ozempic',
        startDate: startDate,
        cycleDays: 7,
        initialDoseMg: 0.25,
      );

      // Act
      final schedules = useCase.execute(plan, fromDate: fromDate, generationDays: 30);

      // Assert
      expect(schedules.every((s) => s.scheduledDate.isAfter(fromDate) ||
          s.scheduledDate.day == fromDate.day), true);
    });

    test('should generate schedules with correct plan id', () {
      // Arrange
      final plan = DosagePlan(
        id: 'plan-1',
        userId: 'user-1',
        medicationName: 'Ozempic',
        startDate: DateTime(2025, 1, 1),
        cycleDays: 7,
        initialDoseMg: 0.25,
      );

      // Act
      final schedules = useCase.execute(plan, generationDays: 14);

      // Assert
      expect(schedules.every((s) => s.dosagePlanId == 'plan-1'), true);
    });

    test('should generate unique schedule IDs', () {
      // Arrange
      final plan = DosagePlan(
        id: 'plan-1',
        userId: 'user-1',
        medicationName: 'Ozempic',
        startDate: DateTime(2025, 1, 1),
        cycleDays: 7,
        initialDoseMg: 0.25,
      );

      // Act
      final schedules = useCase.execute(plan, generationDays: 30);

      // Assert
      final ids = schedules.map((s) => s.id).toList();
      expect(ids.length, ids.toSet().length, reason: 'All IDs should be unique');
    });
  });
}
</file>

<file path="test/features/tracking/domain/usecases/validate_dosage_plan_usecase_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';
import 'package:n06/features/tracking/domain/usecases/validate_dosage_plan_usecase.dart';

void main() {
  group('ValidateDosagePlanUseCase', () {
    late ValidateDosagePlanUseCase useCase;

    setUp(() {
      useCase = ValidateDosagePlanUseCase();
    });

    group('valid dosage plan', () {
      test('should return success for valid dosage plan', () {
        // Arrange
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
        );

        // Act
        final result = useCase.validate(plan);

        // Assert
        expect(result.isValid, true);
        expect(result.errorMessage, isNull);
      });

      test('should return success for valid dosage plan with escalation', () {
        // Arrange
        final escalationPlan = [
          const EscalationStep(weeksFromStart: 4, doseMg: 0.5),
          const EscalationStep(weeksFromStart: 8, doseMg: 1.0),
        ];
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
          escalationPlan: escalationPlan,
        );

        // Act
        final result = useCase.validate(plan);

        // Assert
        expect(result.isValid, true);
      });
    });

    group('validates plan structure', () {
      test('should validate medication name is not empty', () {
        // The entity constructor validates this, so we test the logic directly
        final result = useCase.validateMedicationName('');
        expect(result.isValid, false);
        expect(result.errorMessage, contains('약물명'));
      });

      test('should validate cycle days is positive', () {
        final result = useCase.validateCycleDays(0);
        expect(result.isValid, false);
        expect(result.errorMessage, contains('주기'));
      });

      test('should validate initial dose is positive', () {
        final result = useCase.validateInitialDose(0.0);
        expect(result.isValid, false);
        expect(result.errorMessage, contains('용량'));
      });

      test('should validate escalation plan monotonicity', () {
        final steps = [
          const EscalationStep(weeksFromStart: 4, doseMg: 1.0),
          const EscalationStep(weeksFromStart: 8, doseMg: 0.5),
        ];
        final result = useCase.validateEscalationPlan(0.25, steps);
        expect(result.isValid, false);
        expect(result.errorMessage, contains('증량'));
      });
    });
  });
}
</file>

<file path="test/features/tracking/domain/usecases/validate_symptom_edit_usecase_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/usecases/validate_symptom_edit_usecase.dart';

void main() {
  late ValidateSymptomEditUseCase useCase;

  setUp(() {
    useCase = ValidateSymptomEditUseCase();
  });

  group('ValidateSymptomEditUseCase', () {
    test('should return success for severity in range 1-10', () {
      // Arrange & Act
      final result = useCase.execute(severity: 5, symptomName: '메스꺼움');

      // Assert
      expect(result.isSuccess, true);
      expect(result.isFailure, false);
    });

    test('should return error for severity below 1', () {
      // Arrange & Act
      final result = useCase.execute(severity: 0, symptomName: '메스꺼움');

      // Assert
      expect(result.isSuccess, false);
      expect(result.isFailure, true);
      expect(result.error, isNotNull);
    });

    test('should return error for severity above 10', () {
      // Arrange & Act
      final result = useCase.execute(severity: 11, symptomName: '메스꺼움');

      // Assert
      expect(result.isSuccess, false);
      expect(result.isFailure, true);
      expect(result.error, isNotNull);
    });

    test('should return error for empty symptom name', () {
      // Arrange & Act
      final result = useCase.execute(severity: 5, symptomName: '');

      // Assert
      expect(result.isSuccess, false);
      expect(result.isFailure, true);
      expect(result.error, isNotNull);
    });

    test('should validate symptom name from predefined list', () {
      // Arrange
      final validSymptoms = ['메스꺼움', '구토', '변비', '설사', '복통', '두통', '피로'];

      // Act & Assert
      for (var symptom in validSymptoms) {
        final result = useCase.execute(severity: 5, symptomName: symptom);
        expect(result.isSuccess, true);
      }
    });

    test('should allow custom symptom names (not in predefined list)', () {
      // Arrange & Act
      final result = useCase.execute(severity: 5, symptomName: '커스텀증상');

      // Assert
      expect(result.isSuccess, true);
    });

    test('should accept boundary value 1 for severity', () {
      // Arrange & Act
      final result = useCase.execute(severity: 1, symptomName: '메스꺼움');

      // Assert
      expect(result.isSuccess, true);
    });

    test('should accept boundary value 10 for severity', () {
      // Arrange & Act
      final result = useCase.execute(severity: 10, symptomName: '메스꺼움');

      // Assert
      expect(result.isSuccess, true);
    });
  });
}
</file>

<file path="test/features/tracking/domain/usecases/validate_weight_edit_usecase_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/usecases/validate_weight_edit_usecase.dart';

void main() {
  late ValidateWeightEditUseCase useCase;

  setUp(() {
    useCase = ValidateWeightEditUseCase();
  });

  group('ValidateWeightEditUseCase', () {
    test('should return success for valid weight in range 20-300kg', () {
      // Arrange
      final weight = 70.5;

      // Act
      final result = useCase.execute(weight);

      // Assert
      expect(result.isSuccess, true);
      expect(result.isFailure, false);
      expect(result.error, isNull);
    });

    test('should return error for weight below 20kg', () {
      // Arrange
      final weight = 19.9;

      // Act
      final result = useCase.execute(weight);

      // Assert
      expect(result.isSuccess, false);
      expect(result.isFailure, true);
      expect(result.error, isNotNull);
      expect(result.error, contains('20'));
    });

    test('should return error for weight above 300kg', () {
      // Arrange
      final weight = 300.1;

      // Act
      final result = useCase.execute(weight);

      // Assert
      expect(result.isSuccess, false);
      expect(result.isFailure, true);
      expect(result.error, isNotNull);
      expect(result.error, contains('300'));
    });

    test('should return error for negative weight', () {
      // Arrange
      final weight = -5.0;

      // Act
      final result = useCase.execute(weight);

      // Assert
      expect(result.isSuccess, false);
      expect(result.isFailure, true);
      expect(result.error, isNotNull);
    });

    test('should return error for zero weight', () {
      // Arrange
      final weight = 0.0;

      // Act
      final result = useCase.execute(weight);

      // Assert
      expect(result.isSuccess, false);
      expect(result.isFailure, true);
      expect(result.error, isNotNull);
    });

    test('should return success with warning for weight < 30kg but >= 20kg', () {
      // Arrange
      final weight = 25.0;

      // Act
      final result = useCase.execute(weight);

      // Assert
      expect(result.isSuccess, true);
      expect(result.warning, isNotNull);
      expect(result.isFailure, false);
    });

    test('should return success with warning for weight > 200kg but <= 300kg', () {
      // Arrange
      final weight = 250.0;

      // Act
      final result = useCase.execute(weight);

      // Assert
      expect(result.isSuccess, true);
      expect(result.warning, isNotNull);
      expect(result.isFailure, false);
    });

    test('should accept boundary value 20kg', () {
      // Arrange
      final weight = 20.0;

      // Act
      final result = useCase.execute(weight);

      // Assert
      expect(result.isSuccess, true);
    });

    test('should accept boundary value 300kg', () {
      // Arrange
      final weight = 300.0;

      // Act
      final result = useCase.execute(weight);

      // Assert
      expect(result.isSuccess, true);
    });
  });
}
</file>

<file path="test/features/tracking/infrastructure/dtos/emergency_symptom_check_dto_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/emergency_symptom_check.dart';
import 'package:n06/features/tracking/infrastructure/dtos/emergency_symptom_check_dto.dart';

void main() {
  group('EmergencySymptomCheckDto', () {
    test('Entity를 DTO로 변환 시, 모든 필드 매핑', () {
      // Arrange
      final entity = EmergencySymptomCheck(
        id: 'test-id',
        userId: 'user-123',
        checkedAt: DateTime(2025, 1, 1, 10, 0),
        checkedSymptoms: ['증상1', '증상2'],
      );

      // Act
      final dto = EmergencySymptomCheckDto.fromEntity(entity);

      // Assert
      expect(dto.userId, entity.userId);
      expect(dto.checkedAt, entity.checkedAt);
      expect(dto.checkedSymptoms, entity.checkedSymptoms);
    });

    test('DTO를 Entity로 변환 시, 모든 필드 매핑', () {
      // Arrange
      final dto = EmergencySymptomCheckDto()
        ..id = 1
        ..userId = 'user-123'
        ..checkedAt = DateTime(2025, 1, 1, 10, 0)
        ..checkedSymptoms = ['증상1'];

      // Act
      final entity = dto.toEntity();

      // Assert
      expect(entity.id, dto.id.toString());
      expect(entity.userId, dto.userId);
      expect(entity.checkedAt, dto.checkedAt);
      expect(entity.checkedSymptoms, dto.checkedSymptoms);
    });

    test('빈 증상 리스트 변환 시, 빈 리스트 유지', () {
      // Arrange
      final entity = EmergencySymptomCheck(
        id: 'test-id',
        userId: 'user-123',
        checkedAt: DateTime.now(),
        checkedSymptoms: [],
      );

      // Act
      final dto = EmergencySymptomCheckDto.fromEntity(entity);
      final convertedEntity = dto.toEntity();

      // Assert
      expect(convertedEntity.checkedSymptoms, isEmpty);
    });

    test('여러 증상 변환 시, 순서 유지', () {
      // Arrange
      final symptoms = ['증상1', '증상2', '증상3'];
      final entity = EmergencySymptomCheck(
        id: 'test-id',
        userId: 'user-123',
        checkedAt: DateTime.now(),
        checkedSymptoms: symptoms,
      );

      // Act
      final dto = EmergencySymptomCheckDto.fromEntity(entity);
      final convertedEntity = dto.toEntity();

      // Assert
      expect(convertedEntity.checkedSymptoms, orderedEquals(symptoms));
    });
  });
}
</file>

<file path="test/features/tracking/infrastructure/dtos/symptom_log_dto_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/infrastructure/dtos/symptom_log_dto.dart';

void main() {
  group('SymptomLogDto', () {
    // TC-SL-DTO-01: Entity → DTO 변환
    test('should convert SymptomLog entity to SymptomLogDto', () {
      // Arrange
      final entity = SymptomLog(
        id: 'sl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        symptomName: '메스꺼움',
        severity: 4,
        tags: const ['기름진음식', '과식'],
      );

      // Act
      final dto = SymptomLogDto.fromEntity(entity);

      // Assert
      expect(dto.symptomName, entity.symptomName);
      expect(dto.severity, entity.severity);
      expect(dto.userId, entity.userId);
      expect(dto.logDate, entity.logDate);
      expect(dto.daysSinceEscalation, entity.daysSinceEscalation);
      expect(dto.isPersistent24h, entity.isPersistent24h);
    });

    // TC-SL-DTO-02: DTO → Entity 변환
    test('should convert SymptomLogDto to entity', () {
      // Arrange
      final now = DateTime.now();
      final dto = SymptomLogDto()
        ..userId = 'user-001'
        ..logDate = DateTime(2025, 11, 7)
        ..symptomName = '메스꺼움'
        ..severity = 4
        ..daysSinceEscalation = 3
        ..createdAt = now;

      // Act
      final entity = dto.toEntity(tags: const []);

      // Assert
      expect(entity.userId, dto.userId);
      expect(entity.logDate, dto.logDate);
      expect(entity.symptomName, dto.symptomName);
      expect(entity.severity, dto.severity);
      expect(entity.daysSinceEscalation, dto.daysSinceEscalation);
    });

    // TC-SL-DTO-03: isPersistent24h 필드 변환
    test('should preserve isPersistent24h in DTO conversion', () {
      // Arrange
      final entity = SymptomLog(
        id: 'sl-001',
        userId: 'user-001',
        logDate: DateTime.now(),
        symptomName: '구토',
        severity: 9,
        isPersistent24h: true,
      );

      // Act
      final dto = SymptomLogDto.fromEntity(entity);
      final converted = dto.toEntity(tags: const []);

      // Assert
      expect(converted.isPersistent24h, isTrue);
    });

    // TC-SL-DTO-04: Round-trip 변환
    test('should preserve data in round-trip conversion', () {
      // Arrange
      final now = DateTime.now();
      final original = SymptomLog(
        id: 'sl-004',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        symptomName: '복통',
        severity: 3,
        daysSinceEscalation: 2,
        isPersistent24h: false,
        note: 'test note',
        tags: const ['스트레스'],
        createdAt: now,
      );

      // Act
      final dto = SymptomLogDto.fromEntity(original);
      final converted = dto.toEntity(tags: original.tags);

      // Assert
      expect(converted.userId, original.userId);
      expect(converted.logDate, original.logDate);
      expect(converted.symptomName, original.symptomName);
      expect(converted.severity, original.severity);
      expect(converted.daysSinceEscalation, original.daysSinceEscalation);
      expect(converted.isPersistent24h, original.isPersistent24h);
      expect(converted.note, original.note);
      expect(converted.tags, original.tags);
    });
  });
}
</file>

<file path="test/features/tracking/infrastructure/dtos/weight_log_dto_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/infrastructure/dtos/weight_log_dto.dart';

void main() {
  group('WeightLogDto', () {
    // TC-WL-DTO-01: Entity → DTO 변환
    test('should convert WeightLog entity to WeightLogDto', () {
      // Arrange
      final now = DateTime.now();
      final entity = WeightLog(
        id: 'wl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        weightKg: 75.5,
        createdAt: now,
      );

      // Act
      final dto = WeightLogDto.fromEntity(entity);

      // Assert
      expect(dto.userId, entity.userId);
      expect(dto.logDate, entity.logDate);
      expect(dto.weightKg, entity.weightKg);
      expect(dto.createdAt, entity.createdAt);
    });

    // TC-WL-DTO-02: DTO → Entity 변환
    test('should convert WeightLogDto to WeightLog entity', () {
      // Arrange
      final now = DateTime.now();
      final dto = WeightLogDto()
        ..userId = 'user-001'
        ..logDate = DateTime(2025, 11, 7)
        ..weightKg = 75.5
        ..createdAt = now;

      // Act
      final entity = dto.toEntity();

      // Assert
      expect(entity.userId, dto.userId);
      expect(entity.logDate, dto.logDate);
      expect(entity.weightKg, dto.weightKg);
      expect(entity.createdAt, dto.createdAt);
    });

    // TC-WL-DTO-03: Round-trip 변환 (데이터 손실 없음)
    test('should preserve data in round-trip conversion', () {
      // Arrange
      final now = DateTime.now();
      final original = WeightLog(
        id: 'wl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        weightKg: 75.5,
        createdAt: now,
      );

      // Act
      final dto = WeightLogDto.fromEntity(original);
      final converted = dto.toEntity();

      // Assert
      expect(converted.userId, original.userId);
      expect(converted.logDate, original.logDate);
      expect(converted.weightKg, original.weightKg);
      expect(converted.createdAt, original.createdAt);
    });
  });
}
</file>

<file path="test/features/tracking/infrastructure/repositories/isar_emergency_check_repository_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:isar/isar.dart';
import 'package:n06/features/tracking/domain/entities/emergency_symptom_check.dart';
import 'package:n06/features/tracking/infrastructure/dtos/emergency_symptom_check_dto.dart';
import 'package:n06/features/tracking/infrastructure/repositories/isar_emergency_check_repository.dart';

void main() {
  group('IsarEmergencyCheckRepository Integration', () {
    late Isar isar;
    late IsarEmergencyCheckRepository repository;

    setUp(() async {
      isar = await Isar.open(
        [EmergencySymptomCheckDtoSchema],
        directory: '',
        name: 'test_emergency_check_${DateTime.now().millisecondsSinceEpoch}',
      );
      repository = IsarEmergencyCheckRepository(isar);
    });

    tearDown(() async {
      await isar.close(deleteFromDisk: true);
    });

    test('증상 체크 저장 시, DB에 정상 저장', () async {
      // Arrange
      final check = EmergencySymptomCheck(
        id: 'test-id',
        userId: 'user-123',
        checkedAt: DateTime(2025, 1, 1),
        checkedSymptoms: ['증상1'],
      );

      // Act
      await repository.saveEmergencyCheck(check);

      // Assert
      final saved = await isar.emergencySymptomCheckDtos.where().findAll();
      expect(saved.length, 1);
      expect(saved.first.userId, 'user-123');
    });

    test('사용자별 증상 체크 조회 시, 해당 사용자 데이터만 반환', () async {
      // Arrange
      final check1 = EmergencySymptomCheck(
        id: '1',
        userId: 'user-123',
        checkedAt: DateTime(2025, 1, 1),
        checkedSymptoms: ['증상1'],
      );
      final check2 = EmergencySymptomCheck(
        id: '2',
        userId: 'user-456',
        checkedAt: DateTime(2025, 1, 2),
        checkedSymptoms: ['증상2'],
      );
      await repository.saveEmergencyCheck(check1);
      await repository.saveEmergencyCheck(check2);

      // Act
      final result = await repository.getEmergencyChecks('user-123');

      // Assert
      expect(result.length, 1);
      expect(result.first.userId, 'user-123');
    });

    test('증상 체크 삭제 시, DB에서 제거', () async {
      // Arrange
      final check = EmergencySymptomCheck(
        id: 'test-id',
        userId: 'user-123',
        checkedAt: DateTime.now(),
        checkedSymptoms: ['증상1'],
      );
      await repository.saveEmergencyCheck(check);

      // Act
      final saved = await isar.emergencySymptomCheckDtos.where().findAll();
      final dtoId = saved.first.id;
      await repository.deleteEmergencyCheck(dtoId.toString());

      // Assert
      final remaining = await isar.emergencySymptomCheckDtos.where().findAll();
      expect(remaining, isEmpty);
    });

    test('최근 체크 순서로 정렬 조회', () async {
      // Arrange
      final check1 = EmergencySymptomCheck(
        id: '1',
        userId: 'user-123',
        checkedAt: DateTime(2025, 1, 1),
        checkedSymptoms: ['증상1'],
      );
      final check2 = EmergencySymptomCheck(
        id: '2',
        userId: 'user-123',
        checkedAt: DateTime(2025, 1, 3),
        checkedSymptoms: ['증상2'],
      );
      final check3 = EmergencySymptomCheck(
        id: '3',
        userId: 'user-123',
        checkedAt: DateTime(2025, 1, 2),
        checkedSymptoms: ['증상3'],
      );
      await repository.saveEmergencyCheck(check1);
      await repository.saveEmergencyCheck(check2);
      await repository.saveEmergencyCheck(check3);

      // Act
      final result = await repository.getEmergencyChecks('user-123');

      // Assert
      expect(result.length, 3);
      expect(result[0].checkedAt, DateTime(2025, 1, 3)); // 최신순
      expect(result[1].checkedAt, DateTime(2025, 1, 2));
      expect(result[2].checkedAt, DateTime(2025, 1, 1));
    });

    test('존재하지 않는 ID 삭제 시, 예외 발생하지 않음', () async {
      // Act & Assert
      expect(
        () => repository.deleteEmergencyCheck('non-existent'),
        returnsNormally,
      );
    });

    test('증상 체크 수정 시, DB에 업데이트', () async {
      // Arrange
      final check = EmergencySymptomCheck(
        id: 'test-id',
        userId: 'user-123',
        checkedAt: DateTime.now(),
        checkedSymptoms: ['증상1'],
      );
      await repository.saveEmergencyCheck(check);

      // 저장된 DTO의 ID 가져오기
      final saved = await isar.emergencySymptomCheckDtos.where().findAll();
      final dtoId = saved.first.id;

      // Act
      final updated = EmergencySymptomCheck(
        id: dtoId.toString(),
        userId: check.userId,
        checkedAt: check.checkedAt,
        checkedSymptoms: ['새로운 증상'],
      );
      await repository.updateEmergencyCheck(updated);

      // Assert
      final result = await repository.getEmergencyChecks(check.userId);
      expect(result.first.checkedSymptoms, ['새로운 증상']);
    });

    test('같은 증상 반복 체크 시, 별도 기록으로 저장', () async {
      // Arrange
      final check1 = EmergencySymptomCheck(
        id: '1',
        userId: 'user-123',
        checkedAt: DateTime(2025, 1, 1, 10, 0),
        checkedSymptoms: ['24시간 이상 계속 구토'],
      );
      final check2 = EmergencySymptomCheck(
        id: '2',
        userId: 'user-123',
        checkedAt: DateTime(2025, 1, 1, 14, 0), // 4시간 후
        checkedSymptoms: ['24시간 이상 계속 구토'], // 같은 증상
      );

      // Act
      await repository.saveEmergencyCheck(check1);
      await repository.saveEmergencyCheck(check2);

      // Assert
      final result = await repository.getEmergencyChecks('user-123');
      expect(result.length, 2); // 별도 기록
      expect(result[0].checkedAt, DateTime(2025, 1, 1, 14, 0)); // 최신순
      expect(result[1].checkedAt, DateTime(2025, 1, 1, 10, 0));
    });
  });
}
</file>

<file path="test/features/tracking/presentation/widgets/date_selection_widget_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/presentation/widgets/date_selection_widget.dart';

void main() {
  group('DateSelectionWidget', () {
    group('TC-DSW-01: Quick Button Rendering', () {
      testWidgets('should render quick date buttons',
          (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: DateSelectionWidget(
                onDateSelected: (_) {},
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('오늘'), findsOneWidget);
        expect(find.text('어제'), findsOneWidget);
        expect(find.text('2일 전'), findsOneWidget);
      });

      testWidgets('should render calendar button', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: DateSelectionWidget(
                onDateSelected: (_) {},
              ),
            ),
          ),
        );

        // Assert
        expect(find.byIcon(Icons.calendar_today), findsOneWidget);
      });
    });

    group('TC-DSW-02: Quick Button Click', () {
      testWidgets('should select today on button tap',
          (WidgetTester tester) async {
        // Arrange
        DateTime? selectedDate;
        final now = DateTime.now();
        final today = DateTime(now.year, now.month, now.day);

        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: DateSelectionWidget(
                onDateSelected: (date) => selectedDate = date,
              ),
            ),
          ),
        );

        // Act
        await tester.tap(find.text('오늘'));
        await tester.pump();

        // Assert
        expect(selectedDate, today);
      });

      testWidgets('should select yesterday on button tap',
          (WidgetTester tester) async {
        // Arrange
        DateTime? selectedDate;
        final yesterday = DateTime.now().subtract(const Duration(days: 1));
        final expectedDate = DateTime(yesterday.year, yesterday.month, yesterday.day);

        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: DateSelectionWidget(
                onDateSelected: (date) => selectedDate = date,
              ),
            ),
          ),
        );

        // Act
        await tester.tap(find.text('어제'));
        await tester.pump();

        // Assert
        expect(selectedDate, expectedDate);
      });

      testWidgets('should select 2 days ago on button tap',
          (WidgetTester tester) async {
        // Arrange
        DateTime? selectedDate;
        final twoDaysAgo = DateTime.now().subtract(const Duration(days: 2));
        final expectedDate = DateTime(twoDaysAgo.year, twoDaysAgo.month, twoDaysAgo.day);

        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: DateSelectionWidget(
                onDateSelected: (date) => selectedDate = date,
              ),
            ),
          ),
        );

        // Act
        await tester.tap(find.text('2일 전'));
        await tester.pump();

        // Assert
        expect(selectedDate, expectedDate);
      });
    });

    group('TC-DSW-03: Calendar Date Selection', () {
      testWidgets('should display calendar when calendar button is tapped',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: DateSelectionWidget(
                onDateSelected: (_) {},
              ),
            ),
          ),
        );

        // Act
        await tester.tap(find.byIcon(Icons.calendar_today));
        await tester.pumpAndSettle();

        // Assert - CalendarDatePicker가 표시됨
        expect(find.byType(CalendarDatePicker), findsOneWidget);
      });
    });

    group('TC-DSW-04: Future Date Restriction', () {
      testWidgets('should disable future dates in calendar',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: DateSelectionWidget(
                onDateSelected: (_) {},
              ),
            ),
          ),
        );

        // Act
        await tester.tap(find.byIcon(Icons.calendar_today));
        await tester.pumpAndSettle();

        // Assert - Calendar가 표시되고 미래 날짜는 비활성화됨
        final calendarWidget = tester.widget<CalendarDatePicker>(
          find.byType(CalendarDatePicker),
        );

        // lastDate가 오늘 또는 그 이전이어야 함
        final now = DateTime.now();
        final today = DateTime(now.year, now.month, now.day);
        expect(calendarWidget.lastDate.isAtSameMomentAs(today) ||
            calendarWidget.lastDate.isBefore(today), true);
      });
    });
  });
}
</file>

<file path="test/helpers/test_async_utils.dart">
import 'dart:async';

import 'package:fake_async/fake_async.dart';
import 'package:flutter_test/flutter_test.dart';

/// Utilities for testing asynchronous code with fake timers
///
/// Example usage:
/// ```dart
/// test('should retry 3 times', () {
///   testWithFakeAsync((async) {
///     var count = 0;
///
///     Future<void> retry() async {
///       for (var i = 0; i < 3; i++) {
///         count++;
///         await Future.delayed(Duration(seconds: 1));
///       }
///     }
///
///     retry();
///     async.elapse(Duration(seconds: 3));
///
///     expect(count, 3);
///   });
/// });
/// ```

/// Test function with fake async wrapper
void testWithFakeAsync(
  void Function(FakeAsync async) testBody, {
  Duration? initialTime,
}) {
  fakeAsync((async) {
    if (initialTime != null) {
      async.elapse(initialTime);
    }
    testBody(async);
  });
}

/// Elapse time and pump frames in widget tests
Future<void> pumpAndElapse(
  WidgetTester tester,
  Duration duration, {
  Duration? pumpDuration,
}) async {
  final pump = pumpDuration ?? const Duration(milliseconds: 100);
  final iterations = duration.inMilliseconds ~/ pump.inMilliseconds;

  for (var i = 0; i < iterations; i++) {
    await tester.pump(pump);
  }
}

/// Wait for a condition with timeout
Future<void> waitFor(
  bool Function() condition, {
  Duration timeout = const Duration(seconds: 5),
  Duration pollInterval = const Duration(milliseconds: 100),
}) async {
  final endTime = DateTime.now().add(timeout);

  while (!condition()) {
    if (DateTime.now().isAfter(endTime)) {
      throw TimeoutException(
        'Condition not met within $timeout',
        timeout,
      );
    }
    await Future.delayed(pollInterval);
  }
}

/// Wait for a stream to emit a specific value
Future<T> waitForStreamValue<T>(
  Stream<T> stream, {
  bool Function(T value)? condition,
  Duration timeout = const Duration(seconds: 5),
}) async {
  final completer = Completer<T>();
  late StreamSubscription<T> subscription;

  final timer = Timer(timeout, () {
    if (!completer.isCompleted) {
      subscription.cancel();
      completer.completeError(
        TimeoutException(
          'Stream did not emit expected value within $timeout',
          timeout,
        ),
      );
    }
  });

  subscription = stream.listen((value) {
    if (condition == null || condition(value)) {
      if (!completer.isCompleted) {
        timer.cancel();
        subscription.cancel();
        completer.complete(value);
      }
    }
  });

  return completer.future;
}

/// Retry a future with exponential backoff
Future<T> retryWithBackoff<T>(
  Future<T> Function() operation, {
  int maxAttempts = 3,
  Duration initialDelay = const Duration(milliseconds: 100),
  double backoffMultiplier = 2.0,
}) async {
  var attempt = 0;
  var delay = initialDelay;

  while (true) {
    try {
      return await operation();
    } catch (e) {
      attempt++;
      if (attempt >= maxAttempts) {
        rethrow;
      }
      await Future.delayed(delay);
      delay *= backoffMultiplier;
    }
  }
}
</file>

<file path="test/helpers/test_data_builders.dart">
// Test data builders for creating test entities
//
// Usage:
// ```dart
// final user = UserBuilder()
//   .withId('user123')
//   .withName('Test User')
//   .build();
//
// final dose = DoseBuilder()
//   .withDoseMg(0.5)
//   .withAdministeredAt(DateTime.now())
//   .build();
// ```
library;

/// Base builder class with common functionality
abstract class TestDataBuilder<T> {
  T build();
}

/// Builder for creating test user data
///
/// TODO: Update with actual User entity when domain layer is implemented
class UserBuilder extends TestDataBuilder<Map<String, dynamic>> {
  String id = 'test-user-id';
  String name = 'Test User';
  String email = 'test@example.com';
  String? profileImageUrl;
  String oauthProvider = 'kakao';

  UserBuilder withId(String value) {
    id = value;
    return this;
  }

  UserBuilder withName(String value) {
    name = value;
    return this;
  }

  UserBuilder withEmail(String value) {
    email = value;
    return this;
  }

  UserBuilder withProfileImage(String value) {
    profileImageUrl = value;
    return this;
  }

  UserBuilder withOAuthProvider(String value) {
    oauthProvider = value;
    return this;
  }

  @override
  Map<String, dynamic> build() {
    return {
      'id': id,
      'name': name,
      'email': email,
      'profileImageUrl': profileImageUrl,
      'oauthProvider': oauthProvider,
    };
  }
}

/// Builder for creating test dose data
///
/// TODO: Update with actual Dose entity when domain layer is implemented
class DoseBuilder extends TestDataBuilder<Map<String, dynamic>> {
  int id = 1;
  double doseMg = 0.25;
  DateTime administeredAt = DateTime(2024, 1, 1, 9, 0);
  String? injectionSite;
  String? note;

  DoseBuilder withId(int value) {
    id = value;
    return this;
  }

  DoseBuilder withDoseMg(double value) {
    doseMg = value;
    return this;
  }

  DoseBuilder withAdministeredAt(DateTime value) {
    administeredAt = value;
    return this;
  }

  DoseBuilder withInjectionSite(String value) {
    injectionSite = value;
    return this;
  }

  DoseBuilder withNote(String value) {
    note = value;
    return this;
  }

  @override
  Map<String, dynamic> build() {
    return {
      'id': id,
      'doseMg': doseMg,
      'administeredAt': administeredAt.toIso8601String(),
      'injectionSite': injectionSite,
      'note': note,
    };
  }
}

/// Builder for creating test weight log data
class WeightLogBuilder extends TestDataBuilder<Map<String, dynamic>> {
  int id = 1;
  String userId = 'test-user-id';
  DateTime logDate = DateTime(2024, 1, 1);
  double weightKg = 70.0;

  WeightLogBuilder withId(int value) {
    id = value;
    return this;
  }

  WeightLogBuilder withUserId(String value) {
    userId = value;
    return this;
  }

  WeightLogBuilder withLogDate(DateTime value) {
    logDate = value;
    return this;
  }

  WeightLogBuilder withWeightKg(double value) {
    weightKg = value;
    return this;
  }

  @override
  Map<String, dynamic> build() {
    return {
      'id': id,
      'userId': userId,
      'logDate': logDate.toIso8601String(),
      'weightKg': weightKg,
    };
  }
}

/// Builder for creating test symptom log data
class SymptomLogBuilder extends TestDataBuilder<Map<String, dynamic>> {
  int id = 1;
  String userId = 'test-user-id';
  DateTime logDate = DateTime(2024, 1, 1);
  String symptomName = '메스꺼움';
  int severity = 5;
  int? daysSinceEscalation;
  bool? isPersistent24h;
  String? note;
  List<String> contextTags = [];

  SymptomLogBuilder withId(int value) {
    id = value;
    return this;
  }

  SymptomLogBuilder withUserId(String value) {
    userId = value;
    return this;
  }

  SymptomLogBuilder withLogDate(DateTime value) {
    logDate = value;
    return this;
  }

  SymptomLogBuilder withSymptomName(String value) {
    symptomName = value;
    return this;
  }

  SymptomLogBuilder withSeverity(int value) {
    severity = value;
    return this;
  }

  SymptomLogBuilder withDaysSinceEscalation(int value) {
    daysSinceEscalation = value;
    return this;
  }

  SymptomLogBuilder withPersistent24h(bool value) {
    isPersistent24h = value;
    return this;
  }

  SymptomLogBuilder withNote(String value) {
    note = value;
    return this;
  }

  SymptomLogBuilder withContextTags(List<String> value) {
    contextTags = value;
    return this;
  }

  @override
  Map<String, dynamic> build() {
    return {
      'id': id,
      'userId': userId,
      'logDate': logDate.toIso8601String(),
      'symptomName': symptomName,
      'severity': severity,
      'daysSinceEscalation': daysSinceEscalation,
      'isPersistent24h': isPersistent24h,
      'note': note,
      'contextTags': contextTags,
    };
  }
}

/// Builder for creating test dosage plan data
class DosagePlanBuilder extends TestDataBuilder<Map<String, dynamic>> {
  int id = 1;
  String userId = 'test-user-id';
  String medicationName = 'Ozempic';
  DateTime startDate = DateTime(2024, 1, 1);
  int cycleDays = 7;
  double initialDoseMg = 0.25;
  List<Map<String, dynamic>> escalationPlan = [];
  bool isActive = true;

  DosagePlanBuilder withId(int value) {
    id = value;
    return this;
  }

  DosagePlanBuilder withUserId(String value) {
    userId = value;
    return this;
  }

  DosagePlanBuilder withMedicationName(String value) {
    medicationName = value;
    return this;
  }

  DosagePlanBuilder withStartDate(DateTime value) {
    startDate = value;
    return this;
  }

  DosagePlanBuilder withCycleDays(int value) {
    cycleDays = value;
    return this;
  }

  DosagePlanBuilder withInitialDoseMg(double value) {
    initialDoseMg = value;
    return this;
  }

  DosagePlanBuilder withEscalationPlan(List<Map<String, dynamic>> value) {
    escalationPlan = value;
    return this;
  }

  DosagePlanBuilder withIsActive(bool value) {
    isActive = value;
    return this;
  }

  @override
  Map<String, dynamic> build() {
    return {
      'id': id,
      'userId': userId,
      'medicationName': medicationName,
      'startDate': startDate.toIso8601String(),
      'cycleDays': cycleDays,
      'initialDoseMg': initialDoseMg,
      'escalationPlan': escalationPlan,
      'isActive': isActive,
    };
  }
}
</file>

<file path="test/helpers/test_riverpod_utils.dart">
import 'dart:async';

import 'package:flutter/widgets.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';

/// Utilities for testing Riverpod providers
///
/// Usage:
/// ```dart
/// test('should fetch data from repository', () async {
///   final container = createContainer(
///     overrides: [
///       medicationRepositoryProvider.overrideWithValue(
///         FakeMedicationRepository(),
///       ),
///     ],
///   );
///
///   final state = await container.read(medicationNotifierProvider.future);
///   expect(state, isNotEmpty);
///
///   container.dispose();
/// });
/// ```

/// Create a ProviderContainer with overrides
ProviderContainer createContainer({
  List<Override> overrides = const [],
  ProviderContainer? parent,
  List<ProviderObserver>? observers,
}) {
  final container = ProviderContainer(
    parent: parent,
    overrides: overrides,
    observers: observers,
  );

  // Register cleanup
  addTearDown(container.dispose);

  return container;
}

/// Create a ProviderScope for widget tests
ProviderScope createProviderScope({
  required Widget child,
  List<Override> overrides = const [],
  List<ProviderObserver>? observers,
}) {
  return ProviderScope(
    overrides: overrides,
    observers: observers,
    child: child,
  );
}

/// Test observer for tracking provider state changes
class TestProviderObserver extends ProviderObserver {
  final List<ProviderListenerEvent> events = [];

  @override
  void didAddProvider(
    ProviderBase provider,
    Object? value,
    ProviderContainer container,
  ) {
    events.add(ProviderListenerEvent.didAdd(provider, value));
  }

  @override
  void didUpdateProvider(
    ProviderBase provider,
    Object? previousValue,
    Object? newValue,
    ProviderContainer container,
  ) {
    events.add(ProviderListenerEvent.didUpdate(provider, previousValue, newValue));
  }

  @override
  void didDisposeProvider(
    ProviderBase provider,
    ProviderContainer container,
  ) {
    events.add(ProviderListenerEvent.didDispose(provider));
  }

  @override
  void providerDidFail(
    ProviderBase provider,
    Object error,
    StackTrace stackTrace,
    ProviderContainer container,
  ) {
    events.add(ProviderListenerEvent.didFail(provider, error, stackTrace));
  }

  /// Get all update events for a specific provider
  List<ProviderListenerEvent> getUpdatesFor(ProviderBase provider) {
    return events.where((e) => e.provider == provider && e.type == EventType.update).toList();
  }

  /// Get the last value for a specific provider
  Object? getLastValueFor(ProviderBase provider) {
    final updates = getUpdatesFor(provider);
    return updates.isEmpty ? null : updates.last.newValue;
  }

  /// Check if provider was disposed
  bool wasDisposed(ProviderBase provider) {
    return events.any((e) => e.provider == provider && e.type == EventType.dispose);
  }

  /// Clear all recorded events
  void clear() {
    events.clear();
  }
}

/// Event types for provider observer
enum EventType {
  add,
  update,
  dispose,
  fail,
}

/// Provider listener event
class ProviderListenerEvent {
  final ProviderBase provider;
  final EventType type;
  final Object? previousValue;
  final Object? newValue;
  final Object? error;
  final StackTrace? stackTrace;

  ProviderListenerEvent.didAdd(this.provider, this.newValue)
      : type = EventType.add,
        previousValue = null,
        error = null,
        stackTrace = null;

  ProviderListenerEvent.didUpdate(this.provider, this.previousValue, this.newValue)
      : type = EventType.update,
        error = null,
        stackTrace = null;

  ProviderListenerEvent.didDispose(this.provider)
      : type = EventType.dispose,
        previousValue = null,
        newValue = null,
        error = null,
        stackTrace = null;

  ProviderListenerEvent.didFail(this.provider, this.error, this.stackTrace)
      : type = EventType.fail,
        previousValue = null,
        newValue = null;

  @override
  String toString() {
    switch (type) {
      case EventType.add:
        return 'ProviderListenerEvent.didAdd(${provider.runtimeType}, $newValue)';
      case EventType.update:
        return 'ProviderListenerEvent.didUpdate(${provider.runtimeType}, $previousValue -> $newValue)';
      case EventType.dispose:
        return 'ProviderListenerEvent.didDispose(${provider.runtimeType})';
      case EventType.fail:
        return 'ProviderListenerEvent.didFail(${provider.runtimeType}, $error)';
    }
  }
}

/// Wait for an AsyncValue to complete with data
Future<T> waitForAsyncValue<T>(
  ProviderContainer container,
  ProviderListenable<AsyncValue<T>> provider, {
  Duration timeout = const Duration(seconds: 5),
}) async {
  final completer = Completer<T>();

  final subscription = container.listen<AsyncValue<T>>(
    provider,
    (previous, next) {
      if (!completer.isCompleted) {
        next.when(
          data: (data) => completer.complete(data),
          loading: () {},
          error: (error, stack) => completer.completeError(error, stack),
        );
      }
    },
  );

  try {
    return await completer.future.timeout(timeout);
  } finally {
    subscription.close();
  }
}

/// Pump widget with ProviderScope
Future<void> pumpWithProviderScope(
  WidgetTester tester,
  Widget widget, {
  List<Override> overrides = const [],
  List<ProviderObserver>? observers,
}) async {
  await tester.pumpWidget(
    createProviderScope(
      overrides: overrides,
      observers: observers,
      child: widget,
    ),
  );
}
</file>

<file path="test/unit/test_environment_validation_test.dart">
import 'dart:async';

import 'package:fake_async/fake_async.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mocktail/mocktail.dart';
import '../fakes/fake_medication_repository.dart';
import '../helpers/test_async_utils.dart';
import '../helpers/test_data_builders.dart';

/// Test environment validation
///
/// This test suite validates that the test environment is properly set up:
/// - mocktail for mocking
/// - fake_async for time-based testing
/// - fake repositories for in-memory testing
/// - test data builders for easy test data creation

void main() {
  group('Test Environment Validation', () {
    group('mocktail', () {
      test('should create and use mocks', () {
        // Arrange
        final mock = MockTestInterface();
        when(() => mock.getValue()).thenReturn('mocked value');

        // Act
        final result = mock.getValue();

        // Assert
        expect(result, 'mocked value');
        verify(() => mock.getValue()).called(1);
      });

      test('should verify mock interactions', () {
        // Arrange
        final mock = MockTestInterface();
        when(() => mock.asyncOperation()).thenAnswer((_) async => 42);

        // Act
        mock.asyncOperation();

        // Assert
        verify(() => mock.asyncOperation()).called(1);
        verifyNoMoreInteractions(mock);
      });
    });

    group('fake_async', () {
      test('should control time with fake async', () {
        fakeAsync((async) {
          // Arrange
          var completed = false;
          Future.delayed(const Duration(seconds: 1), () {
            completed = true;
          });

          // Act - no time has passed
          expect(completed, false);

          // Act - elapse 1 second
          async.elapse(const Duration(seconds: 1));

          // Assert
          expect(completed, true);
        });
      });

      test('should test periodic operations', () {
        fakeAsync((async) {
          // Arrange
          var counter = 0;
          Timer.periodic(const Duration(seconds: 1), (timer) {
            counter++;
            if (counter >= 3) timer.cancel();
          });

          // Act & Assert
          expect(counter, 0);

          async.elapse(const Duration(seconds: 1));
          expect(counter, 1);

          async.elapse(const Duration(seconds: 1));
          expect(counter, 2);

          async.elapse(const Duration(seconds: 1));
          expect(counter, 3);
        });
      });
    });

    group('Fake Repository', () {
      late FakeMedicationRepository repository;

      setUp(() {
        repository = FakeMedicationRepository();
      });

      tearDown(() {
        repository.dispose();
      });

      test('should save and retrieve data', () async {
        // Arrange
        final dose = DoseBuilder()
            .withId(1)
            .withDoseMg(0.25)
            .withAdministeredAt(DateTime(2024, 1, 1))
            .build();

        // Act
        await repository.saveDose(dose);
        final doses = await repository.getDoses();

        // Assert
        expect(doses, hasLength(1));
        expect(doses.first['doseMg'], 0.25);
      });

      test('should emit stream updates', () async {
        // Arrange
        final dose1 = DoseBuilder().withId(1).withDoseMg(0.25).build();

        // Act
        await repository.saveDose(dose1);

        // Assert - verify data was saved
        final doses = await repository.getDoses();
        expect(doses, hasLength(1));
        expect(doses.first['doseMg'], 0.25);

        // Note: Stream testing will be validated with actual domain entities
        // when the domain layer is implemented
      }, skip: 'Stream functionality will be tested with actual domain layer');

      test('should simulate errors', () async {
        // Arrange
        repository.throwOnNextOperation(Exception('Test error'));
        final dose = DoseBuilder().build();

        // Act & Assert
        expect(
          () => repository.saveDose(dose),
          throwsA(isA<Exception>()),
        );
      });

      test('should support operation delays', () async {
        // Arrange
        repository.enableDelays(delay: const Duration(milliseconds: 100));
        final dose = DoseBuilder().build();

        // Act
        final startTime = DateTime.now();
        await repository.saveDose(dose);
        final endTime = DateTime.now();

        // Assert
        final elapsed = endTime.difference(startTime);
        expect(elapsed.inMilliseconds, greaterThanOrEqualTo(100));
      });
    });

    group('Test Data Builders', () {
      test('should build user data', () {
        // Arrange & Act
        final user = UserBuilder()
            .withId('user123')
            .withName('Test User')
            .withEmail('test@example.com')
            .build();

        // Assert
        expect(user['id'], 'user123');
        expect(user['name'], 'Test User');
        expect(user['email'], 'test@example.com');
      });

      test('should build dose data', () {
        // Arrange & Act
        final dose = DoseBuilder()
            .withDoseMg(0.5)
            .withInjectionSite('복부')
            .withNote('아침 투여')
            .build();

        // Assert
        expect(dose['doseMg'], 0.5);
        expect(dose['injectionSite'], '복부');
        expect(dose['note'], '아침 투여');
      });

      test('should build weight log data', () {
        // Arrange & Act
        final weightLog = WeightLogBuilder()
            .withWeightKg(72.5)
            .withLogDate(DateTime(2024, 1, 15))
            .build();

        // Assert
        expect(weightLog['weightKg'], 72.5);
        expect(weightLog['logDate'], DateTime(2024, 1, 15).toIso8601String());
      });

      test('should build symptom log data', () {
        // Arrange & Act
        final symptomLog = SymptomLogBuilder()
            .withSymptomName('메스꺼움')
            .withSeverity(7)
            .withContextTags(['기름진음식', '공복'])
            .build();

        // Assert
        expect(symptomLog['symptomName'], '메스꺼움');
        expect(symptomLog['severity'], 7);
        expect(symptomLog['contextTags'], ['기름진음식', '공복']);
      });

      test('should build dosage plan data', () {
        // Arrange & Act
        final plan = DosagePlanBuilder()
            .withMedicationName('Ozempic')
            .withInitialDoseMg(0.25)
            .withCycleDays(7)
            .withEscalationPlan([
              {'weeks': 4, 'doseMg': 0.5},
              {'weeks': 8, 'doseMg': 1.0},
            ])
            .build();

        // Assert
        expect(plan['medicationName'], 'Ozempic');
        expect(plan['initialDoseMg'], 0.25);
        expect(plan['cycleDays'], 7);
        expect(plan['escalationPlan'], hasLength(2));
      });
    });

    group('Test Async Utils', () {
      test('should wait for stream value', () async {
        // Arrange
        final controller = StreamController<int>();
        final stream = controller.stream;

        // Act
        Future.delayed(const Duration(milliseconds: 100), () {
          controller.add(42);
        });

        final result = await waitForStreamValue(
          stream,
          condition: (value) => value == 42,
        );

        // Assert
        expect(result, 42);
        await controller.close();
      });

      test('should retry with backoff', () async {
        // Arrange
        var attempts = 0;

        Future<int> operation() async {
          attempts++;
          if (attempts < 3) {
            throw Exception('Retry');
          }
          return 42;
        }

        // Act
        final result = await retryWithBackoff(
          operation,
          maxAttempts: 3,
          initialDelay: const Duration(milliseconds: 10),
        );

        // Assert
        expect(result, 42);
        expect(attempts, 3);
      });
    });
  });
}

// Mock classes for testing
class MockTestInterface extends Mock implements TestInterface {}

abstract class TestInterface {
  String getValue();
  Future<int> asyncOperation();
}
</file>

<file path="web/index.html">
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="n06">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>n06</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>
</file>

<file path="web/manifest.json">
{
    "name": "n06",
    "short_name": "n06",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}
</file>

<file path="windows/flutter/CMakeLists.txt">
# This file controls Flutter-level build steps. It should not be edited.
cmake_minimum_required(VERSION 3.14)

set(EPHEMERAL_DIR "${CMAKE_CURRENT_SOURCE_DIR}/ephemeral")

# Configuration provided via flutter tool.
include(${EPHEMERAL_DIR}/generated_config.cmake)

# TODO: Move the rest of this into files in ephemeral. See
# https://github.com/flutter/flutter/issues/57146.
set(WRAPPER_ROOT "${EPHEMERAL_DIR}/cpp_client_wrapper")

# Set fallback configurations for older versions of the flutter tool.
if (NOT DEFINED FLUTTER_TARGET_PLATFORM)
  set(FLUTTER_TARGET_PLATFORM "windows-x64")
endif()

# === Flutter Library ===
set(FLUTTER_LIBRARY "${EPHEMERAL_DIR}/flutter_windows.dll")

# Published to parent scope for install step.
set(FLUTTER_LIBRARY ${FLUTTER_LIBRARY} PARENT_SCOPE)
set(FLUTTER_ICU_DATA_FILE "${EPHEMERAL_DIR}/icudtl.dat" PARENT_SCOPE)
set(PROJECT_BUILD_DIR "${PROJECT_DIR}/build/" PARENT_SCOPE)
set(AOT_LIBRARY "${PROJECT_DIR}/build/windows/app.so" PARENT_SCOPE)

list(APPEND FLUTTER_LIBRARY_HEADERS
  "flutter_export.h"
  "flutter_windows.h"
  "flutter_messenger.h"
  "flutter_plugin_registrar.h"
  "flutter_texture_registrar.h"
)
list(TRANSFORM FLUTTER_LIBRARY_HEADERS PREPEND "${EPHEMERAL_DIR}/")
add_library(flutter INTERFACE)
target_include_directories(flutter INTERFACE
  "${EPHEMERAL_DIR}"
)
target_link_libraries(flutter INTERFACE "${FLUTTER_LIBRARY}.lib")
add_dependencies(flutter flutter_assemble)

# === Wrapper ===
list(APPEND CPP_WRAPPER_SOURCES_CORE
  "core_implementations.cc"
  "standard_codec.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_CORE PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_PLUGIN
  "plugin_registrar.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_PLUGIN PREPEND "${WRAPPER_ROOT}/")
list(APPEND CPP_WRAPPER_SOURCES_APP
  "flutter_engine.cc"
  "flutter_view_controller.cc"
)
list(TRANSFORM CPP_WRAPPER_SOURCES_APP PREPEND "${WRAPPER_ROOT}/")

# Wrapper sources needed for a plugin.
add_library(flutter_wrapper_plugin STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
)
apply_standard_settings(flutter_wrapper_plugin)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  POSITION_INDEPENDENT_CODE ON)
set_target_properties(flutter_wrapper_plugin PROPERTIES
  CXX_VISIBILITY_PRESET hidden)
target_link_libraries(flutter_wrapper_plugin PUBLIC flutter)
target_include_directories(flutter_wrapper_plugin PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_plugin flutter_assemble)

# Wrapper sources needed for the runner.
add_library(flutter_wrapper_app STATIC
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_APP}
)
apply_standard_settings(flutter_wrapper_app)
target_link_libraries(flutter_wrapper_app PUBLIC flutter)
target_include_directories(flutter_wrapper_app PUBLIC
  "${WRAPPER_ROOT}/include"
)
add_dependencies(flutter_wrapper_app flutter_assemble)

# === Flutter tool backend ===
# _phony_ is a non-existent file to force this command to run every time,
# since currently there's no way to get a full input/output list from the
# flutter tool.
set(PHONY_OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/_phony_")
set_source_files_properties("${PHONY_OUTPUT}" PROPERTIES SYMBOLIC TRUE)
add_custom_command(
  OUTPUT ${FLUTTER_LIBRARY} ${FLUTTER_LIBRARY_HEADERS}
    ${CPP_WRAPPER_SOURCES_CORE} ${CPP_WRAPPER_SOURCES_PLUGIN}
    ${CPP_WRAPPER_SOURCES_APP}
    ${PHONY_OUTPUT}
  COMMAND ${CMAKE_COMMAND} -E env
    ${FLUTTER_TOOL_ENVIRONMENT}
    "${FLUTTER_ROOT}/packages/flutter_tools/bin/tool_backend.bat"
      ${FLUTTER_TARGET_PLATFORM} $<CONFIG>
  VERBATIM
)
add_custom_target(flutter_assemble DEPENDS
  "${FLUTTER_LIBRARY}"
  ${FLUTTER_LIBRARY_HEADERS}
  ${CPP_WRAPPER_SOURCES_CORE}
  ${CPP_WRAPPER_SOURCES_PLUGIN}
  ${CPP_WRAPPER_SOURCES_APP}
)
</file>

<file path="windows/runner/CMakeLists.txt">
cmake_minimum_required(VERSION 3.14)
project(runner LANGUAGES CXX)

# Define the application target. To change its name, change BINARY_NAME in the
# top-level CMakeLists.txt, not the value here, or `flutter run` will no longer
# work.
#
# Any new source files that you add to the application should be added here.
add_executable(${BINARY_NAME} WIN32
  "flutter_window.cpp"
  "main.cpp"
  "utils.cpp"
  "win32_window.cpp"
  "${FLUTTER_MANAGED_DIR}/generated_plugin_registrant.cc"
  "Runner.rc"
  "runner.exe.manifest"
)

# Apply the standard set of build settings. This can be removed for applications
# that need different build settings.
apply_standard_settings(${BINARY_NAME})

# Add preprocessor definitions for the build version.
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION=\"${FLUTTER_VERSION}\"")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MAJOR=${FLUTTER_VERSION_MAJOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_MINOR=${FLUTTER_VERSION_MINOR}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_PATCH=${FLUTTER_VERSION_PATCH}")
target_compile_definitions(${BINARY_NAME} PRIVATE "FLUTTER_VERSION_BUILD=${FLUTTER_VERSION_BUILD}")

# Disable Windows macros that collide with C++ standard library functions.
target_compile_definitions(${BINARY_NAME} PRIVATE "NOMINMAX")

# Add dependency libraries and include directories. Add any application-specific
# dependencies here.
target_link_libraries(${BINARY_NAME} PRIVATE flutter flutter_wrapper_app)
target_link_libraries(${BINARY_NAME} PRIVATE "dwmapi.lib")
target_include_directories(${BINARY_NAME} PRIVATE "${CMAKE_SOURCE_DIR}")

# Run the Flutter tool portions of the build. This must not be removed.
add_dependencies(${BINARY_NAME} flutter_assemble)
</file>

<file path="windows/runner/flutter_window.cpp">
#include "flutter_window.h"

#include <optional>

#include "flutter/generated_plugin_registrant.h"

FlutterWindow::FlutterWindow(const flutter::DartProject& project)
    : project_(project) {}

FlutterWindow::~FlutterWindow() {}

bool FlutterWindow::OnCreate() {
  if (!Win32Window::OnCreate()) {
    return false;
  }

  RECT frame = GetClientArea();

  // The size here must match the window dimensions to avoid unnecessary surface
  // creation / destruction in the startup path.
  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(
      frame.right - frame.left, frame.bottom - frame.top, project_);
  // Ensure that basic setup of the controller was successful.
  if (!flutter_controller_->engine() || !flutter_controller_->view()) {
    return false;
  }
  RegisterPlugins(flutter_controller_->engine());
  SetChildContent(flutter_controller_->view()->GetNativeWindow());

  flutter_controller_->engine()->SetNextFrameCallback([&]() {
    this->Show();
  });

  // Flutter can complete the first frame before the "show window" callback is
  // registered. The following call ensures a frame is pending to ensure the
  // window is shown. It is a no-op if the first frame hasn't completed yet.
  flutter_controller_->ForceRedraw();

  return true;
}

void FlutterWindow::OnDestroy() {
  if (flutter_controller_) {
    flutter_controller_ = nullptr;
  }

  Win32Window::OnDestroy();
}

LRESULT
FlutterWindow::MessageHandler(HWND hwnd, UINT const message,
                              WPARAM const wparam,
                              LPARAM const lparam) noexcept {
  // Give Flutter, including plugins, an opportunity to handle window messages.
  if (flutter_controller_) {
    std::optional<LRESULT> result =
        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,
                                                      lparam);
    if (result) {
      return *result;
    }
  }

  switch (message) {
    case WM_FONTCHANGE:
      flutter_controller_->engine()->ReloadSystemFonts();
      break;
  }

  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);
}
</file>

<file path="windows/runner/flutter_window.h">
#ifndef RUNNER_FLUTTER_WINDOW_H_
#define RUNNER_FLUTTER_WINDOW_H_

#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>

#include <memory>

#include "win32_window.h"

// A window that does nothing but host a Flutter view.
class FlutterWindow : public Win32Window {
 public:
  // Creates a new FlutterWindow hosting a Flutter view running |project|.
  explicit FlutterWindow(const flutter::DartProject& project);
  virtual ~FlutterWindow();

 protected:
  // Win32Window:
  bool OnCreate() override;
  void OnDestroy() override;
  LRESULT MessageHandler(HWND window, UINT const message, WPARAM const wparam,
                         LPARAM const lparam) noexcept override;

 private:
  // The project to run.
  flutter::DartProject project_;

  // The Flutter instance hosted by this window.
  std::unique_ptr<flutter::FlutterViewController> flutter_controller_;
};

#endif  // RUNNER_FLUTTER_WINDOW_H_
</file>

<file path="windows/runner/main.cpp">
#include <flutter/dart_project.h>
#include <flutter/flutter_view_controller.h>
#include <windows.h>

#include "flutter_window.h"
#include "utils.h"

int APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,
                      _In_ wchar_t *command_line, _In_ int show_command) {
  // Attach to console when present (e.g., 'flutter run') or create a
  // new console when running with a debugger.
  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {
    CreateAndAttachConsole();
  }

  // Initialize COM, so that it is available for use in the library and/or
  // plugins.
  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);

  flutter::DartProject project(L"data");

  std::vector<std::string> command_line_arguments =
      GetCommandLineArguments();

  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));

  FlutterWindow window(project);
  Win32Window::Point origin(10, 10);
  Win32Window::Size size(1280, 720);
  if (!window.Create(L"n06", origin, size)) {
    return EXIT_FAILURE;
  }
  window.SetQuitOnClose(true);

  ::MSG msg;
  while (::GetMessage(&msg, nullptr, 0, 0)) {
    ::TranslateMessage(&msg);
    ::DispatchMessage(&msg);
  }

  ::CoUninitialize();
  return EXIT_SUCCESS;
}
</file>

<file path="windows/runner/resource.h">
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Runner.rc
//
#define IDI_APP_ICON                    101

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
</file>

<file path="windows/runner/runner.exe.manifest">
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
    </windowsSettings>
  </application>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows 10 and Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
</assembly>
</file>

<file path="windows/runner/Runner.rc">
// Microsoft Visual C++ generated resource script.
//
#pragma code_page(65001)
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_APP_ICON            ICON                    "resources\\app_icon.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#if defined(FLUTTER_VERSION_MAJOR) && defined(FLUTTER_VERSION_MINOR) && defined(FLUTTER_VERSION_PATCH) && defined(FLUTTER_VERSION_BUILD)
#define VERSION_AS_NUMBER FLUTTER_VERSION_MAJOR,FLUTTER_VERSION_MINOR,FLUTTER_VERSION_PATCH,FLUTTER_VERSION_BUILD
#else
#define VERSION_AS_NUMBER 1,0,0,0
#endif

#if defined(FLUTTER_VERSION)
#define VERSION_AS_STRING FLUTTER_VERSION
#else
#define VERSION_AS_STRING "1.0.0"
#endif

VS_VERSION_INFO VERSIONINFO
 FILEVERSION VERSION_AS_NUMBER
 PRODUCTVERSION VERSION_AS_NUMBER
 FILEFLAGSMASK VS_FFI_FILEFLAGSMASK
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904e4"
        BEGIN
            VALUE "CompanyName", "com.glp1" "\0"
            VALUE "FileDescription", "n06" "\0"
            VALUE "FileVersion", VERSION_AS_STRING "\0"
            VALUE "InternalName", "n06" "\0"
            VALUE "LegalCopyright", "Copyright (C) 2025 com.glp1. All rights reserved." "\0"
            VALUE "OriginalFilename", "n06.exe" "\0"
            VALUE "ProductName", "n06" "\0"
            VALUE "ProductVersion", VERSION_AS_STRING "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1252
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
</file>

<file path="windows/runner/utils.cpp">
#include "utils.h"

#include <flutter_windows.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>

#include <iostream>

void CreateAndAttachConsole() {
  if (::AllocConsole()) {
    FILE *unused;
    if (freopen_s(&unused, "CONOUT$", "w", stdout)) {
      _dup2(_fileno(stdout), 1);
    }
    if (freopen_s(&unused, "CONOUT$", "w", stderr)) {
      _dup2(_fileno(stdout), 2);
    }
    std::ios::sync_with_stdio();
    FlutterDesktopResyncOutputStreams();
  }
}

std::vector<std::string> GetCommandLineArguments() {
  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.
  int argc;
  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
  if (argv == nullptr) {
    return std::vector<std::string>();
  }

  std::vector<std::string> command_line_arguments;

  // Skip the first argument as it's the binary name.
  for (int i = 1; i < argc; i++) {
    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));
  }

  ::LocalFree(argv);

  return command_line_arguments;
}

std::string Utf8FromUtf16(const wchar_t* utf16_string) {
  if (utf16_string == nullptr) {
    return std::string();
  }
  unsigned int target_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      -1, nullptr, 0, nullptr, nullptr)
    -1; // remove the trailing null character
  int input_length = (int)wcslen(utf16_string);
  std::string utf8_string;
  if (target_length == 0 || target_length > utf8_string.max_size()) {
    return utf8_string;
  }
  utf8_string.resize(target_length);
  int converted_length = ::WideCharToMultiByte(
      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,
      input_length, utf8_string.data(), target_length, nullptr, nullptr);
  if (converted_length == 0) {
    return std::string();
  }
  return utf8_string;
}
</file>

<file path="windows/runner/utils.h">
#ifndef RUNNER_UTILS_H_
#define RUNNER_UTILS_H_

#include <string>
#include <vector>

// Creates a console for the process, and redirects stdout and stderr to
// it for both the runner and the Flutter library.
void CreateAndAttachConsole();

// Takes a null-terminated wchar_t* encoded in UTF-16 and returns a std::string
// encoded in UTF-8. Returns an empty std::string on failure.
std::string Utf8FromUtf16(const wchar_t* utf16_string);

// Gets the command line arguments passed in as a std::vector<std::string>,
// encoded in UTF-8. Returns an empty std::vector<std::string> on failure.
std::vector<std::string> GetCommandLineArguments();

#endif  // RUNNER_UTILS_H_
</file>

<file path="windows/runner/win32_window.cpp">
#include "win32_window.h"

#include <dwmapi.h>
#include <flutter_windows.h>

#include "resource.h"

namespace {

/// Window attribute that enables dark mode window decorations.
///
/// Redefined in case the developer's machine has a Windows SDK older than
/// version 10.0.22000.0.
/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute
#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE
#define DWMWA_USE_IMMERSIVE_DARK_MODE 20
#endif

constexpr const wchar_t kWindowClassName[] = L"FLUTTER_RUNNER_WIN32_WINDOW";

/// Registry key for app theme preference.
///
/// A value of 0 indicates apps should use dark mode. A non-zero or missing
/// value indicates apps should use light mode.
constexpr const wchar_t kGetPreferredBrightnessRegKey[] =
  L"Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize";
constexpr const wchar_t kGetPreferredBrightnessRegValue[] = L"AppsUseLightTheme";

// The number of Win32Window objects that currently exist.
static int g_active_window_count = 0;

using EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);

// Scale helper to convert logical scaler values to physical using passed in
// scale factor
int Scale(int source, double scale_factor) {
  return static_cast<int>(source * scale_factor);
}

// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.
// This API is only needed for PerMonitor V1 awareness mode.
void EnableFullDpiSupportIfAvailable(HWND hwnd) {
  HMODULE user32_module = LoadLibraryA("User32.dll");
  if (!user32_module) {
    return;
  }
  auto enable_non_client_dpi_scaling =
      reinterpret_cast<EnableNonClientDpiScaling*>(
          GetProcAddress(user32_module, "EnableNonClientDpiScaling"));
  if (enable_non_client_dpi_scaling != nullptr) {
    enable_non_client_dpi_scaling(hwnd);
  }
  FreeLibrary(user32_module);
}

}  // namespace

// Manages the Win32Window's window class registration.
class WindowClassRegistrar {
 public:
  ~WindowClassRegistrar() = default;

  // Returns the singleton registrar instance.
  static WindowClassRegistrar* GetInstance() {
    if (!instance_) {
      instance_ = new WindowClassRegistrar();
    }
    return instance_;
  }

  // Returns the name of the window class, registering the class if it hasn't
  // previously been registered.
  const wchar_t* GetWindowClass();

  // Unregisters the window class. Should only be called if there are no
  // instances of the window.
  void UnregisterWindowClass();

 private:
  WindowClassRegistrar() = default;

  static WindowClassRegistrar* instance_;

  bool class_registered_ = false;
};

WindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;

const wchar_t* WindowClassRegistrar::GetWindowClass() {
  if (!class_registered_) {
    WNDCLASS window_class{};
    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);
    window_class.lpszClassName = kWindowClassName;
    window_class.style = CS_HREDRAW | CS_VREDRAW;
    window_class.cbClsExtra = 0;
    window_class.cbWndExtra = 0;
    window_class.hInstance = GetModuleHandle(nullptr);
    window_class.hIcon =
        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));
    window_class.hbrBackground = 0;
    window_class.lpszMenuName = nullptr;
    window_class.lpfnWndProc = Win32Window::WndProc;
    RegisterClass(&window_class);
    class_registered_ = true;
  }
  return kWindowClassName;
}

void WindowClassRegistrar::UnregisterWindowClass() {
  UnregisterClass(kWindowClassName, nullptr);
  class_registered_ = false;
}

Win32Window::Win32Window() {
  ++g_active_window_count;
}

Win32Window::~Win32Window() {
  --g_active_window_count;
  Destroy();
}

bool Win32Window::Create(const std::wstring& title,
                         const Point& origin,
                         const Size& size) {
  Destroy();

  const wchar_t* window_class =
      WindowClassRegistrar::GetInstance()->GetWindowClass();

  const POINT target_point = {static_cast<LONG>(origin.x),
                              static_cast<LONG>(origin.y)};
  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);
  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);
  double scale_factor = dpi / 96.0;

  HWND window = CreateWindow(
      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,
      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),
      Scale(size.width, scale_factor), Scale(size.height, scale_factor),
      nullptr, nullptr, GetModuleHandle(nullptr), this);

  if (!window) {
    return false;
  }

  UpdateTheme(window);

  return OnCreate();
}

bool Win32Window::Show() {
  return ShowWindow(window_handle_, SW_SHOWNORMAL);
}

// static
LRESULT CALLBACK Win32Window::WndProc(HWND const window,
                                      UINT const message,
                                      WPARAM const wparam,
                                      LPARAM const lparam) noexcept {
  if (message == WM_NCCREATE) {
    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);
    SetWindowLongPtr(window, GWLP_USERDATA,
                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));

    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);
    EnableFullDpiSupportIfAvailable(window);
    that->window_handle_ = window;
  } else if (Win32Window* that = GetThisFromHandle(window)) {
    return that->MessageHandler(window, message, wparam, lparam);
  }

  return DefWindowProc(window, message, wparam, lparam);
}

LRESULT
Win32Window::MessageHandler(HWND hwnd,
                            UINT const message,
                            WPARAM const wparam,
                            LPARAM const lparam) noexcept {
  switch (message) {
    case WM_DESTROY:
      window_handle_ = nullptr;
      Destroy();
      if (quit_on_close_) {
        PostQuitMessage(0);
      }
      return 0;

    case WM_DPICHANGED: {
      auto newRectSize = reinterpret_cast<RECT*>(lparam);
      LONG newWidth = newRectSize->right - newRectSize->left;
      LONG newHeight = newRectSize->bottom - newRectSize->top;

      SetWindowPos(hwnd, nullptr, newRectSize->left, newRectSize->top, newWidth,
                   newHeight, SWP_NOZORDER | SWP_NOACTIVATE);

      return 0;
    }
    case WM_SIZE: {
      RECT rect = GetClientArea();
      if (child_content_ != nullptr) {
        // Size and position the child window.
        MoveWindow(child_content_, rect.left, rect.top, rect.right - rect.left,
                   rect.bottom - rect.top, TRUE);
      }
      return 0;
    }

    case WM_ACTIVATE:
      if (child_content_ != nullptr) {
        SetFocus(child_content_);
      }
      return 0;

    case WM_DWMCOLORIZATIONCOLORCHANGED:
      UpdateTheme(hwnd);
      return 0;
  }

  return DefWindowProc(window_handle_, message, wparam, lparam);
}

void Win32Window::Destroy() {
  OnDestroy();

  if (window_handle_) {
    DestroyWindow(window_handle_);
    window_handle_ = nullptr;
  }
  if (g_active_window_count == 0) {
    WindowClassRegistrar::GetInstance()->UnregisterWindowClass();
  }
}

Win32Window* Win32Window::GetThisFromHandle(HWND const window) noexcept {
  return reinterpret_cast<Win32Window*>(
      GetWindowLongPtr(window, GWLP_USERDATA));
}

void Win32Window::SetChildContent(HWND content) {
  child_content_ = content;
  SetParent(content, window_handle_);
  RECT frame = GetClientArea();

  MoveWindow(content, frame.left, frame.top, frame.right - frame.left,
             frame.bottom - frame.top, true);

  SetFocus(child_content_);
}

RECT Win32Window::GetClientArea() {
  RECT frame;
  GetClientRect(window_handle_, &frame);
  return frame;
}

HWND Win32Window::GetHandle() {
  return window_handle_;
}

void Win32Window::SetQuitOnClose(bool quit_on_close) {
  quit_on_close_ = quit_on_close;
}

bool Win32Window::OnCreate() {
  // No-op; provided for subclasses.
  return true;
}

void Win32Window::OnDestroy() {
  // No-op; provided for subclasses.
}

void Win32Window::UpdateTheme(HWND const window) {
  DWORD light_mode;
  DWORD light_mode_size = sizeof(light_mode);
  LSTATUS result = RegGetValue(HKEY_CURRENT_USER, kGetPreferredBrightnessRegKey,
                               kGetPreferredBrightnessRegValue,
                               RRF_RT_REG_DWORD, nullptr, &light_mode,
                               &light_mode_size);

  if (result == ERROR_SUCCESS) {
    BOOL enable_dark_mode = light_mode == 0;
    DwmSetWindowAttribute(window, DWMWA_USE_IMMERSIVE_DARK_MODE,
                          &enable_dark_mode, sizeof(enable_dark_mode));
  }
}
</file>

<file path="windows/runner/win32_window.h">
#ifndef RUNNER_WIN32_WINDOW_H_
#define RUNNER_WIN32_WINDOW_H_

#include <windows.h>

#include <functional>
#include <memory>
#include <string>

// A class abstraction for a high DPI-aware Win32 Window. Intended to be
// inherited from by classes that wish to specialize with custom
// rendering and input handling
class Win32Window {
 public:
  struct Point {
    unsigned int x;
    unsigned int y;
    Point(unsigned int x, unsigned int y) : x(x), y(y) {}
  };

  struct Size {
    unsigned int width;
    unsigned int height;
    Size(unsigned int width, unsigned int height)
        : width(width), height(height) {}
  };

  Win32Window();
  virtual ~Win32Window();

  // Creates a win32 window with |title| that is positioned and sized using
  // |origin| and |size|. New windows are created on the default monitor. Window
  // sizes are specified to the OS in physical pixels, hence to ensure a
  // consistent size this function will scale the inputted width and height as
  // as appropriate for the default monitor. The window is invisible until
  // |Show| is called. Returns true if the window was created successfully.
  bool Create(const std::wstring& title, const Point& origin, const Size& size);

  // Show the current window. Returns true if the window was successfully shown.
  bool Show();

  // Release OS resources associated with window.
  void Destroy();

  // Inserts |content| into the window tree.
  void SetChildContent(HWND content);

  // Returns the backing Window handle to enable clients to set icon and other
  // window properties. Returns nullptr if the window has been destroyed.
  HWND GetHandle();

  // If true, closing this window will quit the application.
  void SetQuitOnClose(bool quit_on_close);

  // Return a RECT representing the bounds of the current client area.
  RECT GetClientArea();

 protected:
  // Processes and route salient window messages for mouse handling,
  // size change and DPI. Delegates handling of these to member overloads that
  // inheriting classes can handle.
  virtual LRESULT MessageHandler(HWND window,
                                 UINT const message,
                                 WPARAM const wparam,
                                 LPARAM const lparam) noexcept;

  // Called when CreateAndShow is called, allowing subclass window-related
  // setup. Subclasses should return false if setup fails.
  virtual bool OnCreate();

  // Called when Destroy is called.
  virtual void OnDestroy();

 private:
  friend class WindowClassRegistrar;

  // OS callback called by message pump. Handles the WM_NCCREATE message which
  // is passed when the non-client area is being created and enables automatic
  // non-client DPI scaling so that the non-client area automatically
  // responds to changes in DPI. All other messages are handled by
  // MessageHandler.
  static LRESULT CALLBACK WndProc(HWND const window,
                                  UINT const message,
                                  WPARAM const wparam,
                                  LPARAM const lparam) noexcept;

  // Retrieves a class instance pointer for |window|
  static Win32Window* GetThisFromHandle(HWND const window) noexcept;

  // Update the window frame's theme to match the system theme.
  static void UpdateTheme(HWND const window);

  bool quit_on_close_ = false;

  // window handle for top level window.
  HWND window_handle_ = nullptr;

  // window handle for hosted content.
  HWND child_content_ = nullptr;
};

#endif  // RUNNER_WIN32_WINDOW_H_
</file>

<file path="windows/.gitignore">
flutter/ephemeral/

# Visual Studio user-specific files.
*.suo
*.user
*.userosscache
*.sln.docstates

# Visual Studio build-related files.
x64/
x86/

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!*.[Cc]ache/
</file>

<file path="windows/CMakeLists.txt">
# Project-level configuration.
cmake_minimum_required(VERSION 3.14)
project(n06 LANGUAGES CXX)

# The name of the executable created for the application. Change this to change
# the on-disk name of your application.
set(BINARY_NAME "n06")

# Explicitly opt in to modern CMake behaviors to avoid warnings with recent
# versions of CMake.
cmake_policy(VERSION 3.14...3.25)

# Define build configuration option.
get_property(IS_MULTICONFIG GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(IS_MULTICONFIG)
  set(CMAKE_CONFIGURATION_TYPES "Debug;Profile;Release"
    CACHE STRING "" FORCE)
else()
  if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
    set(CMAKE_BUILD_TYPE "Debug" CACHE
      STRING "Flutter build mode" FORCE)
    set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS
      "Debug" "Profile" "Release")
  endif()
endif()
# Define settings for the Profile build mode.
set(CMAKE_EXE_LINKER_FLAGS_PROFILE "${CMAKE_EXE_LINKER_FLAGS_RELEASE}")
set(CMAKE_SHARED_LINKER_FLAGS_PROFILE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE}")
set(CMAKE_C_FLAGS_PROFILE "${CMAKE_C_FLAGS_RELEASE}")
set(CMAKE_CXX_FLAGS_PROFILE "${CMAKE_CXX_FLAGS_RELEASE}")

# Use Unicode for all projects.
add_definitions(-DUNICODE -D_UNICODE)

# Compilation settings that should be applied to most targets.
#
# Be cautious about adding new options here, as plugins use this function by
# default. In most cases, you should add new options to specific targets instead
# of modifying this function.
function(APPLY_STANDARD_SETTINGS TARGET)
  target_compile_features(${TARGET} PUBLIC cxx_std_17)
  target_compile_options(${TARGET} PRIVATE /W4 /WX /wd"4100")
  target_compile_options(${TARGET} PRIVATE /EHsc)
  target_compile_definitions(${TARGET} PRIVATE "_HAS_EXCEPTIONS=0")
  target_compile_definitions(${TARGET} PRIVATE "$<$<CONFIG:Debug>:_DEBUG>")
endfunction()

# Flutter library and tool build rules.
set(FLUTTER_MANAGED_DIR "${CMAKE_CURRENT_SOURCE_DIR}/flutter")
add_subdirectory(${FLUTTER_MANAGED_DIR})

# Application build; see runner/CMakeLists.txt.
add_subdirectory("runner")


# Generated plugin build rules, which manage building the plugins and adding
# them to the application.
include(flutter/generated_plugins.cmake)


# === Installation ===
# Support files are copied into place next to the executable, so that it can
# run in place. This is done instead of making a separate bundle (as on Linux)
# so that building and running from within Visual Studio will work.
set(BUILD_BUNDLE_DIR "$<TARGET_FILE_DIR:${BINARY_NAME}>")
# Make the "install" step default, as it's required to run.
set(CMAKE_VS_INCLUDE_INSTALL_TO_DEFAULT_BUILD 1)
if(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT)
  set(CMAKE_INSTALL_PREFIX "${BUILD_BUNDLE_DIR}" CACHE PATH "..." FORCE)
endif()

set(INSTALL_BUNDLE_DATA_DIR "${CMAKE_INSTALL_PREFIX}/data")
set(INSTALL_BUNDLE_LIB_DIR "${CMAKE_INSTALL_PREFIX}")

install(TARGETS ${BINARY_NAME} RUNTIME DESTINATION "${CMAKE_INSTALL_PREFIX}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_ICU_DATA_FILE}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  COMPONENT Runtime)

install(FILES "${FLUTTER_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
  COMPONENT Runtime)

if(PLUGIN_BUNDLED_LIBRARIES)
  install(FILES "${PLUGIN_BUNDLED_LIBRARIES}"
    DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
    COMPONENT Runtime)
endif()

# Copy the native assets provided by the build.dart from all packages.
set(NATIVE_ASSETS_DIR "${PROJECT_BUILD_DIR}native_assets/windows/")
install(DIRECTORY "${NATIVE_ASSETS_DIR}"
   DESTINATION "${INSTALL_BUNDLE_LIB_DIR}"
   COMPONENT Runtime)

# Fully re-copy the assets directory on each build to avoid having stale files
# from a previous install.
set(FLUTTER_ASSET_DIR_NAME "flutter_assets")
install(CODE "
  file(REMOVE_RECURSE \"${INSTALL_BUNDLE_DATA_DIR}/${FLUTTER_ASSET_DIR_NAME}\")
  " COMPONENT Runtime)
install(DIRECTORY "${PROJECT_BUILD_DIR}/${FLUTTER_ASSET_DIR_NAME}"
  DESTINATION "${INSTALL_BUNDLE_DATA_DIR}" COMPONENT Runtime)

# Install the AOT library on non-Debug builds only.
install(FILES "${AOT_LIBRARY}" DESTINATION "${INSTALL_BUNDLE_DATA_DIR}"
  CONFIGURATIONS Profile;Release
  COMPONENT Runtime)
</file>

<file path=".metadata">
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "adc901062556672b4138e18a4dc62a4be8f4b3c2"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: adc901062556672b4138e18a4dc62a4be8f4b3c2
      base_revision: adc901062556672b4138e18a4dc62a4be8f4b3c2
    - platform: android
      create_revision: adc901062556672b4138e18a4dc62a4be8f4b3c2
      base_revision: adc901062556672b4138e18a4dc62a4be8f4b3c2
    - platform: ios
      create_revision: adc901062556672b4138e18a4dc62a4be8f4b3c2
      base_revision: adc901062556672b4138e18a4dc62a4be8f4b3c2
    - platform: linux
      create_revision: adc901062556672b4138e18a4dc62a4be8f4b3c2
      base_revision: adc901062556672b4138e18a4dc62a4be8f4b3c2
    - platform: macos
      create_revision: adc901062556672b4138e18a4dc62a4be8f4b3c2
      base_revision: adc901062556672b4138e18a4dc62a4be8f4b3c2
    - platform: web
      create_revision: adc901062556672b4138e18a4dc62a4be8f4b3c2
      base_revision: adc901062556672b4138e18a4dc62a4be8f4b3c2
    - platform: windows
      create_revision: adc901062556672b4138e18a4dc62a4be8f4b3c2
      base_revision: adc901062556672b4138e18a4dc62a4be8f4b3c2

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'
</file>

<file path="analysis_options.yaml">
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options
</file>

<file path="build.yaml">
# Build configuration for code generation

targets:
  $default:
    builders:
      # Riverpod code generation
      riverpod_generator:
        generate_for:
          - lib/**
          - test/**
        options:
          # Generate code for both lib and test directories
          generate_combined_builder_output: true

      # Isar code generation
      isar_generator:
        generate_for:
          - lib/**
        options:
          # Isar specific options if needed
</file>

<file path="claude.md">
# GLP-1 MVP - Development Orchestration

## When to Use This Guide

**Before coding**: Read this document first to understand the workflow
**During development**: Use as navigation map to relevant documentation
**When stuck**: Check decision trees and critical rules

---


## Critical Rules (Non-negotiable)

### Layer Dependency
```
Presentation → Application → Domain ← Infrastructure
```

**Violation = Immediate rejection**

### Repository Pattern
```
Application/Presentation → Repository Interface (Domain)
                        → Repository Implementation (Infrastructure)
```

**Why**: Phase 1 transition depends on this (1-line change)

---

## Decision Trees

### "Where should this code go?"

```
Is it UI rendering?
  → Presentation Layer (features/{feature}/presentation/)

Is it state management or UseCase orchestration?
  → Application Layer (features/{feature}/application/)

Is it business logic or data model?
  → Domain Layer (features/{feature}/domain/)

Is it database access or DTO conversion?
  → Infrastructure Layer (features/{feature}/infrastructure/)
```

### "What Provider type should I use?"

```
CRUD operations with async?
  → AsyncNotifierProvider (see state-management.md)

Real-time Isar watch?
  → StreamProvider (see state-management.md)

Immutable service or repository?
  → Provider (see state-management.md)

Derived calculation from other providers?
  → Provider (see state-management.md)
```

---


## Common Mistakes

### ❌ NEVER
```dart
// Application accessing Isar directly
final isar = ref.watch(isarProvider); // WRONG

// Skipping Repository interface
class ConcreteRepository { } // WRONG (no interface)

// Domain importing Flutter
import 'package:flutter/material.dart'; // in domain/ folder

// Writing code before test
// (Violates TDD - see docs/tdd.md)
```

### ✅ ALWAYS
```dart
// Use Repository interface
final repo = ref.read(medicationRepositoryProvider);

// Domain defines interface
abstract class MedicationRepository { }

// Infrastructure implements
class IsarMedicationRepository implements MedicationRepository { }

// Test first
test('should...', () { }); // Then write code
```

**Details**: See `docs/code_structure.md` (DO/DON'T sections)

---

## Quick Reference

### File Location Patterns
```
features/{feature}/
  presentation/screens/{feature}_screen.dart
  application/notifiers/{feature}_notifier.dart
  domain/entities/{entity}.dart
  domain/repositories/{feature}_repository.dart
  infrastructure/repositories/isar_{feature}_repository.dart
  infrastructure/dtos/{entity}_dto.dart
```

### Naming Conventions
```
Entity: DoseRecord (domain/entities/)
DTO: DoseRecordDto (infrastructure/dtos/)
Repository Interface: MedicationRepository (domain/repositories/)
Repository Impl: IsarMedicationRepository (infrastructure/repositories/)
Notifier: MedicationNotifier (application/notifiers/)
Provider: medicationNotifierProvider
```

**Full structure**: See `docs/code_structure.md`

---

## Phase 0 → Phase 1 Transition

**Impact**: Infrastructure Layer ONLY (1-line change per repository)

```dart
// Phase 0
@riverpod
MedicationRepository medicationRepository(ref) =>
  IsarMedicationRepository(ref.watch(isarProvider));

// Phase 1
@riverpod
MedicationRepository medicationRepository(ref) =>
  SupabaseMedicationRepository(ref.watch(supabaseProvider));
```

**Zero changes**: Domain, Application, Presentation

**Requirement**: Repository Pattern strictly enforced

**Details**: See `docs/techstack.md` (Phase Transition section)

---

## Before Committing

```
[ ] Tests pass (flutter test)
[ ] No warnings (flutter analyze)
[ ] TDD cycle completed (docs/tdd.md)
[ ] Repository pattern maintained (docs/code_structure.md)
[ ] No layer violations (check imports)
[ ] Performance constraints met (docs/requirements.md)
```

---

## When Stuck

### Architecture questions
→ `docs/code_structure.md`

### State management questions
→ `docs/state-management.md`

### Business logic questions
→ `docs/requirements.md` or `docs/userflow.md`

### Data model questions
→ `docs/database.md`

### Testing questions
→ `docs/tdd.md`

### Technology choice questions
→ `docs/techstack.md`

---

## Core Principles

1. **Separation of Concerns**: Each layer has ONE responsibility (see code_structure.md)
2. **Dependency Inversion**: Depend on interfaces, not implementations (Repository Pattern)
3. **Test-Driven**: Test first, code second (see tdd.md)
4. **Phase Flexibility**: Infrastructure-only changes for Phase 1 (see techstack.md)

## rules
- sot 문서를 작성할 때는 한글로 작성하라.
</file>

<file path="devtools_options.yaml">
description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:
  - patrol: true
</file>

<file path="android/app/build.gradle.kts">
plugins {
    id("com.android.application")
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.glp1.n06"
    compileSdk = 34
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
        isCoreLibraryDesugaringEnabled = true
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.glp1.n06"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
        }
    }
}

flutter {
    source = "../.."
}

dependencies {
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.0.4")
}
</file>

<file path="android/build.gradle.kts">
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory =
    rootProject.layout.buildDirectory
        .dir("../../build")
        .get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)

    // Apply Java toolchain configuration after plugins are loaded
    pluginManager.withPlugin("java") {
        extensions.configure<JavaPluginExtension> {
            toolchain {
                languageVersion.set(JavaLanguageVersion.of(11))
            }
        }
    }

    tasks.withType<JavaCompile>().configureEach {
        sourceCompatibility = JavaVersion.VERSION_11.toString()
        targetCompatibility = JavaVersion.VERSION_11.toString()
    }

    tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile>().configureEach {
        kotlinOptions {
            jvmTarget = "11"
        }
    }
}

subprojects {
    afterEvaluate {
        if (plugins.hasPlugin("com.android.application") || plugins.hasPlugin("com.android.library")) {
            configure<com.android.build.gradle.BaseExtension> {
                compileSdkVersion(34)
            }
        }
    }
}

subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}
</file>

<file path="android/gradle.properties">
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true

# Disable Kotlin JVM target validation
kotlin.jvm.target.validation.mode=warning
</file>

<file path="ios/Runner/Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>N06</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>n06</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
	<!-- Kakao & Naver URL Schemes -->
	<key>LSApplicationQueriesSchemes</key>
	<array>
		<!-- Kakao -->
		<string>kakaokompassauth</string>
		<string>kakaolink</string>
		<!-- Naver -->
		<string>naversearchapp</string>
		<string>naversearchthirdlogin</string>
	</array>
	<!-- Custom URL Schemes -->
	<key>CFBundleURLTypes</key>
	<array>
		<!-- Kakao -->
		<dict>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>CFBundleURLSchemes</key>
			<array>
				<string>kakao32dfc3999b53af153dbcefa7014093bc</string>
			</array>
		</dict>
		<!-- Naver (Bundle ID 기반) -->
		<dict>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>CFBundleURLSchemes</key>
			<array>
				<string>com.glp1.n06</string>
			</array>
		</dict>
	</array>
</dict>
</plist>
</file>

<file path="ios/Runner.xcodeproj/project.pbxproj">
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */ = {isa = PBXBuildFile; fileRef = 1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */; };
		331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C807B294A618700263BE5 /* RunnerTests.swift */; };
		3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */ = {isa = PBXBuildFile; fileRef = 3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */; };
		74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 74858FAE1ED2DC5600515810 /* AppDelegate.swift */; };
		97C146FC1CF9000F007C117D /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FA1CF9000F007C117D /* Main.storyboard */; };
		97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FD1CF9000F007C117D /* Assets.xcassets */; };
		97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */; };
		B68150C38358B76E6FB85606 /* Pods_Runner.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 4F868B28A947C826EF2684DD /* Pods_Runner.framework */; };
		EFC5FBF477996D670559CCD2 /* Pods_RunnerTests.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 768258261C04F770109F7E43 /* Pods_RunnerTests.framework */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C8085294A63A400263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 97C146E61CF9000F007C117D /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 97C146ED1CF9000F007C117D;
			remoteInfo = Runner;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		9705A1C41CF9048500538489 /* Embed Frameworks */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Embed Frameworks";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = GeneratedPluginRegistrant.h; sourceTree = "<group>"; };
		1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GeneratedPluginRegistrant.m; sourceTree = "<group>"; };
		331C807B294A618700263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		331C8081294A63A400263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		35E92D4B5EC498C7010AAB41 /* Pods-RunnerTests.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.release.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.release.xcconfig"; sourceTree = "<group>"; };
		37224E2ADD0146FD9CDFF7F2 /* Pods-Runner.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.release.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"; sourceTree = "<group>"; };
		3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = AppFrameworkInfo.plist; path = Flutter/AppFrameworkInfo.plist; sourceTree = "<group>"; };
		4CE0855CADAA9F3EC99C8690 /* Pods-RunnerTests.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.profile.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.profile.xcconfig"; sourceTree = "<group>"; };
		4F868B28A947C826EF2684DD /* Pods_Runner.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_Runner.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		60E639334F0804AD5D15668D /* Pods-Runner.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.profile.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig"; sourceTree = "<group>"; };
		74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "Runner-Bridging-Header.h"; sourceTree = "<group>"; };
		74858FAE1ED2DC5600515810 /* AppDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		768258261C04F770109F7E43 /* Pods_RunnerTests.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_RunnerTests.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = Release.xcconfig; path = Flutter/Release.xcconfig; sourceTree = "<group>"; };
		7B64C5F021806937E316B521 /* Pods-RunnerTests.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.debug.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.debug.xcconfig"; sourceTree = "<group>"; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Debug.xcconfig; path = Flutter/Debug.xcconfig; sourceTree = "<group>"; };
		9740EEB31CF90195004384FC /* Generated.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Generated.xcconfig; path = Flutter/Generated.xcconfig; sourceTree = "<group>"; };
		97C146EE1CF9000F007C117D /* Runner.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Runner.app; sourceTree = BUILT_PRODUCTS_DIR; };
		97C146FB1CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
		97C146FD1CF9000F007C117D /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		97C147001CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
		97C147021CF9000F007C117D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		F3331C6A5FA9079262775E3F /* Pods-Runner.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.debug.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		7B50AA39F68FF0A0B5471004 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				EFC5FBF477996D670559CCD2 /* Pods_RunnerTests.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EB1CF9000F007C117D /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				B68150C38358B76E6FB85606 /* Pods_Runner.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		331C8082294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C807B294A618700263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		88DD77DA018B2CA99A3D45F0 /* Pods */ = {
			isa = PBXGroup;
			children = (
				F3331C6A5FA9079262775E3F /* Pods-Runner.debug.xcconfig */,
				37224E2ADD0146FD9CDFF7F2 /* Pods-Runner.release.xcconfig */,
				60E639334F0804AD5D15668D /* Pods-Runner.profile.xcconfig */,
				7B64C5F021806937E316B521 /* Pods-RunnerTests.debug.xcconfig */,
				35E92D4B5EC498C7010AAB41 /* Pods-RunnerTests.release.xcconfig */,
				4CE0855CADAA9F3EC99C8690 /* Pods-RunnerTests.profile.xcconfig */,
			);
			path = Pods;
			sourceTree = "<group>";
		};
		9740EEB11CF90186004384FC /* Flutter */ = {
			isa = PBXGroup;
			children = (
				3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				9740EEB31CF90195004384FC /* Generated.xcconfig */,
			);
			name = Flutter;
			sourceTree = "<group>";
		};
		97C146E51CF9000F007C117D = {
			isa = PBXGroup;
			children = (
				9740EEB11CF90186004384FC /* Flutter */,
				97C146F01CF9000F007C117D /* Runner */,
				97C146EF1CF9000F007C117D /* Products */,
				331C8082294A63A400263BE5 /* RunnerTests */,
				88DD77DA018B2CA99A3D45F0 /* Pods */,
				F9CECB710402832D83334A60 /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		97C146EF1CF9000F007C117D /* Products */ = {
			isa = PBXGroup;
			children = (
				97C146EE1CF9000F007C117D /* Runner.app */,
				331C8081294A63A400263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		97C146F01CF9000F007C117D /* Runner */ = {
			isa = PBXGroup;
			children = (
				97C146FA1CF9000F007C117D /* Main.storyboard */,
				97C146FD1CF9000F007C117D /* Assets.xcassets */,
				97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */,
				97C147021CF9000F007C117D /* Info.plist */,
				1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */,
				1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */,
				74858FAE1ED2DC5600515810 /* AppDelegate.swift */,
				74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
		F9CECB710402832D83334A60 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				4F868B28A947C826EF2684DD /* Pods_Runner.framework */,
				768258261C04F770109F7E43 /* Pods_RunnerTests.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C8080294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				EB9DEC5A849033785A9495F3 /* [CP] Check Pods Manifest.lock */,
				331C807D294A63A400263BE5 /* Sources */,
				331C807F294A63A400263BE5 /* Resources */,
				7B50AA39F68FF0A0B5471004 /* Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
				331C8086294A63A400263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C8081294A63A400263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		97C146ED1CF9000F007C117D /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				06AE9D005718BB4ADDB644B0 /* [CP] Check Pods Manifest.lock */,
				9740EEB61CF901F6004384FC /* Run Script */,
				97C146EA1CF9000F007C117D /* Sources */,
				97C146EB1CF9000F007C117D /* Frameworks */,
				97C146EC1CF9000F007C117D /* Resources */,
				9705A1C41CF9048500538489 /* Embed Frameworks */,
				3B06AD1E1E4923F5004D2608 /* Thin Binary */,
				F24C38ADCFB1B177EB855004 /* [CP] Embed Pods Frameworks */,
				79E029AC4483F349DE2380E7 /* [CP] Copy Pods Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = Runner;
			productName = Runner;
			productReference = 97C146EE1CF9000F007C117D /* Runner.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		97C146E61CF9000F007C117D /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C8080294A63A400263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 97C146ED1CF9000F007C117D;
					};
					97C146ED1CF9000F007C117D = {
						CreatedOnToolsVersion = 7.3.1;
						LastSwiftMigration = 1100;
					};
				};
			};
			buildConfigurationList = 97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 97C146E51CF9000F007C117D;
			productRefGroup = 97C146EF1CF9000F007C117D /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				97C146ED1CF9000F007C117D /* Runner */,
				331C8080294A63A400263BE5 /* RunnerTests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C807F294A63A400263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EC1CF9000F007C117D /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */,
				3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */,
				97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */,
				97C146FC1CF9000F007C117D /* Main.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		06AE9D005718BB4ADDB644B0 /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-Runner-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		3B06AD1E1E4923F5004D2608 /* Thin Binary */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${TARGET_BUILD_DIR}/${INFOPLIST_PATH}",
			);
			name = "Thin Binary";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" embed_and_thin";
		};
		79E029AC4483F349DE2380E7 /* [CP] Copy Pods Resources */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources-${CONFIGURATION}-input-files.xcfilelist",
			);
			name = "[CP] Copy Pods Resources";
			outputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources-${CONFIGURATION}-output-files.xcfilelist",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-resources.sh\"\n";
			showEnvVarsInLog = 0;
		};
		9740EEB61CF901F6004384FC /* Run Script */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "Run Script";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" build";
		};
		EB9DEC5A849033785A9495F3 /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-RunnerTests-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		F24C38ADCFB1B177EB855004 /* [CP] Embed Pods Frameworks */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-input-files.xcfilelist",
			);
			name = "[CP] Embed Pods Frameworks";
			outputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-output-files.xcfilelist",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks.sh\"\n";
			showEnvVarsInLog = 0;
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C807D294A63A400263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EA1CF9000F007C117D /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */,
				1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C8086294A63A400263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 97C146ED1CF9000F007C117D /* Runner */;
			targetProxy = 331C8085294A63A400263BE5 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		97C146FA1CF9000F007C117D /* Main.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C146FB1CF9000F007C117D /* Base */,
			);
			name = Main.storyboard;
			sourceTree = "<group>";
		};
		97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C147001CF9000F007C117D /* Base */,
			);
			name = LaunchScreen.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		249021D3217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				STRING_CATALOG_GENERATE_SYMBOLS = YES;
				SUPPORTED_PLATFORMS = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Profile;
		};
		249021D4217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.glp1.n06;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Profile;
		};
		331C8088294A63A400263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7B64C5F021806937E316B521 /* Pods-RunnerTests.debug.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.glp1.n06.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Debug;
		};
		331C8089294A63A400263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 35E92D4B5EC498C7010AAB41 /* Pods-RunnerTests.release.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.glp1.n06.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Release;
		};
		331C808A294A63A400263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 4CE0855CADAA9F3EC99C8690 /* Pods-RunnerTests.profile.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.glp1.n06.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Profile;
		};
		97C147031CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				STRING_CATALOG_GENERATE_SYMBOLS = YES;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		97C147041CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				STRING_CATALOG_GENERATE_SYMBOLS = YES;
				SUPPORTED_PLATFORMS = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		97C147061CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.glp1.n06;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Debug;
		};
		97C147071CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.glp1.n06;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C8088294A63A400263BE5 /* Debug */,
				331C8089294A63A400263BE5 /* Release */,
				331C808A294A63A400263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Debug;
		};
		97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147031CF9000F007C117D /* Debug */,
				97C147041CF9000F007C117D /* Release */,
				249021D3217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Debug;
		};
		97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147061CF9000F007C117D /* Debug */,
				97C147071CF9000F007C117D /* Release */,
				249021D4217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Debug;
		};
/* End XCConfigurationList section */
	};
	rootObject = 97C146E61CF9000F007C117D /* Project object */;
}
</file>

<file path="ios/Runner.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:Runner.xcodeproj">
   </FileRef>
   <FileRef
      location = "group:Pods/Pods.xcodeproj">
   </FileRef>
</Workspace>
</file>

<file path="ios/Podfile">
# Uncomment this line to define a global platform for your project
# platform :ios, '13.0'

# CocoaPods analytics sends network stats synchronously affecting flutter build latency.
ENV['COCOAPODS_DISABLE_STATS'] = 'true'

project 'Runner', {
  'Debug' => :debug,
  'Profile' => :release,
  'Release' => :release,
}

def flutter_root
  generated_xcode_build_settings_path = File.expand_path(File.join('..', 'Flutter', 'Generated.xcconfig'), __FILE__)
  unless File.exist?(generated_xcode_build_settings_path)
    raise "#{generated_xcode_build_settings_path} must exist. If you're running pod install manually, make sure flutter pub get is executed first"
  end

  File.foreach(generated_xcode_build_settings_path) do |line|
    matches = line.match(/FLUTTER_ROOT\=(.*)/)
    return matches[1].strip if matches
  end
  raise "FLUTTER_ROOT not found in #{generated_xcode_build_settings_path}. Try deleting Generated.xcconfig, then run flutter pub get"
end

require File.expand_path(File.join('packages', 'flutter_tools', 'bin', 'podhelper'), flutter_root)

flutter_ios_podfile_setup

target 'Runner' do
  use_frameworks!

  flutter_install_all_ios_pods File.dirname(File.realpath(__FILE__))
  target 'RunnerTests' do
    inherit! :search_paths
  end
end

post_install do |installer|
  installer.pods_project.targets.each do |target|
    flutter_additional_ios_build_settings(target)
    target.build_configurations.each do |config|
      config.build_settings['CLANG_ALLOW_NON_MODULAR_INCLUDES_IN_FRAMEWORK_MODULES'] = 'YES'
    end
  end
end
</file>

<file path="lib/features/authentication/infrastructure/datasources/naver_auth_datasource.dart">
import 'dart:developer' as developer;
import 'package:flutter/foundation.dart';
import 'package:flutter_naver_login/flutter_naver_login.dart';
import 'package:flutter_naver_login/interface/types/naver_token.dart';
import 'package:flutter_naver_login/interface/types/naver_account_result.dart';
import 'package:flutter_naver_login/interface/types/naver_login_result.dart';
import 'package:flutter_naver_login/interface/types/naver_login_status.dart';

/// Data source for Naver OAuth 2.0 authentication.
///
/// Implements the official Naver Flutter SDK login pattern:
/// 1. Call FlutterNaverLogin.logIn()
/// 2. Check NaverLoginStatus
/// 3. Throw exception if status is not loggedIn
class NaverAuthDataSource {
  /// Performs Naver login and validates the result.
  ///
  /// Throws:
  /// - [Exception] if login fails or user cancels
  /// - [Exception] if status is not NaverLoginStatus.loggedIn
  Future<NaverLoginResult> login() async {
    final NaverLoginResult result = await FlutterNaverLogin.logIn();

    if (result.status == NaverLoginStatus.error) {
      throw Exception('Naver login failed');
    } else if (result.status != NaverLoginStatus.loggedIn) {
      throw Exception('Naver login cancelled or failed');
    }

    return result;
  }

  /// Logs out from Naver and deletes local token.
  ///
  /// The SDK always deletes the local token regardless of API success,
  /// so errors are ignored to ensure local cleanup.
  Future<void> logout() async {
    try {
      await FlutterNaverLogin.logOutAndDeleteToken();
    } catch (error) {
      // SDK guarantees local token is deleted even if API fails
      // Log error but don't throw to ensure logout completes
      if (kDebugMode) {
        developer.log(
          'Naver logout completed with error (local token still deleted)',
          name: 'NaverAuthDataSource',
          error: error,
          level: 900,
        );
      }
    }
  }

  /// Retrieves Naver user information.
  ///
  /// The SDK automatically uses the current access token.
  /// No parameters needed.
  ///
  /// Throws:
  /// - [Exception] if not authenticated or API call fails
  Future<NaverAccountResult> getUser() async {
    return await FlutterNaverLogin.getCurrentAccount();
  }

  /// Gets the current access token and validates it.
  ///
  /// Throws:
  /// - [Exception] if token is expired or invalid
  Future<NaverToken> getCurrentToken() async {
    final NaverToken token =
        await FlutterNaverLogin.getCurrentAccessToken();

    if (!token.isValid()) {
      throw Exception('Naver token expired');
    }

    return token;
  }
}
</file>

<file path="lib/features/dashboard/application/providers.dart">
import 'package:n06/features/dashboard/domain/repositories/badge_repository.dart';
import 'package:n06/features/dashboard/infrastructure/repositories/isar_badge_repository.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:n06/core/providers.dart';

part 'providers.g.dart';

@riverpod
BadgeRepository badgeRepository(BadgeRepositoryRef ref) {
  final isar = ref.watch(isarProvider);
  return IsarBadgeRepository(isar);
}
</file>

<file path="lib/features/dashboard/domain/usecases/verify_badge_conditions_usecase.dart">
import 'package:n06/features/dashboard/domain/entities/user_badge.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';

class VerifyBadgeConditionsUseCase {
  /// 각 뱃지의 획득 조건을 검증하고 진행도를 계산합니다.
  List<UserBadge> execute({
    required List<UserBadge> currentBadges,
    required int continuousRecordDays,
    required double weightLossPercentage,
    required bool hasFirstDose,
    required List<DoseRecord> allDoseRecords,
  }) {
    final now = DateTime.now();
    final updatedBadges = <UserBadge>[];

    for (final badge in currentBadges) {
      var updatedBadge = badge;

      // 연속 7일 기록
      if (badge.badgeId == 'streak_7') {
        final progress = ((continuousRecordDays / 7) * 100).toInt().clamp(0, 100);
        updatedBadge = badge.copyWith(
          progressPercentage: progress,
          status: continuousRecordDays >= 7 ? BadgeStatus.achieved : BadgeStatus.inProgress,
          achievedAt: continuousRecordDays >= 7 && badge.achievedAt == null ? now : badge.achievedAt,
          updatedAt: now,
        );
      }

      // 연속 30일 기록
      if (badge.badgeId == 'streak_30') {
        final progress = ((continuousRecordDays / 30) * 100).toInt().clamp(0, 100);
        updatedBadge = badge.copyWith(
          progressPercentage: progress,
          status: continuousRecordDays >= 30 ? BadgeStatus.achieved : BadgeStatus.inProgress,
          achievedAt: continuousRecordDays >= 30 && badge.achievedAt == null ? now : badge.achievedAt,
          updatedAt: now,
        );
      }

      // 체중 5% 감량
      if (badge.badgeId == 'weight_5percent') {
        final progress = ((weightLossPercentage / 5) * 100).toInt().clamp(0, 100);
        updatedBadge = badge.copyWith(
          progressPercentage: progress,
          status: weightLossPercentage >= 5.0 ? BadgeStatus.achieved : BadgeStatus.inProgress,
          achievedAt: weightLossPercentage >= 5.0 && badge.achievedAt == null ? now : badge.achievedAt,
          updatedAt: now,
        );
      }

      // 체중 10% 감량
      if (badge.badgeId == 'weight_10percent') {
        final progress = ((weightLossPercentage / 10) * 100).toInt().clamp(0, 100);
        updatedBadge = badge.copyWith(
          progressPercentage: progress,
          status: weightLossPercentage >= 10.0 ? BadgeStatus.achieved : BadgeStatus.inProgress,
          achievedAt: weightLossPercentage >= 10.0 && badge.achievedAt == null ? now : badge.achievedAt,
          updatedAt: now,
        );
      }

      // 첫 투여 완료
      if (badge.badgeId == 'first_dose') {
        updatedBadge = badge.copyWith(
          progressPercentage: hasFirstDose ? 100 : 0,
          status: hasFirstDose ? BadgeStatus.achieved : BadgeStatus.locked,
          achievedAt: hasFirstDose && badge.achievedAt == null ? now : badge.achievedAt,
          updatedAt: now,
        );
      }

      updatedBadges.add(updatedBadge);
    }

    return updatedBadges;
  }
}
</file>

<file path="lib/features/dashboard/infrastructure/dtos/user_badge_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/dashboard/domain/entities/user_badge.dart';

part 'user_badge_dto.g.dart';

@collection
class UserBadgeDto {
  Id? isarId;
  late String id;
  late String userId;
  late String badgeId;
  late String status; // enum string: locked, inProgress, achieved
  late int progressPercentage;
  DateTime? achievedAt;
  late DateTime createdAt;
  late DateTime updatedAt;

  UserBadgeDto();

  UserBadge toEntity() {
    return UserBadge(
      id: id,
      userId: userId,
      badgeId: badgeId,
      status: _stringToStatus(status),
      progressPercentage: progressPercentage,
      achievedAt: achievedAt,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  factory UserBadgeDto.fromEntity(UserBadge entity) {
    return UserBadgeDto()
      ..id = entity.id
      ..userId = entity.userId
      ..badgeId = entity.badgeId
      ..status = entity.status.toString().split('.').last
      ..progressPercentage = entity.progressPercentage
      ..achievedAt = entity.achievedAt
      ..createdAt = entity.createdAt
      ..updatedAt = entity.updatedAt;
  }

  UserBadgeDto copyWith({
    Id? isarId,
    String? id,
    String? userId,
    String? badgeId,
    String? status,
    int? progressPercentage,
    DateTime? achievedAt,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return UserBadgeDto()
      ..isarId = isarId ?? this.isarId
      ..id = id ?? this.id
      ..userId = userId ?? this.userId
      ..badgeId = badgeId ?? this.badgeId
      ..status = status ?? this.status
      ..progressPercentage = progressPercentage ?? this.progressPercentage
      ..achievedAt = achievedAt ?? this.achievedAt
      ..createdAt = createdAt ?? this.createdAt
      ..updatedAt = updatedAt ?? this.updatedAt;
  }

  static BadgeStatus _stringToStatus(String value) {
    return BadgeStatus.values.firstWhere(
      (e) => e.toString().split('.').last == value,
      orElse: () => BadgeStatus.locked,
    );
  }
}
</file>

<file path="lib/features/data_sharing/application/notifiers/data_sharing_notifier.dart">
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:n06/features/data_sharing/domain/entities/shared_data_report.dart';
import 'package:n06/features/data_sharing/domain/repositories/date_range.dart';
import 'package:n06/features/data_sharing/application/providers.dart';

part 'data_sharing_notifier.g.dart';

class DataSharingState {
  final bool isActive;
  final DateRange? selectedPeriod;
  final SharedDataReport? report;
  final String? error;
  final bool isLoading;

  DataSharingState({
    this.isActive = false,
    this.selectedPeriod,
    this.report,
    this.error,
    this.isLoading = false,
  });

  DataSharingState copyWith({
    bool? isActive,
    DateRange? selectedPeriod,
    SharedDataReport? report,
    String? error,
    bool? isLoading,
  }) {
    return DataSharingState(
      isActive: isActive ?? this.isActive,
      selectedPeriod: selectedPeriod ?? this.selectedPeriod,
      report: report ?? this.report,
      error: error ?? this.error,
      isLoading: isLoading ?? this.isLoading,
    );
  }
}

@riverpod
class DataSharingNotifier extends _$DataSharingNotifier {
  @override
  DataSharingState build() {
    return DataSharingState(isActive: false);
  }

  Future<void> enterSharingMode(String userId, DateRange period) async {
    try {
      state = state.copyWith(isLoading: true, error: null);

      final repository = ref.read(sharedDataRepositoryProvider);
      final report = await repository.getReportData(userId, period);

      state = state.copyWith(
        isActive: true,
        selectedPeriod: period,
        report: report,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        error: e.toString(),
        isLoading: false,
      );
    }
  }

  Future<void> changePeriod(String userId, DateRange period) async {
    try {
      state = state.copyWith(isLoading: true, error: null);

      final repository = ref.read(sharedDataRepositoryProvider);
      final report = await repository.getReportData(userId, period);

      state = state.copyWith(
        selectedPeriod: period,
        report: report,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        error: e.toString(),
        isLoading: false,
      );
    }
  }

  void exitSharingMode() {
    state = DataSharingState(isActive: false);
  }
}
</file>

<file path="lib/features/data_sharing/application/providers.dart">
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:n06/features/data_sharing/infrastructure/repositories/isar_shared_data_repository.dart';
import 'package:n06/features/data_sharing/domain/repositories/shared_data_repository.dart';
import 'package:n06/core/providers.dart';

part 'providers.g.dart';

@riverpod
SharedDataRepository sharedDataRepository(SharedDataRepositoryRef ref) {
  final isar = ref.watch(isarProvider);
  return IsarSharedDataRepository(isar);
}
</file>

<file path="lib/features/data_sharing/domain/usecases/data_sharing_aggregator.dart">
import 'package:n06/features/data_sharing/domain/entities/shared_data_report.dart';

class DataSharingAggregator {
  /// Calculate weight change trend from report
  WeightTrend calculateWeightTrend(SharedDataReport report) {
    final sortedWeights = report.getWeightLogsSorted();

    if (sortedWeights.isEmpty) {
      return WeightTrend(
        startWeight: null,
        endWeight: null,
        change: 0,
        changePercentage: 0,
      );
    }

    final startWeight = sortedWeights.first.weightKg;
    final endWeight = sortedWeights.last.weightKg;
    final change = endWeight - startWeight;
    final changePercentage = (startWeight > 0 ? (change / startWeight) * 100 : 0).toDouble();

    return WeightTrend(
      startWeight: startWeight,
      endWeight: endWeight,
      change: change,
      changePercentage: changePercentage,
    );
  }

  /// Calculate average symptom severity from report
  double calculateAverageSeverity(SharedDataReport report) {
    if (report.symptomLogs.isEmpty) {
      return 0;
    }

    final totalSeverity = report.symptomLogs.fold<double>(
      0,
      (sum, log) => sum + log.severity,
    );

    return totalSeverity / report.symptomLogs.length;
  }

  /// Group symptoms by context tags
  Map<String, int> groupSymptomsByTag(SharedDataReport report) {
    final tagMap = <String, int>{};

    for (final log in report.symptomLogs) {
      for (final tag in log.tags) {
        tagMap[tag] = (tagMap[tag] ?? 0) + 1;
      }
    }

    return tagMap;
  }

  /// Identify dose escalation points from schedules
  List<DateTime> identifyEscalationPoints(SharedDataReport report) {
    final sortedSchedules = report.doseSchedules.toList()
      ..sort((a, b) => a.scheduledDate.compareTo(b.scheduledDate));

    final escalationPoints = <DateTime>[];
    double? previousDose;

    for (final schedule in sortedSchedules) {
      if (previousDose != null && schedule.scheduledDoseMg > previousDose) {
        escalationPoints.add(schedule.scheduledDate);
      }
      previousDose = schedule.scheduledDoseMg;
    }

    return escalationPoints;
  }
}

class WeightTrend {
  final double? startWeight;
  final double? endWeight;
  final double change;
  final double changePercentage;

  WeightTrend({
    required this.startWeight,
    required this.endWeight,
    required this.change,
    required this.changePercentage,
  });

  bool get isPositive => change > 0;
  bool get isNegative => change < 0;
  bool get isNoChange => change == 0;
}
</file>

<file path="lib/features/data_sharing/infrastructure/repositories/isar_shared_data_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/data_sharing/domain/entities/emergency_symptom_check.dart';
import 'package:n06/features/data_sharing/domain/entities/shared_data_report.dart';
import 'package:n06/features/data_sharing/domain/repositories/date_range.dart';
import 'package:n06/features/data_sharing/domain/repositories/shared_data_repository.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/infrastructure/dtos/dose_record_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/dose_schedule_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/weight_log_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/symptom_log_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/symptom_context_tag_dto.dart';

class IsarSharedDataRepository implements SharedDataRepository {
  final Isar isar;

  IsarSharedDataRepository(this.isar);

  @override
  Future<SharedDataReport> getReportData(String userId, DateRange dateRange) async {
    // Calculate date range
    final now = DateTime.now();
    final endDate = DateTime(now.year, now.month, now.day);
    final startDate = dateRange.getStartDate(endDate);

    // Fetch dose records within date range
    final doseRecordDtos = await isar.doseRecordDtos
        .where()
        .indexedDateBetween(startDate, endDate)
        .findAll();
    final doseRecords = doseRecordDtos.map((dto) => dto.toEntity()).toList();

    // Fetch dose schedules within date range (for adherence calculation)
    final doseScheduleDtos = await isar.doseScheduleDtos.where().findAll();
    final doseSchedulesInRange = doseScheduleDtos.where((dto) {
      return !dto.scheduledDate.isBefore(startDate) &&
          !dto.scheduledDate.isAfter(endDate);
    }).toList();
    final doseSchedules = doseSchedulesInRange.map((dto) => dto.toEntity()).toList();

    // Fetch weight logs within date range, filtered by user
    final weightLogDtos = await isar.weightLogDtos.where().findAll();
    final weightLogsInRange = weightLogDtos
        .where((dto) {
          final dtoDate = DateTime(dto.logDate.year, dto.logDate.month, dto.logDate.day);
          return dto.userId == userId &&
              !dtoDate.isBefore(startDate) &&
              !dtoDate.isAfter(endDate);
        })
        .map((dto) => dto.toEntity())
        .toList();

    // Fetch symptom logs within date range, filtered by user
    final symptomLogDtos = await isar.symptomLogDtos.where().findAll();
    final filteredSymptomDtos = symptomLogDtos
        .where((dto) => dto.userId == userId)
        .toList();

    final List<dynamic> symptomLogsInRange = [];
    for (final symptomDto in filteredSymptomDtos) {
      final dtoDate = DateTime(symptomDto.logDate.year, symptomDto.logDate.month, symptomDto.logDate.day);
      if (!dtoDate.isBefore(startDate) && !dtoDate.isAfter(endDate)) {
        // Fetch associated tags for this symptom
        final tags = await isar.symptomContextTagDtos.where().findAll();
        final tagsForSymptom = tags
            .where((tagDto) => tagDto.symptomLogIsarId == symptomDto.id)
            .map((tagDto) => tagDto.tagName)
            .toList();

        symptomLogsInRange.add(symptomDto.toEntity(tags: tagsForSymptom));
      }
    }

    // For now, emergency checks are empty as they're not yet implemented
    // TODO: Implement emergency symptom check storage
    final emergencyChecks = <EmergencySymptomCheck>[];

    // Cast symptom logs to proper type
    final List<dynamic> symptomLogsCasted = List<dynamic>.from(symptomLogsInRange);

    return SharedDataReport(
      dateRangeStart: startDate,
      dateRangeEnd: endDate,
      doseRecords: doseRecords,
      weightLogs: weightLogsInRange,
      symptomLogs: symptomLogsCasted.cast<SymptomLog>(),
      emergencyChecks: emergencyChecks,
      doseSchedules: doseSchedules,
    );
  }
}
</file>

<file path="lib/features/notification/infrastructure/services/local_notification_scheduler.dart">
import 'package:flutter/material.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:n06/features/notification/domain/services/notification_scheduler.dart';
import 'package:n06/features/notification/infrastructure/services/permission_service.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';
import 'package:timezone/timezone.dart' as tz;

/// flutter_local_notifications를 사용한 알림 스케줄링 구현
class LocalNotificationScheduler implements NotificationScheduler {
  final PermissionService _permissionService;
  late FlutterLocalNotificationsPlugin _flutterLocalNotificationsPlugin;
  bool _isInitialized = false;

  LocalNotificationScheduler(this._permissionService) {
    _flutterLocalNotificationsPlugin = FlutterLocalNotificationsPlugin();
  }

  /// 플러그인 초기화
  Future<void> initialize() async {
    const AndroidInitializationSettings androidInitializationSettings =
        AndroidInitializationSettings('app_icon');
    const DarwinInitializationSettings iOSInitializationSettings =
        DarwinInitializationSettings(
      requestAlertPermission: true,
      requestBadgePermission: true,
      requestSoundPermission: true,
    );

    const InitializationSettings initializationSettings =
        InitializationSettings(
      android: androidInitializationSettings,
      iOS: iOSInitializationSettings,
    );

    await _flutterLocalNotificationsPlugin.initialize(
      initializationSettings,
      onDidReceiveNotificationResponse: _onNotificationResponse,
    );

    _isInitialized = true;
  }

  /// 초기화 여부
  bool get isInitialized => _isInitialized;

  /// 알림 권한 확인
  @override
  Future<bool> checkPermission() async {
    return await _permissionService.checkPermission();
  }

  /// 알림 권한 요청
  @override
  Future<bool> requestPermission() async {
    return await _permissionService.requestPermission();
  }

  /// 투여 스케줄 기반 알림 등록
  @override
  Future<void> scheduleNotifications({
    required List<DoseSchedule> doseSchedules,
    required TimeOfDay notificationTime,
  }) async {
    // 같은 날짜의 중복 제거
    final uniqueDates = <DateTime>{};
    final filteredSchedules = <DoseSchedule>[];

    for (final schedule in doseSchedules) {
      // 과거 날짜 제외
      if (schedule.scheduledDate.isBefore(DateTime.now())) {
        continue;
      }

      final dateOnly = DateTime(
        schedule.scheduledDate.year,
        schedule.scheduledDate.month,
        schedule.scheduledDate.day,
      );

      if (!uniqueDates.contains(dateOnly)) {
        uniqueDates.add(dateOnly);
        filteredSchedules.add(schedule);
      }
    }

    // 각 스케줄에 대해 알림 등록
    for (int i = 0; i < filteredSchedules.length; i++) {
      final schedule = filteredSchedules[i];
      final scheduledDateTime = DateTime(
        schedule.scheduledDate.year,
        schedule.scheduledDate.month,
        schedule.scheduledDate.day,
        notificationTime.hour,
        notificationTime.minute,
      );

      // 알림 시간이 현재보다 이미 지난 경우, 다음날로 설정
      final notificationDateTime = scheduledDateTime.isBefore(DateTime.now())
          ? scheduledDateTime.add(const Duration(days: 1))
          : scheduledDateTime;

      const AndroidNotificationDetails androidNotificationDetails =
          AndroidNotificationDetails(
        'dose_notification_channel',
        '투여 알림',
        channelDescription: '투여 예정일 알림',
        importance: Importance.max,
        priority: Priority.high,
        showWhen: true,
      );

      const DarwinNotificationDetails iOSNotificationDetails =
          DarwinNotificationDetails(
        presentAlert: true,
        presentBadge: true,
        presentSound: true,
      );

      const NotificationDetails notificationDetails = NotificationDetails(
        android: androidNotificationDetails,
        iOS: iOSNotificationDetails,
      );

      await _flutterLocalNotificationsPlugin.zonedSchedule(
        i,
        '투여 예정일 알림',
        '오늘은 투여일입니다',
        tz.TZDateTime.from(notificationDateTime, tz.local),
        notificationDetails,
        androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
        uiLocalNotificationDateInterpretation:
            UILocalNotificationDateInterpretation.absoluteTime,
      );
    }
  }

  /// 모든 알림 취소
  @override
  Future<void> cancelAllNotifications() async {
    await _flutterLocalNotificationsPlugin.cancelAll();
  }

  /// 대기 중인 알림 목록 조회
  Future<List<PendingNotificationRequest>> getPendingNotifications() async {
    return await _flutterLocalNotificationsPlugin.pendingNotificationRequests();
  }

  /// 알림 응답 처리
  void _onNotificationResponse(NotificationResponse notificationResponse) {
    // 알림 탭했을 때의 처리 로직
    // 추후 Router를 통해 투여 스케줄러 화면으로 이동하도록 설정 가능
  }
}
</file>

<file path="lib/features/notification/infrastructure/services/permission_service.dart">
import 'package:permission_handler/permission_handler.dart' as permission_handler;

/// 디바이스 알림 권한 관리 서비스
class PermissionService {
  /// 알림 권한 확인
  Future<bool> checkPermission() async {
    final status = await permission_handler.Permission.notification.status;
    return status.isGranted;
  }

  /// 알림 권한 요청
  Future<bool> requestPermission() async {
    final status = await permission_handler.Permission.notification.request();
    return status.isGranted;
  }

  /// 앱 설정 열기
  Future<bool> openAppSettings() async {
    return await permission_handler.openAppSettings();
  }
}
</file>

<file path="lib/features/notification/presentation/screens/notification_settings_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/notification/application/notifiers/notification_notifier.dart';
import 'package:n06/features/notification/presentation/widgets/time_picker_button.dart';

/// 푸시 알림 설정 화면
class NotificationSettingsScreen extends ConsumerWidget {
  const NotificationSettingsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final settingsAsync = ref.watch(notificationNotifierProvider);

    return Scaffold(
      appBar: AppBar(title: const Text('푸시 알림 설정'), elevation: 0),
      body: settingsAsync.when(
        data: (settings) => _buildContent(context, ref, settings),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stackTrace) => Center(child: Text('오류가 발생했습니다: $error')),
      ),
    );
  }

  Widget _buildContent(BuildContext context, WidgetRef ref, dynamic settings) {
    final notifier = ref.read(notificationNotifierProvider.notifier);

    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        // 알림 활성화 토글
        Card(
          elevation: 2,
          child: ListTile(
            title: const Text('알림 활성화'),
            subtitle: Text(settings.notificationEnabled ? '알림이 활성화되었습니다' : '알림이 비활성화되었습니다'),
            trailing: Switch(
              value: settings.notificationEnabled,
              onChanged: (value) async {
                await notifier.toggleNotificationEnabled();
              },
            ),
          ),
        ),
        const SizedBox(height: 16),

        // 알림 시간 설정
        Card(
          elevation: 2,
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text('알림 시간', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                const SizedBox(height: 12),
                TimePickerButton(
                  currentTime: settings.notificationTime,
                  onTimeSelected: (selectedTime) async {
                    await notifier.updateNotificationTime(selectedTime);
                    if (context.mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(
                          content: Text('알림 설정이 저장되었습니다'),
                          duration: Duration(seconds: 2),
                        ),
                      );
                    }
                  },
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 16),

        // 정보
        Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: Colors.blue.shade50,
            borderRadius: BorderRadius.circular(8),
          ),
          child: const Text(
            '알림은 매 투여 예정일 설정된 시간에 발송됩니다.',
            style: TextStyle(fontSize: 12, color: Colors.blue),
          ),
        ),
      ],
    );
  }
}
</file>

<file path="lib/features/notification/presentation/widgets/time_picker_button.dart">
import 'package:flutter/material.dart';

/// 시간 선택 버튼 위젯
class TimePickerButton extends StatelessWidget {
  final TimeOfDay currentTime;
  final Function(TimeOfDay) onTimeSelected;

  const TimePickerButton({super.key, required this.currentTime, required this.onTimeSelected});

  String _formatTime(TimeOfDay time) {
    final hour = time.hour.toString().padLeft(2, '0');
    final minute = time.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: double.infinity,
      child: OutlinedButton.icon(
        key: const Key('notification_time_button'),
        onPressed: () async {
          final selectedTime = await showTimePicker(context: context, initialTime: currentTime);
          if (selectedTime != null) {
            onTimeSelected(selectedTime);
          }
        },
        icon: const Icon(Icons.access_time),
        label: Text(_formatTime(currentTime)),
        style: OutlinedButton.styleFrom(padding: const EdgeInsets.symmetric(vertical: 12)),
      ),
    );
  }
}
</file>

<file path="lib/features/onboarding/application/providers.dart">
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:n06/core/providers.dart';
import 'package:n06/features/onboarding/domain/repositories/user_repository.dart';
import 'package:n06/features/onboarding/domain/repositories/profile_repository.dart';
import 'package:n06/features/onboarding/domain/repositories/medication_repository.dart';
import 'package:n06/features/onboarding/domain/repositories/tracking_repository.dart';
import 'package:n06/features/onboarding/domain/repositories/schedule_repository.dart';
import 'package:n06/features/onboarding/domain/usecases/check_onboarding_status_usecase.dart';
import 'package:n06/features/onboarding/infrastructure/repositories/isar_user_repository.dart';
import 'package:n06/features/onboarding/infrastructure/repositories/isar_profile_repository.dart';
import 'package:n06/features/onboarding/infrastructure/repositories/isar_medication_repository.dart';
import 'package:n06/features/onboarding/infrastructure/repositories/isar_tracking_repository.dart';
import 'package:n06/features/onboarding/infrastructure/repositories/isar_schedule_repository.dart';
import 'package:n06/features/onboarding/infrastructure/services/transaction_service.dart';

part 'providers.g.dart';

/// UserRepository Provider
@riverpod
UserRepository userRepository(UserRepositoryRef ref) {
  final isarInstance = ref.watch(isarProvider);
  return IsarUserRepository(isarInstance);
}

/// ProfileRepository Provider
@riverpod
ProfileRepository profileRepository(ProfileRepositoryRef ref) {
  final isarInstance = ref.watch(isarProvider);
  return IsarProfileRepository(isarInstance);
}

/// MedicationRepository Provider
@riverpod
MedicationRepository medicationRepository(MedicationRepositoryRef ref) {
  final isarInstance = ref.watch(isarProvider);
  return IsarMedicationRepository(isarInstance);
}

/// TrackingRepository Provider
@riverpod
TrackingRepository trackingRepository(TrackingRepositoryRef ref) {
  final isarInstance = ref.watch(isarProvider);
  return IsarTrackingRepository(isarInstance);
}

/// ScheduleRepository Provider
@riverpod
ScheduleRepository scheduleRepository(ScheduleRepositoryRef ref) {
  final isarInstance = ref.watch(isarProvider);
  return IsarScheduleRepository(isarInstance);
}

/// TransactionService Provider
@riverpod
TransactionService transactionService(TransactionServiceRef ref) {
  final isarInstance = ref.watch(isarProvider);
  return TransactionService(isarInstance);
}

/// CheckOnboardingStatusUseCase Provider
@riverpod
CheckOnboardingStatusUseCase checkOnboardingStatusUseCase(
  CheckOnboardingStatusUseCaseRef ref,
) {
  final profileRepo = ref.watch(profileRepositoryProvider);
  return CheckOnboardingStatusUseCase(profileRepo);
}
</file>

<file path="lib/features/onboarding/presentation/widgets/basic_profile_form.dart">
import 'package:flutter/material.dart';

/// 기본 프로필(이름) 입력 폼
class BasicProfileForm extends StatefulWidget {
  final Function(String) onNameChanged;
  final VoidCallback onNext;

  const BasicProfileForm({super.key, required this.onNameChanged, required this.onNext});

  @override
  State<BasicProfileForm> createState() => _BasicProfileFormState();
}

class _BasicProfileFormState extends State<BasicProfileForm> {
  late TextEditingController _nameController;
  bool _isNameValid = false;

  @override
  void initState() {
    super.initState();
    _nameController = TextEditingController();
    _nameController.addListener(_validateName);
  }

  void _validateName() {
    final isValid = _nameController.text.trim().isNotEmpty;
    setState(() {
      _isNameValid = isValid;
    });
  }

  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(24.0),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Text('이름을 입력해주세요', style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
          const SizedBox(height: 32),
          TextField(
            controller: _nameController,
            decoration: InputDecoration(
              hintText: '성명',
              border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
              errorText: _nameController.text.isEmpty && _nameController.text.isNotEmpty
                  ? '이름을 입력해주세요'
                  : null,
            ),
            onChanged: (value) {
              widget.onNameChanged(value);
              setState(() {});
            },
          ),
          const SizedBox(height: 32),
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              onPressed: _isNameValid ? widget.onNext : null,
              child: const Text('다음'),
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/onboarding/presentation/widgets/dosage_plan_form.dart">
import 'package:flutter/material.dart';
import 'package:n06/features/onboarding/domain/entities/escalation_step.dart';

/// 투여 계획 입력 폼
class DosagePlanForm extends StatefulWidget {
  final Function(String, DateTime, int, double, List<EscalationStep>?) onDataChanged;
  final VoidCallback onNext;

  const DosagePlanForm({super.key, required this.onDataChanged, required this.onNext});

  @override
  State<DosagePlanForm> createState() => _DosagePlanFormState();
}

class _DosagePlanFormState extends State<DosagePlanForm> {
  late TextEditingController _medicationNameController;
  late TextEditingController _cycleDaysController;
  late TextEditingController _initialDoseController;

  DateTime? _startDate;
  final List<EscalationStep> _escalationSteps = [];
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _medicationNameController = TextEditingController();
    _cycleDaysController = TextEditingController();
    _initialDoseController = TextEditingController();
    _startDate = DateTime.now();
  }

  @override
  void dispose() {
    _medicationNameController.dispose();
    _cycleDaysController.dispose();
    _initialDoseController.dispose();
    super.dispose();
  }

  bool _canProceed() {
    final medicationName = _medicationNameController.text.trim();
    final cycleDays = int.tryParse(_cycleDaysController.text);
    final initialDose = double.tryParse(_initialDoseController.text);

    if (medicationName.isEmpty) {
      _errorMessage = '약물명을 입력해주세요.';
      return false;
    }

    if (cycleDays == null || cycleDays <= 0) {
      _errorMessage = '투여 주기는 양수여야 합니다.';
      return false;
    }

    if (initialDose == null || initialDose <= 0) {
      _errorMessage = '초기 용량은 양수여야 합니다.';
      return false;
    }

    _errorMessage = null;
    return true;
  }

  void _addEscalationStep() {
    showDialog(
      context: context,
      builder: (context) => _EscalationStepDialog(
        onSave: (weeks, doseMg) {
          setState(() {
            _escalationSteps.add(EscalationStep(weeks: weeks, doseMg: doseMg));
          });
          Navigator.pop(context);
        },
      ),
    );
  }

  void _removeEscalationStep(int index) {
    setState(() {
      _escalationSteps.removeAt(index);
    });
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(24.0),
      child: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('투여 계획 설정', style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
            const SizedBox(height: 32),
            TextField(
              controller: _medicationNameController,
              decoration: InputDecoration(
                labelText: '약물명',
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
              ),
            ),
            const SizedBox(height: 16),
            ListTile(
              title: const Text('시작일'),
              subtitle: Text(_startDate?.toString() ?? ''),
              onTap: () async {
                final date = await showDatePicker(
                  context: context,
                  initialDate: _startDate ?? DateTime.now(),
                  firstDate: DateTime.now().subtract(const Duration(days: 30)),
                  lastDate: DateTime.now().add(const Duration(days: 365)),
                );
                if (date != null) {
                  setState(() {
                    _startDate = date;
                  });
                }
              },
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _cycleDaysController,
              keyboardType: TextInputType.number,
              decoration: InputDecoration(
                labelText: '투여 주기 (일)',
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _initialDoseController,
              keyboardType: const TextInputType.numberWithOptions(decimal: true),
              decoration: InputDecoration(
                labelText: '초기 용량 (mg)',
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
              ),
            ),
            const SizedBox(height: 24),
            if (_escalationSteps.isNotEmpty)
              Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text('증량 계획', style: TextStyle(fontWeight: FontWeight.bold)),
                  const SizedBox(height: 8),
                  ListView.builder(
                    shrinkWrap: true,
                    physics: const NeverScrollableScrollPhysics(),
                    itemCount: _escalationSteps.length,
                    itemBuilder: (context, index) {
                      final step = _escalationSteps[index];
                      return ListTile(
                        title: Text('${step.weeks}주차 → ${step.doseMg}mg'),
                        trailing: IconButton(
                          icon: const Icon(Icons.delete),
                          onPressed: () => _removeEscalationStep(index),
                        ),
                      );
                    },
                  ),
                  const SizedBox(height: 8),
                ],
              ),
            ElevatedButton.icon(
              onPressed: _addEscalationStep,
              icon: const Icon(Icons.add),
              label: const Text('증량 단계 추가'),
            ),
            const SizedBox(height: 24),
            if (_errorMessage != null)
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.red.shade50,
                  border: Border.all(color: Colors.red),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(_errorMessage!, style: TextStyle(color: Colors.red.shade700)),
              ),
            const SizedBox(height: 24),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: _canProceed() ? widget.onNext : null,
                child: const Text('다음'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// 증량 단계 추가 다이얼로그
class _EscalationStepDialog extends StatefulWidget {
  final Function(int, double) onSave;

  const _EscalationStepDialog({super.key, required this.onSave});

  @override
  State<_EscalationStepDialog> createState() => _EscalationStepDialogState();
}

class _EscalationStepDialogState extends State<_EscalationStepDialog> {
  late TextEditingController _weeksController;
  late TextEditingController _doseController;

  @override
  void initState() {
    super.initState();
    _weeksController = TextEditingController();
    _doseController = TextEditingController();
  }

  @override
  void dispose() {
    _weeksController.dispose();
    _doseController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('증량 단계 추가'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          TextField(
            controller: _weeksController,
            keyboardType: TextInputType.number,
            decoration: const InputDecoration(labelText: '주차'),
          ),
          const SizedBox(height: 16),
          TextField(
            controller: _doseController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            decoration: const InputDecoration(labelText: '용량 (mg)'),
          ),
        ],
      ),
      actions: [
        TextButton(onPressed: () => Navigator.pop(context), child: const Text('취소')),
        TextButton(
          onPressed: () {
            final weeks = int.tryParse(_weeksController.text);
            final dose = double.tryParse(_doseController.text);
            if (weeks != null && dose != null) {
              widget.onSave(weeks, dose);
            }
          },
          child: const Text('추가'),
        ),
      ],
    );
  }
}
</file>

<file path="lib/features/onboarding/presentation/widgets/weight_goal_form.dart">
import 'package:flutter/material.dart';

/// 체중 및 목표 입력 폼
class WeightGoalForm extends StatefulWidget {
  final Function(double, double, int?) onDataChanged;
  final VoidCallback onNext;

  const WeightGoalForm({super.key, required this.onDataChanged, required this.onNext});

  @override
  State<WeightGoalForm> createState() => _WeightGoalFormState();
}

class _WeightGoalFormState extends State<WeightGoalForm> {
  late TextEditingController _currentWeightController;
  late TextEditingController _targetWeightController;
  late TextEditingController _targetPeriodController;

  double? _currentWeight;
  double? _targetWeight;
  int? _targetPeriod;
  double? _weeklyGoal;
  bool _hasWarning = false;
  String? _errorMessage;

  @override
  void initState() {
    super.initState();
    _currentWeightController = TextEditingController();
    _targetWeightController = TextEditingController();
    _targetPeriodController = TextEditingController();

    _currentWeightController.addListener(_recalculate);
    _targetWeightController.addListener(_recalculate);
    _targetPeriodController.addListener(_recalculate);
  }

  void _recalculate() {
    _currentWeight = double.tryParse(_currentWeightController.text);
    _targetWeight = double.tryParse(_targetWeightController.text);
    _targetPeriod = int.tryParse(_targetPeriodController.text);

    setState(() {
      _errorMessage = null;
      _weeklyGoal = null;
      _hasWarning = false;

      if (_currentWeight == null || _targetWeight == null) {
        return;
      }

      if (_currentWeight! < 20 || _currentWeight! > 300) {
        _errorMessage = '현재 체중은 20kg 이상 300kg 이하여야 합니다.';
        return;
      }

      if (_targetWeight! < 20 || _targetWeight! > 300) {
        _errorMessage = '목표 체중은 20kg 이상 300kg 이하여야 합니다.';
        return;
      }

      if (_targetWeight! >= _currentWeight!) {
        _errorMessage = '목표 체중은 현재 체중보다 작아야 합니다.';
        return;
      }

      if (_targetPeriod != null && _targetPeriod! > 0) {
        _weeklyGoal = (_currentWeight! - _targetWeight!) / _targetPeriod!;
        _hasWarning = _weeklyGoal! > 1.0;
      }
    });

    widget.onDataChanged(_currentWeight ?? 0, _targetWeight ?? 0, _targetPeriod);
  }

  @override
  void dispose() {
    _currentWeightController.dispose();
    _targetWeightController.dispose();
    _targetPeriodController.dispose();
    super.dispose();
  }

  bool _canProceed() {
    return _currentWeight != null && _targetWeight != null && _errorMessage == null;
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(24.0),
      child: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('체중 및 목표 설정', style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
            const SizedBox(height: 32),
            TextField(
              controller: _currentWeightController,
              keyboardType: const TextInputType.numberWithOptions(decimal: true),
              decoration: InputDecoration(
                labelText: '현재 체중 (kg)',
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _targetWeightController,
              keyboardType: const TextInputType.numberWithOptions(decimal: true),
              decoration: InputDecoration(
                labelText: '목표 체중 (kg)',
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
              ),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _targetPeriodController,
              keyboardType: TextInputType.number,
              decoration: InputDecoration(
                labelText: '목표 기간 (주, 선택)',
                border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
              ),
            ),
            const SizedBox(height: 24),
            if (_errorMessage != null)
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.red.shade50,
                  border: Border.all(color: Colors.red),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(_errorMessage!, style: TextStyle(color: Colors.red.shade700)),
              ),
            if (_weeklyGoal != null)
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.blue.shade50,
                  border: Border.all(color: Colors.blue),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  '주간 목표: ${_weeklyGoal!.toStringAsFixed(2)}kg/주',
                  style: TextStyle(color: Colors.blue.shade700),
                ),
              ),
            if (_hasWarning)
              Container(
                margin: const EdgeInsets.only(top: 8),
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.orange.shade50,
                  border: Border.all(color: Colors.orange),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  '⚠ 주간 목표가 1kg을 초과합니다. 안전한 목표를 권장합니다.',
                  style: TextStyle(color: Colors.orange.shade700),
                ),
              ),
            const SizedBox(height: 32),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: _canProceed() ? widget.onNext : null,
                child: const Text('다음'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/profile/domain/repositories/profile_repository.dart">
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';

/// ProfileRepository interface for profile data access
abstract class ProfileRepository {
  /// Get user profile by user ID
  ///
  /// Throws [Exception] if user profile not found
  Future<UserProfile> getUserProfile(String userId);

  /// Save or update user profile
  Future<void> saveUserProfile(UserProfile profile);

  /// Watch user profile changes
  Stream<UserProfile> watchUserProfile(String userId);

  /// Update weekly goals for recording targets
  ///
  /// Updates the weekly weight record goal and weekly symptom record goal
  /// for the user profile. Goals must be in range 0-7.
  ///
  /// Parameters:
  ///   - userId: Target user ID
  ///   - weeklyWeightRecordGoal: Target number of weight logs per week (0-7)
  ///   - weeklySymptomRecordGoal: Target number of symptom logs per week (0-7)
  ///
  /// Throws [Exception] if user profile not found
  Future<void> updateWeeklyGoals(
    String userId,
    int weeklyWeightRecordGoal,
    int weeklySymptomRecordGoal,
  );
}
</file>

<file path="lib/features/profile/infrastructure/repositories/isar_profile_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/profile/domain/repositories/profile_repository.dart';
import 'package:n06/features/profile/infrastructure/dtos/user_profile_dto.dart';

/// Isar implementation of ProfileRepository
class IsarProfileRepository implements ProfileRepository {
  final Isar isar;

  IsarProfileRepository(this.isar);

  @override
  Future<UserProfile> getUserProfile(String userId) async {
    final dto = await isar.userProfileDtos.filter().userIdEqualTo(userId).findFirst();

    if (dto == null) {
      throw Exception('User profile not found for user: $userId');
    }

    return dto.toEntity();
  }

  @override
  Future<void> saveUserProfile(UserProfile profile) async {
    final dto = UserProfileDto.fromEntity(profile);
    await isar.writeTxn(() async {
      await isar.userProfileDtos.put(dto);
    });
  }

  @override
  Stream<UserProfile> watchUserProfile(String userId) {
    return isar.userProfileDtos
        .filter()
        .userIdEqualTo(userId)
        .watch(fireImmediately: true)
        .map((dtos) {
      if (dtos.isEmpty) {
        throw Exception('User profile not found for user: $userId');
      }
      return dtos.first.toEntity();
    });
  }

  @override
  Future<void> updateWeeklyGoals(
    String userId,
    int weeklyWeightRecordGoal,
    int weeklySymptomRecordGoal,
  ) async {
    final existingDto = await isar.userProfileDtos
        .filter()
        .userIdEqualTo(userId)
        .findFirst();

    if (existingDto == null) {
      throw Exception('User profile not found for user: $userId');
    }

    // Update the goals
    existingDto.weeklyWeightRecordGoal = weeklyWeightRecordGoal;
    existingDto.weeklySymptomRecordGoal = weeklySymptomRecordGoal;

    // Save with transaction
    await isar.writeTxn(() async {
      await isar.userProfileDtos.put(existingDto);
    });
  }
}
</file>

<file path="lib/features/profile/presentation/screens/weekly_goal_settings_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/profile/application/notifiers/profile_notifier.dart';
import 'package:n06/features/profile/presentation/widgets/weekly_goal_input_widget.dart';

/// Screen for adjusting weekly recording goals
///
/// Allows users to set target number of weight logs and symptom logs per week (0-7).
class WeeklyGoalSettingsScreen extends ConsumerStatefulWidget {
  const WeeklyGoalSettingsScreen({super.key});

  @override
  ConsumerState<WeeklyGoalSettingsScreen> createState() => _WeeklyGoalSettingsScreenState();
}

class _WeeklyGoalSettingsScreenState extends ConsumerState<WeeklyGoalSettingsScreen> {
  late int _weightGoal;
  late int _symptomGoal;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _initializeValues();
  }

  void _initializeValues() {
    final profileState = ref.read(profileNotifierProvider);
    if (profileState.hasValue && profileState.value != null) {
      _weightGoal = profileState.value!.weeklyWeightRecordGoal;
      _symptomGoal = profileState.value!.weeklySymptomRecordGoal;
    }
  }

  Future<void> _onSave() async {
    // Show confirmation dialog if setting goal to 0
    if (_weightGoal == 0 || _symptomGoal == 0) {
      final confirm = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('목표 0 설정'),
          content: const Text('목표를 0으로 설정하시겠습니까?'),
          actions: [
            TextButton(onPressed: () => Navigator.pop(context, false), child: const Text('취소')),
            TextButton(onPressed: () => Navigator.pop(context, true), child: const Text('확인')),
          ],
        ),
      );
      if (confirm != true) return;
    }

    setState(() => _isLoading = true);

    try {
      await ref.read(profileNotifierProvider.notifier).updateWeeklyGoals(_weightGoal, _symptomGoal);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('주간 목표가 저장되었습니다')));
        Navigator.pop(context);
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isLoading = false);
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('저장 중 오류가 발생했습니다: $e'), backgroundColor: Colors.red));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final profileState = ref.watch(profileNotifierProvider);

    return Scaffold(
      appBar: AppBar(title: const Text('주간 기록 목표 조정'), elevation: 0),
      body: profileState.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stackTrace) => _buildErrorState(error),
        data: (profile) {
          if (profile == null) {
            return _buildErrorState(Exception('Profile not found'));
          }
          return _buildForm(profile);
        },
      ),
    );
  }

  Widget _buildForm(dynamic profile) {
    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Information section
            Container(
              padding: const EdgeInsets.all(12.0),
              decoration: BoxDecoration(
                color: Colors.blue[50],
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.blue[200]!),
              ),
              child: const Text(
                '주간 목표를 설정하여 기록 달성을 추적하세요.\n투여 목표는 계획된 스케줄로부터 자동 계산됩니다.',
                style: TextStyle(fontSize: 12),
              ),
            ),
            const SizedBox(height: 24),

            // Weight record goal
            Text('주간 체중 기록 목표', style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            WeeklyGoalInputWidget(
              label: '주간 체중 기록 횟수 (0~7회)',
              initialValue: _weightGoal,
              onChanged: (value) => setState(() => _weightGoal = value),
            ),
            const SizedBox(height: 20),

            Text(
              '$_weightGoal회 / 주',
              style: Theme.of(context).textTheme.bodyLarge?.copyWith(color: Colors.grey[600]),
            ),
            const SizedBox(height: 32),

            // Symptom record goal
            Text('주간 부작용 기록 목표', style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 8),
            WeeklyGoalInputWidget(
              label: '주간 부작용 기록 횟수 (0~7회)',
              initialValue: _symptomGoal,
              onChanged: (value) => setState(() => _symptomGoal = value),
            ),
            const SizedBox(height: 20),

            Text(
              '$_symptomGoal회 / 주',
              style: Theme.of(context).textTheme.bodyLarge?.copyWith(color: Colors.grey[600]),
            ),
            const SizedBox(height: 40),

            // Dose plan info (read-only)
            Container(
              padding: const EdgeInsets.all(12.0),
              decoration: BoxDecoration(
                color: Colors.grey[100],
                borderRadius: BorderRadius.circular(8),
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('투여 목표 (읽기 전용)', style: Theme.of(context).textTheme.bodySmall),
                  const SizedBox(height: 8),
                  Text(
                    '투여 목표는 현재 투여 스케줄에 따라 자동으로 계산됩니다.',
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 40),

            // Save button
            SizedBox(
              width: double.infinity,
              child: ElevatedButton(
                onPressed: _isLoading ? null : _onSave,
                child: _isLoading
                    ? const SizedBox(
                        height: 20,
                        width: 20,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : const Text('저장'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildErrorState(Object error) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, size: 60, color: Colors.red[300]),
            const SizedBox(height: 16),
            const Text('프로필 정보를 불러올 수 없습니다'),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () {
                ref.invalidate(profileNotifierProvider);
              },
              child: const Text('다시 시도'),
            ),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/settings/presentation/screens/settings_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:n06/features/authentication/application/notifiers/auth_notifier.dart';
import 'package:n06/features/authentication/presentation/widgets/logout_confirm_dialog.dart';
import 'package:n06/features/profile/application/notifiers/profile_notifier.dart';
import 'package:n06/features/settings/presentation/widgets/settings_menu_item.dart';

/// Settings screen for user to manage profile, dose plan, and notifications
class SettingsScreen extends ConsumerWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authNotifierProvider);

    // Business Rule 1: Check if user is authenticated
    return authState.when(
      loading: () => Scaffold(
        appBar: AppBar(
          title: const Text('설정'),
          elevation: 0,
        ),
        body: const Center(
          child: CircularProgressIndicator(),
        ),
      ),
      error: (error, stackTrace) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (context.mounted) {
            context.go('/login');
          }
        });
        return const SizedBox.shrink();
      },
      data: (user) {
        if (user == null) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (context.mounted) {
              context.go('/login');
            }
          });
          return const SizedBox.shrink();
        }

        final profileState = ref.watch(profileNotifierProvider);

        return Scaffold(
          appBar: AppBar(
            title: const Text('설정'),
            elevation: 0,
          ),
          body: profileState.when(
            loading: () => const Center(
              child: CircularProgressIndicator(),
            ),
            error: (error, stackTrace) => _buildError(context, ref, error),
            data: (profile) {
              if (profile == null) {
                return _buildError(context, ref, Exception('Profile not found'));
              }
              return _buildSettings(context, ref, profile);
            },
          ),
        );
      },
    );
  }

  /// Build settings menu UI
  Widget _buildSettings(
    BuildContext context,
    WidgetRef ref,
    dynamic profile,
  ) {
    final userName = profile.userId;

    return ListView(
      children: [
        // User information section
        Container(
          padding: const EdgeInsets.all(16.0),
          color: Colors.grey[50],
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                '사용자 정보',
                style: Theme.of(context).textTheme.titleSmall,
                textAlign: TextAlign.left,
              ),
              const SizedBox(height: 16),
              ListTile(
                title: const Text('이름'),
                subtitle: Text(userName),
                contentPadding: EdgeInsets.zero,
              ),
              ListTile(
                title: const Text('목표 체중'),
                subtitle: Text('${profile.targetWeight.value}kg'),
                contentPadding: EdgeInsets.zero,
              ),
            ],
          ),
        ),
        const SizedBox(height: 24),

        // Settings menu items
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                '설정',
                style: Theme.of(context).textTheme.titleSmall,
              ),
              const SizedBox(height: 16),
              // Business Rule 3: Clear labels and descriptions
              SettingsMenuItem(
                title: '프로필 및 목표 수정',
                subtitle: '이름과 목표 체중을 변경할 수 있습니다',
                onTap: () => context.push('/profile/edit'),
              ),
              SettingsMenuItem(
                title: '투여 계획 수정',
                subtitle: '약물 투여 계획을 변경할 수 있습니다',
                onTap: () => context.push('/dose-plan/edit'),
              ),
              SettingsMenuItem(
                title: '주간 기록 목표 조정',
                subtitle: '주간 체중 및 증상 기록 목표를 설정합니다',
                onTap: () => context.push('/weekly-goal/edit'),
              ),
              SettingsMenuItem(
                title: '푸시 알림 설정',
                subtitle: '알림 시간과 방식을 설정합니다',
                onTap: () => context.push('/notification/settings'),
              ),
            ],
          ),
        ),
        const SizedBox(height: 32),

        // Divider
        Divider(
          height: 1,
          color: Colors.grey[300],
        ),
        const SizedBox(height: 24),

        // Business Rule 4: Logout at bottom
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16.0),
          child: SettingsMenuItem(
            title: '로그아웃',
            subtitle: '앱에서 로그아웃합니다',
            onTap: () => _handleLogout(context, ref),
          ),
        ),
        const SizedBox(height: 32),
      ],
    );
  }

  /// Build error UI with retry option
  Widget _buildError(BuildContext context, WidgetRef ref, Object error) {
    // Edge Case 1: Check for session expired
    final isSessionExpired = error.toString().contains('Unauthorized') ||
        error.toString().contains('401') ||
        error.toString().contains('session');

    if (isSessionExpired) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        context.go('/login');
      });
      return const SizedBox.shrink();
    }

    // Edge Case 2: Network error with retry option
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.error_outline,
              size: 60,
              color: Colors.red[300],
            ),
            const SizedBox(height: 16),
            const Text('프로필 정보를 불러올 수 없습니다'),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: () {
                final authState = ref.read(authNotifierProvider);
                if (authState.hasValue && authState.value != null) {
                  ref
                      .read(profileNotifierProvider.notifier)
                      .loadProfile(authState.value!.id);
                }
              },
              child: const Text('다시 시도'),
            ),
          ],
        ),
      ),
    );
  }

  /// Handle logout with confirmation dialog
  /// Business Rule 5: Confirmation step needed
  Future<void> _handleLogout(BuildContext context, WidgetRef ref) async {
    // Show logout confirmation dialog
    await showDialog<void>(
      context: context,
      builder: (context) => LogoutConfirmDialog(
        onConfirm: () {
          // Proceed with logout
          _performLogout(context, ref);
        },
      ),
    );
  }

  /// Perform the actual logout operation
  Future<void> _performLogout(BuildContext context, WidgetRef ref) async {
    if (!context.mounted) return;

    // Show loading indicator during logout
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const Center(
        child: CircularProgressIndicator(),
      ),
    );

    try {
      // Call logout on the notifier
      await ref.read(authNotifierProvider.notifier).logout();

      if (context.mounted) {
        // Close loading dialog
        Navigator.pop(context);
        // Navigate to login screen
        context.go('/login');
      }
    } catch (e) {
      if (context.mounted) {
        // Close loading dialog
        Navigator.pop(context);
        // Show error message
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('로그아웃 중 오류가 발생했습니다: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}
</file>

<file path="lib/features/tracking/application/notifiers/weight_record_edit_notifier.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/tracking/domain/entities/audit_log.dart';
import 'package:n06/features/tracking/domain/usecases/validate_weight_edit_usecase.dart';
import 'package:n06/features/tracking/domain/usecases/validate_date_unique_constraint_usecase.dart';
import 'package:n06/features/tracking/domain/usecases/log_record_change_usecase.dart';
import 'package:n06/features/tracking/application/providers.dart';
import 'package:n06/features/dashboard/application/notifiers/dashboard_notifier.dart';
import 'package:uuid/uuid.dart';

class WeightRecordEditNotifier extends AsyncNotifier<void> {
  late ValidateWeightEditUseCase _validateUseCase;
  late ValidateDateUniqueConstraintUseCase _validateDateUseCase;
  late LogRecordChangeUseCase _logUseCase;

  @override
  Future<void> build() async {
    _validateUseCase = ValidateWeightEditUseCase();
    _validateDateUseCase = ValidateDateUniqueConstraintUseCase(
      ref.watch(trackingRepositoryProvider),
    );
    _logUseCase = LogRecordChangeUseCase(
      ref.watch(auditRepositoryProvider),
    );
  }

  Future<void> updateWeight({
    required String recordId,
    required double newWeight,
    required String userId,
    DateTime? newDate,
    bool allowOverwrite = false,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final trackingRepo = ref.read(trackingRepositoryProvider);

      // Validate weight
      final weightValidation = _validateUseCase.execute(newWeight);
      if (weightValidation.isFailure) {
        throw Exception(weightValidation.error ?? 'Invalid weight');
      }

      // Get original log
      final originalLog = await trackingRepo.getWeightLogById(recordId);
      if (originalLog == null) {
        throw Exception('Record not found');
      }

      // Validate date if changed
      if (newDate != null && newDate != originalLog.logDate) {
        final dateValidation = await _validateDateUseCase.execute(
          userId: userId,
          date: newDate,
          editingRecordId: recordId,
        );

        if (dateValidation.isConflict && !allowOverwrite) {
          throw Exception('Date conflict: ${dateValidation.existingRecordId}');
        }

        if (dateValidation.isFailure) {
          throw Exception(dateValidation.error ?? 'Invalid date');
        }

        // Update with new date
        await trackingRepo.updateWeightLogWithDate(recordId, newWeight, newDate);

        // Log change
        await _logUseCase.execute(AuditLog(
          id: const Uuid().v4(),
          userId: userId,
          recordId: recordId,
          recordType: 'weight',
          changeType: 'update',
          oldValue: {
            'weightKg': originalLog.weightKg,
            'logDate': originalLog.logDate.toIso8601String(),
          },
          newValue: {
            'weightKg': newWeight,
            'logDate': newDate.toIso8601String(),
          },
          timestamp: DateTime.now(),
        ));
      } else {
        // Update weight only
        if (originalLog.weightKg != newWeight) {
          await trackingRepo.updateWeightLog(recordId, newWeight);

          // Log change
          await _logUseCase.execute(AuditLog(
            id: const Uuid().v4(),
            userId: userId,
            recordId: recordId,
            recordType: 'weight',
            changeType: 'update',
            oldValue: {'weightKg': originalLog.weightKg},
            newValue: {'weightKg': newWeight},
            timestamp: DateTime.now(),
          ));
        }
      }

      // Invalidate dashboard to trigger statistics recalculation
      ref.invalidate(dashboardNotifierProvider);
    });
  }

  Future<void> deleteWeight({
    required String recordId,
    required String userId,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final trackingRepo = ref.read(trackingRepositoryProvider);

      // Get original log for audit
      final originalLog = await trackingRepo.getWeightLogById(recordId);
      if (originalLog == null) {
        throw Exception('Record not found');
      }

      // Delete
      await trackingRepo.deleteWeightLog(recordId);

      // Log deletion
      await _logUseCase.execute(AuditLog(
        id: const Uuid().v4(),
        userId: userId,
        recordId: recordId,
        recordType: 'weight',
        changeType: 'delete',
        oldValue: {
          'weightKg': originalLog.weightKg,
          'logDate': originalLog.logDate.toIso8601String(),
        },
        newValue: null,
        timestamp: DateTime.now(),
      ));

      // Invalidate dashboard to trigger statistics recalculation
      ref.invalidate(dashboardNotifierProvider);
    });
  }
}
</file>

<file path="lib/features/tracking/domain/entities/dosage_plan.dart">
import 'package:equatable/equatable.dart';

const double maxDoseMg = 2.4;

class EscalationStep extends Equatable {
  final int weeksFromStart;
  final double doseMg;

  const EscalationStep({
    required this.weeksFromStart,
    required this.doseMg,
  });

  @override
  List<Object?> get props => [weeksFromStart, doseMg];
}

class DosagePlan extends Equatable {
  final String id;
  final String userId;
  final String medicationName;
  final DateTime startDate;
  final int cycleDays;
  final double initialDoseMg;
  final List<EscalationStep>? escalationPlan;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;

  DosagePlan({
    required this.id,
    required this.userId,
    required this.medicationName,
    required this.startDate,
    required this.cycleDays,
    required this.initialDoseMg,
    this.escalationPlan,
    this.isActive = true,
    DateTime? createdAt,
    DateTime? updatedAt,
  })  : createdAt = createdAt ?? DateTime.now(),
        updatedAt = updatedAt ?? DateTime.now() {
    _validate();
  }

  void _validate() {
    // Validate start date is not in the future
    if (startDate.isAfter(DateTime.now())) {
      throw ArgumentError('Start date cannot be in the future');
    }

    // Validate cycle days
    if (cycleDays < 1) {
      throw ArgumentError('Cycle days must be at least 1');
    }

    // Validate initial dose
    if (initialDoseMg < 0) {
      throw ArgumentError('Initial dose cannot be negative');
    }

    // Validate escalation plan
    if (escalationPlan != null && escalationPlan!.isNotEmpty) {
      _validateEscalationPlan();
    }
  }

  void _validateEscalationPlan() {
    final steps = escalationPlan!;

    // Check monotonic increase
    double previousDose = initialDoseMg;
    int previousWeeks = 0;

    for (final step in steps) {
      // Check dose is monotonic increasing
      if (step.doseMg <= previousDose) {
        throw ArgumentError('Escalation plan must have monotonic increasing doses');
      }

      // Check dose doesn't exceed max
      if (step.doseMg > maxDoseMg) {
        throw ArgumentError('Escalation dose cannot exceed ${maxDoseMg}mg');
      }

      // Check weeks are in increasing order
      if (step.weeksFromStart <= previousWeeks) {
        throw ArgumentError('Escalation steps must be in chronological order');
      }

      previousDose = step.doseMg;
      previousWeeks = step.weeksFromStart;
    }
  }

  /// Calculate current dose based on weeks elapsed since start date
  double getCurrentDose({required int weeksElapsed}) {
    if (escalationPlan == null || escalationPlan!.isEmpty) {
      return initialDoseMg;
    }

    double currentDose = initialDoseMg;

    for (final step in escalationPlan!) {
      if (weeksElapsed > step.weeksFromStart) {
        currentDose = step.doseMg;
      } else {
        break;
      }
    }

    return currentDose;
  }

  /// Calculate weeks elapsed since plan start
  int getWeeksElapsed() {
    final now = DateTime.now();
    final difference = now.difference(startDate);
    return (difference.inDays / 7).ceil();
  }

  @override
  List<Object?> get props => [
    id,
    userId,
    medicationName,
    startDate,
    cycleDays,
    initialDoseMg,
    escalationPlan,
    isActive,
    createdAt,
    updatedAt,
  ];

  DosagePlan copyWith({
    String? id,
    String? userId,
    String? medicationName,
    DateTime? startDate,
    int? cycleDays,
    double? initialDoseMg,
    List<EscalationStep>? escalationPlan,
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return DosagePlan(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      medicationName: medicationName ?? this.medicationName,
      startDate: startDate ?? this.startDate,
      cycleDays: cycleDays ?? this.cycleDays,
      initialDoseMg: initialDoseMg ?? this.initialDoseMg,
      escalationPlan: escalationPlan ?? this.escalationPlan,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}
</file>

<file path="lib/features/tracking/domain/entities/dose_schedule.dart">
import 'package:equatable/equatable.dart';

class DoseSchedule extends Equatable {
  final String id;
  final String dosagePlanId;
  final DateTime scheduledDate;
  final double scheduledDoseMg;
  final Object? notificationTime;
  final DateTime createdAt;

  DoseSchedule({
    required this.id,
    required this.dosagePlanId,
    required this.scheduledDate,
    required this.scheduledDoseMg,
    this.notificationTime,
    DateTime? createdAt,
  }) : createdAt = createdAt ?? DateTime.now();

  /// Check if schedule is overdue (before today)
  bool isOverdue() {
    final today = DateTime.now();
    final scheduleDate = DateTime(
      scheduledDate.year,
      scheduledDate.month,
      scheduledDate.day,
    );
    final todayDate = DateTime(today.year, today.month, today.day);
    return scheduleDate.isBefore(todayDate);
  }

  /// Check if schedule is today
  bool isToday() {
    final today = DateTime.now();
    return scheduledDate.year == today.year &&
        scheduledDate.month == today.month &&
        scheduledDate.day == today.day;
  }

  /// Check if schedule is in the future (after today)
  bool isUpcoming() {
    final today = DateTime.now();
    final scheduleDate = DateTime(
      scheduledDate.year,
      scheduledDate.month,
      scheduledDate.day,
    );
    final todayDate = DateTime(today.year, today.month, today.day);
    return scheduleDate.isAfter(todayDate);
  }

  /// Calculate days until/since scheduled date
  /// Positive number = future, Negative = past
  int daysUntil() {
    final today = DateTime.now();
    final todayDate = DateTime(today.year, today.month, today.day);
    final scheduleDate = DateTime(
      scheduledDate.year,
      scheduledDate.month,
      scheduledDate.day,
    );
    return scheduleDate.difference(todayDate).inDays;
  }

  @override
  List<Object?> get props => [
    id,
    dosagePlanId,
    scheduledDate,
    scheduledDoseMg,
    notificationTime,
    createdAt,
  ];

  DoseSchedule copyWith({
    String? id,
    String? dosagePlanId,
    DateTime? scheduledDate,
    double? scheduledDoseMg,
    DateTime? notificationTime,
    DateTime? createdAt,
  }) {
    return DoseSchedule(
      id: id ?? this.id,
      dosagePlanId: dosagePlanId ?? this.dosagePlanId,
      scheduledDate: scheduledDate ?? this.scheduledDate,
      scheduledDoseMg: scheduledDoseMg ?? this.scheduledDoseMg,
      notificationTime: notificationTime ?? this.notificationTime,
      createdAt: createdAt ?? this.createdAt,
    );
  }
}
</file>

<file path="lib/features/tracking/domain/usecases/analyze_plan_change_impact_usecase.dart">
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';

/// Data class representing the impact of a plan change
class PlanChangeImpact {
  final int affectedScheduleCount;
  final DateTime? firstAffectedDate;
  final List<String> changedFields;
  final bool hasEscalationChange;
  final int currentWeekElapsed;
  final String? warningMessage;

  const PlanChangeImpact({
    required this.affectedScheduleCount,
    required this.changedFields,
    required this.hasEscalationChange,
    required this.currentWeekElapsed,
    this.firstAffectedDate,
    this.warningMessage,
  });

  /// Check if there are any changes
  bool get hasChanges => changedFields.isNotEmpty;
}

/// UseCase to analyze the impact of plan changes
class AnalyzePlanChangeImpactUseCase {
  /// Analyze impact of changing from oldPlan to newPlan
  PlanChangeImpact execute({
    required DosagePlan oldPlan,
    required DosagePlan newPlan,
    required DateTime? fromDate,
  }) {
    final currentDate = fromDate ?? DateTime.now();
    final changedFields = _identifyChangedFields(oldPlan, newPlan);

    if (changedFields.isEmpty) {
      return PlanChangeImpact(
        affectedScheduleCount: 0,
        changedFields: [],
        hasEscalationChange: false,
        currentWeekElapsed: _calculateWeeksElapsed(newPlan.startDate, currentDate),
      );
    }

    // Count affected schedules (future schedules only)
    final affectedCount = _countAffectedSchedules(newPlan, currentDate);

    // Determine if escalation plan changed
    final hasEscalationChange = _hasEscalationChanged(oldPlan, newPlan);

    // Calculate current week
    final currentWeek = _calculateWeeksElapsed(newPlan.startDate, currentDate);

    // Generate warning message if needed
    String? warningMessage;
    if (changedFields.contains('escalationPlan') && currentWeek > 0) {
      warningMessage =
          '현재 $currentWeek주차 진행 중입니다. '
          '변경 시 이후 증량 일정이 조정됩니다.';
    }

    if (changedFields.contains('initialDoseMg') &&
        _isDoseChangeSignificant(oldPlan.initialDoseMg, newPlan.initialDoseMg)) {
      warningMessage = warningMessage ?? '';
      warningMessage += '용량 변경이 큽니다. 의료진과 상담 후 진행하세요.';
    }

    return PlanChangeImpact(
      affectedScheduleCount: affectedCount,
      firstAffectedDate: _calculateFirstAffectedDate(newPlan, currentDate),
      changedFields: changedFields,
      hasEscalationChange: hasEscalationChange,
      currentWeekElapsed: currentWeek,
      warningMessage: warningMessage?.isEmpty == true ? null : warningMessage,
    );
  }

  /// Identify which fields have changed
  List<String> _identifyChangedFields(DosagePlan oldPlan, DosagePlan newPlan) {
    final changedFields = <String>[];

    if (oldPlan.medicationName != newPlan.medicationName) {
      changedFields.add('medicationName');
    }
    if (oldPlan.startDate != newPlan.startDate) {
      changedFields.add('startDate');
    }
    if (oldPlan.cycleDays != newPlan.cycleDays) {
      changedFields.add('cycleDays');
    }
    if (oldPlan.initialDoseMg != newPlan.initialDoseMg) {
      changedFields.add('initialDoseMg');
    }
    if (!_escalationPlansEqual(oldPlan.escalationPlan, newPlan.escalationPlan)) {
      changedFields.add('escalationPlan');
    }

    return changedFields;
  }

  /// Count schedules that will be affected by the change
  int _countAffectedSchedules(DosagePlan plan, DateTime fromDate) {
    // Estimate based on 1 year worth of schedules
    final daysTillEndOfYear = DateTime(fromDate.year + 1).difference(fromDate).inDays;
    return (daysTillEndOfYear / plan.cycleDays).ceil();
  }

  /// Calculate the first date affected by changes
  DateTime _calculateFirstAffectedDate(DosagePlan plan, DateTime fromDate) {
    // First affected date is the next dose date after fromDate
    final today = DateTime(fromDate.year, fromDate.month, fromDate.day);
    DateTime nextDate = DateTime(plan.startDate.year, plan.startDate.month, plan.startDate.day);

    while (nextDate.isBefore(today)) {
      nextDate = nextDate.add(Duration(days: plan.cycleDays));
    }

    return nextDate;
  }

  /// Check if escalation plan has changed
  bool _hasEscalationChanged(DosagePlan oldPlan, DosagePlan newPlan) {
    return !_escalationPlansEqual(oldPlan.escalationPlan, newPlan.escalationPlan);
  }

  /// Compare two escalation plans
  bool _escalationPlansEqual(List<EscalationStep>? plan1, List<EscalationStep>? plan2) {
    if (plan1 == null && plan2 == null) return true;
    if (plan1 == null || plan2 == null) return false;
    if (plan1.length != plan2.length) return false;

    for (int i = 0; i < plan1.length; i++) {
      if (plan1[i].weeksFromStart != plan2[i].weeksFromStart ||
          plan1[i].doseMg != plan2[i].doseMg) {
        return false;
      }
    }

    return true;
  }

  /// Check if dose change is significant (>20% change)
  bool _isDoseChangeSignificant(double oldDose, double newDose) {
    final percentageChange = ((newDose - oldDose).abs() / oldDose * 100);
    return percentageChange > 20;
  }

  /// Calculate weeks elapsed since plan start
  int _calculateWeeksElapsed(DateTime startDate, DateTime currentDate) {
    final difference = currentDate.difference(startDate);
    return (difference.inDays / 7).floor();
  }
}
</file>

<file path="lib/features/tracking/domain/usecases/dose_notification_usecase.dart">
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';

class NotificationPayload {
  final String id;
  final String title;
  final String message;
  final String deepLink;
  final Map<String, dynamic> data;

  NotificationPayload({
    required this.id,
    required this.title,
    required this.message,
    required this.deepLink,
    required this.data,
  });
}

class DoseNotificationUseCase {
  /// Create notification payload from dose schedule
  NotificationPayload createNotificationPayload(DoseSchedule schedule) {
    return NotificationPayload(
      id: schedule.id,
      title: '투여 알림',
      message: '${schedule.scheduledDoseMg}mg 투여 시간입니다.',
      deepLink: '/medication/schedule/${schedule.id}',
      data: {
        'scheduleId': schedule.id,
        'planId': schedule.dosagePlanId,
        'doseMg': schedule.scheduledDoseMg,
        'scheduledDate': schedule.scheduledDate.toIso8601String(),
      },
    );
  }

  /// Check if schedule should have notification scheduled
  bool shouldScheduleNotification(DoseSchedule schedule) {
    final now = DateTime.now();
    // Don't schedule notification for past schedules
    return schedule.scheduledDate.isAfter(now) ||
        schedule.scheduledDate.isAtSameMomentAs(now);
  }

  /// Get notification time for schedule
  String? getNotificationTimeString(DoseSchedule schedule) {
    if (schedule.notificationTime == null) {
      return null;
    }

    return schedule.notificationTime.toString();
  }
}
</file>

<file path="lib/features/tracking/domain/usecases/schedule_generator_usecase.dart">
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';

class TimeOfDay {
  final int hour;
  final int minute;

  TimeOfDay({required this.hour, required this.minute});

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TimeOfDay &&
          runtimeType == other.runtimeType &&
          hour == other.hour &&
          minute == other.minute;

  @override
  int get hashCode => hour.hashCode ^ minute.hashCode;
}

class ScheduleGeneratorUseCase {
  /// Generate complete schedule from plan start date to end date
  List<DoseSchedule> generateSchedules(
    DosagePlan plan,
    DateTime endDate, {
    Object? notificationTime,
  }) {
    if (endDate.isBefore(plan.startDate)) {
      return [];
    }

    final schedules = <DoseSchedule>[];
    DateTime currentDate = plan.startDate.add(Duration(days: plan.cycleDays));

    while (!currentDate.isAfter(endDate)) {
      final weeksElapsed = _calculateWeeksElapsed(plan.startDate, currentDate);
      final currentDose = plan.getCurrentDose(weeksElapsed: weeksElapsed);

      final schedule = DoseSchedule(
        id: _generateId(plan.id, schedules.length),
        dosagePlanId: plan.id,
        scheduledDate: currentDate,
        scheduledDoseMg: currentDose,
        notificationTime: notificationTime,
      );

      schedules.add(schedule);
      currentDate = currentDate.add(Duration(days: plan.cycleDays));
    }

    return schedules;
  }

  /// Recalculate schedules from a specific change date
  List<DoseSchedule> recalculateSchedulesFrom(
    DosagePlan updatedPlan,
    DateTime changeDate,
    DateTime endDate,
    List<DoseSchedule> existingSchedules, {
    Object? notificationTime,
  }) {
    // Keep schedules before change date
    final keepSchedules = existingSchedules
        .where((s) => s.scheduledDate.isBefore(changeDate))
        .toList();

    // Generate new schedules from change date
    final newSchedules = <DoseSchedule>[];
    DateTime currentDate = changeDate;

    if (keepSchedules.isNotEmpty) {
      final lastKeptSchedule = keepSchedules.last;
      currentDate = lastKeptSchedule.scheduledDate
          .add(Duration(days: updatedPlan.cycleDays));
    }

    while (!currentDate.isAfter(endDate)) {
      final weeksElapsed =
          _calculateWeeksElapsed(updatedPlan.startDate, currentDate);
      final currentDose = updatedPlan.getCurrentDose(weeksElapsed: weeksElapsed);

      final schedule = DoseSchedule(
        id: _generateId(updatedPlan.id, keepSchedules.length + newSchedules.length),
        dosagePlanId: updatedPlan.id,
        scheduledDate: currentDate,
        scheduledDoseMg: currentDose,
        notificationTime: notificationTime,
      );

      newSchedules.add(schedule);
      currentDate = currentDate.add(Duration(days: updatedPlan.cycleDays));
    }

    return [...keepSchedules, ...newSchedules];
  }

  /// Calculate weeks elapsed since plan start date
  int _calculateWeeksElapsed(DateTime startDate, DateTime currentDate) {
    final difference = currentDate.difference(startDate);
    return (difference.inDays / 7).ceil();
  }

  /// Generate unique ID for schedule
  String _generateId(String planId, int index) {
    return '${planId}_schedule_$index';
  }
}
</file>

<file path="lib/features/tracking/infrastructure/dtos/dosage_plan_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';

part 'dosage_plan_dto.g.dart';

@collection
class DosagePlanDto {
  Id? id = Isar.autoIncrement;
  late String planId; // UUID
  late String userId;
  late String medicationName;
  late DateTime startDate;
  late int cycleDays;
  late double initialDoseMg;
  late List<EscalationStepDto>? escalationPlan;
  late bool isActive;
  late DateTime createdAt;
  late DateTime updatedAt;

  DosagePlanDto();

  DosagePlanDto.fromEntity(DosagePlan entity) {
    planId = entity.id;
    userId = entity.userId;
    medicationName = entity.medicationName;
    startDate = entity.startDate;
    cycleDays = entity.cycleDays;
    initialDoseMg = entity.initialDoseMg;
    escalationPlan = entity.escalationPlan?.map((step) {
      return EscalationStepDto.withValues(
        weeksFromStart: step.weeksFromStart,
        doseMg: step.doseMg,
      );
    }).toList();
    isActive = entity.isActive;
    createdAt = entity.createdAt;
    updatedAt = entity.updatedAt;
  }

  DosagePlan toEntity() {
    return DosagePlan(
      id: planId,
      userId: userId,
      medicationName: medicationName,
      startDate: startDate,
      cycleDays: cycleDays,
      initialDoseMg: initialDoseMg,
      escalationPlan: escalationPlan?.map((dto) {
        return EscalationStep(
          weeksFromStart: dto.weeksFromStart,
          doseMg: dto.doseMg,
        );
      }).toList(),
      isActive: isActive,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }
}

@embedded
class EscalationStepDto {
  late int weeksFromStart;
  late double doseMg;

  EscalationStepDto();

  EscalationStepDto.withValues({
    required this.weeksFromStart,
    required this.doseMg,
  });
}
</file>

<file path="lib/features/tracking/infrastructure/dtos/dose_schedule_dto.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';

part 'dose_schedule_dto.g.dart';

@collection
class DoseScheduleDto {
  Id? id = Isar.autoIncrement;
  late String scheduleId; // UUID
  late String dosagePlanId;
  late DateTime scheduledDate;
  late double scheduledDoseMg;
  late String? notificationTimeStr; // HH:mm format
  late DateTime createdAt;

  DoseScheduleDto();

  DoseScheduleDto.fromEntity(DoseSchedule entity) {
    scheduleId = entity.id;
    dosagePlanId = entity.dosagePlanId;
    scheduledDate = entity.scheduledDate;
    scheduledDoseMg = entity.scheduledDoseMg;
    if (entity.notificationTime != null) {
      notificationTimeStr = entity.notificationTime.toString();
    }
    createdAt = entity.createdAt;
  }

  DoseSchedule toEntity() {
    Object? notificationTime;
    if (notificationTimeStr != null) {
      notificationTime = notificationTimeStr; // Store as string
    }

    return DoseSchedule(
      id: scheduleId,
      dosagePlanId: dosagePlanId,
      scheduledDate: scheduledDate,
      scheduledDoseMg: scheduledDoseMg,
      notificationTime: notificationTime,
      createdAt: createdAt,
    );
  }
}
</file>

<file path="lib/features/tracking/infrastructure/dtos/plan_change_history_dto.dart">
import 'dart:convert';

import 'package:isar/isar.dart';
import 'package:n06/features/tracking/domain/entities/plan_change_history.dart';

part 'plan_change_history_dto.g.dart';

@collection
class PlanChangeHistoryDto {
  Id? id = Isar.autoIncrement;
  late String historyId; // UUID
  late String dosagePlanId;
  late DateTime changedAt;
  late String oldPlanJson; // JSON string
  late String newPlanJson; // JSON string

  @Index()
  late DateTime indexedChangedAt;

  PlanChangeHistoryDto();

  PlanChangeHistoryDto.fromEntity(PlanChangeHistory entity) {
    historyId = entity.id;
    dosagePlanId = entity.dosagePlanId;
    changedAt = entity.changedAt;
    oldPlanJson = _mapToJson(entity.oldPlan);
    newPlanJson = _mapToJson(entity.newPlan);
    indexedChangedAt = entity.changedAt;
  }

  PlanChangeHistory toEntity() {
    return PlanChangeHistory(
      id: historyId,
      dosagePlanId: dosagePlanId,
      changedAt: changedAt,
      oldPlan: _jsonToMap(oldPlanJson),
      newPlan: _jsonToMap(newPlanJson),
    );
  }

  static String _mapToJson(Map<String, dynamic> map) {
    return jsonEncode(map);
  }

  static Map<String, dynamic> _jsonToMap(String json) {
    return jsonDecode(json) as Map<String, dynamic>;
  }
}
</file>

<file path="lib/features/tracking/infrastructure/repositories/isar_audit_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/tracking/domain/entities/audit_log.dart';
import 'package:n06/features/tracking/domain/repositories/audit_repository.dart';

class IsarAuditRepository implements AuditRepository {
  final Isar _isar;

  IsarAuditRepository(this._isar);

  // For Phase 0 MVP, audit logs are kept in memory
  // In Phase 1, these will be persisted to Supabase or Isar
  final List<AuditLog> _auditLogs = [];

  @override
  Future<void> logChange(AuditLog log) async {
    // Store in memory (Phase 0)
    _auditLogs.add(log);
  }

  @override
  Future<List<AuditLog>> getChangeLogs(String userId, String recordId) async {
    return _auditLogs
        .where((log) => log.userId == userId && log.recordId == recordId)
        .toList();
  }
}
</file>

<file path="lib/features/tracking/infrastructure/services/notification_service.dart">
import 'dart:developer' as developer;

import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:n06/features/tracking/domain/usecases/dose_notification_usecase.dart';

class NotificationService {
  static final NotificationService _instance = NotificationService._internal();

  final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
      FlutterLocalNotificationsPlugin();

  late NotificationDetails _notificationDetails;

  NotificationService._internal();

  factory NotificationService() {
    return _instance;
  }

  Future<void> initialize() async {
    const androidInitializationSettings =
        AndroidInitializationSettings('@mipmap/ic_launcher');

    const initializationSettings = InitializationSettings(
      android: androidInitializationSettings,
    );

    await flutterLocalNotificationsPlugin.initialize(initializationSettings);

    _notificationDetails = const NotificationDetails(
      android: AndroidNotificationDetails(
        'dose_notification_channel',
        'Dose Notifications',
        channelDescription: 'Notifications for medication dose reminders',
        importance: Importance.max,
        priority: Priority.high,
      ),
    );
  }

  /// Request notification permission
  Future<bool> requestPermission() async {
    final result = await flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin>()
        ?.requestExactAlarmsPermission();

    return result ?? false;
  }

  /// Schedule notification for dose
  Future<void> scheduleNotification({
    required String id,
    required String title,
    required String message,
    required DateTime scheduledDate,
    required int? hour,
    required int? minute,
  }) async {
    if (hour == null || minute == null) {
      return;
    }

    try {
      final notificationDateTime = DateTime(
        scheduledDate.year,
        scheduledDate.month,
        scheduledDate.day,
        hour,
        minute,
      );

      // Only schedule if not in the past
      if (notificationDateTime.isBefore(DateTime.now())) {
        return;
      }

      // Calculate delay
      final delay = notificationDateTime.difference(DateTime.now());
      if (delay.isNegative) {
        return; // Don't schedule if in the past
      }

      // Show test notification (simplified for now)
      await showTestNotification(title: title, message: message);
    } catch (e) {
      developer.log('Failed to schedule notification: $e');
    }
  }

  /// Schedule notification from payload
  Future<void> scheduleNotificationFromPayload(
    NotificationPayload payload, {
    required int? hour,
    required int? minute,
    required DateTime scheduledDate,
  }) async {
    await scheduleNotification(
      id: payload.id,
      title: payload.title,
      message: payload.message,
      scheduledDate: scheduledDate,
      hour: hour,
      minute: minute,
    );
  }

  /// Cancel notification
  Future<void> cancelNotification(String id) async {
    try {
      final notificationId = id.hashCode.abs() % 2147483647;
      await flutterLocalNotificationsPlugin.cancel(notificationId);
    } catch (e) {
      developer.log('Failed to cancel notification: $e');
    }
  }

  /// Cancel all notifications
  Future<void> cancelAllNotifications() async {
    await flutterLocalNotificationsPlugin.cancelAll();
  }

  /// Show test notification (for testing)
  Future<void> showTestNotification({
    required String title,
    required String message,
  }) async {
    await flutterLocalNotificationsPlugin.show(
      0,
      title,
      message,
      _notificationDetails,
    );
  }
}
</file>

<file path="lib/features/tracking/presentation/dialogs/dose_edit_dialog.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';
import 'package:n06/features/tracking/application/providers.dart';

const List<String> _injectionSites = ['복부', '허벅지', '상완'];

class DoseEditDialog extends ConsumerStatefulWidget {
  final DoseRecord currentRecord;
  final String userId;
  final VoidCallback? onSaveSuccess;

  const DoseEditDialog({
    super.key,
    required this.currentRecord,
    required this.userId,
    this.onSaveSuccess,
  });

  @override
  ConsumerState<DoseEditDialog> createState() => _DoseEditDialogState();
}

class _DoseEditDialogState extends ConsumerState<DoseEditDialog> {
  late TextEditingController _doseController;
  late String? _selectedSite;
  late TextEditingController _noteController;
  String? _errorMessage;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _doseController = TextEditingController(text: widget.currentRecord.actualDoseMg.toString());
    _selectedSite = widget.currentRecord.injectionSite;
    _noteController = TextEditingController(text: widget.currentRecord.note ?? '');
  }

  @override
  void dispose() {
    _doseController.dispose();
    _noteController.dispose();
    super.dispose();
  }

  void _validateDose(String value) {
    setState(() {
      _errorMessage = null;
    });

    if (value.isEmpty) return;

    try {
      final dose = double.parse(value);
      if (dose <= 0) {
        setState(() {
          _errorMessage = '투여량은 0보다 커야 합니다';
        });
      }
    } on FormatException {
      setState(() {
        _errorMessage = '숫자를 입력해주세요';
      });
    }
  }

  Future<void> _saveChanges() async {
    if (_errorMessage != null || _doseController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(_errorMessage ?? '유효한 값을 입력해주세요'), backgroundColor: Colors.red),
      );
      return;
    }

    if (_selectedSite == null) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(const SnackBar(content: Text('투여 부위를 선택해주세요'), backgroundColor: Colors.red));
      return;
    }

    final newDose = double.parse(_doseController.text);

    setState(() {
      _isLoading = true;
    });

    try {
      final notifier = ref.read(doseRecordEditNotifierProvider.notifier);
      await notifier.updateDoseRecord(
        recordId: widget.currentRecord.id,
        newDoseMg: newDose,
        injectionSite: _selectedSite!,
        note: _noteController.text.isEmpty ? null : _noteController.text,
        userId: widget.userId,
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('투여 기록이 수정되었습니다'), backgroundColor: Colors.green),
        );
        widget.onSaveSuccess?.call();
        Navigator.of(context).pop();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('저장 실패: ${e.toString()}'), backgroundColor: Colors.red),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text('투여 기록 수정', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
              const SizedBox(height: 24),
              // 투여량 입력
              Text('투여량 (mg)', style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 8),
              TextField(
                controller: _doseController,
                keyboardType: const TextInputType.numberWithOptions(decimal: true),
                onChanged: _validateDose,
                decoration: InputDecoration(
                  hintText: '투여량을 입력해주세요',
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                  errorText: _errorMessage,
                  contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                ),
              ),
              const SizedBox(height: 24),
              // 투여 부위 선택
              Text('투여 부위', style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 8),
              DropdownButton<String>(
                value: _selectedSite,
                isExpanded: true,
                hint: const Text('부위를 선택해주세요'),
                onChanged: (String? newValue) {
                  setState(() {
                    _selectedSite = newValue;
                  });
                },
                items: _injectionSites.map((String site) {
                  return DropdownMenuItem<String>(value: site, child: Text(site));
                }).toList(),
              ),
              const SizedBox(height: 24),
              // 메모
              Text('메모 (선택 사항)', style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 8),
              TextField(
                controller: _noteController,
                maxLines: 3,
                decoration: InputDecoration(
                  hintText: '추가 정보를 입력해주세요',
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                  contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                ),
              ),
              const SizedBox(height: 24),
              // 버튼들
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: _isLoading ? null : () => Navigator.pop(context),
                    child: const Text('취소'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: (_isLoading || _errorMessage != null || _selectedSite == null)
                        ? null
                        : _saveChanges,
                    child: _isLoading
                        ? const SizedBox(
                            height: 16,
                            width: 16,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          )
                        : const Text('저장'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/tracking/presentation/dialogs/record_delete_dialog.dart">
import 'package:flutter/material.dart';

class RecordDeleteDialog extends StatelessWidget {
  final String recordType;
  final String recordInfo;
  final VoidCallback onConfirm;

  const RecordDeleteDialog({
    super.key,
    required this.recordType,
    required this.recordInfo,
    required this.onConfirm,
  });

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('기록 삭제'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('다음 기록을 삭제하시겠습니까?', style: Theme.of(context).textTheme.bodyMedium),
          const SizedBox(height: 12),
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Colors.grey.shade100,
              borderRadius: BorderRadius.circular(8),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(recordType, style: const TextStyle(fontSize: 12, color: Colors.grey)),
                const SizedBox(height: 4),
                Text(recordInfo, style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w500)),
              ],
            ),
          ),
          const SizedBox(height: 16),
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: Colors.red.shade50,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: Colors.red.shade200),
            ),
            child: Row(
              children: [
                Icon(Icons.warning_outlined, color: Colors.red.shade800, size: 20),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    '이 작업은 되돌릴 수 없습니다',
                    style: TextStyle(fontSize: 12, color: Colors.red.shade800),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
      actions: [
        TextButton(onPressed: () => Navigator.pop(context), child: const Text('취소')),
        ElevatedButton(
          onPressed: () {
            onConfirm();
            Navigator.pop(context);
          },
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.red,
            foregroundColor: Colors.white,
          ),
          child: const Text('삭제'),
        ),
      ],
    );
  }
}
</file>

<file path="lib/features/tracking/presentation/dialogs/symptom_edit_dialog.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/application/providers.dart';
import 'package:n06/features/tracking/domain/usecases/validate_symptom_edit_usecase.dart';

const List<String> _symptomOptions = ['메스꺼움', '구토', '변비', '설사', '복통', '두통', '피로'];

const List<String> _contextTags = ['기름진음식', '과식', '음주', '공복', '스트레스', '수면부족'];

class SymptomEditDialog extends ConsumerStatefulWidget {
  final SymptomLog currentLog;
  final String userId;
  final VoidCallback? onSaveSuccess;

  const SymptomEditDialog({
    super.key,
    required this.currentLog,
    required this.userId,
    this.onSaveSuccess,
  });

  @override
  ConsumerState<SymptomEditDialog> createState() => _SymptomEditDialogState();
}

class _SymptomEditDialogState extends ConsumerState<SymptomEditDialog> {
  late String _selectedSymptom;
  late int _selectedSeverity;
  late List<String> _selectedTags;
  late TextEditingController _noteController;
  late ValidateSymptomEditUseCase _validateUseCase;
  String? _errorMessage;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _selectedSymptom = widget.currentLog.symptomName;
    _selectedSeverity = widget.currentLog.severity;
    _selectedTags = List.from(widget.currentLog.tags);
    _noteController = TextEditingController(text: widget.currentLog.note ?? '');
    _validateUseCase = ValidateSymptomEditUseCase();
  }

  @override
  void dispose() {
    _noteController.dispose();
    super.dispose();
  }

  void _validateFields() {
    setState(() {
      _errorMessage = null;
    });

    final result = _validateUseCase.execute(
      severity: _selectedSeverity,
      symptomName: _selectedSymptom,
    );

    if (result.isFailure) {
      setState(() {
        _errorMessage = result.error;
      });
    }
  }

  void _toggleTag(String tag) {
    setState(() {
      if (_selectedTags.contains(tag)) {
        _selectedTags.remove(tag);
      } else {
        _selectedTags.add(tag);
      }
    });
  }

  Future<void> _saveChanges() async {
    _validateFields();

    if (_errorMessage != null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(_errorMessage ?? '유효한 값을 입력해주세요'), backgroundColor: Colors.red),
      );
      return;
    }

    setState(() {
      _isLoading = true;
    });

    try {
      final updatedLog = SymptomLog(
        id: widget.currentLog.id,
        userId: widget.currentLog.userId,
        logDate: widget.currentLog.logDate,
        symptomName: _selectedSymptom,
        severity: _selectedSeverity,
        daysSinceEscalation: widget.currentLog.daysSinceEscalation,
        isPersistent24h: widget.currentLog.isPersistent24h,
        tags: _selectedTags,
        note: _noteController.text.isEmpty ? null : _noteController.text,
      );

      final notifier = ref.read(symptomRecordEditNotifierProvider.notifier);
      await notifier.updateSymptom(recordId: widget.currentLog.id, updatedLog: updatedLog);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('증상 기록이 수정되었습니다'), backgroundColor: Colors.green),
        );
        widget.onSaveSuccess?.call();
        Navigator.of(context).pop();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('저장 실패: ${e.toString()}'), backgroundColor: Colors.red),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text('증상 수정', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
              const SizedBox(height: 24),
              // 증상 선택
              Text('증상', style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 8),
              DropdownButton<String>(
                value: _selectedSymptom,
                isExpanded: true,
                onChanged: (String? newValue) {
                  if (newValue != null) {
                    setState(() {
                      _selectedSymptom = newValue;
                    });
                    _validateFields();
                  }
                },
                items: _symptomOptions.map((String symptom) {
                  return DropdownMenuItem<String>(value: symptom, child: Text(symptom));
                }).toList(),
              ),
              const SizedBox(height: 24),
              // 심각도 슬라이더
              Text('심각도: $_selectedSeverity/10', style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 8),
              Slider(
                value: _selectedSeverity.toDouble(),
                min: 1,
                max: 10,
                divisions: 9,
                onChanged: (double value) {
                  setState(() {
                    _selectedSeverity = value.toInt();
                  });
                  _validateFields();
                },
              ),
              const SizedBox(height: 24),
              // 컨텍스트 태그
              Text('컨텍스트 (선택 사항)', style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                children: _contextTags.map((tag) {
                  final isSelected = _selectedTags.contains(tag);
                  return FilterChip(
                    label: Text(tag),
                    selected: isSelected,
                    onSelected: (_) => _toggleTag(tag),
                  );
                }).toList(),
              ),
              const SizedBox(height: 24),
              // 메모
              Text('메모 (선택 사항)', style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 8),
              TextField(
                controller: _noteController,
                maxLines: 3,
                decoration: InputDecoration(
                  hintText: '추가 정보를 입력해주세요',
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                  contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                ),
              ),
              if (_errorMessage != null) ...[
                const SizedBox(height: 16),
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.red.shade50,
                    borderRadius: BorderRadius.circular(4),
                    border: Border.all(color: Colors.red.shade200),
                  ),
                  child: Text(
                    '❌ $_errorMessage',
                    style: TextStyle(fontSize: 14, color: Colors.red.shade800),
                  ),
                ),
              ],
              const SizedBox(height: 24),
              // 버튼들
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: _isLoading ? null : () => Navigator.pop(context),
                    child: const Text('취소'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: (_isLoading || _errorMessage != null) ? null : _saveChanges,
                    child: _isLoading
                        ? const SizedBox(
                            height: 16,
                            width: 16,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          )
                        : const Text('저장'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/tracking/presentation/dialogs/weight_edit_dialog.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/application/providers.dart';
import 'package:n06/features/tracking/domain/usecases/validate_weight_edit_usecase.dart';

class WeightEditDialog extends ConsumerStatefulWidget {
  final WeightLog currentLog;
  final String userId;
  final VoidCallback? onSaveSuccess;

  const WeightEditDialog({
    super.key,
    required this.currentLog,
    required this.userId,
    this.onSaveSuccess,
  });

  @override
  ConsumerState<WeightEditDialog> createState() => _WeightEditDialogState();
}

class _WeightEditDialogState extends ConsumerState<WeightEditDialog> {
  late TextEditingController _weightController;
  late DateTime _selectedDate;
  late ValidateWeightEditUseCase _validateUseCase;
  String? _errorMessage;
  String? _warningMessage;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _weightController = TextEditingController(text: widget.currentLog.weightKg.toString());
    _selectedDate = widget.currentLog.logDate;
    _validateUseCase = ValidateWeightEditUseCase();
  }

  @override
  void dispose() {
    _weightController.dispose();
    super.dispose();
  }

  void _validateWeight(String value) {
    setState(() {
      _errorMessage = null;
      _warningMessage = null;
    });

    if (value.isEmpty) return;

    try {
      final weight = double.parse(value);
      final result = _validateUseCase.execute(weight);

      setState(() {
        if (result.isFailure) {
          _errorMessage = result.error;
        } else if (result.warning != null) {
          _warningMessage = result.warning;
        }
      });
    } on FormatException {
      setState(() {
        _errorMessage = '숫자를 입력해주세요';
      });
    }
  }

  Future<void> _selectDate(BuildContext context) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2000),
      lastDate: DateTime.now(),
    );

    if (picked != null && picked != _selectedDate) {
      setState(() {
        _selectedDate = picked;
      });
    }
  }

  Future<void> _saveChanges() async {
    if (_errorMessage != null || _weightController.text.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(_errorMessage ?? '유효한 값을 입력해주세요'), backgroundColor: Colors.red),
      );
      return;
    }

    final newWeight = double.parse(_weightController.text);

    setState(() {
      _isLoading = true;
    });

    try {
      final notifier = ref.read(weightRecordEditNotifierProvider.notifier);
      await notifier.updateWeight(
        recordId: widget.currentLog.id,
        newWeight: newWeight,
        userId: widget.userId,
        newDate: _selectedDate,
        allowOverwrite: false,
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('체중 기록이 수정되었습니다'), backgroundColor: Colors.green),
        );
        widget.onSaveSuccess?.call();
        Navigator.of(context).pop();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('저장 실패: ${e.toString()}'), backgroundColor: Colors.red),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      child: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text('체중 수정', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
              const SizedBox(height: 24),
              // 날짜 선택
              Text('기록 날짜', style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 8),
              GestureDetector(
                onTap: () => _selectDate(context),
                child: Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.grey.shade300),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text(
                        '${_selectedDate.year}-${_selectedDate.month.toString().padLeft(2, '0')}-${_selectedDate.day.toString().padLeft(2, '0')}',
                        style: const TextStyle(fontSize: 16),
                      ),
                      const Icon(Icons.calendar_today, size: 20),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 24),
              // 체중 입력
              Text('체중 (kg)', style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 8),
              TextField(
                controller: _weightController,
                keyboardType: const TextInputType.numberWithOptions(decimal: true),
                onChanged: _validateWeight,
                decoration: InputDecoration(
                  hintText: '체중을 입력해주세요',
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                  errorText: _errorMessage,
                  contentPadding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
                ),
              ),
              if (_warningMessage != null) ...[
                const SizedBox(height: 8),
                Container(
                  padding: const EdgeInsets.all(8),
                  decoration: BoxDecoration(
                    color: Colors.orange.shade50,
                    borderRadius: BorderRadius.circular(4),
                    border: Border.all(color: Colors.orange.shade200),
                  ),
                  child: Text(
                    '⚠ $_warningMessage',
                    style: TextStyle(fontSize: 12, color: Colors.orange.shade800),
                  ),
                ),
              ],
              const SizedBox(height: 24),
              // 버튼들
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  TextButton(
                    onPressed: _isLoading ? null : () => Navigator.pop(context),
                    child: const Text('취소'),
                  ),
                  const SizedBox(width: 8),
                  ElevatedButton(
                    onPressed: (_isLoading || _errorMessage != null) ? null : _saveChanges,
                    child: _isLoading
                        ? const SizedBox(
                            height: 16,
                            width: 16,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          )
                        : const Text('저장'),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/tracking/presentation/screens/emergency_check_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:n06/features/tracking/application/providers.dart';
import 'package:n06/features/tracking/domain/entities/emergency_symptom_check.dart';
import 'package:n06/features/tracking/presentation/widgets/consultation_recommendation_dialog.dart';

/// F005: 증상 체크 화면
///
/// 긴급 증상 체크리스트를 제공하고,
/// 사용자가 선택한 증상에 따라 전문가 상담을 권장합니다.
///
/// BR1: 체크리스트 항목 (7개 고정)
/// BR3: 전문가 상담 권장 조건 (하나라도 선택 시 권장)
/// BR4: 데이터 저장 규칙 (emergency_symptom_checks, symptom_logs)
class EmergencyCheckScreen extends ConsumerStatefulWidget {
  const EmergencyCheckScreen({super.key});

  @override
  ConsumerState<EmergencyCheckScreen> createState() => _EmergencyCheckScreenState();
}

class _EmergencyCheckScreenState extends ConsumerState<EmergencyCheckScreen> {
  /// BR1: 체크리스트 항목 (7개 고정)
  static const emergencySymptoms = [
    '24시간 이상 계속 구토하고 있어요',
    '물이나 음식을 전혀 삼킬 수 없어요',
    '매우 심한 복통이 있어요 (견디기 어려운 정도)',
    '설사가 48시간 이상 계속되고 있어요',
    '소변이 진한 갈색이거나 8시간 이상 나오지 않았어요',
    '대변에 피가 섞여 있거나 검은색이에요',
    '피부나 눈 흰자위가 노랗게 변했어요',
  ];

  /// 선택된 증상 목록
  late List<bool> selectedStates;

  @override
  void initState() {
    super.initState();
    selectedStates = List.filled(emergencySymptoms.length, false);
  }

  /// 확인 버튼 클릭 처리
  void _handleConfirm() {
    final selectedSymptoms = <String>[];
    for (int i = 0; i < selectedStates.length; i++) {
      if (selectedStates[i]) {
        selectedSymptoms.add(emergencySymptoms[i]);
      }
    }

    // BR3: 전문가 상담 권장 조건 (하나라도 선택 시)
    if (selectedSymptoms.isNotEmpty) {
      // 증상 체크 저장
      _saveEmergencyCheck(selectedSymptoms);

      // 전문가 상담 권장 다이얼로그 표시
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => ConsultationRecommendationDialog(selectedSymptoms: selectedSymptoms),
      ).then((_) {
        // 다이얼로그 닫힌 후 화면 종료
        Navigator.of(context).pop();
      });
    }
  }

  /// 증상 체크 저장
  /// BR4: emergency_symptom_checks + symptom_logs 저장
  Future<void> _saveEmergencyCheck(List<String> selectedSymptoms) async {
    // 사용자 ID는 실제 앱에서 AuthNotifier에서 가져와야 함
    // 현재는 테스트 ID 사용
    const userId = 'current-user-id';

    final check = EmergencySymptomCheck(
      id: const Uuid().v4(),
      userId: userId,
      checkedAt: DateTime.now(),
      checkedSymptoms: selectedSymptoms,
    );

    // Notifier를 통한 저장 (자동으로 부작용 기록도 생성)
    try {
      await ref.read(emergencyCheckNotifierProvider.notifier).saveEmergencyCheck(userId, check);

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('증상이 기록되었습니다.'), duration: Duration(seconds: 2)),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text('기록 실패: $e'), backgroundColor: Colors.red));
      }
    }
  }

  /// 해당 없음 버튼 클릭 처리
  void _handleNoSymptoms() {
    Navigator.of(context).pop();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('증상 체크'), elevation: 0),
      body: SingleChildScrollView(
        child: Column(
          children: [
            // 헤더
            Container(
              padding: const EdgeInsets.all(16),
              color: Colors.blue.shade50,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Text(
                    '다음 증상 중 해당하는 것이 있나요?',
                    style: TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                  ),
                  const SizedBox(height: 8),
                  Text('해당하는 증상을 선택해주세요.', style: TextStyle(fontSize: 14, color: Colors.grey[600])),
                ],
              ),
            ),

            // 증상 체크리스트
            Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                children: List.generate(
                  emergencySymptoms.length,
                  (index) => CheckboxListTile(
                    value: selectedStates[index],
                    onChanged: (value) {
                      setState(() {
                        selectedStates[index] = value ?? false;
                      });
                    },
                    title: Text(emergencySymptoms[index], style: const TextStyle(fontSize: 14)),
                    controlAffinity: ListTileControlAffinity.leading,
                    contentPadding: const EdgeInsets.symmetric(horizontal: 0),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
      bottomNavigationBar: Container(
        padding: const EdgeInsets.all(16),
        child: Row(
          children: [
            Expanded(
              child: OutlinedButton(onPressed: _handleNoSymptoms, child: const Text('해당 없음')),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: ElevatedButton(
                // 증상이 선택되지 않으면 비활성화
                onPressed: selectedStates.any((state) => state) ? _handleConfirm : null,
                child: const Text('확인'),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/tracking/presentation/screens/symptom_record_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';
import 'package:go_router/go_router.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/application/providers.dart';
import 'package:n06/features/tracking/presentation/widgets/date_selection_widget.dart';
import 'package:n06/features/tracking/presentation/widgets/coping_guide_widget.dart';

/// F002: 증상 기록 화면
///
/// 사용자가 부작용 증상을 기록할 수 있는 화면입니다.
/// 증상 선택, 심각도 선택, 태그 선택, 경과일 표시, 대처 가이드 연동 기능을 제공합니다.
class SymptomRecordScreen extends ConsumerStatefulWidget {
  const SymptomRecordScreen({super.key});

  @override
  ConsumerState<SymptomRecordScreen> createState() =>
      _SymptomRecordScreenState();
}

class _SymptomRecordScreenState extends ConsumerState<SymptomRecordScreen> {
  static const List<String> _symptoms = [
    '메스꺼움',
    '구토',
    '변비',
    '설사',
    '복통',
    '두통',
    '피로',
  ];

  static const List<String> _contextTags = [
    '기름진음식',
    '과식',
    '음주',
    '공복',
    '스트레스',
    '수면부족',
  ];

  late DateTime selectedDate;
  final Set<String> selectedSymptoms = {};
  int severity = 5;
  bool? isPersistent24h;
  final Set<String> selectedTags = {};
  String memo = '';
  int? daysSinceEscalation;
  bool isLoading = false;
  SymptomLog? savedLog;

  @override
  void initState() {
    super.initState();
    // 오늘 날짜로 초기화
    final now = DateTime.now();
    selectedDate = DateTime(now.year, now.month, now.day);
    _loadEscalationDate();
  }

  Future<void> _loadEscalationDate() async {
    final userId = _getCurrentUserId();
    final notifier = ref.read(trackingNotifierProvider.notifier);
    final escalationDate = await notifier.getLatestDoseEscalationDate(userId);

    if (escalationDate != null && mounted) {
      final days = selectedDate.difference(escalationDate).inDays;
      setState(() {
        daysSinceEscalation = days;
      });
    }
  }

  void _handleDateSelected(DateTime date) {
    setState(() {
      selectedDate = date;
    });
    _loadEscalationDate();
  }

  Future<void> _handleSave() async {
    // 입력값 검증
    if (selectedSymptoms.isEmpty) {
      _showErrorDialog('증상을 선택해주세요');
      return;
    }

    // 심각도 7-10점인 경우 24시간 지속 여부 확인 필수
    if (severity >= 7 && isPersistent24h == null) {
      _showErrorDialog('24시간 이상 지속 여부를 선택해주세요');
      return;
    }

    setState(() => isLoading = true);

    try {
      final userId = _getCurrentUserId();
      final notifier = ref.read(trackingNotifierProvider.notifier);

      // 각 증상별로 기록 저장
      for (final symptom in selectedSymptoms) {
        final log = SymptomLog(
          id: const Uuid().v4(),
          userId: userId,
          logDate: selectedDate,
          symptomName: symptom,
          severity: severity,
          daysSinceEscalation: daysSinceEscalation,
          isPersistent24h: severity >= 7 ? isPersistent24h : null,
          note: memo.isNotEmpty ? memo : null,
          tags: selectedTags.toList(),
          createdAt: DateTime.now(),
        );

        await notifier.saveSymptomLog(log);
        savedLog = log;
      }

      if (!mounted) return;

      // 대처 가이드 표시
      await _showCopingGuide();
    } catch (e) {
      if (mounted) {
        _showErrorDialog('저장 중 오류가 발생했습니다: $e');
      }
    } finally {
      if (mounted) {
        setState(() => isLoading = false);
      }
    }
  }

  Future<void> _showCopingGuide() async {
    if (savedLog == null) return;

    if (!mounted) return;

    // 대처 가이드 위젯 표시
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      builder: (context) => DraggableScrollableSheet(
        expand: false,
        builder: (context, scrollController) => SingleChildScrollView(
          controller: scrollController,
          child: CopingGuideWidget(
            symptomName: savedLog!.symptomName,
            severity: savedLog!.severity,
            onClose: () => Navigator.of(context).pop(),
          ),
        ),
      ),
    );

    // 심각도 7-10점이고 24시간 지속인 경우 증상 체크 화면 안내
    if (severity >= 7 && isPersistent24h == true) {
      await Future.delayed(const Duration(milliseconds: 500));
      if (mounted) {
        _showEmergencyCheckPrompt();
      }
    }
  }

  void _showEmergencyCheckPrompt() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('증상 체크'),
        content: const Text(
          '심각한 증상이 지속되고 있습니다.\n증상 체크 화면에서 더 자세히 확인하시겠어요?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('나중에'),
          ),
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              // F005 증상 체크 화면으로 이동
              context.push('/emergency/check');
            },
            child: const Text('이동'),
          ),
        ],
      ),
    );
  }

  void _showErrorDialog(String message) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('오류'),
        content: Text(message),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('확인'),
          ),
        ],
      ),
    );
  }

  String _getCurrentUserId() {
    // TODO: AuthNotifier에서 현재 사용자 ID 가져오기
    return 'current-user-id';
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('증상 기록'),
        elevation: 0,
      ),
      body: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // 날짜 선택
              const Text(
                '날짜 선택',
                style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 12),
              DateSelectionWidget(
                initialDate: selectedDate,
                onDateSelected: _handleDateSelected,
              ),

              // 경과일 표시
              if (daysSinceEscalation != null) ...[
                const SizedBox(height: 16),
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.blue.shade50,
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Text(
                    '용량 증량 후 $daysSinceEscalation일째',
                    style: TextStyle(
                      color: Colors.blue.shade900,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
              ],

              // 증상 선택
              const SizedBox(height: 24),
              const Text(
                '증상 선택',
                style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 12),
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: _symptoms.map((symptom) {
                  final isSelected = selectedSymptoms.contains(symptom);
                  return FilterChip(
                    label: Text(symptom),
                    selected: isSelected,
                    onSelected: (selected) {
                      setState(() {
                        if (selected) {
                          selectedSymptoms.add(symptom);
                        } else {
                          selectedSymptoms.remove(symptom);
                        }
                      });
                    },
                  );
                }).toList(),
              ),

              // 심각도 선택
              const SizedBox(height: 24),
              const Text(
                '심각도 (1-10점)',
                style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 12),
              Column(
                children: [
                  Slider(
                    value: severity.toDouble(),
                    min: 1,
                    max: 10,
                    divisions: 9,
                    label: severity.toString(),
                    onChanged: (value) {
                      setState(() {
                        severity = value.toInt();
                        // 심각도가 6 이하로 낮아지면 isPersistent24h 리셋
                        if (severity < 7) {
                          isPersistent24h = null;
                        }
                      });
                    },
                  ),
                  Text(
                    '현재: $severity점',
                    style: const TextStyle(fontSize: 14),
                  ),
                ],
              ),

              // 심각도 7-10점인 경우 24시간 지속 여부 질문
              if (severity >= 7) ...[
                const SizedBox(height: 24),
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.orange.shade50,
                    borderRadius: BorderRadius.circular(8),
                    border: Border.all(color: Colors.orange.shade300),
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        '24시간 이상 지속되고 있나요?',
                        style: TextStyle(
                          fontWeight: FontWeight.w500,
                          fontSize: 14,
                        ),
                      ),
                      const SizedBox(height: 12),
                      Row(
                        children: [
                          Expanded(
                            child: OutlinedButton(
                              onPressed: () {
                                setState(() => isPersistent24h = false);
                              },
                              style: OutlinedButton.styleFrom(
                                backgroundColor: isPersistent24h == false
                                    ? Colors.grey.shade200
                                    : Colors.transparent,
                              ),
                              child: const Text('아니오'),
                            ),
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: ElevatedButton(
                              onPressed: () {
                                setState(() => isPersistent24h = true);
                              },
                              style: ElevatedButton.styleFrom(
                                backgroundColor: isPersistent24h == true
                                    ? Colors.orange
                                    : Colors.grey,
                              ),
                              child: const Text(
                                '예',
                                style: TextStyle(color: Colors.white),
                              ),
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ],

              // 컨텍스트 태그 선택 (심각도 1-6점일 때만)
              if (severity < 7) ...[
                const SizedBox(height: 24),
                const Text(
                  '컨텍스트 태그 (선택)',
                  style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 12),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: _contextTags.map((tag) {
                    final isSelected = selectedTags.contains(tag);
                    return ChoiceChip(
                      label: Text('#$tag'),
                      selected: isSelected,
                      onSelected: (selected) {
                        setState(() {
                          if (selected) {
                            selectedTags.add(tag);
                          } else {
                            selectedTags.remove(tag);
                          }
                        });
                      },
                    );
                  }).toList(),
                ),
              ],

              // 메모 입력
              const SizedBox(height: 24),
              const Text(
                '메모 (선택)',
                style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 12),
              TextField(
                onChanged: (value) {
                  setState(() => memo = value);
                },
                maxLines: 3,
                decoration: InputDecoration(
                  hintText: '추가 정보를 입력하세요',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                  contentPadding: const EdgeInsets.all(12),
                ),
              ),

              // 저장 버튼
              const SizedBox(height: 32),
              SizedBox(
                width: double.infinity,
                height: 48,
                child: ElevatedButton(
                  onPressed: isLoading ? null : _handleSave,
                  child: isLoading
                      ? const SizedBox(
                          height: 24,
                          width: 24,
                          child: CircularProgressIndicator(
                            valueColor:
                                AlwaysStoppedAnimation<Color>(Colors.white),
                            strokeWidth: 2,
                          ),
                        )
                      : const Text('저장'),
                ),
              ),

              const SizedBox(height: 16),
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/tracking/presentation/sheets/record_detail_sheet.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';
import 'package:n06/features/tracking/presentation/dialogs/weight_edit_dialog.dart';
import 'package:n06/features/tracking/presentation/dialogs/symptom_edit_dialog.dart';
import 'package:n06/features/tracking/presentation/dialogs/dose_edit_dialog.dart';
import 'package:n06/features/tracking/presentation/dialogs/record_delete_dialog.dart';
import 'package:n06/features/tracking/application/providers.dart';

String _formatDate(DateTime date) {
  return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
}

String _formatDateTime(DateTime dateTime) {
  return '${_formatDate(dateTime)} ${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
}

class RecordDetailSheet extends ConsumerWidget {
  final dynamic record;
  final String userId;
  final VoidCallback? onRecordUpdated;

  const RecordDetailSheet({
    super.key,
    required this.record,
    required this.userId,
    this.onRecordUpdated,
  });

  factory RecordDetailSheet.weight({
    required WeightLog log,
    required String userId,
    VoidCallback? onRecordUpdated,
  }) {
    return RecordDetailSheet(record: log, userId: userId, onRecordUpdated: onRecordUpdated);
  }

  factory RecordDetailSheet.symptom({
    required SymptomLog log,
    required String userId,
    VoidCallback? onRecordUpdated,
  }) {
    return RecordDetailSheet(record: log, userId: userId, onRecordUpdated: onRecordUpdated);
  }

  factory RecordDetailSheet.dose({
    required DoseRecord record,
    required String userId,
    VoidCallback? onRecordUpdated,
  }) {
    return RecordDetailSheet(record: record, userId: userId, onRecordUpdated: onRecordUpdated);
  }

  void _showEditDialog(BuildContext context, WidgetRef ref) {
    if (record is WeightLog) {
      showDialog(
        context: context,
        builder: (_) => WeightEditDialog(
          currentLog: record as WeightLog,
          userId: userId,
          onSaveSuccess: () {
            onRecordUpdated?.call();
            Navigator.pop(context); // Close sheet
          },
        ),
      );
    } else if (record is SymptomLog) {
      showDialog(
        context: context,
        builder: (_) => SymptomEditDialog(
          currentLog: record as SymptomLog,
          userId: userId,
          onSaveSuccess: () {
            onRecordUpdated?.call();
            Navigator.pop(context);
          },
        ),
      );
    } else if (record is DoseRecord) {
      showDialog(
        context: context,
        builder: (_) => DoseEditDialog(
          currentRecord: record as DoseRecord,
          userId: userId,
          onSaveSuccess: () {
            onRecordUpdated?.call();
            Navigator.pop(context);
          },
        ),
      );
    }
  }

  void _showDeleteDialog(BuildContext context, WidgetRef ref) {
    String recordType = '';
    String recordInfo = '';
    Future<void> Function() deleteCallback = () async {};

    if (record is WeightLog) {
      final log = record as WeightLog;
      recordType = '체중 기록';
      recordInfo = '${log.weightKg}kg (${_formatDate(log.logDate)})';
      deleteCallback = () async {
        final notifier = ref.read(weightRecordEditNotifierProvider.notifier);
        await notifier.deleteWeight(recordId: log.id, userId: userId);
      };
    } else if (record is SymptomLog) {
      final log = record as SymptomLog;
      recordType = '증상 기록';
      recordInfo = '${log.symptomName} (${_formatDate(log.logDate)})';
      deleteCallback = () async {
        final notifier = ref.read(symptomRecordEditNotifierProvider.notifier);
        await notifier.deleteSymptom(recordId: log.id, userId: userId);
      };
    } else if (record is DoseRecord) {
      final dose = record as DoseRecord;
      recordType = '투여 기록';
      recordInfo = '${dose.actualDoseMg}mg (${_formatDateTime(dose.administeredAt)})';
      deleteCallback = () async {
        final notifier = ref.read(doseRecordEditNotifierProvider.notifier);
        await notifier.deleteDoseRecord(recordId: dose.id, userId: userId);
      };
    }

    showDialog(
      context: context,
      builder: (_) => RecordDeleteDialog(
        recordType: recordType,
        recordInfo: recordInfo,
        onConfirm: () async {
          try {
            await deleteCallback();
            if (context.mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('$recordType가 삭제되었습니다'), backgroundColor: Colors.green),
              );
              onRecordUpdated?.call();
              Navigator.pop(context); // Close sheet
            }
          } catch (e) {
            if (context.mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('삭제 실패: ${e.toString()}'), backgroundColor: Colors.red),
              );
            }
          }
        },
      ),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    Widget contentWidget = const SizedBox.shrink();

    if (record is WeightLog) {
      final log = record as WeightLog;
      contentWidget = Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildHeader('체중 기록'),
          const SizedBox(height: 16),
          _buildInfoRow('날짜', _formatDate(log.logDate)),
          _buildInfoRow('체중', '${log.weightKg} kg'),
          _buildInfoRow(
            '기록 시간',
            '${log.createdAt.hour.toString().padLeft(2, '0')}:${log.createdAt.minute.toString().padLeft(2, '0')}',
          ),
        ],
      );
    } else if (record is SymptomLog) {
      final log = record as SymptomLog;
      contentWidget = Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildHeader('증상 기록'),
          const SizedBox(height: 16),
          _buildInfoRow('날짜', _formatDate(log.logDate)),
          _buildInfoRow('증상', log.symptomName),
          _buildInfoRow('심각도', '${log.severity}/10'),
          if (log.tags.isNotEmpty) ...[
            const SizedBox(height: 12),
            Text('컨텍스트', style: Theme.of(context).textTheme.labelMedium),
            const SizedBox(height: 8),
            Wrap(
              spacing: 8,
              children: log.tags
                  .map(
                    (tag) => Chip(
                      label: Text(tag),
                      labelStyle: const TextStyle(fontSize: 12),
                      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                    ),
                  )
                  .toList(),
            ),
          ],
          if (log.note != null && log.note!.isNotEmpty) ...[
            const SizedBox(height: 12),
            Text('메모', style: Theme.of(context).textTheme.labelMedium),
            const SizedBox(height: 8),
            Text(log.note!),
          ],
        ],
      );
    } else if (record is DoseRecord) {
      final dose = record as DoseRecord;
      contentWidget = Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildHeader('투여 기록'),
          const SizedBox(height: 16),
          _buildInfoRow('날짜', _formatDate(dose.administeredAt)),
          _buildInfoRow(
            '시간',
            '${dose.administeredAt.hour.toString().padLeft(2, '0')}:${dose.administeredAt.minute.toString().padLeft(2, '0')}',
          ),
          _buildInfoRow('투여량', '${dose.actualDoseMg} mg'),
          if (dose.injectionSite != null) _buildInfoRow('투여 부위', dose.injectionSite!),
          _buildInfoRow('상태', dose.isCompleted ? '완료' : '미완료'),
          if (dose.note != null && dose.note!.isNotEmpty) ...[
            const SizedBox(height: 12),
            Text('메모', style: Theme.of(context).textTheme.labelMedium),
            const SizedBox(height: 8),
            Text(dose.note!),
          ],
        ],
      );
    }

    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.only(
          topLeft: Radius.circular(16),
          topRight: Radius.circular(16),
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            contentWidget,
            const SizedBox(height: 24),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                OutlinedButton.icon(
                  onPressed: () => _showEditDialog(context, ref),
                  icon: const Icon(Icons.edit),
                  label: const Text('수정'),
                ),
                const SizedBox(width: 8),
                ElevatedButton.icon(
                  onPressed: () => _showDeleteDialog(context, ref),
                  icon: const Icon(Icons.delete_outline),
                  label: const Text('삭제'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.red.shade100,
                    foregroundColor: Colors.red,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildHeader(String title) {
    return Text(title, style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold));
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label, style: const TextStyle(fontSize: 14, color: Colors.grey)),
          Text(value, style: const TextStyle(fontSize: 14, fontWeight: FontWeight.w500)),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/tracking/presentation/widgets/consultation_recommendation_dialog.dart">
import 'package:flutter/material.dart';

/// F005: 전문가 상담 권장 다이얼로그
///
/// 사용자가 긴급 증상 중 하나라도 선택했을 때,
/// 전문가와의 상담이 필요함을 안내하는 모달 다이얼로그
class ConsultationRecommendationDialog extends StatelessWidget {
  /// 사용자가 선택한 증상 목록
  final List<String> selectedSymptoms;

  const ConsultationRecommendationDialog({super.key, required this.selectedSymptoms});

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text(
        '전문가와 상담이 필요합니다',
        style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: Colors.red),
      ),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // 선택된 증상 목록
            const Text('선택하신 증상:', style: TextStyle(fontSize: 14, fontWeight: FontWeight.w600)),
            const SizedBox(height: 12),
            ...selectedSymptoms.map(
              (symptom) => Padding(
                padding: const EdgeInsets.only(bottom: 8.0),
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    const Icon(Icons.warning, color: Colors.red, size: 20),
                    const SizedBox(width: 8),
                    Expanded(child: Text(symptom, style: const TextStyle(fontSize: 14))),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 16),

            // 안내 메시지
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: Colors.red.shade50,
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.red.shade200, width: 1),
              ),
              child: const Text(
                '선택하신 증상으로 보아 전문가의 상담이 필요해 보입니다. '
                '가능한 한 빨리 의료진에게 연락하시기 바랍니다.',
                style: TextStyle(fontSize: 13, height: 1.5, color: Colors.black87),
              ),
            ),
          ],
        ),
      ),
      actions: [TextButton(onPressed: () => Navigator.of(context).pop(), child: const Text('확인'))],
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
    );
  }
}
</file>

<file path="macos/Runner.xcodeproj/project.pbxproj">
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXAggregateTarget section */
		33CC111A2044C6BA0003C045 /* Flutter Assemble */ = {
			isa = PBXAggregateTarget;
			buildConfigurationList = 33CC111B2044C6BA0003C045 /* Build configuration list for PBXAggregateTarget "Flutter Assemble" */;
			buildPhases = (
				33CC111E2044C6BF0003C045 /* ShellScript */,
			);
			dependencies = (
			);
			name = "Flutter Assemble";
			productName = FLX;
		};
/* End PBXAggregateTarget section */

/* Begin PBXBuildFile section */
		331C80D8294CF71000263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C80D7294CF71000263BE5 /* RunnerTests.swift */; };
		335BBD1B22A9A15E00E9071D /* GeneratedPluginRegistrant.swift in Sources */ = {isa = PBXBuildFile; fileRef = 335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */; };
		33CC10F12044A3C60003C045 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 33CC10F02044A3C60003C045 /* AppDelegate.swift */; };
		33CC10F32044A3C60003C045 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 33CC10F22044A3C60003C045 /* Assets.xcassets */; };
		33CC10F62044A3C60003C045 /* MainMenu.xib in Resources */ = {isa = PBXBuildFile; fileRef = 33CC10F42044A3C60003C045 /* MainMenu.xib */; };
		33CC11132044BFA00003C045 /* MainFlutterWindow.swift in Sources */ = {isa = PBXBuildFile; fileRef = 33CC11122044BFA00003C045 /* MainFlutterWindow.swift */; };
		38AA0DED541000C07A5D0651 /* Pods_Runner.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = FAA31C599CDED0855E3BCF42 /* Pods_Runner.framework */; };
		52D27B549169BC947A7DE96C /* Pods_RunnerTests.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 016DDD3C3FA4DE4925B1058D /* Pods_RunnerTests.framework */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C80D9294CF71000263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 33CC10E52044A3C60003C045 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 33CC10EC2044A3C60003C045;
			remoteInfo = Runner;
		};
		33CC111F2044C79F0003C045 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 33CC10E52044A3C60003C045 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 33CC111A2044C6BA0003C045;
			remoteInfo = FLX;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		33CC110E2044A8840003C045 /* Bundle Framework */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Bundle Framework";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		016DDD3C3FA4DE4925B1058D /* Pods_RunnerTests.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_RunnerTests.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		331C80D5294CF71000263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		331C80D7294CF71000263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		333000ED22D3DE5D00554162 /* Warnings.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Warnings.xcconfig; sourceTree = "<group>"; };
		335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = GeneratedPluginRegistrant.swift; sourceTree = "<group>"; };
		33CC10ED2044A3C60003C045 /* n06.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = n06.app; sourceTree = BUILT_PRODUCTS_DIR; };
		33CC10F02044A3C60003C045 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		33CC10F22044A3C60003C045 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; name = Assets.xcassets; path = Runner/Assets.xcassets; sourceTree = "<group>"; };
		33CC10F52044A3C60003C045 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/MainMenu.xib; sourceTree = "<group>"; };
		33CC10F72044A3C60003C045 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; name = Info.plist; path = Runner/Info.plist; sourceTree = "<group>"; };
		33CC11122044BFA00003C045 /* MainFlutterWindow.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainFlutterWindow.swift; sourceTree = "<group>"; };
		33CEB47222A05771004F2AC0 /* Flutter-Debug.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Flutter-Debug.xcconfig"; sourceTree = "<group>"; };
		33CEB47422A05771004F2AC0 /* Flutter-Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Flutter-Release.xcconfig"; sourceTree = "<group>"; };
		33CEB47722A0578A004F2AC0 /* Flutter-Generated.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = "Flutter-Generated.xcconfig"; path = "ephemeral/Flutter-Generated.xcconfig"; sourceTree = "<group>"; };
		33E51913231747F40026EE4D /* DebugProfile.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = DebugProfile.entitlements; sourceTree = "<group>"; };
		33E51914231749380026EE4D /* Release.entitlements */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.entitlements; path = Release.entitlements; sourceTree = "<group>"; };
		33E5194F232828860026EE4D /* AppInfo.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = AppInfo.xcconfig; sourceTree = "<group>"; };
		4F6D9AB220933305119C31B9 /* Pods-RunnerTests.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.release.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.release.xcconfig"; sourceTree = "<group>"; };
		5626795C590979B8945C7244 /* Pods-RunnerTests.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.debug.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.debug.xcconfig"; sourceTree = "<group>"; };
		5E4AACB672F34892D999CBC2 /* Pods-Runner.release.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.release.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.release.xcconfig"; sourceTree = "<group>"; };
		69F27D9A0512633463792FD2 /* Pods-Runner.debug.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.debug.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.debug.xcconfig"; sourceTree = "<group>"; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Release.xcconfig; sourceTree = "<group>"; };
		8F8289C2912DF69CD411CC98 /* Pods-Runner.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-Runner.profile.xcconfig"; path = "Target Support Files/Pods-Runner/Pods-Runner.profile.xcconfig"; sourceTree = "<group>"; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; path = Debug.xcconfig; sourceTree = "<group>"; };
		E7C4261899DF12915F74C162 /* Pods-RunnerTests.profile.xcconfig */ = {isa = PBXFileReference; includeInIndex = 1; lastKnownFileType = text.xcconfig; name = "Pods-RunnerTests.profile.xcconfig"; path = "Target Support Files/Pods-RunnerTests/Pods-RunnerTests.profile.xcconfig"; sourceTree = "<group>"; };
		FAA31C599CDED0855E3BCF42 /* Pods_Runner.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = Pods_Runner.framework; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		331C80D2294CF70F00263BE5 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				52D27B549169BC947A7DE96C /* Pods_RunnerTests.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10EA2044A3C60003C045 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				38AA0DED541000C07A5D0651 /* Pods_Runner.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		331C80D6294CF71000263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C80D7294CF71000263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		33BA886A226E78AF003329D5 /* Configs */ = {
			isa = PBXGroup;
			children = (
				33E5194F232828860026EE4D /* AppInfo.xcconfig */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				333000ED22D3DE5D00554162 /* Warnings.xcconfig */,
			);
			path = Configs;
			sourceTree = "<group>";
		};
		33CC10E42044A3C60003C045 = {
			isa = PBXGroup;
			children = (
				33FAB671232836740065AC1E /* Runner */,
				33CEB47122A05771004F2AC0 /* Flutter */,
				331C80D6294CF71000263BE5 /* RunnerTests */,
				33CC10EE2044A3C60003C045 /* Products */,
				D73912EC22F37F3D000D13A0 /* Frameworks */,
				FB4DEAA399F1F6340D548344 /* Pods */,
			);
			sourceTree = "<group>";
		};
		33CC10EE2044A3C60003C045 /* Products */ = {
			isa = PBXGroup;
			children = (
				33CC10ED2044A3C60003C045 /* n06.app */,
				331C80D5294CF71000263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		33CC11242044D66E0003C045 /* Resources */ = {
			isa = PBXGroup;
			children = (
				33CC10F22044A3C60003C045 /* Assets.xcassets */,
				33CC10F42044A3C60003C045 /* MainMenu.xib */,
				33CC10F72044A3C60003C045 /* Info.plist */,
			);
			name = Resources;
			path = ..;
			sourceTree = "<group>";
		};
		33CEB47122A05771004F2AC0 /* Flutter */ = {
			isa = PBXGroup;
			children = (
				335BBD1A22A9A15E00E9071D /* GeneratedPluginRegistrant.swift */,
				33CEB47222A05771004F2AC0 /* Flutter-Debug.xcconfig */,
				33CEB47422A05771004F2AC0 /* Flutter-Release.xcconfig */,
				33CEB47722A0578A004F2AC0 /* Flutter-Generated.xcconfig */,
			);
			path = Flutter;
			sourceTree = "<group>";
		};
		33FAB671232836740065AC1E /* Runner */ = {
			isa = PBXGroup;
			children = (
				33CC10F02044A3C60003C045 /* AppDelegate.swift */,
				33CC11122044BFA00003C045 /* MainFlutterWindow.swift */,
				33E51913231747F40026EE4D /* DebugProfile.entitlements */,
				33E51914231749380026EE4D /* Release.entitlements */,
				33CC11242044D66E0003C045 /* Resources */,
				33BA886A226E78AF003329D5 /* Configs */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
		D73912EC22F37F3D000D13A0 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				FAA31C599CDED0855E3BCF42 /* Pods_Runner.framework */,
				016DDD3C3FA4DE4925B1058D /* Pods_RunnerTests.framework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		FB4DEAA399F1F6340D548344 /* Pods */ = {
			isa = PBXGroup;
			children = (
				69F27D9A0512633463792FD2 /* Pods-Runner.debug.xcconfig */,
				5E4AACB672F34892D999CBC2 /* Pods-Runner.release.xcconfig */,
				8F8289C2912DF69CD411CC98 /* Pods-Runner.profile.xcconfig */,
				5626795C590979B8945C7244 /* Pods-RunnerTests.debug.xcconfig */,
				4F6D9AB220933305119C31B9 /* Pods-RunnerTests.release.xcconfig */,
				E7C4261899DF12915F74C162 /* Pods-RunnerTests.profile.xcconfig */,
			);
			name = Pods;
			path = Pods;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C80D4294CF70F00263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C80DE294CF71000263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				25458DDCFBB5075E2D3711E4 /* [CP] Check Pods Manifest.lock */,
				331C80D1294CF70F00263BE5 /* Sources */,
				331C80D2294CF70F00263BE5 /* Frameworks */,
				331C80D3294CF70F00263BE5 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				331C80DA294CF71000263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C80D5294CF71000263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		33CC10EC2044A3C60003C045 /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 33CC10FB2044A3C60003C045 /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				39C37A326CB414E7E75EF476 /* [CP] Check Pods Manifest.lock */,
				33CC10E92044A3C60003C045 /* Sources */,
				33CC10EA2044A3C60003C045 /* Frameworks */,
				33CC10EB2044A3C60003C045 /* Resources */,
				33CC110E2044A8840003C045 /* Bundle Framework */,
				3399D490228B24CF009A79C7 /* ShellScript */,
				B9A61E4F26C86657020D16DE /* [CP] Embed Pods Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
				33CC11202044C79F0003C045 /* PBXTargetDependency */,
			);
			name = Runner;
			productName = Runner;
			productReference = 33CC10ED2044A3C60003C045 /* n06.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		33CC10E52044A3C60003C045 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastSwiftUpdateCheck = 0920;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C80D4294CF70F00263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 33CC10EC2044A3C60003C045;
					};
					33CC10EC2044A3C60003C045 = {
						CreatedOnToolsVersion = 9.2;
						LastSwiftMigration = 1100;
						ProvisioningStyle = Automatic;
						SystemCapabilities = {
							com.apple.Sandbox = {
								enabled = 1;
							};
						};
					};
					33CC111A2044C6BA0003C045 = {
						CreatedOnToolsVersion = 9.2;
						ProvisioningStyle = Manual;
					};
				};
			};
			buildConfigurationList = 33CC10E82044A3C60003C045 /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 33CC10E42044A3C60003C045;
			productRefGroup = 33CC10EE2044A3C60003C045 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				33CC10EC2044A3C60003C045 /* Runner */,
				331C80D4294CF70F00263BE5 /* RunnerTests */,
				33CC111A2044C6BA0003C045 /* Flutter Assemble */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C80D3294CF70F00263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10EB2044A3C60003C045 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				33CC10F32044A3C60003C045 /* Assets.xcassets in Resources */,
				33CC10F62044A3C60003C045 /* MainMenu.xib in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		25458DDCFBB5075E2D3711E4 /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-RunnerTests-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		3399D490228B24CF009A79C7 /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "echo \"$PRODUCT_NAME.app\" > \"$PROJECT_DIR\"/Flutter/ephemeral/.app_filename && \"$FLUTTER_ROOT\"/packages/flutter_tools/bin/macos_assemble.sh embed\n";
		};
		33CC111E2044C6BF0003C045 /* ShellScript */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				Flutter/ephemeral/FlutterInputs.xcfilelist,
			);
			inputPaths = (
				Flutter/ephemeral/tripwire,
			);
			outputFileListPaths = (
				Flutter/ephemeral/FlutterOutputs.xcfilelist,
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"$FLUTTER_ROOT\"/packages/flutter_tools/bin/macos_assemble.sh && touch Flutter/ephemeral/tripwire";
		};
		39C37A326CB414E7E75EF476 /* [CP] Check Pods Manifest.lock */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
				"${PODS_PODFILE_DIR_PATH}/Podfile.lock",
				"${PODS_ROOT}/Manifest.lock",
			);
			name = "[CP] Check Pods Manifest.lock";
			outputFileListPaths = (
			);
			outputPaths = (
				"$(DERIVED_FILE_DIR)/Pods-Runner-checkManifestLockResult.txt",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "diff \"${PODS_PODFILE_DIR_PATH}/Podfile.lock\" \"${PODS_ROOT}/Manifest.lock\" > /dev/null\nif [ $? != 0 ] ; then\n    # print error to STDERR\n    echo \"error: The sandbox is not in sync with the Podfile.lock. Run 'pod install' or update your CocoaPods installation.\" >&2\n    exit 1\nfi\n# This output is used by Xcode 'outputs' to avoid re-running this script phase.\necho \"SUCCESS\" > \"${SCRIPT_OUTPUT_FILE_0}\"\n";
			showEnvVarsInLog = 0;
		};
		B9A61E4F26C86657020D16DE /* [CP] Embed Pods Frameworks */ = {
			isa = PBXShellScriptBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-input-files.xcfilelist",
			);
			name = "[CP] Embed Pods Frameworks";
			outputFileListPaths = (
				"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks-${CONFIGURATION}-output-files.xcfilelist",
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "\"${PODS_ROOT}/Target Support Files/Pods-Runner/Pods-Runner-frameworks.sh\"\n";
			showEnvVarsInLog = 0;
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C80D1294CF70F00263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C80D8294CF71000263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		33CC10E92044A3C60003C045 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				33CC11132044BFA00003C045 /* MainFlutterWindow.swift in Sources */,
				33CC10F12044A3C60003C045 /* AppDelegate.swift in Sources */,
				335BBD1B22A9A15E00E9071D /* GeneratedPluginRegistrant.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C80DA294CF71000263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 33CC10EC2044A3C60003C045 /* Runner */;
			targetProxy = 331C80D9294CF71000263BE5 /* PBXContainerItemProxy */;
		};
		33CC11202044C79F0003C045 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 33CC111A2044C6BA0003C045 /* Flutter Assemble */;
			targetProxy = 33CC111F2044C79F0003C045 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		33CC10F42044A3C60003C045 /* MainMenu.xib */ = {
			isa = PBXVariantGroup;
			children = (
				33CC10F52044A3C60003C045 /* Base */,
			);
			name = MainMenu.xib;
			path = Runner;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		331C80DB294CF71000263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 5626795C590979B8945C7244 /* Pods-RunnerTests.debug.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.glp1.n06.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/n06.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/n06";
			};
			name = Debug;
		};
		331C80DC294CF71000263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 4F6D9AB220933305119C31B9 /* Pods-RunnerTests.release.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.glp1.n06.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/n06.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/n06";
			};
			name = Release;
		};
		331C80DD294CF71000263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = E7C4261899DF12915F74C162 /* Pods-RunnerTests.profile.xcconfig */;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.glp1.n06.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/n06.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/n06";
			};
			name = Profile;
		};
		338D0CE9231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
			};
			name = Profile;
		};
		338D0CEA231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/DebugProfile.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_VERSION = 5.0;
			};
			name = Profile;
		};
		338D0CEB231458BD00FA5F75 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Manual;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Profile;
		};
		33CC10F92044A3C60003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = macosx;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		33CC10FA2044A3C60003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++14";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CODE_SIGN_IDENTITY = "-";
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
			};
			name = Release;
		};
		33CC10FC2044A3C60003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/DebugProfile.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		33CC10FD2044A3C60003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 33E5194F232828860026EE4D /* AppInfo.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = Runner/Release.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				PROVISIONING_PROFILE_SPECIFIER = "";
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
		33CC111C2044C6BA0003C045 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Manual;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Debug;
		};
		33CC111D2044C6BA0003C045 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				PRODUCT_NAME = "$(TARGET_NAME)";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C80DE294CF71000263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C80DB294CF71000263BE5 /* Debug */,
				331C80DC294CF71000263BE5 /* Release */,
				331C80DD294CF71000263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC10E82044A3C60003C045 /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC10F92044A3C60003C045 /* Debug */,
				33CC10FA2044A3C60003C045 /* Release */,
				338D0CE9231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC10FB2044A3C60003C045 /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC10FC2044A3C60003C045 /* Debug */,
				33CC10FD2044A3C60003C045 /* Release */,
				338D0CEA231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		33CC111B2044C6BA0003C045 /* Build configuration list for PBXAggregateTarget "Flutter Assemble" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				33CC111C2044C6BA0003C045 /* Debug */,
				33CC111D2044C6BA0003C045 /* Release */,
				338D0CEB231458BD00FA5F75 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 33CC10E52044A3C60003C045 /* Project object */;
}
</file>

<file path="macos/Runner.xcworkspace/contents.xcworkspacedata">
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:Runner.xcodeproj">
   </FileRef>
   <FileRef
      location = "group:Pods/Pods.xcodeproj">
   </FileRef>
</Workspace>
</file>

<file path="test/core/routing/app_router_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:go_router/go_router.dart';
import 'package:n06/core/routing/app_router.dart' show appRouter;

void main() {
  group('GoRouter Navigation Tests', () {
    test('TC-GR-01: should start at login route', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasLoginRoute = namedRoutes.containsKey('login');

      // Assert
      expect(
        hasLoginRoute,
        isTrue,
        reason: 'Initial route should be /login',
      );
    });

    test('TC-GR-02: should have /settings route available', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasSettingsRoute = namedRoutes.containsKey('settings');

      // Assert
      expect(
        hasSettingsRoute,
        isTrue,
        reason: 'Should be able to navigate to /settings',
      );
    });

    test('TC-GR-03: should have /profile/edit route available', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasProfileRoute = namedRoutes.containsKey('profile_edit');

      // Assert
      expect(
        hasProfileRoute,
        isTrue,
        reason: 'Should be able to navigate to /profile/edit',
      );
    });

    test('TC-GR-04: should have /dose-plan/edit route available', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasDosePlanRoute = namedRoutes.containsKey('dose_plan_edit');

      // Assert
      expect(
        hasDosePlanRoute,
        isTrue,
        reason: 'Should be able to navigate to /dose-plan/edit',
      );
    });

    test('TC-GR-05: should have /weekly-goal/edit route available', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasWeeklyGoalRoute = namedRoutes.containsKey('weekly_goal_edit');

      // Assert
      expect(
        hasWeeklyGoalRoute,
        isTrue,
        reason: 'Should be able to navigate to /weekly-goal/edit',
      );
    });

    test('TC-GR-06: should have /notification/settings route available', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasNotificationRoute = namedRoutes.containsKey('notification_settings');

      // Assert
      expect(
        hasNotificationRoute,
        isTrue,
        reason: 'Should be able to navigate to /notification/settings',
      );
    });

    test('TC-GR-07: should have /emergency/check route available', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasEmergencyRoute = namedRoutes.containsKey('emergency_check');

      // Assert
      expect(
        hasEmergencyRoute,
        isTrue,
        reason: 'Should be able to navigate to /emergency/check',
      );
    });

    test('TC-GR-08: should have /tracking/weight route available', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasWeightRoute = namedRoutes.containsKey('weight_record');

      // Assert
      expect(
        hasWeightRoute,
        isTrue,
        reason: 'Should be able to navigate to /tracking/weight',
      );
    });

    test('TC-GR-09: should have /tracking/symptom route available', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasSymptomRoute = namedRoutes.containsKey('symptom_record');

      // Assert
      expect(
        hasSymptomRoute,
        isTrue,
        reason: 'Should be able to navigate to /tracking/symptom',
      );
    });

    test('TC-GR-10: should have /coping-guide route available', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasCopingGuideRoute = namedRoutes.containsKey('coping_guide');

      // Assert
      expect(
        hasCopingGuideRoute,
        isTrue,
        reason: 'Should be able to navigate to /coping-guide',
      );
    });

    test('TC-GR-11: should have /data-sharing route available', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasDataSharingRoute = namedRoutes.containsKey('data_sharing');

      // Assert
      expect(
        hasDataSharingRoute,
        isTrue,
        reason: 'Should be able to navigate to /data-sharing',
      );
    });

    test('TC-GR-12: should have /home route available', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasHomeRoute = namedRoutes.containsKey('home');

      // Assert
      expect(
        hasHomeRoute,
        isTrue,
        reason: 'Should have /home route available',
      );
    });

    test('TC-GR-13: should have all expected routes configured', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);
      final expectedRoutes = [
        'login',
        'settings',
        'profile_edit',
        'dose_plan_edit',
        'weekly_goal_edit',
        'notification_settings',
        'emergency_check',
        'weight_record',
        'symptom_record',
        'coping_guide',
        'data_sharing',
        'home',
        'onboarding',
      ];

      // Act
      final missingRoutes = expectedRoutes
          .where((route) => !namedRoutes.containsKey(route))
          .toList();

      // Assert
      expect(
        missingRoutes,
        isEmpty,
        reason: 'All expected routes should be configured',
      );
    });
  });

  group('GoRouter Route Configuration Tests', () {
    test('should have login route defined', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasLoginRoute = namedRoutes.containsKey('login');

      // Assert
      expect(hasLoginRoute, isTrue, reason: 'Login route should be defined');
    });

    test('should have settings route defined', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasSettingsRoute = namedRoutes.containsKey('settings');

      // Assert
      expect(hasSettingsRoute, isTrue, reason: 'Settings route should be defined');
    });

    test('should have profile edit route defined', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasProfileRoute = namedRoutes.containsKey('profile_edit');

      // Assert
      expect(hasProfileRoute, isTrue, reason: 'Profile edit route should be defined');
    });

    test('should have dose plan edit route defined', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasDosePlanRoute = namedRoutes.containsKey('dose_plan_edit');

      // Assert
      expect(hasDosePlanRoute, isTrue, reason: 'Dose plan edit route should be defined');
    });

    test('should have weekly goal edit route defined', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasWeeklyGoalRoute = namedRoutes.containsKey('weekly_goal_edit');

      // Assert
      expect(hasWeeklyGoalRoute, isTrue, reason: 'Weekly goal edit route should be defined');
    });

    test('should have notification settings route defined', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasNotificationRoute = namedRoutes.containsKey('notification_settings');

      // Assert
      expect(hasNotificationRoute, isTrue, reason: 'Notification settings route should be defined');
    });

    test('should have emergency check route defined', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasEmergencyRoute = namedRoutes.containsKey('emergency_check');

      // Assert
      expect(hasEmergencyRoute, isTrue, reason: 'Emergency check route should be defined');
    });

    test('should have weight record route defined', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasWeightRoute = namedRoutes.containsKey('weight_record');

      // Assert
      expect(hasWeightRoute, isTrue, reason: 'Weight record route should be defined');
    });

    test('should have symptom record route defined', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasSymptomRoute = namedRoutes.containsKey('symptom_record');

      // Assert
      expect(hasSymptomRoute, isTrue, reason: 'Symptom record route should be defined');
    });

    test('should have coping guide route defined', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasCopingGuideRoute = namedRoutes.containsKey('coping_guide');

      // Assert
      expect(hasCopingGuideRoute, isTrue, reason: 'Coping guide route should be defined');
    });

    test('should have data sharing route defined', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasDataSharingRoute = namedRoutes.containsKey('data_sharing');

      // Assert
      expect(hasDataSharingRoute, isTrue, reason: 'Data sharing route should be defined');
    });

    test('should have home route defined', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasHomeRoute = namedRoutes.containsKey('home');

      // Assert
      expect(hasHomeRoute, isTrue, reason: 'Home route should be defined');
    });

    test('should have onboarding route defined', () {
      // Arrange
      final router = appRouter;
      final namedRoutes = _extractNamedRoutes(router);

      // Act
      final hasOnboardingRoute = namedRoutes.containsKey('onboarding');

      // Assert
      expect(hasOnboardingRoute, isTrue, reason: 'Onboarding route should be defined');
    });
  });
}

/// Helper function to extract named routes from GoRouter configuration
Map<String, String> _extractNamedRoutes(GoRouter router) {
  final routes = <String, String>{};
  for (final route in router.configuration.routes) {
    if (route is GoRoute && route.name != null) {
      routes[route.name!] = route.path;
    }
  }
  return routes;
}
</file>

<file path="test/features/dashboard/domain/entities/dashboard_data_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/dashboard/domain/entities/dashboard_data.dart';
import 'package:n06/features/dashboard/domain/entities/weekly_progress.dart';
import 'package:n06/features/dashboard/domain/entities/next_schedule.dart';
import 'package:n06/features/dashboard/domain/entities/weekly_summary.dart';

void main() {
  group('DashboardData', () {
    final weeklyProgress = WeeklyProgress(
      doseCompletedCount: 3,
      doseTargetCount: 3,
      doseRate: 1.0,
      weightRecordCount: 3,
      weightTargetCount: 7,
      weightRate: 0.43,
      symptomRecordCount: 2,
      symptomTargetCount: 7,
      symptomRate: 0.29,
    );

    final nextSchedule = NextSchedule(
      nextDoseDate: DateTime(2024, 11, 9),
      nextDoseMg: 0.5,
      nextEscalationDate: DateTime(2024, 11, 23),
      goalEstimateDate: DateTime(2024, 12, 20),
    );

    final weeklySummary = WeeklySummary(
      doseCompletedCount: 3,
      weightChangeKg: -1.2,
      symptomRecordCount: 2,
      adherencePercentage: 100.0,
    );

    final dashboardData = DashboardData(
      userName: 'John Doe',
      continuousRecordDays: 5,
      currentWeek: 2,
      weeklyProgress: weeklyProgress,
      nextSchedule: nextSchedule,
      weeklySummary: weeklySummary,
      badges: [],
      timeline: [],
      insightMessage: '현재 추세라면 2개월 내 목표 달성 가능해요',
    );

    test('should create valid DashboardData instance', () {
      expect(dashboardData.userName, 'John Doe');
      expect(dashboardData.continuousRecordDays, 5);
      expect(dashboardData.currentWeek, 2);
      expect(dashboardData.weeklyProgress, weeklyProgress);
      expect(dashboardData.nextSchedule, nextSchedule);
      expect(dashboardData.weeklySummary, weeklySummary);
      expect(dashboardData.badges, []);
      expect(dashboardData.timeline, []);
      expect(dashboardData.insightMessage, '현재 추세라면 2개월 내 목표 달성 가능해요');
    });

    test('should support equality comparison', () {
      final dashboardData2 = DashboardData(
        userName: 'John Doe',
        continuousRecordDays: 5,
        currentWeek: 2,
        weeklyProgress: weeklyProgress,
        nextSchedule: nextSchedule,
        weeklySummary: weeklySummary,
        badges: [],
        timeline: [],
        insightMessage: '현재 추세라면 2개월 내 목표 달성 가능해요',
      );

      expect(dashboardData, dashboardData2);
    });

    test('should support inequality comparison', () {
      final dashboardData2 = DashboardData(
        userName: 'Jane Doe',
        continuousRecordDays: 5,
        currentWeek: 2,
        weeklyProgress: weeklyProgress,
        nextSchedule: nextSchedule,
        weeklySummary: weeklySummary,
        badges: [],
        timeline: [],
        insightMessage: null,
      );

      expect(dashboardData, isNot(dashboardData2));
    });

    test('should copyWith correctly', () {
      final copied = dashboardData.copyWith(
        userName: 'Jane Doe',
        continuousRecordDays: 10,
      );

      expect(copied.userName, 'Jane Doe');
      expect(copied.continuousRecordDays, 10);
      expect(copied.currentWeek, 2);
      expect(copied.weeklyProgress, weeklyProgress);
    });
  });
}
</file>

<file path="test/features/data_sharing/infrastructure/repositories/isar_shared_data_repository_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';
import 'package:n06/features/data_sharing/domain/repositories/date_range.dart';
import 'package:n06/features/data_sharing/infrastructure/repositories/isar_shared_data_repository.dart';
import 'package:n06/features/tracking/infrastructure/dtos/dose_record_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/dose_schedule_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/weight_log_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/symptom_log_dto.dart';

void main() {
  group('IsarSharedDataRepository', () {
    late Isar isar;
    late IsarSharedDataRepository repository;
    final userId = 'test-user-123';
    final now = DateTime.now();

    setUp(() async {
      final tempDir = await getTemporaryDirectory();
      isar = await Isar.open(
        [
          DoseRecordDtoSchema,
          DoseScheduleDtoSchema,
          WeightLogDtoSchema,
          SymptomLogDtoSchema,
        ],
        directory: tempDir.path,
        inspector: true,
      );
      repository = IsarSharedDataRepository(isar);
    });

    tearDown(() async {
      await isar.close(deleteFromDisk: true);
    });

    test('should fetch dose records within date range', () async {
      // Arrange
      final startDate = DateTime(now.year, now.month, 1);
      final endDate = DateTime(now.year, now.month + 1, 0);

      await isar.writeTxn(() async {
        await isar.doseRecordDtos.putAll([
          DoseRecordDto()
            ..dosagePlanId = 'plan1'
            ..administeredAt = startDate.add(const Duration(days: 5))
            ..actualDoseMg = 0.25
            ..isCompleted = true,
          DoseRecordDto()
            ..dosagePlanId = 'plan1'
            ..administeredAt = endDate.add(const Duration(days: 10)) // Outside range
            ..actualDoseMg = 0.25
            ..isCompleted = true,
        ]);
      });

      // Act
      final report = await repository.getReportData(userId, DateRange.lastMonth);

      // Assert
      expect(report.doseRecords.length, 1);
      expect(report.doseRecords.first.id, '1');
    });

    test('should fetch weight logs within date range', () async {
      // Arrange
      final startDate = DateTime(now.year, now.month, 1);

      await isar.writeTxn(() async {
        await isar.weightLogDtos.putAll([
          WeightLogDto()
            ..userId = userId
            ..logDate = startDate.add(const Duration(days: 5))
            ..weightKg = 75.5,
          WeightLogDto()
            ..userId = userId
            ..logDate = startDate.subtract(const Duration(days: 40)) // Outside 30-day range
            ..weightKg = 76.0,
        ]);
      });

      // Act
      final report = await repository.getReportData(userId, DateRange.lastMonth);

      // Assert
      expect(report.weightLogs.length, 1);
      expect(report.weightLogs.first.weightKg, 75.5);
    });

    test('should fetch symptom logs within date range', () async {
      // Arrange
      final startDate = DateTime(now.year, now.month, 1);

      await isar.writeTxn(() async {
        await isar.symptomLogDtos.putAll([
          SymptomLogDto()
            ..userId = userId
            ..logDate = startDate.add(const Duration(days: 5))
            ..symptomName = '메스꺼움'
            ..severity = 5,
          SymptomLogDto()
            ..userId = userId
            ..logDate = startDate.subtract(const Duration(days: 40))
            ..symptomName = '두통'
            ..severity = 3,
        ]);
      });

      // Act
      final report = await repository.getReportData(userId, DateRange.lastMonth);

      // Assert
      expect(report.symptomLogs.length, 1);
      expect(report.symptomLogs.first.symptomName, '메스꺼움');
    });

    test('should return empty report when no data exists', () async {
      // Act
      final report = await repository.getReportData(userId, DateRange.lastMonth);

      // Assert
      expect(report.doseRecords, isEmpty);
      expect(report.weightLogs, isEmpty);
      expect(report.symptomLogs, isEmpty);
      expect(report.emergencyChecks, isEmpty);
    });

    test('should handle partial data correctly', () async {
      // Arrange - Only add dose records, no weight/symptom logs
      final startDate = DateTime(now.year, now.month, 1);

      await isar.writeTxn(() async {
        await isar.doseRecordDtos.put(
          DoseRecordDto()
            ..dosagePlanId = 'plan1'
            ..administeredAt = startDate.add(const Duration(days: 5))
            ..actualDoseMg = 0.25
            ..isCompleted = true,
        );
      });

      // Act
      final report = await repository.getReportData(userId, DateRange.lastMonth);

      // Assert
      expect(report.doseRecords.length, 1);
      expect(report.weightLogs, isEmpty);
      expect(report.symptomLogs, isEmpty);
    });

    test('should fetch dose schedules for adherence calculation', () async {
      // Arrange
      final startDate = DateTime(now.year, now.month, 1);

      await isar.writeTxn(() async {
        await isar.doseScheduleDtos.putAll([
          DoseScheduleDto()
            ..dosagePlanId = 'plan1'
            ..scheduledDate = startDate.add(const Duration(days: 0))
            ..scheduledDoseMg = 0.25,
          DoseScheduleDto()
            ..dosagePlanId = 'plan1'
            ..scheduledDate = startDate.add(const Duration(days: 7))
            ..scheduledDoseMg = 0.25,
        ]);
      });

      // Act
      final report = await repository.getReportData(userId, DateRange.lastMonth);

      // Assert
      expect(report.doseSchedules.length, 2);
    });

    test('should handle allTime date range correctly', () async {
      // Arrange - Add records from different months
      await isar.writeTxn(() async {
        await isar.doseRecordDtos.putAll([
          DoseRecordDto()
            ..dosagePlanId = 'plan1'
            ..administeredAt = DateTime(2024, 1, 15)
            ..actualDoseMg = 0.25
            ..isCompleted = true,
          DoseRecordDto()
            ..dosagePlanId = 'plan1'
            ..administeredAt = DateTime(2024, 6, 15)
            ..actualDoseMg = 0.5
            ..isCompleted = true,
          DoseRecordDto()
            ..dosagePlanId = 'plan1'
            ..administeredAt = DateTime(2024, 12, 15)
            ..actualDoseMg = 1.0
            ..isCompleted = true,
        ]);
      });

      // Act
      final report = await repository.getReportData(userId, DateRange.allTime);

      // Assert
      expect(report.doseRecords.length, 3);
    });

    test('should filter by correct user', () async {
      // Arrange - Add records for different users
      final otherUserId = 'other-user-456';
      final startDate = DateTime(now.year, now.month, 1);

      await isar.writeTxn(() async {
        await isar.weightLogDtos.putAll([
          WeightLogDto()
            ..userId = userId
            ..logDate = startDate.add(const Duration(days: 5))
            ..weightKg = 75.5,
          WeightLogDto()
            ..userId = otherUserId
            ..logDate = startDate.add(const Duration(days: 5))
            ..weightKg = 80.0,
        ]);
      });

      // Act
      final report = await repository.getReportData(userId, DateRange.lastMonth);

      // Assert
      expect(report.weightLogs.length, 1);
      expect(report.weightLogs.first.weightKg, 75.5);
    });
  });
}
</file>

<file path="test/features/notification/application/notifiers/notification_notifier_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:n06/features/notification/application/notifiers/notification_notifier.dart';
import 'package:n06/features/notification/domain/entities/notification_settings.dart';
import 'package:n06/features/notification/domain/repositories/notification_repository.dart';
import 'package:n06/features/notification/domain/services/notification_scheduler.dart';
import 'package:n06/features/tracking/application/providers.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';
import 'package:n06/features/tracking/domain/repositories/medication_repository.dart';

// Type-safe matchers for null safety
T anyOfType<T>() => any as T;
T anyNamedOfType<T>(String name) => anyNamed(name) as T;

class MockNotificationRepository extends Mock
    implements NotificationRepository {}

class MockNotificationScheduler extends Mock implements NotificationScheduler {}

class MockMedicationRepository extends Mock implements MedicationRepository {}

void main() {
  group('NotificationNotifier', () {
    late MockNotificationRepository mockRepository;
    late MockNotificationScheduler mockScheduler;
    late MockMedicationRepository mockMedicationRepository;

    setUp(() {
      mockRepository = MockNotificationRepository();
      mockScheduler = MockNotificationScheduler();
      mockMedicationRepository = MockMedicationRepository();
    });

    test('should initialize with loading state', () {
      // Arrange
      when(mockRepository.getNotificationSettings('user123'))
          .thenAnswer((_) async => null);

      final container = ProviderContainer(
        overrides: [
          notificationRepositoryProvider
              .overrideWithValue(mockRepository),
          notificationSchedulerProvider
              .overrideWithValue(mockScheduler),
          medicationRepositoryProvider
              .overrideWithValue(mockMedicationRepository),
        ],
      );

      // Act & Assert
      expect(
        container.read(notificationNotifierProvider),
        isA<AsyncLoading<NotificationSettings>>(),
      );
    });

    test('should load notification settings on build', () async {
      // Arrange
      final mockSettings = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );
      when(mockRepository.getNotificationSettings('user123'))
          .thenAnswer((_) async => mockSettings);

      final container = ProviderContainer(
        overrides: [
          notificationRepositoryProvider
              .overrideWithValue(mockRepository),
          notificationSchedulerProvider
              .overrideWithValue(mockScheduler),
          medicationRepositoryProvider
              .overrideWithValue(mockMedicationRepository),
        ],
      );

      // Act
      await container.read(notificationNotifierProvider.future);

      // Assert
      final state = container.read(notificationNotifierProvider);
      expect(state.value, mockSettings);
    });

    test('should return default settings when none exist', () async {
      // Arrange
      when(mockRepository.getNotificationSettings('user123'))
          .thenAnswer((_) async => null);

      final container = ProviderContainer(
        overrides: [
          notificationRepositoryProvider
              .overrideWithValue(mockRepository),
          notificationSchedulerProvider
              .overrideWithValue(mockScheduler),
          medicationRepositoryProvider
              .overrideWithValue(mockMedicationRepository),
        ],
      );

      // Act
      await container.read(notificationNotifierProvider.future);

      // Assert
      final state = container.read(notificationNotifierProvider);
      expect(state.value!.notificationTime.hour, 9);
      expect(state.value!.notificationEnabled, true);
    });

    test('should update notification time and reschedule', () async {
      // Arrange
      final mockSettings = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );
      final doseSchedule = DoseSchedule(
        id: 'schedule1',
        dosagePlanId: 'plan1',
        scheduledDate: DateTime.now().add(const Duration(days: 1)),
        scheduledDoseMg: 0.5,
      );

      when(mockRepository.getNotificationSettings('user123'))
          .thenAnswer((_) async => mockSettings);
      when(mockRepository.saveNotificationSettings(anyOfType<NotificationSettings>()))
          .thenAnswer((_) async => {});
      when(mockScheduler.cancelAllNotifications())
          .thenAnswer((_) async => {});
      when(mockScheduler.scheduleNotifications(
        doseSchedules: anyNamedOfType<List<DoseSchedule>>('doseSchedules'),
        notificationTime: anyNamedOfType<TimeOfDay>('notificationTime'),
      )).thenAnswer((_) async => {});
      when(mockMedicationRepository.getDoseSchedules(anyOfType<String>()))
          .thenAnswer((_) async => [doseSchedule]);

      final container = ProviderContainer(
        overrides: [
          notificationRepositoryProvider
              .overrideWithValue(mockRepository),
          notificationSchedulerProvider
              .overrideWithValue(mockScheduler),
          medicationRepositoryProvider
              .overrideWithValue(mockMedicationRepository),
        ],
      );

      // Act
      final notifier =
          container.read(notificationNotifierProvider.notifier);
      await notifier.updateNotificationTime(
        const TimeOfDay(hour: 21, minute: 0),
      );

      // Assert
      verify(mockRepository.saveNotificationSettings(anyOfType<NotificationSettings>())).called(1);
      verify(mockScheduler.cancelAllNotifications()).called(1);
      verify(mockScheduler.scheduleNotifications(
        doseSchedules: anyNamedOfType<List<DoseSchedule>>('doseSchedules'),
        notificationTime: anyNamedOfType<TimeOfDay>('notificationTime'),
      )).called(1);
    });

    test('should toggle notification enabled with permission check', () async {
      // Arrange
      final mockSettings = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );
      final doseSchedule = DoseSchedule(
        id: 'schedule1',
        dosagePlanId: 'plan1',
        scheduledDate: DateTime.now().add(const Duration(days: 1)),
        scheduledDoseMg: 0.5,
      );

      when(mockRepository.getNotificationSettings('user123'))
          .thenAnswer((_) async => mockSettings);
      when(mockScheduler.checkPermission())
          .thenAnswer((_) async => true);
      when(mockRepository.saveNotificationSettings(anyOfType<NotificationSettings>()))
          .thenAnswer((_) async => {});
      when(mockScheduler.cancelAllNotifications())
          .thenAnswer((_) async => {});
      when(mockScheduler.scheduleNotifications(
        doseSchedules: anyNamedOfType<List<DoseSchedule>>('doseSchedules'),
        notificationTime: anyNamedOfType<TimeOfDay>('notificationTime'),
      )).thenAnswer((_) async => {});
      when(mockMedicationRepository.getDoseSchedules(anyOfType<String>()))
          .thenAnswer((_) async => [doseSchedule]);

      final container = ProviderContainer(
        overrides: [
          notificationRepositoryProvider
              .overrideWithValue(mockRepository),
          notificationSchedulerProvider
              .overrideWithValue(mockScheduler),
          medicationRepositoryProvider
              .overrideWithValue(mockMedicationRepository),
        ],
      );

      // Act
      final notifier =
          container.read(notificationNotifierProvider.notifier);
      await notifier.toggleNotificationEnabled();

      // Assert
      verify(mockScheduler.checkPermission()).called(1);
      verify(mockRepository.saveNotificationSettings(anyOfType<NotificationSettings>())).called(1);
    });

    test('should request permission when toggling without permission', () async {
      // Arrange
      final mockSettings = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );
      final doseSchedule = DoseSchedule(
        id: 'schedule1',
        dosagePlanId: 'plan1',
        scheduledDate: DateTime.now().add(const Duration(days: 1)),
        scheduledDoseMg: 0.5,
      );

      when(mockRepository.getNotificationSettings('user123'))
          .thenAnswer((_) async => mockSettings);
      when(mockScheduler.checkPermission())
          .thenAnswer((_) async => false);
      when(mockScheduler.requestPermission())
          .thenAnswer((_) async => true);
      when(mockRepository.saveNotificationSettings(anyOfType<NotificationSettings>()))
          .thenAnswer((_) async => {});
      when(mockScheduler.scheduleNotifications(
        doseSchedules: anyNamedOfType<List<DoseSchedule>>('doseSchedules'),
        notificationTime: anyNamedOfType<TimeOfDay>('notificationTime'),
      )).thenAnswer((_) async => {});
      when(mockMedicationRepository.getDoseSchedules(anyOfType<String>()))
          .thenAnswer((_) async => [doseSchedule]);

      final container = ProviderContainer(
        overrides: [
          notificationRepositoryProvider
              .overrideWithValue(mockRepository),
          notificationSchedulerProvider
              .overrideWithValue(mockScheduler),
          medicationRepositoryProvider
              .overrideWithValue(mockMedicationRepository),
        ],
      );

      // Act
      final notifier =
          container.read(notificationNotifierProvider.notifier);
      await notifier.toggleNotificationEnabled();

      // Assert
      verify(mockScheduler.requestPermission()).called(1);
      verify(mockRepository.saveNotificationSettings(anyOfType<NotificationSettings>())).called(1);
    });

    test('should not enable when permission denied', () async {
      // Arrange
      final mockSettings = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );

      when(mockRepository.getNotificationSettings('user123'))
          .thenAnswer((_) async => mockSettings);
      when(mockScheduler.checkPermission())
          .thenAnswer((_) async => false);
      when(mockScheduler.requestPermission())
          .thenAnswer((_) async => false);

      final container = ProviderContainer(
        overrides: [
          notificationRepositoryProvider
              .overrideWithValue(mockRepository),
          notificationSchedulerProvider
              .overrideWithValue(mockScheduler),
          medicationRepositoryProvider
              .overrideWithValue(mockMedicationRepository),
        ],
      );

      // Act
      final notifier =
          container.read(notificationNotifierProvider.notifier);
      await notifier.toggleNotificationEnabled();

      // Assert
      verifyNever(mockRepository.saveNotificationSettings(anyOfType<NotificationSettings>()));
    });

    test('should cancel all notifications when disabling', () async {
      // Arrange
      final mockSettings = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );

      when(mockRepository.getNotificationSettings('user123'))
          .thenAnswer((_) async => mockSettings);
      when(mockScheduler.checkPermission())
          .thenAnswer((_) async => true);
      when(mockRepository.saveNotificationSettings(anyOfType<NotificationSettings>()))
          .thenAnswer((_) async => {});
      when(mockScheduler.cancelAllNotifications())
          .thenAnswer((_) async => {});

      final container = ProviderContainer(
        overrides: [
          notificationRepositoryProvider
              .overrideWithValue(mockRepository),
          notificationSchedulerProvider
              .overrideWithValue(mockScheduler),
          medicationRepositoryProvider
              .overrideWithValue(mockMedicationRepository),
        ],
      );

      // Act
      final notifier =
          container.read(notificationNotifierProvider.notifier);
      await notifier.toggleNotificationEnabled();

      // Assert
      verify(mockScheduler.cancelAllNotifications()).called(1);
    });
  });
}
</file>

<file path="test/features/notification/domain/services/notification_scheduler_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:n06/features/notification/domain/services/notification_scheduler.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';

class MockNotificationScheduler extends Mock implements NotificationScheduler {}

void main() {
  group('NotificationScheduler Interface', () {
    late MockNotificationScheduler mockScheduler;

    setUp(() {
      mockScheduler = MockNotificationScheduler();
    });

    test('should define checkPermission method', () async {
      // Arrange
      when(mockScheduler.checkPermission())
          .thenAnswer((_) async => true);

      // Act
      final hasPermission = await mockScheduler.checkPermission();

      // Assert
      expect(hasPermission, isA<bool>());
      expect(hasPermission, true);
      verify(mockScheduler.checkPermission()).called(1);
    });

    test('should define requestPermission method', () async {
      // Arrange
      when(mockScheduler.requestPermission())
          .thenAnswer((_) async => true);

      // Act
      final granted = await mockScheduler.requestPermission();

      // Assert
      expect(granted, isTrue);
      verify(mockScheduler.requestPermission()).called(1);
    });

    test('should define scheduleNotifications method', () async {
      // Arrange
      final doseSchedule = DoseSchedule(
        id: 'schedule1',
        dosagePlanId: 'plan1',
        scheduledDate: DateTime.now().add(const Duration(days: 1)),
        scheduledDoseMg: 0.5,
      );
      when(mockScheduler.scheduleNotifications(
        doseSchedules: [doseSchedule],
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
      )).thenAnswer((_) async => {});

      // Act
      await mockScheduler.scheduleNotifications(
        doseSchedules: [doseSchedule],
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
      );

      // Assert
      verify(mockScheduler.scheduleNotifications(
        doseSchedules: [doseSchedule],
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
      )).called(1);
    });

    test('should define cancelAllNotifications method', () async {
      // Arrange
      when(mockScheduler.cancelAllNotifications())
          .thenAnswer((_) async => {});

      // Act
      await mockScheduler.cancelAllNotifications();

      // Assert
      verify(mockScheduler.cancelAllNotifications()).called(1);
    });

    test('should return false when permission check fails', () async {
      // Arrange
      when(mockScheduler.checkPermission())
          .thenAnswer((_) async => false);

      // Act
      final hasPermission = await mockScheduler.checkPermission();

      // Assert
      expect(hasPermission, false);
    });

    test('should return false when permission request denied', () async {
      // Arrange
      when(mockScheduler.requestPermission())
          .thenAnswer((_) async => false);

      // Act
      final granted = await mockScheduler.requestPermission();

      // Assert
      expect(granted, false);
    });
  });
}
</file>

<file path="test/features/notification/infrastructure/repositories/isar_notification_repository_test.dart">
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:isar/isar.dart';
import 'package:n06/features/notification/domain/entities/notification_settings.dart';
import 'package:n06/features/notification/infrastructure/dtos/notification_settings_dto.dart';
import 'package:n06/features/notification/infrastructure/repositories/isar_notification_repository.dart';

void main() {
  late Isar testIsar;
  late IsarNotificationRepository repository;

  setUp(() async {
    final tempDir = await getTemporaryDirectory();
    // Isar 테스트 환경 초기화
    testIsar = await Isar.open(
      [NotificationSettingsDtoSchema],
      directory: tempDir.path,
      inspector: false,
    );
    repository = IsarNotificationRepository(testIsar);
  });

  tearDown(() async {
    await testIsar.close(deleteFromDisk: true);
  });

  group('IsarNotificationRepository', () {
    test('should save notification settings to Isar', () async {
      // Arrange
      final settings = NotificationSettings(
        userId: 'user123',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );

      // Act
      await repository.saveNotificationSettings(settings);

      // Assert
      final savedSettings =
          await repository.getNotificationSettings('user123');
      expect(savedSettings, isNotNull);
      expect(savedSettings!.notificationTime.hour, 9);
      expect(savedSettings.notificationEnabled, true);
    });

    test('should return null when settings not found', () async {
      // Arrange & Act
      final settings =
          await repository.getNotificationSettings('nonexistent_user');

      // Assert
      expect(settings, isNull);
    });

    test('should update existing settings', () async {
      // Arrange
      final initial = NotificationSettings(
        userId: 'user456',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );
      await repository.saveNotificationSettings(initial);

      // Act
      final updated = NotificationSettings(
        userId: 'user456',
        notificationTime: const TimeOfDay(hour: 21, minute: 0),
        notificationEnabled: false,
      );
      await repository.saveNotificationSettings(updated);

      // Assert
      final savedSettings =
          await repository.getNotificationSettings('user456');
      expect(savedSettings!.notificationTime.hour, 21);
      expect(savedSettings.notificationEnabled, false);
    });

    test('should preserve existing settings for different users', () async {
      // Arrange
      final settings1 = NotificationSettings(
        userId: 'user789',
        notificationTime: const TimeOfDay(hour: 9, minute: 0),
        notificationEnabled: true,
      );
      final settings2 = NotificationSettings(
        userId: 'user999',
        notificationTime: const TimeOfDay(hour: 14, minute: 30),
        notificationEnabled: false,
      );

      // Act
      await repository.saveNotificationSettings(settings1);
      await repository.saveNotificationSettings(settings2);

      // Assert
      final saved1 = await repository.getNotificationSettings('user789');
      final saved2 = await repository.getNotificationSettings('user999');

      expect(saved1!.notificationTime.hour, 9);
      expect(saved2!.notificationTime.hour, 14);
      expect(saved2.notificationTime.minute, 30);
    });
  });
}
</file>

<file path="test/features/notification/presentation/screens/notification_settings_screen_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/notification/presentation/screens/notification_settings_screen.dart';

void main() {
  group('NotificationSettingsScreen', () {
    testWidgets('should display notification settings components',
        (tester) async {
      // This is a basic smoke test that verifies the screen can be built
      // Full widget tests require proper provider setup which is better done in integration tests
      await tester.pumpWidget(
        const MaterialApp(
          home: NotificationSettingsScreen(),
        ),
      );

      // Allow time for async operations
      await tester.pumpAndSettle();

      // Basic verification that something rendered
      // Full assertions depend on proper mocking of providers
    });
  });
}
</file>

<file path="test/features/profile/infrastructure/repositories/isar_profile_repository_update_weekly_goals_test.dart">
import 'dart:io';

import 'package:flutter_test/flutter_test.dart';
import 'package:isar/isar.dart';
import 'package:n06/features/profile/infrastructure/dtos/user_profile_dto.dart';
import 'package:n06/features/profile/infrastructure/repositories/isar_profile_repository.dart';

void main() {
  group('IsarProfileRepository.updateWeeklyGoals', () {
    late Isar isar;
    late IsarProfileRepository repository;

    setUpAll(() {
      TestWidgetsFlutterBinding.ensureInitialized();
    });

    setUp(() async {
      final dir = Directory.systemTemp.createTempSync('isar_test_profile_');
      isar = await Isar.open(
        [UserProfileDtoSchema],
        directory: dir.path,
        name: 'test_profile_${DateTime.now().millisecondsSinceEpoch}',
      );
      repository = IsarProfileRepository(isar);
    });

    tearDown(() async {
      await isar.close(deleteFromDisk: true);
    });

    test('주간 목표 업데이트 성공', () async {
      // Arrange
      final dto = UserProfileDto()
        ..userId = 'test-user-001'
        ..targetWeightValue = 60.0
        ..currentWeightValue = 70.0
        ..weeklyWeightRecordGoal = 7
        ..weeklySymptomRecordGoal = 7;

      await isar.writeTxn(() async {
        await isar.userProfileDtos.put(dto);
      });

      // Act
      await repository.updateWeeklyGoals('test-user-001', 5, 3);

      // Assert
      final updatedProfile = await repository.getUserProfile('test-user-001');
      expect(updatedProfile.weeklyWeightRecordGoal, equals(5));
      expect(updatedProfile.weeklySymptomRecordGoal, equals(3));
    });

    test('주간 체중 기록 목표 0으로 업데이트', () async {
      // Arrange
      final dto = UserProfileDto()
        ..userId = 'test-user-002'
        ..targetWeightValue = 60.0
        ..currentWeightValue = 70.0
        ..weeklyWeightRecordGoal = 7
        ..weeklySymptomRecordGoal = 7;

      await isar.writeTxn(() async {
        await isar.userProfileDtos.put(dto);
      });

      // Act
      await repository.updateWeeklyGoals('test-user-002', 0, 7);

      // Assert
      final updatedProfile = await repository.getUserProfile('test-user-002');
      expect(updatedProfile.weeklyWeightRecordGoal, equals(0));
      expect(updatedProfile.weeklySymptomRecordGoal, equals(7));
    });

    test('존재하지 않는 사용자 업데이트 시 예외 발생', () async {
      // Act & Assert
      expect(
        () => repository.updateWeeklyGoals('non-existent-user', 5, 3),
        throwsException,
      );
    });

    test('주간 목표만 변경되고 다른 필드는 유지', () async {
      // Arrange
      final originalDto = UserProfileDto()
        ..userId = 'test-user-003'
        ..targetWeightValue = 60.0
        ..currentWeightValue = 70.0
        ..targetPeriodWeeks = 12
        ..weeklyLossGoalKg = 0.83
        ..weeklyWeightRecordGoal = 7
        ..weeklySymptomRecordGoal = 7;

      await isar.writeTxn(() async {
        await isar.userProfileDtos.put(originalDto);
      });

      // Act
      await repository.updateWeeklyGoals('test-user-003', 5, 3);

      // Assert
      final updatedProfile = await repository.getUserProfile('test-user-003');
      expect(updatedProfile.weeklyWeightRecordGoal, equals(5));
      expect(updatedProfile.weeklySymptomRecordGoal, equals(3));
      expect(updatedProfile.targetPeriodWeeks, equals(12));
      expect(updatedProfile.weeklyLossGoalKg, equals(0.83));
    });

    test('여러 번의 업데이트 작업 수행', () async {
      // Arrange
      final dto = UserProfileDto()
        ..userId = 'test-user-004'
        ..targetWeightValue = 60.0
        ..currentWeightValue = 70.0
        ..weeklyWeightRecordGoal = 7
        ..weeklySymptomRecordGoal = 7;

      await isar.writeTxn(() async {
        await isar.userProfileDtos.put(dto);
      });

      // Act - First update
      await repository.updateWeeklyGoals('test-user-004', 5, 3);

      // Assert
      var profile = await repository.getUserProfile('test-user-004');
      expect(profile.weeklyWeightRecordGoal, equals(5));
      expect(profile.weeklySymptomRecordGoal, equals(3));

      // Act - Second update
      await repository.updateWeeklyGoals('test-user-004', 2, 4);

      // Assert
      profile = await repository.getUserProfile('test-user-004');
      expect(profile.weeklyWeightRecordGoal, equals(2));
      expect(profile.weeklySymptomRecordGoal, equals(4));
    });

    test('다른 사용자의 데이터는 영향받지 않음', () async {
      // Arrange
      final dto1 = UserProfileDto()
        ..userId = 'test-user-005'
        ..targetWeightValue = 60.0
        ..currentWeightValue = 70.0
        ..weeklyWeightRecordGoal = 7
        ..weeklySymptomRecordGoal = 7;

      final dto2 = UserProfileDto()
        ..userId = 'test-user-006'
        ..targetWeightValue = 65.0
        ..currentWeightValue = 75.0
        ..weeklyWeightRecordGoal = 7
        ..weeklySymptomRecordGoal = 7;

      await isar.writeTxn(() async {
        await isar.userProfileDtos.put(dto1);
        await isar.userProfileDtos.put(dto2);
      });

      // Act
      await repository.updateWeeklyGoals('test-user-005', 5, 3);

      // Assert
      final profile1 = await repository.getUserProfile('test-user-005');
      final profile2 = await repository.getUserProfile('test-user-006');

      expect(profile1.weeklyWeightRecordGoal, equals(5));
      expect(profile1.weeklySymptomRecordGoal, equals(3));
      expect(profile2.weeklyWeightRecordGoal, equals(7));
      expect(profile2.weeklySymptomRecordGoal, equals(7));
    });
  });
}
</file>

<file path="test/features/tracking/domain/entities/dosage_plan_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';

void main() {
  group('DosagePlan', () {
    group('constructor validation', () {
      test('should create valid dosage plan with required fields', () {
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
        );

        expect(plan.id, 'plan-1');
        expect(plan.userId, 'user-1');
        expect(plan.medicationName, 'Ozempic');
        expect(plan.initialDoseMg, 0.25);
        expect(plan.isActive, true);
        expect(plan.escalationPlan, null);
      });

      test('should throw exception when start date is in future', () {
        expect(
          () => DosagePlan(
            id: 'plan-1',
            userId: 'user-1',
            medicationName: 'Ozempic',
            startDate: DateTime.now().add(Duration(days: 1)),
            cycleDays: 7,
            initialDoseMg: 0.25,
          ),
          throwsArgumentError,
        );
      });

      test('should throw exception when cycle days is less than 1', () {
        expect(
          () => DosagePlan(
            id: 'plan-1',
            userId: 'user-1',
            medicationName: 'Ozempic',
            startDate: DateTime(2025, 1, 1),
            cycleDays: 0,
            initialDoseMg: 0.25,
          ),
          throwsArgumentError,
        );
      });

      test('should throw exception when initial dose is negative', () {
        expect(
          () => DosagePlan(
            id: 'plan-1',
            userId: 'user-1',
            medicationName: 'Ozempic',
            startDate: DateTime(2025, 1, 1),
            cycleDays: 7,
            initialDoseMg: -0.25,
          ),
          throwsArgumentError,
        );
      });

      test(
          'should throw exception when escalation plan has decreasing doses',
          () {
        expect(
          () => DosagePlan(
            id: 'plan-1',
            userId: 'user-1',
            medicationName: 'Ozempic',
            startDate: DateTime(2025, 1, 1),
            cycleDays: 7,
            initialDoseMg: 1.0,
            escalationPlan: [
              EscalationStep(weeksFromStart: 4, doseMg: 0.5), // 감량
              EscalationStep(weeksFromStart: 8, doseMg: 1.5),
            ],
          ),
          throwsArgumentError,
        );
      });

      test(
          'should throw exception when escalation exceeds max dose (2.4mg)',
          () {
        expect(
          () => DosagePlan(
            id: 'plan-1',
            userId: 'user-1',
            medicationName: 'Ozempic',
            startDate: DateTime(2025, 1, 1),
            cycleDays: 7,
            initialDoseMg: 2.0,
            escalationPlan: [
              EscalationStep(weeksFromStart: 4, doseMg: 2.5), // 2.4 초과
            ],
          ),
          throwsArgumentError,
        );
      });

      test(
          'should throw exception when escalation time order is not maintained',
          () {
        expect(
          () => DosagePlan(
            id: 'plan-1',
            userId: 'user-1',
            medicationName: 'Ozempic',
            startDate: DateTime(2025, 1, 1),
            cycleDays: 7,
            initialDoseMg: 0.25,
            escalationPlan: [
              EscalationStep(weeksFromStart: 8, doseMg: 1.0),
              EscalationStep(weeksFromStart: 4, doseMg: 0.5), // 역순
            ],
          ),
          throwsArgumentError,
        );
      });
    });

    group('dose calculation', () {
      test('should return initial dose when no escalation plan exists', () {
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
        );

        expect(plan.getCurrentDose(weeksElapsed: 0), 0.25);
        expect(plan.getCurrentDose(weeksElapsed: 10), 0.25);
      });

      test('should return correct dose during escalation period', () {
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
          escalationPlan: [
            EscalationStep(weeksFromStart: 4, doseMg: 0.5),
            EscalationStep(weeksFromStart: 8, doseMg: 1.0),
          ],
        );

        // Weeks 0-4: 0.25mg (before week 4 completes)
        expect(plan.getCurrentDose(weeksElapsed: 0), 0.25);
        expect(plan.getCurrentDose(weeksElapsed: 3), 0.25);
        expect(plan.getCurrentDose(weeksElapsed: 4), 0.25); // Still initial dose

        // Weeks 5-7: 0.5mg (after week 4 completes)
        expect(plan.getCurrentDose(weeksElapsed: 5), 0.5);
        expect(plan.getCurrentDose(weeksElapsed: 7), 0.5);

        // Weeks 8+: 1.0mg (after week 8 completes)
        expect(plan.getCurrentDose(weeksElapsed: 8), 0.5); // Still 0.5mg at week 8
        expect(plan.getCurrentDose(weeksElapsed: 9), 1.0); // Escalate to 1.0mg after week 8
        expect(plan.getCurrentDose(weeksElapsed: 12), 1.0);
      });

      test('should return max dose after escalation completes', () {
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
          escalationPlan: [
            EscalationStep(weeksFromStart: 4, doseMg: 0.5),
            EscalationStep(weeksFromStart: 8, doseMg: 1.0),
            EscalationStep(weeksFromStart: 12, doseMg: 2.4),
          ],
        );

        expect(plan.getCurrentDose(weeksElapsed: 20), 2.4);
      });
    });

    group('state checking', () {
      test('should detect if plan is active', () {
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
          isActive: true,
        );

        expect(plan.isActive, true);
      });

      test('should detect if plan is inactive', () {
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
          isActive: false,
        );

        expect(plan.isActive, false);
      });
    });

    group('copyWith', () {
      test('should copy plan with updated fields', () {
        final original = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
        );

        final updated = original.copyWith(
          medicationName: 'Saxenda',
          cycleDays: 14,
        );

        expect(updated.id, original.id);
        expect(updated.medicationName, 'Saxenda');
        expect(updated.cycleDays, 14);
        expect(updated.initialDoseMg, original.initialDoseMg);
      });
    });
  });
}
</file>

<file path="test/features/tracking/domain/usecases/injection_site_rotation_usecase_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';
import 'package:n06/features/tracking/domain/usecases/injection_site_rotation_usecase.dart';

void main() {
  group('InjectionSiteRotationUseCase', () {
    late InjectionSiteRotationUseCase useCase;

    setUp(() {
      useCase = InjectionSiteRotationUseCase();
    });

    group('rotation checking', () {
      test('should return no warning when no recent records', () {
        final result = useCase.checkRotation('abdomen', []);

        expect(result.needsWarning, false);
        expect(result.message, isEmpty);
      });

      test('should return warning when same site used within 7 days', () {
        final now = DateTime.now();
        final recentRecord = DoseRecord(
          id: 'record-1',
          dosagePlanId: 'plan-1',
          administeredAt: now.subtract(Duration(days: 3)),
          actualDoseMg: 0.25,
          injectionSite: 'abdomen',
        );

        final result = useCase.checkRotation('abdomen', [recentRecord]);

        expect(result.needsWarning, true);
        expect(result.message.contains('3'), true);
        expect(result.daysSinceLastUse, 3);
      });

      test('should return no warning when same site used 8 days ago', () {
        final now = DateTime.now();
        final recentRecord = DoseRecord(
          id: 'record-1',
          dosagePlanId: 'plan-1',
          administeredAt: now.subtract(Duration(days: 8)),
          actualDoseMg: 0.25,
          injectionSite: 'abdomen',
        );

        final result = useCase.checkRotation('abdomen', [recentRecord]);

        expect(result.needsWarning, false);
      });

      test('should return no warning when different site used recently', () {
        final now = DateTime.now();
        final recentRecord = DoseRecord(
          id: 'record-1',
          dosagePlanId: 'plan-1',
          administeredAt: now.subtract(Duration(days: 2)),
          actualDoseMg: 0.25,
          injectionSite: 'abdomen',
        );

        final result = useCase.checkRotation('thigh', [recentRecord]);

        expect(result.needsWarning, false);
      });

      test('should handle multiple recent records of same site', () {
        final now = DateTime.now();
        final records = [
          DoseRecord(
            id: 'record-1',
            dosagePlanId: 'plan-1',
            administeredAt: now.subtract(Duration(days: 2)),
            actualDoseMg: 0.25,
            injectionSite: 'arm',
          ),
          DoseRecord(
            id: 'record-2',
            dosagePlanId: 'plan-1',
            administeredAt: now.subtract(Duration(days: 5)),
            actualDoseMg: 0.25,
            injectionSite: 'arm',
          ),
        ];

        final result = useCase.checkRotation('arm', records);

        expect(result.needsWarning, true);
        expect(result.daysSinceLastUse, 2); // Most recent
      });
    });

    group('site history visualization', () {
      test('should visualize site usage for last 30 days', () {
        final now = DateTime.now();
        final records = [
          DoseRecord(
            id: 'record-1',
            dosagePlanId: 'plan-1',
            administeredAt: now.subtract(Duration(days: 1)),
            actualDoseMg: 0.25,
            injectionSite: 'abdomen',
          ),
          DoseRecord(
            id: 'record-2',
            dosagePlanId: 'plan-1',
            administeredAt: now.subtract(Duration(days: 8)),
            actualDoseMg: 0.25,
            injectionSite: 'thigh',
          ),
          DoseRecord(
            id: 'record-3',
            dosagePlanId: 'plan-1',
            administeredAt: now.subtract(Duration(days: 15)),
            actualDoseMg: 0.25,
            injectionSite: 'arm',
          ),
          DoseRecord(
            id: 'record-4',
            dosagePlanId: 'plan-1',
            administeredAt: now.subtract(Duration(days: 35)), // Older than 30 days
            actualDoseMg: 0.25,
            injectionSite: 'abdomen',
          ),
        ];

        final siteHistory = useCase.getSiteHistoryList(records);

        expect(siteHistory.length, 3); // Only last 30 days
        expect(siteHistory.contains('abdomen'), true);
        expect(siteHistory.contains('thigh'), true);
        expect(siteHistory.contains('arm'), true);
      });
    });
  });
}
</file>

<file path="test/features/tracking/domain/usecases/missed_dose_analyzer_usecase_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';
import 'package:n06/features/tracking/domain/usecases/missed_dose_analyzer_usecase.dart';

void main() {
  group('MissedDoseAnalyzerUseCase', () {
    late MissedDoseAnalyzerUseCase useCase;

    setUp(() {
      useCase = MissedDoseAnalyzerUseCase();
    });

    test('should return no missed doses when all completed', () {
      final now = DateTime.now();
      final schedules = [
        DoseSchedule(
          id: 'schedule-1',
          dosagePlanId: 'plan-1',
          scheduledDate: now.subtract(Duration(days: 7)),
          scheduledDoseMg: 0.25,
        ),
        DoseSchedule(
          id: 'schedule-2',
          dosagePlanId: 'plan-1',
          scheduledDate: now.subtract(Duration(days: 1)),
          scheduledDoseMg: 0.25,
        ),
      ];

      final records = [
        DoseRecord(
          id: 'record-1',
          doseScheduleId: 'schedule-1',
          dosagePlanId: 'plan-1',
          administeredAt: now.subtract(Duration(days: 7)),
          actualDoseMg: 0.25,
        ),
        DoseRecord(
          id: 'record-2',
          doseScheduleId: 'schedule-2',
          dosagePlanId: 'plan-1',
          administeredAt: now.subtract(Duration(days: 1)),
          actualDoseMg: 0.25,
        ),
      ];

      final result = useCase.analyzeMissedDoses(schedules, records);

      expect(result.missedDoses.isEmpty, true);
    });

    test('should detect missed dose within 5 days', () {
      final now = DateTime.now();
      final schedules = [
        DoseSchedule(
          id: 'schedule-1',
          dosagePlanId: 'plan-1',
          scheduledDate: now.subtract(Duration(days: 3)),
          scheduledDoseMg: 0.25,
        ),
      ];

      final result = useCase.analyzeMissedDoses(schedules, []);

      expect(result.missedDoses.length, 1);
      expect(result.guidanceType, GuidanceType.immediateAdministration);
    });

    test('should detect missed dose over 5 days', () {
      final now = DateTime.now();
      final schedules = [
        DoseSchedule(
          id: 'schedule-1',
          dosagePlanId: 'plan-1',
          scheduledDate: now.subtract(Duration(days: 6)),
          scheduledDoseMg: 0.25,
        ),
      ];

      final result = useCase.analyzeMissedDoses(schedules, []);

      expect(result.missedDoses.length, 1);
      expect(result.guidanceType, GuidanceType.waitForNext);
    });

    test('should recommend expert consultation for 7+ days missed', () {
      final now = DateTime.now();
      final schedules = [
        DoseSchedule(
          id: 'schedule-1',
          dosagePlanId: 'plan-1',
          scheduledDate: now.subtract(Duration(days: 10)),
          scheduledDoseMg: 0.25,
        ),
      ];

      final result = useCase.analyzeMissedDoses(schedules, []);

      expect(result.missedDoses.length, 1);
      expect(result.requiresExpertConsultation, true);
    });

    test('should handle multiple missed doses', () {
      final now = DateTime.now();
      final schedules = [
        DoseSchedule(
          id: 'schedule-1',
          dosagePlanId: 'plan-1',
          scheduledDate: now.subtract(Duration(days: 2)),
          scheduledDoseMg: 0.25,
        ),
        DoseSchedule(
          id: 'schedule-2',
          dosagePlanId: 'plan-1',
          scheduledDate: now.subtract(Duration(days: 6)),
          scheduledDoseMg: 0.25,
        ),
        DoseSchedule(
          id: 'schedule-3',
          dosagePlanId: 'plan-1',
          scheduledDate: now.subtract(Duration(days: 11)),
          scheduledDoseMg: 0.25,
        ),
      ];

      final result = useCase.analyzeMissedDoses(schedules, []);

      expect(result.missedDoses.length, 3);
      expect(result.requiresExpertConsultation, true);
    });

    test('should calculate days elapsed for each missed dose', () {
      final now = DateTime.now();
      final schedules = [
        DoseSchedule(
          id: 'schedule-1',
          dosagePlanId: 'plan-1',
          scheduledDate: now.subtract(Duration(days: 5)),
          scheduledDoseMg: 0.25,
        ),
      ];

      final result = useCase.analyzeMissedDoses(schedules, []);

      expect(result.missedDoses[0].daysElapsed, 5);
    });
  });
}
</file>

<file path="test/features/tracking/domain/usecases/schedule_generator_usecase_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';
import 'package:n06/features/tracking/domain/usecases/schedule_generator_usecase.dart';

void main() {
  group('ScheduleGeneratorUseCase', () {
    late ScheduleGeneratorUseCase useCase;

    setUp(() {
      useCase = ScheduleGeneratorUseCase();
    });

    group('simple schedule generation', () {
      test('should generate schedule for simple plan without escalation', () {
        final startDate = DateTime(2025, 1, 1);
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: startDate,
          cycleDays: 7,
          initialDoseMg: 0.25,
        );

        final endDate = DateTime(2025, 1, 29); // 4 weeks

        final schedules = useCase.generateSchedules(
          plan,
          endDate,
          notificationTime: TimeOfDay(hour: 9, minute: 0),
        );

        expect(schedules.length, 4);
        expect(schedules[0].scheduledDate, DateTime(2025, 1, 8));
        expect(schedules[0].scheduledDoseMg, 0.25);
        expect(schedules[1].scheduledDate, DateTime(2025, 1, 15));
        expect(schedules[2].scheduledDate, DateTime(2025, 1, 22));
        expect(schedules[3].scheduledDate, DateTime(2025, 1, 29));
      });

      test('should generate empty list when end date before start date', () {
        final startDate = DateTime(2025, 1, 1);
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: startDate,
          cycleDays: 7,
          initialDoseMg: 0.25,
        );

        final endDate = DateTime(2024, 12, 31);

        final schedules = useCase.generateSchedules(plan, endDate);

        expect(schedules.isEmpty, true);
      });
    });

    group('escalation plan generation', () {
      test('should generate schedule with escalation plan', () {
        final startDate = DateTime(2025, 1, 1);
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: startDate,
          cycleDays: 7,
          initialDoseMg: 0.25,
          escalationPlan: [
            EscalationStep(weeksFromStart: 4, doseMg: 0.5),
            EscalationStep(weeksFromStart: 8, doseMg: 1.0),
          ],
        );

        final endDate = DateTime(2025, 2, 26); // 8+ weeks

        final schedules = useCase.generateSchedules(plan, endDate);

        // Week 1-4: 0.25mg
        expect(schedules[0].scheduledDoseMg, 0.25); // Jan 8
        expect(schedules[1].scheduledDoseMg, 0.25); // Jan 15
        expect(schedules[2].scheduledDoseMg, 0.25); // Jan 22
        expect(schedules[3].scheduledDoseMg, 0.25); // Jan 29

        // Week 5-8: 0.5mg
        expect(schedules[4].scheduledDoseMg, 0.5); // Feb 5
        expect(schedules[5].scheduledDoseMg, 0.5); // Feb 12
        expect(schedules[6].scheduledDoseMg, 0.5); // Feb 19
        expect(schedules[7].scheduledDoseMg, 0.5); // Feb 26
      });
    });

    group('performance', () {
      test('should generate 6 months schedule within 1 second', () {
        final startDate = DateTime(2025, 1, 1);
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: startDate,
          cycleDays: 7,
          initialDoseMg: 0.25,
          escalationPlan: [
            EscalationStep(weeksFromStart: 4, doseMg: 0.5),
            EscalationStep(weeksFromStart: 8, doseMg: 1.0),
            EscalationStep(weeksFromStart: 12, doseMg: 2.4),
          ],
        );

        final endDate = DateTime(2025, 7, 1); // 6 months

        final stopwatch = Stopwatch()..start();
        final schedules = useCase.generateSchedules(plan, endDate);
        stopwatch.stop();

        expect(schedules.isNotEmpty, true);
        expect(stopwatch.elapsedMilliseconds, lessThan(1000));
      });
    });

    group('recalculation', () {
      test('should recalculate schedules from specific date', () {
        final startDate = DateTime(2025, 1, 1);
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: startDate,
          cycleDays: 7,
          initialDoseMg: 0.25,
          escalationPlan: [
            EscalationStep(weeksFromStart: 4, doseMg: 0.5),
          ],
        );

        final originalEndDate = DateTime(2025, 2, 26);
        final originalSchedules =
            useCase.generateSchedules(plan, originalEndDate);

        // Change plan at week 3
        final changeDate = DateTime(2025, 1, 22); // Week 3
        final updatedPlan = plan.copyWith(
          escalationPlan: [
            EscalationStep(weeksFromStart: 2, doseMg: 0.5),
          ],
        );

        final recalculatedSchedules = useCase.recalculateSchedulesFrom(
          updatedPlan,
          changeDate,
          originalEndDate,
          originalSchedules,
        );

        // Schedules before change date should be unchanged
        expect(
          recalculatedSchedules.where((s) => s.scheduledDate.isBefore(changeDate)).length,
          lessThanOrEqualTo(2),
        );

        // After change date, dose should be 0.5mg
        final afterChangeSchedules = recalculatedSchedules
            .where((s) =>
                s.scheduledDate.isAfter(changeDate) ||
                s.scheduledDate.isAtSameMomentAs(changeDate))
            .toList();

        expect(afterChangeSchedules.isNotEmpty, true);
        expect(afterChangeSchedules.every((s) => s.scheduledDoseMg >= 0.5), true);
      });
    });

    group('notification time', () {
      test('should apply notification time to all schedules', () {
        final startDate = DateTime(2025, 1, 1);
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: startDate,
          cycleDays: 7,
          initialDoseMg: 0.25,
        );

        final endDate = DateTime(2025, 1, 29);
        final notificationTime = TimeOfDay(hour: 14, minute: 30);

        final schedules = useCase.generateSchedules(
          plan,
          endDate,
          notificationTime: notificationTime,
        );

        for (final schedule in schedules) {
          expect(schedule.notificationTime, isNotNull);
          if (schedule.notificationTime is TimeOfDay) {
            final time = schedule.notificationTime as TimeOfDay;
            expect(time.hour, 14);
            expect(time.minute, 30);
          }
        }
      });
    });
  });
}

// Mock TimeOfDay for testing
class TimeOfDay {
  final int hour;
  final int minute;

  TimeOfDay({required this.hour, required this.minute});

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TimeOfDay &&
          runtimeType == other.runtimeType &&
          hour == other.hour &&
          minute == other.minute;

  @override
  int get hashCode => hour.hashCode ^ minute.hashCode;
}
</file>

<file path="test/features/tracking/infrastructure/repositories/isar_dosage_plan_repository_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';
import 'package:n06/features/tracking/domain/entities/plan_change_history.dart';
import 'package:n06/features/tracking/infrastructure/dtos/dosage_plan_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/plan_change_history_dto.dart';
import 'package:n06/features/tracking/infrastructure/repositories/isar_dosage_plan_repository.dart';

void main() {
  group('IsarDosagePlanRepository', () {
    late Isar isar;
    late IsarDosagePlanRepository repository;

    setUp(() async {
      final tempDir = await getTemporaryDirectory();
      // In-memory Isar instance for testing
      isar = await Isar.open(
        [
          DosagePlanDtoSchema,
          PlanChangeHistoryDtoSchema,
        ],
        directory: tempDir.path,
      );
      repository = IsarDosagePlanRepository(isar);
    });

    tearDown(() async {
      await isar.close();
    });

    group('getActiveDosagePlan', () {
      // TC-IDPR-01: Get active dosage plan for user
      test('should get active dosage plan for user', () async {
        // Arrange
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
          isActive: true,
        );
        await repository.saveDosagePlan(plan);

        // Act
        final result = await repository.getActiveDosagePlan('user-1');

        // Assert
        expect(result, isNotNull);
        expect(result!.id, 'plan-1');
        expect(result.isActive, true);
        expect(result.medicationName, 'Ozempic');
      });

      // TC-IDPR-02: Return null when no active plan
      test('should return null when no active plan exists', () async {
        // Act
        final result = await repository.getActiveDosagePlan('user-1');

        // Assert
        expect(result, isNull);
      });

      // TC-IDPR-03: Return only active plan when multiple plans exist
      test('should return only active plan when multiple plans exist', () async {
        // Arrange
        final activePlan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
          isActive: true,
        );
        final inactivePlan = DosagePlan(
          id: 'plan-2',
          userId: 'user-1',
          medicationName: 'Wegovy',
          startDate: DateTime(2024, 1, 1),
          cycleDays: 14,
          initialDoseMg: 0.5,
          isActive: false,
        );
        await repository.saveDosagePlan(activePlan);
        await repository.saveDosagePlan(inactivePlan);

        // Act
        final result = await repository.getActiveDosagePlan('user-1');

        // Assert
        expect(result!.id, 'plan-1');
        expect(result.isActive, true);
      });
    });

    group('getDosagePlan', () {
      // TC-IDPR-04: Get specific plan by ID
      test('should get specific plan by ID', () async {
        // Arrange
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
        );
        await repository.saveDosagePlan(plan);

        // Act
        final result = await repository.getDosagePlan('plan-1');

        // Assert
        expect(result, isNotNull);
        expect(result!.id, 'plan-1');
        expect(result.medicationName, 'Ozempic');
      });

      // TC-IDPR-05: Return null when plan doesn't exist
      test('should return null when plan does not exist', () async {
        // Act
        final result = await repository.getDosagePlan('nonexistent-plan');

        // Assert
        expect(result, isNull);
      });
    });

    group('saveDosagePlan', () {
      // TC-IDPR-06: Save new plan
      test('should save new dosage plan', () async {
        // Arrange
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
        );

        // Act
        await repository.saveDosagePlan(plan);

        // Assert
        final saved = await repository.getDosagePlan('plan-1');
        expect(saved, isNotNull);
        expect(saved!.medicationName, 'Ozempic');
      });
    });

    group('updateDosagePlan', () {
      // TC-IDPR-07: Update existing plan
      test('should update existing dosage plan', () async {
        // Arrange
        final originalPlan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
        );
        await repository.saveDosagePlan(originalPlan);

        final updatedPlan = originalPlan.copyWith(
          medicationName: 'Wegovy',
          initialDoseMg: 0.5,
        );

        // Act
        await repository.updateDosagePlan(updatedPlan);

        // Assert
        final saved = await repository.getDosagePlan('plan-1');
        expect(saved!.medicationName, 'Wegovy');
        expect(saved.initialDoseMg, 0.5);
        expect(saved.cycleDays, 7); // Unchanged
      });
    });

    group('savePlanChangeHistory', () {
      // TC-IDPR-08: Save plan change history
      test('should save plan change history', () async {
        // Arrange
        final history = PlanChangeHistory(
          id: 'history-1',
          dosagePlanId: 'plan-1',
          changedAt: DateTime(2025, 2, 1),
          oldPlan: {'initialDoseMg': 0.25},
          newPlan: {'initialDoseMg': 0.5},
        );

        // Act
        await repository.savePlanChangeHistory(history);

        // Assert
        final saved = await repository.getPlanChangeHistory('plan-1');
        expect(saved, isNotEmpty);
        expect(saved.first.oldPlan['initialDoseMg'], 0.25);
        expect(saved.first.newPlan['initialDoseMg'], 0.5);
      });

      // TC-IDPR-09: Multiple history records
      test('should save multiple history records', () async {
        // Arrange
        final history1 = PlanChangeHistory(
          id: 'history-1',
          dosagePlanId: 'plan-1',
          changedAt: DateTime(2025, 1, 1),
          oldPlan: {'initialDoseMg': 0.25},
          newPlan: {'initialDoseMg': 0.5},
        );
        final history2 = PlanChangeHistory(
          id: 'history-2',
          dosagePlanId: 'plan-1',
          changedAt: DateTime(2025, 2, 1),
          oldPlan: {'initialDoseMg': 0.5},
          newPlan: {'initialDoseMg': 1.0},
        );

        // Act
        await repository.savePlanChangeHistory(history1);
        await repository.savePlanChangeHistory(history2);

        // Assert
        final saved = await repository.getPlanChangeHistory('plan-1');
        expect(saved.length, 2);
      });
    });

    group('getPlanChangeHistory', () {
      // TC-IDPR-10: Get history ordered by most recent first
      test('should get history ordered by most recent first', () async {
        // Arrange
        final history1 = PlanChangeHistory(
          id: 'history-1',
          dosagePlanId: 'plan-1',
          changedAt: DateTime(2025, 1, 1),
          oldPlan: {},
          newPlan: {},
        );
        final history2 = PlanChangeHistory(
          id: 'history-2',
          dosagePlanId: 'plan-1',
          changedAt: DateTime(2025, 2, 1),
          oldPlan: {},
          newPlan: {},
        );
        await repository.savePlanChangeHistory(history1);
        await repository.savePlanChangeHistory(history2);

        // Act
        final result = await repository.getPlanChangeHistory('plan-1');

        // Assert
        expect(result[0].id, 'history-2'); // Most recent
        expect(result[1].id, 'history-1');
      });

      // TC-IDPR-11: Return empty when no history
      test('should return empty list when no history exists', () async {
        // Act
        final result = await repository.getPlanChangeHistory('plan-1');

        // Assert
        expect(result, isEmpty);
      });
    });

    group('updatePlanWithHistory', () {
      // TC-IDPR-12: Update plan and save history in transaction
      test('should update plan and save history in transaction', () async {
        // Arrange
        final originalPlan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
        );
        await repository.saveDosagePlan(originalPlan);

        final updatedPlan = originalPlan.copyWith(initialDoseMg: 0.5);
        final history = PlanChangeHistory(
          id: 'history-1',
          dosagePlanId: 'plan-1',
          changedAt: DateTime.now(),
          oldPlan: {'initialDoseMg': 0.25},
          newPlan: {'initialDoseMg': 0.5},
        );

        // Act
        await repository.updatePlanWithHistory(updatedPlan, history);

        // Assert
        final plan = await repository.getDosagePlan('plan-1');
        final histories = await repository.getPlanChangeHistory('plan-1');

        expect(plan!.initialDoseMg, 0.5);
        expect(histories.length, 1);
        expect(histories.first.oldPlan['initialDoseMg'], 0.25);
      });

      // TC-IDPR-13: Transaction atomicity (both or nothing)
      test('should save both plan and history or neither', () async {
        // Arrange
        final originalPlan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
        );
        await repository.saveDosagePlan(originalPlan);

        final updatedPlan = originalPlan.copyWith(initialDoseMg: 0.5);
        final history = PlanChangeHistory(
          id: 'history-1',
          dosagePlanId: 'plan-1',
          changedAt: DateTime.now(),
          oldPlan: {'initialDoseMg': 0.25},
          newPlan: {'initialDoseMg': 0.5},
        );

        // Act
        await repository.updatePlanWithHistory(updatedPlan, history);

        // Assert - both should be saved together
        final plan = await repository.getDosagePlan('plan-1');
        final histories = await repository.getPlanChangeHistory('plan-1');

        expect(plan!.initialDoseMg, 0.5);
        expect(histories.length, 1);
      });
    });

    group('watchActiveDosagePlan', () {
      // TC-IDPR-14: Watch active plan stream
      test('should emit active plan on watch', () async {
        // Arrange
        final plan = DosagePlan(
          id: 'plan-1',
          userId: 'user-1',
          medicationName: 'Ozempic',
          startDate: DateTime(2025, 1, 1),
          cycleDays: 7,
          initialDoseMg: 0.25,
          isActive: true,
        );

        // Act & Assert
        await expectLater(
          repository.watchActiveDosagePlan('user-1'),
          emits(isNull),
        );

        await repository.saveDosagePlan(plan);

        await expectLater(
          repository.watchActiveDosagePlan('user-1'),
          emits(
            isA<DosagePlan>()
                .having((p) => p.id, 'id', 'plan-1')
                .having((p) => p.isActive, 'isActive', true),
          ),
        );
      });
    });
  });
}
</file>

<file path="test/features/tracking/infrastructure/repositories/isar_dose_schedule_repository_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';
import 'package:n06/features/tracking/infrastructure/dtos/dose_schedule_dto.dart';
import 'package:n06/features/tracking/infrastructure/repositories/isar_dose_schedule_repository.dart';

void main() {
  group('IsarDoseScheduleRepository', () {
    late Isar isar;
    late IsarDoseScheduleRepository repository;

    setUp(() async {
      final tempDir = await getTemporaryDirectory();
      // In-memory Isar instance for testing
      isar = await Isar.open(
        [DoseScheduleDtoSchema],
        directory: tempDir.path,
      );
      repository = IsarDoseScheduleRepository(isar);
    });

    tearDown(() async {
      await isar.close();
    });

    group('saveBatchSchedules', () {
      // TC-IDSR-01: Save batch of schedules
      test('should save batch of schedules', () async {
        // Arrange
        final schedules = [
          DoseSchedule(
            id: 'schedule-1',
            dosagePlanId: 'plan-1',
            scheduledDate: DateTime(2025, 1, 1),
            scheduledDoseMg: 0.25,
          ),
          DoseSchedule(
            id: 'schedule-2',
            dosagePlanId: 'plan-1',
            scheduledDate: DateTime(2025, 1, 8),
            scheduledDoseMg: 0.25,
          ),
          DoseSchedule(
            id: 'schedule-3',
            dosagePlanId: 'plan-1',
            scheduledDate: DateTime(2025, 1, 15),
            scheduledDoseMg: 0.5,
          ),
        ];

        // Act
        await repository.saveBatchSchedules(schedules);

        // Assert
        final saved = await repository.getSchedulesByPlanId('plan-1');
        expect(saved.length, 3);
        expect(saved[0].id, 'schedule-1');
        expect(saved[1].id, 'schedule-2');
        expect(saved[2].id, 'schedule-3');
      });

      // TC-IDSR-02: Save many schedules efficiently
      test('should save many schedules efficiently', () async {
        // Arrange
        final schedules = List.generate(
          100,
          (i) => DoseSchedule(
            id: 'schedule-$i',
            dosagePlanId: 'plan-1',
            scheduledDate: DateTime(2025, 1, 1).add(Duration(days: i * 7)),
            scheduledDoseMg: 0.25,
          ),
        );

        // Act
        final stopwatch = Stopwatch()..start();
        await repository.saveBatchSchedules(schedules);
        stopwatch.stop();

        // Assert
        final saved = await repository.getSchedulesByPlanId('plan-1');
        expect(saved.length, 100);
        expect(stopwatch.elapsedMilliseconds, lessThan(1000)); // Should be fast
      });
    });

    group('getSchedulesByPlanId', () {
      // TC-IDSR-03: Get schedules by plan ID
      test('should get schedules by plan ID', () async {
        // Arrange
        final schedules = [
          DoseSchedule(
            id: 'schedule-1',
            dosagePlanId: 'plan-1',
            scheduledDate: DateTime(2025, 1, 1),
            scheduledDoseMg: 0.25,
          ),
          DoseSchedule(
            id: 'schedule-2',
            dosagePlanId: 'plan-1',
            scheduledDate: DateTime(2025, 1, 8),
            scheduledDoseMg: 0.25,
          ),
        ];
        await repository.saveBatchSchedules(schedules);

        // Act
        final result = await repository.getSchedulesByPlanId('plan-1');

        // Assert
        expect(result.length, 2);
        expect(result.every((s) => s.dosagePlanId == 'plan-1'), true);
      });

      // TC-IDSR-04: Return empty when plan has no schedules
      test('should return empty list when plan has no schedules', () async {
        // Act
        final result = await repository.getSchedulesByPlanId('plan-1');

        // Assert
        expect(result, isEmpty);
      });

      // TC-IDSR-05: Get schedules for different plans separately
      test('should get schedules for different plans separately', () async {
        // Arrange
        final plan1Schedules = [
          DoseSchedule(
            id: 'schedule-1',
            dosagePlanId: 'plan-1',
            scheduledDate: DateTime(2025, 1, 1),
            scheduledDoseMg: 0.25,
          ),
        ];
        final plan2Schedules = [
          DoseSchedule(
            id: 'schedule-2',
            dosagePlanId: 'plan-2',
            scheduledDate: DateTime(2025, 1, 1),
            scheduledDoseMg: 0.5,
          ),
        ];
        await repository.saveBatchSchedules([...plan1Schedules, ...plan2Schedules]);

        // Act
        final plan1Result = await repository.getSchedulesByPlanId('plan-1');
        final plan2Result = await repository.getSchedulesByPlanId('plan-2');

        // Assert
        expect(plan1Result.length, 1);
        expect(plan1Result.first.dosagePlanId, 'plan-1');
        expect(plan1Result.first.scheduledDoseMg, 0.25);

        expect(plan2Result.length, 1);
        expect(plan2Result.first.dosagePlanId, 'plan-2');
        expect(plan2Result.first.scheduledDoseMg, 0.5);
      });
    });

    group('deleteFutureSchedules', () {
      // TC-IDSR-06: Delete schedules from specific date onwards
      test('should delete schedules from specific date onwards', () async {
        // Arrange
        final schedules = [
          DoseSchedule(
            id: 'schedule-1',
            dosagePlanId: 'plan-1',
            scheduledDate: DateTime(2025, 1, 1),
            scheduledDoseMg: 0.25,
          ),
          DoseSchedule(
            id: 'schedule-2',
            dosagePlanId: 'plan-1',
            scheduledDate: DateTime(2025, 1, 15),
            scheduledDoseMg: 0.25,
          ),
          DoseSchedule(
            id: 'schedule-3',
            dosagePlanId: 'plan-1',
            scheduledDate: DateTime(2025, 2, 1),
            scheduledDoseMg: 0.5,
          ),
        ];
        await repository.saveBatchSchedules(schedules);

        // Act
        await repository.deleteFutureSchedules('plan-1', DateTime(2025, 1, 10));

        // Assert
        final remaining = await repository.getSchedulesByPlanId('plan-1');
        expect(remaining.length, 1);
        expect(remaining.first.id, 'schedule-1');
      });

      // TC-IDSR-07: Preserve past schedules
      test('should preserve past schedules when deleting future ones', () async {
        // Arrange
        final now = DateTime.now();
        final schedules = [
          DoseSchedule(
            id: 'schedule-1',
            dosagePlanId: 'plan-1',
            scheduledDate: now.subtract(Duration(days: 30)),
            scheduledDoseMg: 0.25,
          ),
          DoseSchedule(
            id: 'schedule-2',
            dosagePlanId: 'plan-1',
            scheduledDate: now.add(Duration(days: 30)),
            scheduledDoseMg: 0.25,
          ),
        ];
        await repository.saveBatchSchedules(schedules);

        // Act
        await repository.deleteFutureSchedules('plan-1', now);

        // Assert
        final remaining = await repository.getSchedulesByPlanId('plan-1');
        expect(remaining.length, 1);
        expect(remaining.first.id, 'schedule-1');
      });

      // TC-IDSR-08: Delete all future schedules when date is today
      test('should delete all future schedules when date is today', () async {
        // Arrange
        final today = DateTime.now();
        final schedules = [
          DoseSchedule(
            id: 'schedule-1',
            dosagePlanId: 'plan-1',
            scheduledDate: today.add(Duration(days: 1)),
            scheduledDoseMg: 0.25,
          ),
          DoseSchedule(
            id: 'schedule-2',
            dosagePlanId: 'plan-1',
            scheduledDate: today.add(Duration(days: 7)),
            scheduledDoseMg: 0.25,
          ),
        ];
        await repository.saveBatchSchedules(schedules);

        // Act
        await repository.deleteFutureSchedules('plan-1', today);

        // Assert
        final remaining = await repository.getSchedulesByPlanId('plan-1');
        expect(remaining, isEmpty);
      });

      // TC-IDSR-09: No effect when deleting from future date
      test('should have no effect when deleting from future date', () async {
        // Arrange
        final schedules = [
          DoseSchedule(
            id: 'schedule-1',
            dosagePlanId: 'plan-1',
            scheduledDate: DateTime(2025, 1, 1),
            scheduledDoseMg: 0.25,
          ),
          DoseSchedule(
            id: 'schedule-2',
            dosagePlanId: 'plan-1',
            scheduledDate: DateTime(2025, 1, 8),
            scheduledDoseMg: 0.25,
          ),
        ];
        await repository.saveBatchSchedules(schedules);

        // Act
        await repository.deleteFutureSchedules('plan-1', DateTime(2030, 1, 1));

        // Assert
        final remaining = await repository.getSchedulesByPlanId('plan-1');
        expect(remaining.length, 2); // No deletion
      });

      // TC-IDSR-10: Only affects specified plan
      test('should only affect specified plan', () async {
        // Arrange
        final schedules = [
          DoseSchedule(
            id: 'schedule-1',
            dosagePlanId: 'plan-1',
            scheduledDate: DateTime(2025, 2, 1),
            scheduledDoseMg: 0.25,
          ),
          DoseSchedule(
            id: 'schedule-2',
            dosagePlanId: 'plan-2',
            scheduledDate: DateTime(2025, 2, 1),
            scheduledDoseMg: 0.5,
          ),
        ];
        await repository.saveBatchSchedules(schedules);

        // Act
        await repository.deleteFutureSchedules('plan-1', DateTime(2025, 1, 1));

        // Assert
        final plan1Schedules = await repository.getSchedulesByPlanId('plan-1');
        final plan2Schedules = await repository.getSchedulesByPlanId('plan-2');

        expect(plan1Schedules, isEmpty);
        expect(plan2Schedules.length, 1);
        expect(plan2Schedules.first.id, 'schedule-2');
      });
    });

    group('watchSchedulesByPlanId', () {
      // TC-IDSR-11: Watch schedules stream
      test('should emit schedules on watch', () async {
        // Arrange
        final schedules = [
          DoseSchedule(
            id: 'schedule-1',
            dosagePlanId: 'plan-1',
            scheduledDate: DateTime(2025, 1, 1),
            scheduledDoseMg: 0.25,
          ),
        ];

        // Act & Assert
        await expectLater(
          repository.watchSchedulesByPlanId('plan-1'),
          emits(isEmpty),
        );

        await repository.saveBatchSchedules(schedules);

        await expectLater(
          repository.watchSchedulesByPlanId('plan-1'),
          emits(
            isA<List<DoseSchedule>>()
                .having((list) => list.length, 'length', 1)
                .having(
                  (list) => list.first.id,
                  'first.id',
                  'schedule-1',
                ),
          ),
        );
      });
    });
  });
}
</file>

<file path="test/features/tracking/infrastructure/repositories/isar_tracking_repository_test.dart">
import 'package:flutter_test/flutter_test.dart';
import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/infrastructure/dtos/weight_log_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/symptom_log_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/symptom_context_tag_dto.dart';
import 'package:n06/features/tracking/infrastructure/repositories/isar_tracking_repository.dart';

void main() {
  group('IsarTrackingRepository', () {
    late Isar isar;
    late IsarTrackingRepository repository;

    setUp(() async {
      final tempDir = await getTemporaryDirectory();
      // In-memory Isar instance for testing
      isar = await Isar.open(
        [
          WeightLogDtoSchema,
          SymptomLogDtoSchema,
          SymptomContextTagDtoSchema,
        ],
        directory: tempDir.path,
      );
      repository = IsarTrackingRepository(isar);
    });

    tearDown(() async {
      await isar.close();
    });

    // TC-ITR-01: 체중 기록 저장
    test('should save WeightLog to Isar', () async {
      // Arrange
      final log = WeightLog(
        id: 'wl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        weightKg: 75.5,
        createdAt: DateTime.now(),
      );

      // Act
      await repository.saveWeightLog(log);

      // Assert
      final saved = await repository.getWeightLog(log.userId, log.logDate);
      expect(saved, isNotNull);
      expect(saved!.weightKg, log.weightKg);
      expect(saved.userId, log.userId);
    });

    // TC-ITR-02: 체중 중복 기록 (덮어쓰기)
    test('should overwrite duplicate WeightLog', () async {
      // Arrange
      final log1 = WeightLog(
        id: 'wl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        weightKg: 75.5,
        createdAt: DateTime.now(),
      );
      final log2 = WeightLog(
        id: 'wl-002',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7), // 같은 날짜
        weightKg: 74.8,
        createdAt: DateTime.now(),
      );

      // Act
      await repository.saveWeightLog(log1);
      await repository.saveWeightLog(log2);

      // Assert
      final saved = await repository.getWeightLog(log1.userId, log1.logDate);
      expect(saved!.weightKg, 74.8); // 덮어쓰기 확인
    });

    // TC-ITR-03: 증상 기록 저장
    test('should save SymptomLog to Isar', () async {
      // Arrange
      final log = SymptomLog(
        id: 'sl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        symptomName: '메스꺼움',
        severity: 4,
        tags: const ['기름진음식', '과식'],
      );

      // Act
      await repository.saveSymptomLog(log);

      // Assert
      final saved = await repository.getSymptomLogs(log.userId);
      expect(saved, isNotEmpty);
      expect(saved.first.symptomName, log.symptomName);
      expect(saved.first.tags, log.tags);
    });

    // TC-ITR-04: 증상 기록 조회 (날짜 범위)
    test('should get SymptomLogs in date range', () async {
      // Arrange
      await repository.saveSymptomLog(SymptomLog(
        id: 'sl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 1),
        symptomName: '메스꺼움',
        severity: 4,
      ));
      await repository.saveSymptomLog(SymptomLog(
        id: 'sl-002',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        symptomName: '구토',
        severity: 5,
      ));
      await repository.saveSymptomLog(SymptomLog(
        id: 'sl-003',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 15),
        symptomName: '복통',
        severity: 3,
      ));

      // Act
      final logs = await repository.getSymptomLogs(
        'user-001',
        startDate: DateTime(2025, 11, 5),
        endDate: DateTime(2025, 11, 10),
      );

      // Assert
      expect(logs.length, 1); // 11월 7일만 포함
      expect(logs.first.symptomName, '구토');
    });

    // TC-ITR-05: 체중 기록 삭제
    test('should delete WeightLog', () async {
      // Arrange
      final log = WeightLog(
        id: 'wl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        weightKg: 75.5,
        createdAt: DateTime.now(),
      );
      await repository.saveWeightLog(log);

      // Act
      await repository.deleteWeightLog(log.id);

      // Assert
      final deleted = await repository.getWeightLog(log.userId, log.logDate);
      expect(deleted, isNull);
    });

    // TC-ITR-06: 증상 기록 삭제
    test('should delete SymptomLog', () async {
      // Arrange
      final log = SymptomLog(
        id: 'sl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        symptomName: '메스꺼움',
        severity: 4,
      );
      await repository.saveSymptomLog(log);

      // Act
      await repository.deleteSymptomLog(log.id);

      // Assert
      final allLogs = await repository.getSymptomLogs('user-001');
      expect(allLogs.isEmpty, isTrue);
    });

    // TC-ITR-07: 체중 기록 업데이트
    test('should update WeightLog', () async {
      // Arrange
      final log = WeightLog(
        id: 'wl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        weightKg: 75.5,
        createdAt: DateTime.now(),
      );
      await repository.saveWeightLog(log);

      // Act
      await repository.updateWeightLog(log.id, 74.8);

      // Assert
      final updated = await repository.getWeightLog(log.userId, log.logDate);
      expect(updated!.weightKg, 74.8);
    });

    // TC-ITR-08: 증상 기록 업데이트
    test('should update SymptomLog', () async {
      // Arrange
      final log = SymptomLog(
        id: 'sl-001',
        userId: 'user-001',
        logDate: DateTime(2025, 11, 7),
        symptomName: '메스꺼움',
        severity: 4,
      );
      await repository.saveSymptomLog(log);
      final updated = log.copyWith(severity: 7);

      // Act
      await repository.updateSymptomLog(log.id, updated);

      // Assert
      final result = await repository.getSymptomLogs('user-001');
      expect(result.first.severity, 7);
    });

    // TC-ITR-09: 태그 기반 조회
    test('should get symptom logs by tag', () async {
      // Arrange
      await repository.saveSymptomLog(SymptomLog(
        id: 'sl-001',
        userId: 'user-001',
        logDate: DateTime.now(),
        symptomName: '메스꺼움',
        severity: 4,
        tags: const ['기름진음식'],
      ));
      await repository.saveSymptomLog(SymptomLog(
        id: 'sl-002',
        userId: 'user-001',
        logDate: DateTime.now(),
        symptomName: '메스꺼움',
        severity: 4,
        tags: const ['기름진음식'],
      ));
      await repository.saveSymptomLog(SymptomLog(
        id: 'sl-003',
        userId: 'user-001',
        logDate: DateTime.now(),
        symptomName: '복통',
        severity: 3,
        tags: const ['과식'],
      ));

      // Act
      final logs = await repository.getSymptomLogsByTag('기름진음식');

      // Assert
      expect(logs.length, 2);
    });

    // TC-ITR-10: 모든 태그 조회
    test('should get all tags for user', () async {
      // Arrange
      await repository.saveSymptomLog(SymptomLog(
        id: 'sl-001',
        userId: 'user-001',
        logDate: DateTime.now(),
        symptomName: '메스꺼움',
        severity: 4,
        tags: const ['기름진음식', '과식'],
      ));
      await repository.saveSymptomLog(SymptomLog(
        id: 'sl-002',
        userId: 'user-001',
        logDate: DateTime.now(),
        symptomName: '복통',
        severity: 3,
        tags: const ['스트레스'],
      ));

      // Act
      final tags = await repository.getAllTags('user-001');

      // Assert
      expect(tags, containsAll(['기름진음식', '과식', '스트레스']));
    });
  });
}
</file>

<file path="test/features/tracking/presentation/dialogs/dose_edit_dialog_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';
import 'package:n06/features/tracking/presentation/dialogs/dose_edit_dialog.dart';

void main() {
  group('DoseEditDialog', () {
    late DoseRecord currentRecord;

    setUp(() {
      currentRecord = DoseRecord(
        id: 'dose1',
        dosagePlanId: 'plan1',
        administeredAt: DateTime(2025, 1, 15, 10, 0),
        actualDoseMg: 0.5,
        injectionSite: '복부',
        isCompleted: true,
      );
    });

    group('TC-DED-01: Display Current Dose', () {
      testWidgets('should display current dose amount', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: DoseEditDialog(
                  currentRecord: currentRecord,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('0.5'), findsWidgets);
        expect(find.text('투여 기록 수정'), findsOneWidget);
      });

      testWidgets('should display current injection site', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: DoseEditDialog(
                  currentRecord: currentRecord,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('복부'), findsOneWidget);
      });

      testWidgets('should display dose with correct decimal places', (WidgetTester tester) async {
        // Arrange
        final recordWithDifferentDose = DoseRecord(
          id: 'dose1',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2025, 1, 15, 10, 0),
          actualDoseMg: 0.75,
          injectionSite: '상완',
          isCompleted: true,
        );

        // Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: DoseEditDialog(
                  currentRecord: recordWithDifferentDose,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        expect(find.textContaining('0.75'), findsOneWidget);
      });

      testWidgets('should display note if present', (WidgetTester tester) async {
        // Arrange
        final recordWithNote = DoseRecord(
          id: 'dose1',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2025, 1, 15, 10, 0),
          actualDoseMg: 0.5,
          injectionSite: '복부',
          isCompleted: true,
          note: '정상 투여',
        );

        // Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: DoseEditDialog(
                  currentRecord: recordWithNote,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('정상 투여'), findsOneWidget);
      });
    });

    group('TC-DED-02: Update Dose and Save', () {
      testWidgets('should allow changing dose amount', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: DoseEditDialog(
                  currentRecord: currentRecord,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Find and edit dose field
        final textFields = find.byType(TextField);
        expect(textFields, findsWidgets);

        // Enter new dose
        await tester.enterText(textFields.first, '0.75');
        await tester.pumpAndSettle();

        // Assert
        expect(find.text('0.75'), findsOneWidget);
      });

      testWidgets('should allow changing injection site', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: DoseEditDialog(
                  currentRecord: currentRecord,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Find dropdown
        final dropdown = find.byType(DropdownButton);
        if (dropdown.evaluate().isNotEmpty) {
          await tester.tap(dropdown);
          await tester.pumpAndSettle();

          // Select different site
          final option = find.text('허벅지');
          if (option.evaluate().isNotEmpty) {
            await tester.tap(option);
            await tester.pumpAndSettle();

            // Assert
            expect(find.text('허벅지'), findsOneWidget);
          }
        }
      });

      testWidgets('should display save button', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: DoseEditDialog(
                  currentRecord: currentRecord,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('저장'), findsOneWidget);
      });
    });

    group('TC-DED-03: Invalidate Dashboard on Save', () {
      testWidgets('should validate dose is positive', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: DoseEditDialog(
                  currentRecord: currentRecord,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Enter zero dose
        final textField = find.byType(TextField).first;
        await tester.enterText(textField, '0');
        await tester.pumpAndSettle();

        // Assert error should be shown
        expect(find.textContaining('0보다'), findsOneWidget);
      });

      testWidgets('should allow positive dose values', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: DoseEditDialog(
                  currentRecord: currentRecord,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Enter valid dose
        final textField = find.byType(TextField).first;
        await tester.enterText(textField, '1.5');
        await tester.pumpAndSettle();

        // Assert save button should be enabled
        expect(find.text('저장'), findsOneWidget);
      });

      testWidgets('should show all injection site options', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: DoseEditDialog(
                  currentRecord: currentRecord,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Find dropdown
        final dropdown = find.byType(DropdownButton);
        if (dropdown.evaluate().isNotEmpty) {
          await tester.tap(dropdown);
          await tester.pumpAndSettle();

          // Assert at least one site option is available
          expect(find.text('복부'), findsWidgets);
        }
      });

      testWidgets('should accept valid dose and close dialog', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: DoseEditDialog(
                  currentRecord: currentRecord,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Edit dose
        final textField = find.byType(TextField).first;
        await tester.enterText(textField, '1.0');
        await tester.pumpAndSettle();

        // Assert save button exists and is available
        expect(find.text('저장'), findsOneWidget);
      });
    });
  });
}
</file>

<file path="test/features/tracking/presentation/dialogs/record_delete_dialog_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/presentation/dialogs/record_delete_dialog.dart';

void main() {
  group('RecordDeleteDialog', () {
    group('TC-RDD-01: Show Delete Confirmation', () {
      testWidgets('should display delete confirmation message', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDeleteDialog(
                recordType: '체중 기록',
                recordInfo: '70.5 kg (2025-01-01)',
                onConfirm: () {},
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('기록 삭제'), findsOneWidget);
        expect(find.text('체중 기록'), findsOneWidget);
      });

      testWidgets('should show permanent deletion warning', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDeleteDialog(
                recordType: '증상 기록',
                recordInfo: '메스꺼움 (2025-01-01)',
                onConfirm: () {},
              ),
            ),
          ),
        );

        // Assert
        expect(find.textContaining('영구적'), findsOneWidget);
        expect(find.textContaining('복구'), findsOneWidget);
      });

      testWidgets('should display delete and cancel buttons', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDeleteDialog(
                recordType: '체중 기록',
                recordInfo: '70 kg',
                onConfirm: () {},
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('삭제'), findsOneWidget);
        expect(find.text('취소'), findsOneWidget);
      });

      testWidgets('should show different messages for different record types', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDeleteDialog(
                recordType: '투여 기록',
                recordInfo: '0.5 mg (2025-01-01)',
                onConfirm: () {},
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('투여 기록'), findsOneWidget);
      });
    });

    group('TC-RDD-02: Delete Record on Confirm', () {
      testWidgets('should call onConfirm when delete button tapped', (WidgetTester tester) async {
        // Arrange
        bool confirmed = false;

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDeleteDialog(
                recordType: '체중 기록',
                recordInfo: '70 kg',
                onConfirm: () {
                  confirmed = true;
                },
              ),
            ),
          ),
        );

        final deleteButton = find.byWidgetPredicate(
          (widget) => widget is TextButton &&
            widget.child is Text &&
            (widget.child as Text).data == '삭제'
        );
        await tester.tap(deleteButton);
        await tester.pumpAndSettle();

        // Assert
        expect(confirmed, true);
      });

      testWidgets('should close dialog when cancel button tapped', (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: Builder(
                builder: (context) => ElevatedButton(
                  onPressed: () {
                    showDialog(
                      context: context,
                      builder: (_) => RecordDeleteDialog(
                        recordType: '체중 기록',
                        recordInfo: '70 kg',
                        onConfirm: () {},
                      ),
                    );
                  },
                  child: const Text('Open'),
                ),
              ),
            ),
          ),
        );

        // Act
        await tester.tap(find.text('Open'));
        await tester.pumpAndSettle();

        final cancelButton = find.byWidgetPredicate(
          (widget) => widget is TextButton &&
            widget.child is Text &&
            (widget.child as Text).data == '취소'
        );
        await tester.tap(cancelButton);
        await tester.pumpAndSettle();

        // Assert
        expect(find.byType(RecordDeleteDialog), findsNothing);
      });

      testWidgets('should display correct record info', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDeleteDialog(
                recordType: '체중 기록',
                recordInfo: '75.5 kg (2025-01-15)',
                onConfirm: () {},
              ),
            ),
          ),
        );

        // Assert
        expect(find.textContaining('75.5'), findsOneWidget);
      });

      testWidgets('should show confirmation dialog title', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDeleteDialog(
                recordType: '체중 기록',
                recordInfo: '70 kg',
                onConfirm: () {},
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('기록 삭제'), findsOneWidget);
        expect(find.textContaining('삭제하시겠습니까'), findsOneWidget);
      });
    });

    group('TC-RDD-03: Invalidate Dashboard on Delete', () {
      testWidgets('should show destruction warning for delete button', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDeleteDialog(
                recordType: '체중 기록',
                recordInfo: '70 kg',
                onConfirm: () {},
              ),
            ),
          ),
        );

        // Assert - delete button should exist and be distinct
        expect(find.text('삭제'), findsOneWidget);
      });

      testWidgets('should trigger deletion on confirm button tap', (WidgetTester tester) async {
        // Arrange
        bool onConfirmCalled = false;

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDeleteDialog(
                recordType: '체중 기록',
                recordInfo: '70 kg',
                onConfirm: () {
                  onConfirmCalled = true;
                },
              ),
            ),
          ),
        );

        final deleteButton = find.byWidgetPredicate(
          (widget) => widget is TextButton &&
            widget.child is Text &&
            (widget.child as Text).data == '삭제'
        );
        await tester.tap(deleteButton);
        await tester.pumpAndSettle();

        // Assert
        expect(onConfirmCalled, true);
      });

      testWidgets('should allow user to cancel deletion', (WidgetTester tester) async {
        // Arrange
        bool onConfirmCalled = false;

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: Builder(
                builder: (context) => ElevatedButton(
                  onPressed: () {
                    showDialog(
                      context: context,
                      builder: (_) => RecordDeleteDialog(
                        recordType: '체중 기록',
                        recordInfo: '70 kg',
                        onConfirm: () {
                          onConfirmCalled = true;
                        },
                      ),
                    );
                  },
                  child: const Text('Open'),
                ),
              ),
            ),
          ),
        );

        await tester.tap(find.text('Open'));
        await tester.pumpAndSettle();

        final cancelButton = find.byWidgetPredicate(
          (widget) => widget is TextButton &&
            widget.child is Text &&
            (widget.child as Text).data == '취소'
        );
        await tester.tap(cancelButton);
        await tester.pumpAndSettle();

        // Assert - onConfirm should not be called
        expect(onConfirmCalled, false);
      });
    });
  });
}
</file>

<file path="test/features/tracking/presentation/dialogs/symptom_edit_dialog_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/presentation/dialogs/symptom_edit_dialog.dart';

void main() {
  group('SymptomEditDialog', () {
    late SymptomLog currentLog;

    setUp(() {
      currentLog = SymptomLog(
        id: 'symptom1',
        userId: 'user123',
        logDate: DateTime(2025, 1, 15),
        symptomName: '메스꺼움',
        severity: 7,
        tags: const ['기름진음식'],
      );
    });

    group('TC-SED-01: Display Current Symptom Data', () {
      testWidgets('should display current symptom name', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: SymptomEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('메스꺼움'), findsOneWidget);
        expect(find.text('증상 수정'), findsOneWidget);
      });

      testWidgets('should display current severity level', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: SymptomEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('7'), findsWidgets);
        final slider = find.byType(Slider);
        expect(slider, findsOneWidget);
      });

      testWidgets('should display current tags', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: SymptomEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('기름진음식'), findsOneWidget);
      });

      testWidgets('should display multiple tags if present', (WidgetTester tester) async {
        // Arrange
        final logWithMultipleTags = SymptomLog(
          id: 'symptom1',
          userId: 'user123',
          logDate: DateTime(2025, 1, 15),
          symptomName: '메스꺼움',
          severity: 7,
          tags: const ['기름진음식', '과식'],
        );

        // Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: SymptomEditDialog(
                  currentLog: logWithMultipleTags,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('기름진음식'), findsOneWidget);
        expect(find.text('과식'), findsOneWidget);
      });

      testWidgets('should display note if present', (WidgetTester tester) async {
        // Arrange
        final logWithNote = SymptomLog(
          id: 'symptom1',
          userId: 'user123',
          logDate: DateTime(2025, 1, 15),
          symptomName: '메스꺼움',
          severity: 6,
          note: '저녁 식사 후 발생',
          tags: const [],
        );

        // Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: SymptomEditDialog(
                  currentLog: logWithNote,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('저녁 식사 후 발생'), findsOneWidget);
      });
    });

    group('TC-SED-02: Update Symptom and Save', () {
      testWidgets('should allow changing symptom name', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: SymptomEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Find and tap on symptom dropdown
        final dropdown = find.byType(DropdownButton);
        if (dropdown.evaluate().isNotEmpty) {
          await tester.tap(dropdown);
          await tester.pumpAndSettle();

          // Select different symptom
          final option = find.text('구토');
          if (option.evaluate().isNotEmpty) {
            await tester.tap(option);
            await tester.pumpAndSettle();

            // Assert
            expect(find.text('구토'), findsOneWidget);
          }
        }
      });

      testWidgets('should allow adjusting severity with slider', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: SymptomEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Find slider and drag it
        final slider = find.byType(Slider);
        if (slider.evaluate().isNotEmpty) {
          await tester.drag(slider.first, const Offset(50, 0));
          await tester.pumpAndSettle();

          // Assert - slider should exist and be draggable
          expect(slider, findsOneWidget);
        }
      });

      testWidgets('should display save button', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: SymptomEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('저장'), findsOneWidget);
      });
    });

    group('TC-SED-03: Invalidate Dashboard on Save', () {
      testWidgets('should validate severity range 1-10', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: SymptomEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Find slider
        final slider = find.byType(Slider);
        if (slider.evaluate().isNotEmpty) {
          final sliderWidget = tester.widget<Slider>(slider.first);

          // Assert
          expect(sliderWidget.min, 1);
          expect(sliderWidget.max, 10);
        }
      });

      testWidgets('should maintain severity within valid range', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: SymptomEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Get initial severity
        expect(find.text('7'), findsWidgets);

        // Assert severity is within range
        expect(currentLog.severity, inInclusiveRange(1, 10));
      });

      testWidgets('should show all symptom options available', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: SymptomEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert main symptom is displayed
        expect(find.text('메스꺼움'), findsOneWidget);
      });
    });
  });
}
</file>

<file path="test/features/tracking/presentation/dialogs/weight_edit_dialog_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/presentation/dialogs/weight_edit_dialog.dart';

void main() {
  group('WeightEditDialog', () {
    late WeightLog currentLog;

    setUp(() {
      currentLog = WeightLog(
        id: 'log1',
        userId: 'user123',
        logDate: DateTime(2025, 1, 15),
        weightKg: 75.5,
        createdAt: DateTime.now(),
      );
    });

    group('TC-WED-01: Display Current Weight', () {
      testWidgets('should display current weight value', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: WeightEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('75.5'), findsWidgets);
        expect(find.text('체중 수정'), findsOneWidget);
      });

      testWidgets('should show current weight in text field', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: WeightEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        final textField = find.byType(TextField);
        expect(textField, findsWidgets);
      });

      testWidgets('should display date when provided', (WidgetTester tester) async {
        // Arrange
        final logWithDate = WeightLog(
          id: 'log1',
          userId: 'user123',
          logDate: DateTime(2025, 1, 15),
          weightKg: 75.5,
          createdAt: DateTime.now(),
        );

        // Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: WeightEditDialog(
                  currentLog: logWithDate,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        expect(find.textContaining('2025'), findsOneWidget);
      });
    });

    group('TC-WED-02: Update Weight and Save', () {
      testWidgets('should allow editing weight value', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: WeightEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Find and edit weight field
        final textFields = find.byType(TextField);
        expect(textFields, findsWidgets);

        // Enter new weight
        await tester.enterText(textFields.first, '73.5');
        await tester.pumpAndSettle();

        // Assert
        expect(find.text('73.5'), findsOneWidget);
      });

      testWidgets('should display save button', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: WeightEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('저장'), findsOneWidget);
      });

      testWidgets('should accept valid weight and enable save', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: WeightEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        final textField = find.byType(TextField).first;
        await tester.enterText(textField, '72.5');
        await tester.pumpAndSettle();

        // Assert save button exists
        expect(find.text('저장'), findsOneWidget);
      });
    });

    group('TC-WED-03: Show Validation Error', () {
      testWidgets('should show error for weight below 20kg', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: WeightEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Enter invalid weight
        final textField = find.byType(TextField).first;
        await tester.enterText(textField, '15');
        await tester.pumpAndSettle();

        // Assert - error should be shown
        expect(find.textContaining('20'), findsOneWidget);
      });

      testWidgets('should show error for weight above 300kg', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: WeightEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Enter invalid weight
        final textField = find.byType(TextField).first;
        await tester.enterText(textField, '350');
        await tester.pumpAndSettle();

        // Assert
        expect(find.textContaining('300'), findsOneWidget);
      });

      testWidgets('should show error for negative weight', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: WeightEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Enter negative weight
        final textField = find.byType(TextField).first;
        await tester.enterText(textField, '-5');
        await tester.pumpAndSettle();

        // Assert
        expect(find.textContaining('양수'), findsOneWidget);
      });

      testWidgets('should show warning for borderline weight', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: WeightEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Enter borderline weight (very low but within 20-300 range)
        final textField = find.byType(TextField).first;
        await tester.enterText(textField, '25');
        await tester.pumpAndSettle();

        // Assert - should show warning
        expect(find.textContaining('비정상'), findsOneWidget);
      });

      testWidgets('should validate weight in real-time', (WidgetTester tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: WeightEditDialog(
                  currentLog: currentLog,
                  userId: 'user123',
                ),
              ),
            ),
          ),
        );

        // Enter weight and check validation
        final textField = find.byType(TextField).first;
        await tester.enterText(textField, '500');
        await tester.pump();

        // Assert error appears in real-time
        expect(find.textContaining('300'), findsOneWidget);
      });
    });
  });
}
</file>

<file path="test/features/tracking/presentation/screens/symptom_record_screen_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:n06/features/tracking/presentation/screens/symptom_record_screen.dart';
import 'package:n06/features/tracking/domain/repositories/tracking_repository.dart';
import 'package:n06/features/tracking/application/providers.dart';

class MockTrackingRepository extends Mock implements TrackingRepository {}

/// Helper function to wrap screen with mocked providers
Widget _buildTestableWidget(MockTrackingRepository mockRepo) {
  return ProviderScope(
    overrides: [
      trackingRepositoryProvider.overrideWithValue(mockRepo),
    ],
    child: MaterialApp(
      home: SymptomRecordScreen(),
    ),
  );
}

void main() {
  group('SymptomRecordScreen', () {
    late MockTrackingRepository mockTrackingRepository;

    setUp(() {
      mockTrackingRepository = MockTrackingRepository();
    });
    group('TC-SRS-01: Screen Rendering', () {
      testWidgets('should render SymptomRecordScreen',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange & Act
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Assert
        expect(find.text('증상 기록'), findsOneWidget);
        expect(find.text('증상 선택'), findsOneWidget);
        expect(find.text('심각도 (1-10점)'), findsOneWidget);
        expect(find.text('저장'), findsOneWidget);
      });

      testWidgets('should render symptom list',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange & Act
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Assert
        expect(find.text('메스꺼움'), findsOneWidget);
        expect(find.text('구토'), findsOneWidget);
        expect(find.text('변비'), findsOneWidget);
        expect(find.text('설사'), findsOneWidget);
        expect(find.text('복통'), findsOneWidget);
        expect(find.text('두통'), findsOneWidget);
        expect(find.text('피로'), findsOneWidget);
      });

      testWidgets('should render severity slider',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange & Act
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Assert
        expect(find.byType(Slider), findsOneWidget);
      });
    });

    group('TC-SRS-02: Multiple Symptom Selection', () {
      testWidgets('should allow selecting multiple symptoms',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Act
        await tester.tap(find.text('메스꺼움'));
        await tester.pump();
        await tester.tap(find.text('복통'));
        await tester.pump();

        // Assert - FilterChip이 선택되어야 함
        final filterChips = find.byType(FilterChip);
        expect(filterChips, findsWidgets);
      });
    });

    group('TC-SRS-03: Severity Slider', () {
      testWidgets('should display severity slider correctly',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange & Act
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Assert
        expect(find.byType(Slider), findsOneWidget);
        expect(find.text('현재: 5점'), findsOneWidget);
      });

      testWidgets('should update severity value when slider is dragged',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Act
        await tester.drag(find.byType(Slider), const Offset(50, 0));
        await tester.pumpAndSettle();

        // Assert
        expect(find.text('현재: 5점'), findsNothing);
      });
    });

    group('TC-SRS-04: Severity 7-10 Additional Question', () {
      testWidgets('should show 24h persistence question for severity 7-10',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Act - 심각도를 7-10으로 설정
        await tester.drag(find.byType(Slider), const Offset(100, 0));
        await tester.pumpAndSettle();

        // Assert
        expect(find.text('24시간 이상 지속되고 있나요?'), findsOneWidget);
        expect(find.text('예'), findsOneWidget);
        expect(find.text('아니오'), findsOneWidget);
      });

      testWidgets('should not show question for severity below 7',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Assert - 기본 심각도는 5점이므로 질문이 표시되지 않음
        expect(find.text('24시간 이상 지속되고 있나요?'), findsNothing);
      });
    });

    group('TC-SRS-05: Context Tag Selection', () {
      testWidgets('should allow selecting context tags for severity 1-6',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Act & Assert - 기본 심각도 5점에서 태그가 표시되어야 함
        expect(find.text('컨텍스트 태그 (선택)'), findsOneWidget);
        expect(find.text('#기름진음식'), findsOneWidget);
        expect(find.text('#과식'), findsOneWidget);
      });

      testWidgets('should not show context tags for severity 7-10',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Act - 심각도를 7로 설정
        await tester.drag(find.byType(Slider), const Offset(100, 0));
        await tester.pumpAndSettle();

        // Assert
        expect(find.text('컨텍스트 태그 (선택)'), findsNothing);
      });
    });

    group('TC-SRS-06: Memo Input', () {
      testWidgets('should allow entering memo',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Act
        await tester.enterText(
          find.byType(TextField).last,
          '추가 정보',
        );
        await tester.pump();

        // Assert
        expect(find.text('추가 정보'), findsOneWidget);
      });
    });

    group('TC-SRS-07: Escalation Days Display', () {
      testWidgets('should display days since escalation when available',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange & Act
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Note: 실제로는 escalationDate가 있어야 표시됨
        // 통합 테스트에서 검증
      });
    });

    group('TC-SRS-08: Save and Coping Guide Navigation', () {
      testWidgets('should show coping guide after saving',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Act & Assert
        // 실제 저장 및 가이드 표시는 통합 테스트에서 검증
      });
    });

    group('TC-SRS-09: Emergency Check Navigation', () {
      testWidgets('should prompt emergency check for severity 7-10 with persistence',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Note: 실제 navigation은 통합 테스트에서 검증
      });
    });

    group('TC-SRS-10: Error Handling', () {
      testWidgets('should show error when no symptom is selected',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Act - scroll down to reveal the save button
        await tester.drag(
          find.byType(SingleChildScrollView),
          const Offset(0, -500),
        );
        await tester.pumpAndSettle();

        await tester.tap(find.text('저장'));
        await tester.pumpAndSettle();

        // Assert
        expect(find.text('증상을 선택해주세요'), findsOneWidget);
      });

      testWidgets('should show error when severity 7-10 without persistence selection',
          (tester) async {
        // Configure screen size for large layouts
        tester.binding.window.physicalSizeTestValue =
          const Size(1280, 1600);
        addTearDown(tester.binding.window.clearPhysicalSizeTestValue);

        // Arrange
        await tester.pumpWidget(_buildTestableWidget(mockTrackingRepository));

        // Act
        await tester.tap(find.text('메스꺼움'));
        await tester.pump();
        await tester.drag(find.byType(Slider), const Offset(100, 0));
        await tester.pumpAndSettle();

        // Scroll down to reveal the save button
        await tester.drag(
          find.byType(SingleChildScrollView),
          const Offset(0, -500),
        );
        await tester.pumpAndSettle();

        await tester.tap(find.text('저장'));
        await tester.pumpAndSettle();

        // Assert
        expect(find.text('24시간 이상 지속 여부를 선택해주세요'), findsOneWidget);
      });
    });
  });
}
</file>

<file path="test/features/tracking/presentation/sheets/record_detail_sheet_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';
import 'package:n06/features/tracking/presentation/sheets/record_detail_sheet.dart';

void main() {
  group('RecordDetailSheet', () {
    group('TC-RDS-01: Display Record Details', () {
      testWidgets('should display weight record details', (WidgetTester tester) async {
        // Arrange
        final weightLog = WeightLog(
          id: 'log1',
          userId: 'user123',
          logDate: DateTime(2025, 1, 15),
          weightKg: 70.5,
          createdAt: DateTime(2025, 1, 15, 9, 0),
        );

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDetailSheet.weight(log: weightLog, userId: 'user123'),
            ),
          ),
        );

        // Assert
        expect(find.text('70.5'), findsOneWidget);
        expect(find.textContaining('2025'), findsOneWidget);
      });

      testWidgets('should display symptom record details', (WidgetTester tester) async {
        // Arrange
        final symptomLog = SymptomLog(
          id: 'symptom1',
          userId: 'user123',
          logDate: DateTime(2025, 1, 15),
          symptomName: '메스꺼움',
          severity: 7,
          tags: const ['기름진음식', '과식'],
          note: '저녁 식사 후 발생',
        );

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDetailSheet.symptom(log: symptomLog, userId: 'user123'),
            ),
          ),
        );

        // Assert
        expect(find.text('메스꺼움'), findsOneWidget);
        expect(find.text('7'), findsWidgets);
        expect(find.text('기름진음식'), findsOneWidget);
        expect(find.text('과식'), findsOneWidget);
      });

      testWidgets('should display dose record details', (WidgetTester tester) async {
        // Arrange
        final doseRecord = DoseRecord(
          id: 'dose1',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2025, 1, 15, 10, 0),
          actualDoseMg: 0.5,
          injectionSite: '복부',
          isCompleted: true,
          note: '정상 투여',
        );

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDetailSheet.dose(record: doseRecord, userId: 'user123'),
            ),
          ),
        );

        // Assert
        expect(find.text('0.5'), findsWidgets);
        expect(find.text('복부'), findsOneWidget);
      });

      testWidgets('should display all record information formatted correctly', (WidgetTester tester) async {
        // Arrange
        final weightLog = WeightLog(
          id: 'log1',
          userId: 'user123',
          logDate: DateTime(2025, 1, 15),
          weightKg: 75.25,
          createdAt: DateTime(2025, 1, 15, 9, 30),
        );

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDetailSheet.weight(log: weightLog, userId: 'user123'),
            ),
          ),
        );

        // Assert
        expect(find.textContaining('75'), findsOneWidget);
      });

      testWidgets('should display note for symptom record if present', (WidgetTester tester) async {
        // Arrange
        final symptomLog = SymptomLog(
          id: 'symptom1',
          userId: 'user123',
          logDate: DateTime(2025, 1, 15),
          symptomName: '메스꺼움',
          severity: 5,
          note: '저녁 식사 후 발생',
          tags: const [],
        );

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDetailSheet.symptom(log: symptomLog, userId: 'user123'),
            ),
          ),
        );

        // Assert
        expect(find.text('저녁 식사 후 발생'), findsOneWidget);
      });
    });

    group('TC-RDS-02: Open Edit Dialog', () {
      testWidgets('should display edit button for weight record', (WidgetTester tester) async {
        // Arrange
        final weightLog = WeightLog(
          id: 'log1',
          userId: 'user123',
          logDate: DateTime(2025, 1, 15),
          weightKg: 70.0,
          createdAt: DateTime.now(),
        );

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDetailSheet.weight(log: weightLog, userId: 'user123'),
            ),
          ),
        );

        // Assert
        expect(find.text('수정'), findsOneWidget);
      });

      testWidgets('should display edit button for symptom record', (WidgetTester tester) async {
        // Arrange
        final symptomLog = SymptomLog(
          id: 'symptom1',
          userId: 'user123',
          logDate: DateTime(2025, 1, 15),
          symptomName: '메스꺼움',
          severity: 5,
          tags: const [],
        );

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDetailSheet.symptom(log: symptomLog, userId: 'user123'),
            ),
          ),
        );

        // Assert
        expect(find.text('수정'), findsOneWidget);
      });

      testWidgets('should display edit button for dose record', (WidgetTester tester) async {
        // Arrange
        final doseRecord = DoseRecord(
          id: 'dose1',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2025, 1, 15, 10, 0),
          actualDoseMg: 0.5,
          injectionSite: '복부',
          isCompleted: true,
        );

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDetailSheet.dose(record: doseRecord, userId: 'user123'),
            ),
          ),
        );

        // Assert
        expect(find.text('수정'), findsOneWidget);
      });

      testWidgets('should allow opening edit dialog from sheet', (WidgetTester tester) async {
        // Arrange
        final weightLog = WeightLog(
          id: 'log1',
          userId: 'user123',
          logDate: DateTime(2025, 1, 15),
          weightKg: 70.0,
          createdAt: DateTime.now(),
        );

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDetailSheet.weight(log: weightLog, userId: 'user123'),
            ),
          ),
        );

        // Verify edit button exists and is tappable
        final editButton = find.text('수정');
        expect(editButton, findsOneWidget);
      });
    });

    group('TC-RDS-03: Open Delete Dialog', () {
      testWidgets('should display delete button for all record types', (WidgetTester tester) async {
        // Arrange
        final weightLog = WeightLog(
          id: 'log1',
          userId: 'user123',
          logDate: DateTime(2025, 1, 15),
          weightKg: 70.0,
          createdAt: DateTime.now(),
        );

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDetailSheet.weight(log: weightLog, userId: 'user123'),
            ),
          ),
        );

        // Assert
        expect(find.text('삭제'), findsOneWidget);
      });

      testWidgets('should show record info in delete context', (WidgetTester tester) async {
        // Arrange
        final weightLog = WeightLog(
          id: 'log1',
          userId: 'user123',
          logDate: DateTime(2025, 1, 15),
          weightKg: 70.5,
          createdAt: DateTime.now(),
        );

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDetailSheet.weight(log: weightLog, userId: 'user123'),
            ),
          ),
        );

        // Assert - verify weight record is displayed
        expect(find.text('70.5'), findsOneWidget);
      });

      testWidgets('should allow delete action for symptom records', (WidgetTester tester) async {
        // Arrange
        final symptomLog = SymptomLog(
          id: 'symptom1',
          userId: 'user123',
          logDate: DateTime(2025, 1, 15),
          symptomName: '메스꺼움',
          severity: 5,
          tags: const [],
        );

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDetailSheet.symptom(log: symptomLog, userId: 'user123'),
            ),
          ),
        );

        // Assert
        expect(find.text('삭제'), findsOneWidget);
        expect(find.text('메스꺼움'), findsOneWidget);
      });

      testWidgets('should allow delete action for dose records', (WidgetTester tester) async {
        // Arrange
        final doseRecord = DoseRecord(
          id: 'dose1',
          dosagePlanId: 'plan1',
          administeredAt: DateTime(2025, 1, 15, 10, 0),
          actualDoseMg: 0.5,
          injectionSite: '복부',
          isCompleted: true,
        );

        // Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: RecordDetailSheet.dose(record: doseRecord, userId: 'user123'),
            ),
          ),
        );

        // Assert
        expect(find.text('삭제'), findsOneWidget);
      });
    });
  });
}
</file>

<file path="test/features/tracking/presentation/widgets/input_validation_widget_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/presentation/widgets/input_validation_widget.dart';

void main() {
  group('InputValidationWidget', () {
    group('TC-IVW-01: Range Validation', () {
      testWidgets('should accept valid weight 20kg',
          (WidgetTester tester) async {
        // Arrange
        String? lastValue;
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (value) => lastValue = value,
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '20');
        await tester.pump();

        // Assert
        expect(lastValue, '20');
        expect(find.byIcon(Icons.check), findsOneWidget);
      });

      testWidgets('should accept valid weight 75.5kg',
          (WidgetTester tester) async {
        // Arrange
        String? lastValue;
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (value) => lastValue = value,
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '75.5');
        await tester.pump();

        // Assert
        expect(lastValue, '75.5');
        expect(find.byIcon(Icons.check), findsOneWidget);
      });

      testWidgets('should accept valid weight 300kg',
          (WidgetTester tester) async {
        // Arrange
        String? lastValue;
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (value) => lastValue = value,
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '300');
        await tester.pump();

        // Assert
        expect(lastValue, '300');
        expect(find.byIcon(Icons.check), findsOneWidget);
      });
    });

    group('TC-IVW-02: Weight Below 20kg Rejection', () {
      testWidgets('should reject weight below 20kg',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (_) {},
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '15.0');
        await tester.pump();

        // Assert
        expect(find.byIcon(Icons.close), findsOneWidget);
        expect(find.text('20kg 이상이어야 합니다'), findsOneWidget);
      });

      testWidgets('should reject weight 19.9kg',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (_) {},
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '19.9');
        await tester.pump();

        // Assert
        expect(find.byIcon(Icons.close), findsOneWidget);
        expect(find.text('20kg 이상이어야 합니다'), findsOneWidget);
      });
    });

    group('TC-IVW-03: Weight Above 300kg Rejection', () {
      testWidgets('should reject weight above 300kg',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (_) {},
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '350.0');
        await tester.pump();

        // Assert
        expect(find.byIcon(Icons.close), findsOneWidget);
        expect(find.text('300kg 이하여야 합니다'), findsOneWidget);
      });

      testWidgets('should reject weight 300.1kg',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (_) {},
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '300.1');
        await tester.pump();

        // Assert
        expect(find.byIcon(Icons.close), findsOneWidget);
        expect(find.text('300kg 이하여야 합니다'), findsOneWidget);
      });
    });

    group('TC-IVW-04: Zero Weight Rejection', () {
      testWidgets('should reject zero weight',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (_) {},
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '0');
        await tester.pump();

        // Assert
        expect(find.byIcon(Icons.close), findsOneWidget);
      });
    });

    group('TC-IVW-05: Negative Weight Rejection', () {
      testWidgets('should reject negative weight',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (_) {},
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '-50');
        await tester.pump();

        // Assert
        expect(find.byIcon(Icons.close), findsOneWidget);
      });
    });

    group('TC-IVW-06: Decimal Input Support', () {
      testWidgets('should accept decimal numbers',
          (WidgetTester tester) async {
        // Arrange
        String? lastValue;
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (value) => lastValue = value,
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '75.5');
        await tester.pump();

        // Assert
        expect(lastValue, '75.5');
        expect(find.byIcon(Icons.check), findsOneWidget);
      });

      testWidgets('should accept integer numbers',
          (WidgetTester tester) async {
        // Arrange
        String? lastValue;
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (value) => lastValue = value,
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '75');
        await tester.pump();

        // Assert
        expect(lastValue, '75');
        expect(find.byIcon(Icons.check), findsOneWidget);
      });

      testWidgets('should accept numbers with multiple decimal places',
          (WidgetTester tester) async {
        // Arrange
        String? lastValue;
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (value) => lastValue = value,
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '75.25');
        await tester.pump();

        // Assert
        expect(lastValue, '75.25');
        expect(find.byIcon(Icons.check), findsOneWidget);
      });
    });

    group('TC-IVW-07: Real-Time Validation', () {
      testWidgets('should validate on each character input',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (_) {},
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act - first character
        await tester.enterText(find.byType(TextField), '7');
        await tester.pump();

        // Assert
        expect(find.byIcon(Icons.close), findsOneWidget);
      });

      testWidgets('should update validation state when value changes',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (_) {},
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act - invalid then valid
        final textField = find.byType(TextField);
        await tester.enterText(textField, '15');
        await tester.pump();

        // Assert invalid
        expect(find.byIcon(Icons.close), findsOneWidget);

        // Act - clear and enter valid
        await tester.enterText(textField, '75');
        await tester.pump();

        // Assert valid
        expect(find.byIcon(Icons.check), findsOneWidget);
      });
    });

    group('TC-IVW-08: Error Message Display', () {
      testWidgets('should show error message for non-numeric input',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (_) {},
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), 'abc');
        await tester.pump();

        // Assert
        expect(find.text('숫자를 입력하세요'), findsOneWidget);
      });

      testWidgets('should show correct error for below minimum',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (_) {},
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '10');
        await tester.pump();

        // Assert
        expect(find.text('20kg 이상이어야 합니다'), findsOneWidget);
      });

      testWidgets('should show correct error for above maximum',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (_) {},
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '400');
        await tester.pump();

        // Assert
        expect(find.text('300kg 이하여야 합니다'), findsOneWidget);
      });
    });

    group('TC-IVW-09: Focus Changes', () {
      testWidgets('should handle focus changes correctly',
          (WidgetTester tester) async {
        // Arrange
        String? lastValue;
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (value) => lastValue = value,
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act - enter text and lose focus
        await tester.enterText(find.byType(TextField), '75');
        await tester.pump();

        // Assert
        expect(lastValue, '75');
        expect(find.byIcon(Icons.check), findsOneWidget);
      });
    });

    group('TC-IVW-10: Clear Input', () {
      testWidgets('should show no error for empty input',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (_) {},
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(find.byType(TextField), '');
        await tester.pump();

        // Assert
        expect(find.byIcon(Icons.close), findsNothing);
      });

      testWidgets('should clear validation icon when input is cleared',
          (WidgetTester tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: InputValidationWidget(
                fieldName: '체중',
                onChanged: (_) {},
                label: '체중 (kg)',
                hint: '예: 75.5',
              ),
            ),
          ),
        );

        // Act
        final textField = find.byType(TextField);
        await tester.enterText(textField, '75');
        await tester.pump();

        // Assert check icon exists
        expect(find.byIcon(Icons.check), findsOneWidget);

        // Act - clear
        await tester.enterText(textField, '');
        await tester.pump();

        // Assert icon removed
        expect(find.byIcon(Icons.check), findsNothing);
      });
    });
  });
}
</file>

<file path="test/widget_test.dart">
// Widget test for the application
// This test verifies the basic app structure is working correctly

import 'package:flutter_test/flutter_test.dart';

void main() {
  // Placeholder for widget tests
  // Future tests will be added for specific feature screens
  testWidgets('App can be instantiated', (WidgetTester tester) async {
    // This is a placeholder test to ensure the app structure is valid
    expect(true, true);
  });
}
</file>

<file path="README.md">
# GLP-1 치료 관리 MVP (Phase 0)

GLP-1 사용자의 복잡한 개인별 투여 스케줄을 자동 관리하고, 주요 증상 및 체중 변화를 기록하며, 데이터 기반 보고서를 자동 생성하는 Flutter 기반 건강관리 애플리케이션입니다.

## 🎯 핵심 가치

| 항목 | 내용 |
| :--- | :--- |
| **안전성** | 투여 스케줄 관리, 응급 증상 체크리스트 |
| **효율성** | 데이터 기반 치료 관리, 의료진과의 데이터 공유 |
| **동기 부여** | 성취감, 개인화 인사, 뱃지, 진행도 대시보드 |

## 🚀 핵심 기능 (Features)

### F000: 온보딩 & 목표 설정
- 초기 사용자 프로필 설정
- GLP-1 투여 계획 및 치료 목표 설정

### F001: 투여 스케줄러
- 개인별 투여 스케줄 자동 관리
- 투여 완료 기록
- 주사 부위 순환 관리

### F002: 체중/증상 기록
- 체중 변화 추적
- 부작용 및 증상 기록
- 기록 이력 관리

### F003: 데이터 공유 모드
- 읽기 전용 요약 리포트
- 의료진과의 안전한 데이터 공유

### F004: 부작용 대처 가이드
- 증상별 맞춤 대처 방법 제시
- 전문가 조언 기반 가이드

### F005: 증상 체크
- 심각한 증상 체크리스트
- 전문가 상담 필요성 판단
- 응급 상황 안내

### F006: 홈 대시보드 (동기 부여 중심)
- 치료 진행 상황 요약
- 개인화 인사말 및 뱃지
- 주간 진행도 및 타임라인
- 퀵 액션: 체중, 증상, 투여 기록

## 🏗️ 기술 스택

- **Frontend**: Flutter
- **Local Database**: Isar
- **Backend**: Supabase (Phase 1+)
- **Architecture**: Repository Pattern
- **State Management**: Riverpod

## 📁 프로젝트 구조

```
lib/
├── features/
│   ├── authentication/
│   ├── medication_scheduler/
│   ├── health_record/
│   ├── symptom_check/
│   ├── data_sharing/
│   ├── home/
│   └── settings/
├── core/
│   ├── constants/
│   └── theme/
└── main.dart
```

## 📋 사용자 여정 (User Scenarios)

| 시나리오 | 타겟 | 여정 | 기능 |
| :--- | :--- | :--- | :--- |
| **SC0. 치료 시작** | 신규 사용자 | 로그인 → 온보딩 → 홈 | F001, F000 |
| **SC1. 일상 투여 & 기록** | 활성 사용자 | 알림 → 투여 기록 → 증상 기록 → 가이드 | F001, F002, F004 |
| **SC2. 전문가 상담** | 정기 상담 사용자 | 홈 → 데이터 공유 모드 진입 | F003 |
| **SC3. 응급 증상** | 위기 사용자 | 홈 → 증상 체크 → 전문가 상담 안내 | F005 |
| **SC4. 동기 부여** | 꾸준한 사용자 | 홈 대시보드 → 성취감/뱃지 확인 | F006 |

## 🔄 개발 가이드

### 의존성 규칙 (Non-negotiable)
```
Presentation → Application → Domain ← Infrastructure
```

### Repository Pattern
```
Application/Presentation → Repository Interface (Domain)
                        → Repository Implementation (Infrastructure)
```

### 코드 배치 규칙
```dart
// UI 렌더링 → Presentation Layer
features/{feature}/presentation/screens/

// 상태 관리 & UseCase → Application Layer
features/{feature}/application/notifiers/

// 비즈니스 로직 & 데이터 모델 → Domain Layer
features/{feature}/domain/entities/
features/{feature}/domain/repositories/

// DB 접근 & DTO 변환 → Infrastructure Layer
features/{feature}/infrastructure/repositories/
features/{feature}/infrastructure/dtos/
```

## ✅ 개발 전 필수 확인

- [ ] `flutter test` 모든 테스트 통과
- [ ] `flutter analyze` 경고 없음
- [ ] TDD 사이클 완료 (test first, code second)
- [ ] Repository Pattern 유지
- [ ] 레이어 간 의존성 위반 없음
- [ ] 성능 제약 조건 충족

## 📚 추가 문서

- [Architecture Guide](docs/code_structure.md)
- [State Management](docs/state-management.md)
- [Database Schema](docs/database.md)
- [Testing Guide](docs/tdd.md)
- [Tech Stack Details](docs/techstack.md)
- [Product Requirements](docs/prd.md)

## 🚀 Getting Started

```bash
# 의존성 설치
flutter pub get

# 코드 생성 (Riverpod, Freezed 등)
flutter pub run build_runner build

# 앱 실행
flutter run

# 테스트 실행
flutter test

# 분석 (경고 확인)
flutter analyze
```

## 📞 문의 및 피드백

이 프로젝트는 GLP-1 치료 사용자의 안전하고 효율적인 치료 관리를 목표로 개발되고 있습니다.
피드백이나 질문은 이슈 트래커를 통해 등록해주세요.
</file>

<file path="lib/core/routing/app_router.dart">
import 'dart:developer' as developer;
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:n06/features/authentication/presentation/screens/login_screen.dart';
import 'package:n06/features/dashboard/presentation/screens/home_dashboard_screen.dart';
import 'package:n06/features/settings/presentation/screens/settings_screen.dart';
import 'package:n06/features/profile/presentation/screens/profile_edit_screen.dart';
import 'package:n06/features/profile/presentation/screens/weekly_goal_settings_screen.dart';
import 'package:n06/features/tracking/presentation/screens/edit_dosage_plan_screen.dart';
import 'package:n06/features/notification/presentation/screens/notification_settings_screen.dart';
import 'package:n06/features/tracking/presentation/screens/emergency_check_screen.dart';
import 'package:n06/features/tracking/presentation/screens/weight_record_screen.dart';
import 'package:n06/features/tracking/presentation/screens/symptom_record_screen.dart';
import 'package:n06/features/coping_guide/presentation/screens/coping_guide_screen.dart';
import 'package:n06/features/data_sharing/presentation/screens/data_sharing_screen.dart';
import 'package:n06/features/onboarding/presentation/screens/onboarding_screen.dart';

/// GoRouter configuration for the application
final appRouter = GoRouter(
  initialLocation: '/login',
  // Handle errors from Kakao OAuth callbacks gracefully
  onException: (context, state, router) {
    final uri = state.uri;
    if (kDebugMode) {
      developer.log('GoRouter exception for: $uri', name: 'AppRouter');
    }

    // If it's a Kakao OAuth callback error, just ignore it
    // The Kakao SDK will handle the callback
    if (uri.scheme.startsWith('kakao')) {
      if (kDebugMode) {
        developer.log('Ignoring Kakao OAuth callback error in GoRouter', name: 'AppRouter');
      }
      return; // Don't navigate anywhere
    }

    // For other errors, go to login
    router.go('/login');
  },
  routes: [
    /// Authentication
    GoRoute(
      path: '/login',
      name: 'login',
      builder: (context, state) => const LoginScreen(),
    ),

    /// Onboarding (F000)
    GoRoute(
      path: '/onboarding',
      name: 'onboarding',
      builder: (context, state) {
        final userId = state.extra as String?;
        return OnboardingScreen(userId: userId);
      },
    ),

    /// Home/Dashboard (F006)
    GoRoute(
      path: '/home',
      name: 'home',
      builder: (context, state) => const HomeDashboardScreen(),
    ),

    /// Root path redirects to home
    GoRoute(
      path: '/',
      redirect: (context, state) => '/home',
    ),

    /// Settings (UF-SETTINGS / 009)
    GoRoute(
      path: '/settings',
      name: 'settings',
      builder: (context, state) => const SettingsScreen(),
    ),

    /// Profile Management (UF-008)
    GoRoute(
      path: '/profile/edit',
      name: 'profile_edit',
      builder: (context, state) => const ProfileEditScreen(),
    ),

    /// Dosage Plan Edit (UF-009)
    GoRoute(
      path: '/dose-plan/edit',
      name: 'dose_plan_edit',
      builder: (context, state) => const EditDosagePlanScreen(),
    ),

    /// Weekly Goal Settings (UF-013/015)
    GoRoute(
      path: '/weekly-goal/edit',
      name: 'weekly_goal_edit',
      builder: (context, state) => const WeeklyGoalSettingsScreen(),
    ),

    /// Notification Settings (UF-012)
    GoRoute(
      path: '/notification/settings',
      name: 'notification_settings',
      builder: (context, state) => const NotificationSettingsScreen(),
    ),

    /// Emergency Symptoms Check (UF-005)
    GoRoute(
      path: '/emergency/check',
      name: 'emergency_check',
      builder: (context, state) => const EmergencyCheckScreen(),
    ),

    /// Tracking - Weight Record (F002)
    GoRoute(
      path: '/tracking/weight',
      name: 'weight_record',
      builder: (context, state) => const WeightRecordScreen(),
    ),

    /// Tracking - Symptom Record (F002)
    GoRoute(
      path: '/tracking/symptom',
      name: 'symptom_record',
      builder: (context, state) => const SymptomRecordScreen(),
    ),

    /// Coping Guide (F004)
    GoRoute(
      path: '/coping-guide',
      name: 'coping_guide',
      builder: (context, state) => const CopingGuideScreen(),
    ),

    /// Data Sharing (F003)
    GoRoute(
      path: '/data-sharing',
      name: 'data_sharing',
      builder: (context, state) => const DataSharingScreen(),
    ),
  ],
);
</file>

<file path="lib/features/authentication/infrastructure/datasources/kakao_auth_datasource.dart">
import 'dart:async';
import 'dart:developer' as developer;
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart' show debugPrint;
import 'package:flutter/services.dart';
import 'package:kakao_flutter_sdk/kakao_flutter_sdk.dart';

/// Data source for Kakao OAuth 2.0 authentication.
///
/// Implements the official Kakao Flutter SDK login pattern:
/// 1. Check if KakaoTalk is installed
/// 2. Try KakaoTalk login first
/// 3. Fallback to Account login if KakaoTalk fails
/// 4. Propagate CANCELED exception without retry
class KakaoAuthDataSource {
  /// Performs Kakao login following official best practices.
  ///
  /// Login flow:
  /// - If KakaoTalk is installed: try loginWithKakaoTalk()
  /// - If KakaoTalk fails (except user cancel): fallback to loginWithKakaoAccount()
  /// - If KakaoTalk is not installed: use loginWithKakaoAccount() directly
  ///
  /// Throws:
  /// - [PlatformException] with code 'CANCELED' if user cancels (no retry needed)
  /// - [Exception] for other authentication failures
  Future<OAuthToken> login() async {
    try {
      debugPrint('🔍 [HEALTH CHECK] KakaoAuthDataSource.login() called');
      debugPrint('🔍 [HEALTH CHECK] Current thread: ${DateTime.now().millisecondsSinceEpoch}');
      if (kDebugMode) {
        developer.log('🚀 Starting Kakao login...', name: 'KakaoAuthDataSource');
      }

      // Check if we already have a valid token
      if (await AuthApi.instance.hasToken()) {
        debugPrint('🔍 [HEALTH CHECK] Existing token found, checking validity...');
        try {
          final tokenInfo = await UserApi.instance.accessTokenInfo();
          debugPrint('🔍 [HEALTH CHECK] Token is still valid, expires in ${tokenInfo.expiresIn} seconds');
          final token = await TokenManagerProvider.instance.manager.getToken();
          if (token != null) {
            debugPrint('🔍 [HEALTH CHECK] Returning existing valid token');
            return token;
          }
        } catch (e) {
          debugPrint('🔍 [HEALTH CHECK] Existing token is invalid: $e');
        }
      }

      if (await isKakaoTalkInstalled()) {
        debugPrint('🔍 [HEALTH CHECK] KakaoTalk is installed');
        if (kDebugMode) {
          developer.log('📱 KakaoTalk installed, trying KakaoTalk login', name: 'KakaoAuthDataSource');
        }
        try {
          debugPrint('🔍 [HEALTH CHECK] About to call loginWithKakaoTalk()...');
          debugPrint('🔍 [HEALTH CHECK] Creating Future for loginWithKakaoTalk()...');
          final Future<OAuthToken> loginFuture = UserApi.instance.loginWithKakaoTalk();
          debugPrint('🔍 [HEALTH CHECK] Future created, awaiting result...');

          final token = await loginFuture.timeout(
            const Duration(seconds: 120),
            onTimeout: () {
              debugPrint('🔍 [HEALTH CHECK] ⚠️ LOGIN TIMEOUT after 120 seconds!');
              throw TimeoutException('KakaoTalk login timed out after 120 seconds');
            },
          );

          debugPrint('🔍 [HEALTH CHECK] KakaoTalk login returned token: ${token.accessToken.substring(0, 20)}...');
          if (kDebugMode) {
            developer.log('✅ KakaoTalk login successful', name: 'KakaoAuthDataSource');
          }
          return token;
        } catch (error) {
          debugPrint('🔍 [HEALTH CHECK] KakaoTalk login threw error: $error');
          debugPrint('🔍 [HEALTH CHECK] Error type: ${error.runtimeType}');
          if (kDebugMode) {
            developer.log('⚠️ KakaoTalk login failed: $error', name: 'KakaoAuthDataSource');
          }
          // If user cancels, propagate the exception immediately
          if (error is PlatformException && error.code == 'CANCELED') {
            debugPrint('🔍 [HEALTH CHECK] User canceled login, rethrowing');
            rethrow;
          }

          // For other errors (e.g., KakaoTalk login unavailable),
          // fallback to Account login
          debugPrint('🔍 [HEALTH CHECK] Falling back to Account login');
          if (kDebugMode) {
            developer.log('🔄 Falling back to Account login', name: 'KakaoAuthDataSource');
          }
          debugPrint('🔍 [HEALTH CHECK] Creating Future for loginWithKakaoAccount() fallback...');
          final token = await UserApi.instance.loginWithKakaoAccount().timeout(
            const Duration(seconds: 120),
            onTimeout: () {
              debugPrint('🔍 [HEALTH CHECK] ⚠️ ACCOUNT LOGIN TIMEOUT after 120 seconds!');
              throw TimeoutException('Account login timed out after 120 seconds');
            },
          );
          debugPrint('🔍 [HEALTH CHECK] Account login returned token: ${token.accessToken.substring(0, 20)}...');
          if (kDebugMode) {
            developer.log('✅ Account login successful', name: 'KakaoAuthDataSource');
          }
          return token;
        }
      } else {
        // KakaoTalk not installed, use Account login directly
        debugPrint('🔍 [HEALTH CHECK] KakaoTalk not installed, using Account login');
        if (kDebugMode) {
          developer.log('🌐 KakaoTalk not installed, using Account login', name: 'KakaoAuthDataSource');
        }
        debugPrint('🔍 [HEALTH CHECK] About to call loginWithKakaoAccount()...');
        debugPrint('🔍 [HEALTH CHECK] Creating Future for loginWithKakaoAccount()...');

        final Future<OAuthToken> loginFuture = UserApi.instance.loginWithKakaoAccount();
        debugPrint('🔍 [HEALTH CHECK] Future created, adding timeout...');

        final token = await loginFuture.timeout(
          const Duration(seconds: 120),
          onTimeout: () {
            debugPrint('🔍 [HEALTH CHECK] ⚠️ ACCOUNT LOGIN TIMEOUT after 120 seconds!');
            throw TimeoutException('Account login timed out after 120 seconds');
          },
        );

        debugPrint('🔍 [HEALTH CHECK] Account login completed successfully');
        debugPrint('🔍 [HEALTH CHECK] Token received: ${token.accessToken.substring(0, 20)}...');
        debugPrint('🔍 [HEALTH CHECK] Token expires at: ${token.expiresAt}');
        if (kDebugMode) {
          developer.log('✅ Account login successful', name: 'KakaoAuthDataSource');
          developer.log('Token details: expires at ${token.expiresAt}', name: 'KakaoAuthDataSource');
        }
        return token;
      }
    } catch (error, stackTrace) {
      debugPrint('🔍 [HEALTH CHECK] ❌ KakaoAuthDataSource.login() failed');
      debugPrint('🔍 [HEALTH CHECK] Error: $error');
      debugPrint('🔍 [HEALTH CHECK] Error type: ${error.runtimeType}');
      debugPrint('🔍 [HEALTH CHECK] Stack trace: ${stackTrace.toString().split('\n').take(10).join('\n')}');
      if (kDebugMode) {
        developer.log(
          '❌ Kakao login failed',
          name: 'KakaoAuthDataSource',
          error: error,
          stackTrace: stackTrace,
          level: 1000,
        );
      }
      rethrow;
    }
  }

  /// Retrieves Kakao user information.
  ///
  /// Returns the currently logged-in user's profile data.
  ///
  /// Throws:
  /// - [Exception] if not authenticated or API call fails
  Future<User> getUser() async {
    try {
      if (kDebugMode) {
        developer.log('🔍 Calling UserApi.instance.me()...', name: 'KakaoAuthDataSource');
      }
      final user = await UserApi.instance.me();
      if (kDebugMode) {
        developer.log(
          '✅ User info fetched successfully: id=${user.id}, nickname=${user.kakaoAccount?.profile?.nickname}',
          name: 'KakaoAuthDataSource',
        );
      }
      return user;
    } catch (error, stackTrace) {
      if (kDebugMode) {
        developer.log(
          '❌ Failed to fetch user info',
          name: 'KakaoAuthDataSource',
          error: error,
          stackTrace: stackTrace,
          level: 1000,
        );
      }
      rethrow;
    }
  }

  /// Logs out from Kakao.
  ///
  /// The SDK always deletes the local token regardless of API success,
  /// so errors are ignored to ensure local cleanup.
  Future<void> logout() async {
    try {
      await UserApi.instance.logout();
    } catch (error) {
      // SDK guarantees local token is deleted even if API fails
      // Log error but don't throw to ensure logout completes
      if (kDebugMode) {
        developer.log(
          'Kakao logout completed with error (local token still deleted)',
          name: 'KakaoAuthDataSource',
          error: error,
          level: 900,
        );
      }
    }
  }

  /// Checks if the current access token is valid.
  ///
  /// Returns:
  /// - true if token exists and is valid
  /// - false if no token or token is invalid/expired
  Future<bool> isTokenValid() async {
    // Check if token exists
    if (!await AuthApi.instance.hasToken()) {
      return false;
    }

    try {
      // Verify token validity by requesting token info
      await UserApi.instance.accessTokenInfo();
      return true;
    } catch (error) {
      // Token is invalid or expired
      return false;
    }
  }
}
</file>

<file path="lib/features/authentication/infrastructure/repositories/isar_auth_repository.dart">
import 'dart:developer' as developer;
import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:isar/isar.dart';
import 'package:n06/core/services/secure_storage_service.dart';
import 'package:n06/features/authentication/domain/entities/user.dart';
import 'package:n06/features/authentication/domain/exceptions/auth_exceptions.dart';
import 'package:n06/features/authentication/domain/repositories/auth_repository.dart';
import 'package:n06/features/authentication/infrastructure/datasources/kakao_auth_datasource.dart';
import 'package:n06/features/authentication/infrastructure/datasources/naver_auth_datasource.dart';
import 'package:n06/features/authentication/infrastructure/dtos/consent_record_dto.dart';
import 'package:n06/features/authentication/infrastructure/dtos/user_dto.dart';
import 'package:n06/features/onboarding/infrastructure/dtos/user_profile_dto.dart';

/// Isar implementation of AuthRepository.
///
/// Integrates KakaoAuthDataSource, NaverAuthDataSource, and SecureStorageService
/// to provide complete authentication functionality with:
/// - OAuth 2.0 login flow
/// - Token management
/// - User persistence
/// - Consent record tracking
/// - Automatic retry logic (up to 3 times, except for user cancellation)
class IsarAuthRepository implements AuthRepository {
  final Isar _isar;
  final KakaoAuthDataSource _kakaoDataSource;
  final NaverAuthDataSource _naverDataSource;
  final SecureStorageService _secureStorage;

  static const int _maxRetries = 3;
  static const int _retryDelayMs = 100;

  IsarAuthRepository(
    this._isar,
    this._kakaoDataSource,
    this._naverDataSource,
    this._secureStorage,
  );

  @override
  Future<User> loginWithKakao({
    required bool agreedToTerms,
    required bool agreedToPrivacy,
  }) async {
    if (kDebugMode) {
      developer.log(
        '📱 loginWithKakao called in repository',
        name: 'IsarAuthRepository',
      );
    }

    return await _retryOnNetworkError(() async {
      if (kDebugMode) {
        developer.log('1️⃣ Starting Kakao datasource login...', name: 'IsarAuthRepository');
      }

      // 1. DataSource에서 로그인
      final token = await _kakaoDataSource.login();

      if (kDebugMode) {
        developer.log(
          '✅ Token received (expires: ${token.expiresAt})',
          name: 'IsarAuthRepository',
        );
      }

      // 2. 토큰 저장
      if (kDebugMode) {
        developer.log('2️⃣ Saving tokens to secure storage...', name: 'IsarAuthRepository');
      }

      await _secureStorage.saveAccessToken(token.accessToken, token.expiresAt);
      await _secureStorage.saveRefreshToken(token.refreshToken!);

      // 3. 사용자 정보 가져오기
      if (kDebugMode) {
        developer.log('3️⃣ Fetching user info...', name: 'IsarAuthRepository');
      }

      final kakaoUser = await _kakaoDataSource.getUser();

      if (kDebugMode) {
        developer.log(
          '✅ User info received (id: ${kakaoUser.id})',
          name: 'IsarAuthRepository',
        );
      }

      // 4. Domain Entity로 변환
      final user = User(
        id: kakaoUser.id.toString(),
        oauthProvider: 'kakao',
        oauthUserId: kakaoUser.id.toString(),
        name: kakaoUser.kakaoAccount?.profile?.nickname ?? '',
        email: kakaoUser.kakaoAccount?.email ?? '',
        profileImageUrl: kakaoUser.kakaoAccount?.profile?.profileImageUrl,
        lastLoginAt: DateTime.now(),
      );

      // 5. Isar에 저장
      if (kDebugMode) {
        developer.log('4️⃣ Saving user to Isar...', name: 'IsarAuthRepository');
      }

      await _saveUserToIsar(user);
      await _saveConsentToIsar(user.id, agreedToTerms, agreedToPrivacy);

      if (kDebugMode) {
        developer.log(
          '✅ Login completed successfully (user: ${user.id})',
          name: 'IsarAuthRepository',
        );
      }

      return user;
    });
  }

  @override
  Future<User> loginWithNaver({
    required bool agreedToTerms,
    required bool agreedToPrivacy,
  }) async {
    return await _retryOnNetworkError(() async {
      // 1. DataSource에서 로그인
      final result = await _naverDataSource.login();

      // 2. 토큰 가져오기
      final token = await _naverDataSource.getCurrentToken();

      // 3. 토큰 저장
      // NaverAccessToken.expiresAt is String, need to parse it
      DateTime expiresAt;
      try {
        expiresAt = DateTime.parse(token.expiresAt);
      } catch (e) {
        // If parsing fails, set expiry to 2 hours from now as fallback
        expiresAt = DateTime.now().add(const Duration(hours: 2));
      }
      await _secureStorage.saveAccessToken(token.accessToken, expiresAt);
      await _secureStorage.saveRefreshToken(token.refreshToken);

      // 4. 사용자 정보 가져오기 (result.account 사용)
      final account = result.account;
      if (account == null) {
        throw Exception('Failed to get Naver account information');
      }

      // 5. Domain Entity로 변환
      final user = User(
        id: account.id ?? '',
        oauthProvider: 'naver',
        oauthUserId: account.id ?? '',
        name: account.name ?? '',
        email: account.email ?? '',
        profileImageUrl: account.profileImage,
        lastLoginAt: DateTime.now(),
      );

      // 6. Isar에 저장
      await _saveUserToIsar(user);
      await _saveConsentToIsar(user.id, agreedToTerms, agreedToPrivacy);

      return user;
    });
  }

  @override
  Future<void> logout() async {
    try {
      // 현재 사용자 확인 후 적절한 DataSource 호출
      final user = await getCurrentUser();
      if (user?.oauthProvider == 'kakao') {
        await _kakaoDataSource.logout();
      } else if (user?.oauthProvider == 'naver') {
        await _naverDataSource.logout();
      }
    } catch (error) {
      // 네트워크 오류 무시
      if (kDebugMode) {
        developer.log(
          'Logout network error ignored (local cleanup will still proceed)',
          name: 'IsarAuthRepository',
          error: error,
          level: 900,
        );
      }
    } finally {
      // 로컬 토큰은 반드시 삭제
      await _secureStorage.deleteAllTokens();
    }
  }

  @override
  Future<User?> getCurrentUser() async {
    final userDto = await _isar.userDtos.where().findFirst();
    return userDto?.toEntity();
  }

  @override
  Future<bool> isFirstLogin() async {
    // UserProfile이 있는지 확인 (온보딩 완료 여부)
    final user = await getCurrentUser();
    if (user == null) return true;

    // UserProfileDto 확인
    final profileCount = await _isar.userProfileDtos
        .filter()
        .userIdEqualTo(user.id)
        .count();

    return profileCount == 0;
  }

  @override
  Future<bool> isAccessTokenValid() async {
    return !(await _secureStorage.isAccessTokenExpired());
  }

  @override
  Future<String> refreshAccessToken(String refreshToken) async {
    // Phase 0에서는 토큰 갱신 미구현
    // Phase 1에서 Supabase와 함께 구현 예정
    throw UnimplementedError('Token refresh will be implemented in Phase 1');
  }

  /// 사용자를 Isar에 저장 (기존 사용자면 업데이트)
  Future<void> _saveUserToIsar(User user) async {
    await _isar.writeTxn(() async {
      // 기존 사용자 확인 (oauthProvider + oauthUserId로 검색)
      final existing = await _isar.userDtos
          .filter()
          .oauthProviderEqualTo(user.oauthProvider)
          .and()
          .oauthUserIdEqualTo(user.oauthUserId)
          .findFirst();

      if (existing != null) {
        // 기존 사용자 업데이트
        existing.name = user.name;
        existing.email = user.email;
        existing.profileImageUrl = user.profileImageUrl;
        existing.lastLoginAt = user.lastLoginAt;
        await _isar.userDtos.put(existing);
      } else {
        // 신규 사용자 생성
        final dto = UserDto.fromEntity(user);
        await _isar.userDtos.put(dto);
      }
    });
  }

  /// 동의 정보를 Isar에 저장
  Future<void> _saveConsentToIsar(
    String userId,
    bool agreedToTerms,
    bool agreedToPrivacy,
  ) async {
    await _isar.writeTxn(() async {
      final consent = ConsentRecordDto()
        ..userId = userId
        ..termsOfService = agreedToTerms
        ..privacyPolicy = agreedToPrivacy
        ..agreedAt = DateTime.now();

      await _isar.consentRecordDtos.put(consent);
    });
  }

  /// 재시도 로직 헬퍼 메서드
  ///
  /// [operation] 실행할 비동기 작업
  /// [shouldRetry] 에러 발생 시 재시도 여부를 판단하는 함수 (null이면 항상 재시도)
  /// [maxRetries] 최대 재시도 횟수 (기본값: 3)
  ///
  /// 재시도 시 exponential backoff 적용
  Future<T> _retryOnNetworkError<T>(
    Future<T> Function() operation, {
    bool Function(dynamic)? shouldRetry,
    int maxRetries = _maxRetries,
  }) async {
    for (int i = 0; i < maxRetries; i++) {
      try {
        return await operation();
      } catch (error, stackTrace) {
        if (kDebugMode) {
          developer.log(
            'Retry attempt ${i + 1}/$maxRetries failed',
            name: 'IsarAuthRepository',
            error: error,
            stackTrace: stackTrace,
            level: 900,
          );
        }

        // PlatformException CANCELED는 즉시 전파
        if (error is PlatformException && error.code == 'CANCELED') {
          if (kDebugMode) {
            developer.log(
              '🚫 User cancelled - not retrying',
              name: 'IsarAuthRepository',
              error: error,
              level: 1000,
            );
          }
          throw OAuthCancelledException('User cancelled OAuth login');
        }

        // MissingPluginException은 플랫폼 설정 문제 - 재시도 불가
        if (error.toString().contains('MissingPluginException')) {
          if (kDebugMode) {
            developer.log(
              '❌ CRITICAL: Kakao SDK not configured for macOS',
              name: 'IsarAuthRepository',
              error: error,
              stackTrace: stackTrace,
              level: 1000,
            );
            developer.log(
              'Please check: https://github.com/kakao/kakao_flutter_sdk',
              name: 'IsarAuthRepository',
              level: 1000,
            );
          }
          rethrow;
        }

        // shouldRetry가 false를 반환하면 즉시 전파
        if (shouldRetry != null && !shouldRetry(error)) {
          if (kDebugMode) {
            developer.log(
              '⛔ Retry not allowed for this error type',
              name: 'IsarAuthRepository',
              error: error,
              level: 1000,
            );
          }
          rethrow;
        }

        // 마지막 재시도에서 실패하면 예외 발생
        if (i == maxRetries - 1) {
          if (kDebugMode) {
            developer.log(
              '❌ Max retries exceeded',
              name: 'IsarAuthRepository',
              error: error,
              stackTrace: stackTrace,
              level: 1000,
            );
          }
          throw MaxRetriesExceededException('Max retries exceeded: $error');
        }

        // Exponential backoff
        if (kDebugMode) {
          developer.log(
            '🔄 Retrying in ${_retryDelayMs * (i + 1)}ms...',
            name: 'IsarAuthRepository',
            level: 900,
          );
        }
        await Future.delayed(Duration(milliseconds: _retryDelayMs * (i + 1)));
      }
    }

    throw MaxRetriesExceededException('Max retries exceeded');
  }
}
</file>

<file path="lib/features/dashboard/application/notifiers/dashboard_notifier.dart">
import 'package:n06/features/dashboard/domain/entities/dashboard_data.dart';
import 'package:n06/features/dashboard/domain/entities/next_schedule.dart';
import 'package:n06/features/dashboard/domain/entities/timeline_event.dart';
import 'package:n06/features/dashboard/domain/entities/weekly_summary.dart';
import 'package:n06/features/dashboard/domain/repositories/badge_repository.dart';
import 'package:n06/features/dashboard/domain/usecases/calculate_continuous_record_days_usecase.dart';
import 'package:n06/features/dashboard/domain/usecases/calculate_current_week_usecase.dart';
import 'package:n06/features/dashboard/domain/usecases/calculate_weight_goal_estimate_usecase.dart';
import 'package:n06/features/dashboard/domain/usecases/calculate_weekly_progress_usecase.dart';
import 'package:n06/features/dashboard/domain/usecases/verify_badge_conditions_usecase.dart';
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/onboarding/domain/repositories/profile_repository.dart';
import 'package:n06/features/onboarding/domain/repositories/medication_repository.dart'
    as onboarding_medication_repo;
import 'package:n06/features/onboarding/domain/entities/dosage_plan.dart'
    as onboarding_dosage_plan;
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/domain/repositories/tracking_repository.dart';
import 'package:n06/features/onboarding/application/providers.dart'
    as onboarding_providers;
import 'package:n06/features/tracking/application/providers.dart'
    as tracking_providers;
import 'package:n06/features/dashboard/application/providers.dart';
import 'package:n06/features/authentication/application/notifiers/auth_notifier.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'dashboard_notifier.g.dart';

@riverpod
class DashboardNotifier extends _$DashboardNotifier {
  late ProfileRepository _profileRepository;
  late TrackingRepository _trackingRepository;
  late onboarding_medication_repo.MedicationRepository _medicationRepository;
  late BadgeRepository _badgeRepository;

  final _calculateContinuousRecordDays = CalculateContinuousRecordDaysUseCase();
  final _calculateCurrentWeek = CalculateCurrentWeekUseCase();
  final _calculateWeeklyProgress = CalculateWeeklyProgressUseCase();
  final _calculateWeightGoalEstimate = CalculateWeightGoalEstimateUseCase();
  final _verifyBadgeConditions = VerifyBadgeConditionsUseCase();

  @override
  Future<DashboardData> build() async {
    // 인증 상태에서 userId 가져오기
    final authState = ref.watch(authNotifierProvider);
    final userId = authState.value?.id;

    if (userId == null) {
      throw Exception('User not authenticated');
    }

    // repositories 초기화
    _profileRepository = ref.watch(onboarding_providers.profileRepositoryProvider);
    _trackingRepository = ref.watch(tracking_providers.trackingRepositoryProvider);
    _medicationRepository =
        ref.watch(onboarding_providers.medicationRepositoryProvider);
    _badgeRepository = ref.watch(badgeRepositoryProvider);

    return _loadDashboardData(userId);
  }

  Future<void> refresh() async {
    final authState = ref.watch(authNotifierProvider);
    final userId = authState.value?.id;

    if (userId == null) {
      throw Exception('User not authenticated');
    }

    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() => _loadDashboardData(userId));
  }

  Future<DashboardData> _loadDashboardData(String userId) async {
    // 프로필 조회
    final profile = await _profileRepository.getUserProfile(userId);
    if (profile == null) {
      throw Exception('User profile not found - Please complete onboarding first');
    }

    // 활성 투여 계획 조회
    final activePlan =
        await _medicationRepository.getActiveDosagePlan(userId);
    if (activePlan == null) {
      throw Exception('Active dosage plan not found - Please set up your medication plan');
    }

    // 체중 기록, 부작용 기록 조회
    final weights = await _trackingRepository.getWeightLogs(userId);
    final symptoms = await _trackingRepository.getSymptomLogs(userId);

    // 연속 기록일 계산
    final symptomLogs = symptoms.cast<SymptomLog>();
    final continuousRecordDays = _calculateContinuousRecordDays.execute(
        weights, symptomLogs);

    // 현재 주차 계산
    final currentWeek =
        _calculateCurrentWeek.execute(activePlan.startDate.value);

    // 주간 목표 진행도 계산 (임시 데이터)
    final weeklyProgress = _calculateWeeklyProgress.execute(
      doseRecords: [],
      weightLogs: weights,
      symptomLogs: symptomLogs,
      doseTargetCount: 1,
      weightTargetCount: profile.weeklyWeightRecordGoal,
      symptomTargetCount: profile.weeklySymptomRecordGoal,
    );

    // 다음 투여 일정
    final nextSchedule = _calculateNextSchedule(activePlan, weights, profile);

    // 주간 요약
    final weeklySummary = _calculateWeeklySummary(weights, symptoms);

    // 뱃지 조회 및 검증
    final userBadges = await _badgeRepository.getUserBadges(userId);
    final currentWeightKg = weights.isNotEmpty
        ? weights.reduce((a, b) => a.logDate.isAfter(b.logDate) ? a : b).weightKg
        : profile.targetWeight.value + 5;
    final startWeightKg = weights.isNotEmpty
        ? weights
            .reduce((a, b) => a.logDate.isBefore(b.logDate) ? a : b)
            .weightKg
        : currentWeightKg;
    final weightLossPercentage = startWeightKg > 0
        ? ((startWeightKg - currentWeightKg) / startWeightKg) * 100
        : 0.0;

    final updatedBadges = _verifyBadgeConditions.execute(
      currentBadges: userBadges,
      continuousRecordDays: continuousRecordDays,
      weightLossPercentage: weightLossPercentage,
      hasFirstDose: false,
      allDoseRecords: [],
    );

    // 타임라인 생성
    final timeline = _buildTimeline(activePlan, profile, weights);

    return DashboardData(
      userName: profile.userId,
      continuousRecordDays: continuousRecordDays,
      currentWeek: currentWeek,
      weeklyProgress: weeklyProgress,
      nextSchedule: nextSchedule,
      weeklySummary: weeklySummary,
      badges: updatedBadges,
      timeline: timeline,
      insightMessage: _generateInsightMessage(
        continuousRecordDays,
        weightLossPercentage,
        weeklyProgress,
      ),
    );
  }

  NextSchedule _calculateNextSchedule(
    onboarding_dosage_plan.DosagePlan activePlan,
    List<WeightLog> weights,
    UserProfile profile,
  ) {
    final now = DateTime.now();

    // 현재 체중 가져오기
    final currentWeightKg = weights.isNotEmpty
        ? weights
            .reduce((a, b) => a.logDate.isAfter(b.logDate) ? a : b)
            .weightKg
        : profile.targetWeight.value + 5.0;

    // 목표 체중 도달 예상일 계산
    final goalEstimateDate = _calculateWeightGoalEstimate.execute(
      currentWeight: currentWeightKg,
      targetWeight: profile.targetWeight.value,
      weightLogs: weights,
    );

    return NextSchedule(
      nextDoseDate: now.add(Duration(days: 1)),
      nextDoseMg: activePlan.initialDoseMg,
      nextEscalationDate: null,
      goalEstimateDate: goalEstimateDate,
    );
  }

  WeeklySummary _calculateWeeklySummary(
    List<WeightLog> weights,
    List<dynamic> symptoms,
  ) {
    final now = DateTime.now();
    final sevenDaysAgo = now.subtract(Duration(days: 7));

    // 지난 7일간 체중 변화
    final recentWeights = weights
        .where((w) => w.logDate.isAfter(sevenDaysAgo))
        .toList()
      ..sort((a, b) => a.logDate.compareTo(b.logDate));

    final weightChange = recentWeights.length >= 2
        ? recentWeights.first.weightKg - recentWeights.last.weightKg
        : 0.0;

    // 지난 7일간 기록한 증상 개수
    final symptomCount = symptoms
        .where((s) {
          final date = (s as dynamic).logDate as DateTime;
          return date.isAfter(sevenDaysAgo);
        })
        .length;

    return WeeklySummary(
      doseCompletedCount: 0,
      weightChangeKg: weightChange,
      symptomRecordCount: symptomCount,
      adherencePercentage: 85.0,
    );
  }

  List<TimelineEvent> _buildTimeline(
    onboarding_dosage_plan.DosagePlan activePlan,
    UserProfile profile,
    List<WeightLog> weights,
  ) {
    final events = <TimelineEvent>[];

    // 가중치가 없으면 빈 타임라인 반환
    if (weights.isEmpty) return events;

    // 1. 치료 시작일 이벤트
    events.add(
      TimelineEvent(
        id: 'treatment_start',
        dateTime: activePlan.startDate.value,
        eventType: TimelineEventType.treatmentStart,
        title: '치료 시작',
        description: '${activePlan.initialDoseMg}mg 투여 시작',
      ),
    );

    // 2. 용량 증량 이벤트 (escalationPlan이 있을 경우)
    if (activePlan.escalationPlan != null &&
        activePlan.escalationPlan!.isNotEmpty) {
      for (final step in activePlan.escalationPlan!) {
        final escalationDate = activePlan.startDate.value
            .add(Duration(days: step.weeks * 7));
        events.add(
          TimelineEvent(
            id: 'escalation_${step.doseMg.toStringAsFixed(1)}',
            dateTime: escalationDate,
            eventType: TimelineEventType.escalation,
            title: '용량 증량',
            description: '${step.doseMg.toStringAsFixed(2)}mg로 증량',
          ),
        );
      }
    }

    // 3. 체중 마일스톤 이벤트 (25%, 50%, 75%, 100%)
    if (weights.isNotEmpty) {
      final startWeight = weights
          .reduce((a, b) => a.logDate.isBefore(b.logDate) ? a : b)
          .weightKg;
      final targetWeight = profile.targetWeight.value;
      final totalLossNeeded = startWeight - targetWeight;

      if (totalLossNeeded > 0) {
        for (final milestone in [0.25, 0.50, 0.75, 1.0]) {
          final targetLoss = totalLossNeeded * milestone;
          final milestoneWeight = startWeight - targetLoss;

          WeightLog? firstLogBelowMilestone;
          for (final w in weights) {
            if (w.weightKg <= milestoneWeight) {
              if (firstLogBelowMilestone == null ||
                  w.logDate.isBefore(firstLogBelowMilestone.logDate)) {
                firstLogBelowMilestone = w;
              }
            }
          }

          if (firstLogBelowMilestone != null) {
            events.add(
              TimelineEvent(
                id: 'milestone_${(milestone * 100).toInt()}',
                dateTime: firstLogBelowMilestone.logDate,
                eventType: TimelineEventType.weightMilestone,
                title: '목표 진행도 ${(milestone * 100).toInt()}%',
                description:
                    '${firstLogBelowMilestone.weightKg.toStringAsFixed(1)}kg 달성',
              ),
            );
          }
        }
      }
    }

    // 4. 정렬 (오래된 순서대로)
    events.sort((a, b) => a.dateTime.compareTo(b.dateTime));

    return events;
  }

  String? _generateInsightMessage(
    int continuousRecordDays,
    double weightLossPercentage,
    dynamic weeklyProgress,
  ) {
    // 우선순위 1: 연속 기록일 달성
    if (continuousRecordDays >= 30) {
      return '대단해요! 30일 연속 기록을 달성했어요. 이대로라면 건강한 습관이 완성될 거예요!';
    }

    if (continuousRecordDays >= 7) {
      return '축하합니다! 연속 $continuousRecordDays일 기록을 달성했어요. 좋은 기록 유지하세요!';
    }

    // 우선순위 2: 체중 감량 진행
    if (weightLossPercentage >= 10.0) {
      return '놀라운 진전이에요! 목표의 10%를 달성했습니다. 계속 응원할게요!';
    }

    if (weightLossPercentage >= 5.0) {
      return '훌륭해요! 이미 목표의 5%에 도달했어요. 현재 추세라면 목표 달성 가능해요!';
    }

    if (weightLossPercentage >= 1.0) {
      return '좋은 시작이에요! 이미 첫 감량 목표를 달성했습니다. 계속 유지하세요!';
    }

    // 우선순위 3: 기본 격려 메시지
    if (continuousRecordDays > 0) {
      return '$continuousRecordDays일 동안 꾸준히 기록해주셨어요. 오늘도 계속해주세요!';
    }

    return '오늘도 함께 목표를 향해 나아가요! 첫 기록을 해보세요.';
  }
}
</file>

<file path="lib/features/dashboard/presentation/screens/home_dashboard_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/dashboard/application/notifiers/dashboard_notifier.dart';
import 'package:n06/features/dashboard/presentation/widgets/greeting_widget.dart';
import 'package:n06/features/dashboard/presentation/widgets/weekly_progress_widget.dart';
import 'package:n06/features/dashboard/presentation/widgets/quick_action_widget.dart';
import 'package:n06/features/dashboard/presentation/widgets/next_schedule_widget.dart';
import 'package:n06/features/dashboard/presentation/widgets/weekly_report_widget.dart';
import 'package:n06/features/dashboard/presentation/widgets/timeline_widget.dart';
import 'package:n06/features/dashboard/presentation/widgets/badge_widget.dart';

class HomeDashboardScreen extends ConsumerWidget {
  const HomeDashboardScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final dashboardState = ref.watch(dashboardNotifierProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('홈 대시보드'),
        elevation: 0,
      ),
      body: dashboardState.when(
        loading: () => const Center(
          child: CircularProgressIndicator(),
        ),
        error: (error, stackTrace) => Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(Icons.error_outline, size: 60, color: Colors.red[300]),
              const SizedBox(height: 16),
              Text('데이터를 불러올 수 없습니다'),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () {
                  // ignore: unused_result
                  ref.refresh(dashboardNotifierProvider);
                },
                child: const Text('다시 시도'),
              ),
            ],
          ),
        ),
        data: (dashboardData) => RefreshIndicator(
          onRefresh: () async {
            await ref.read(dashboardNotifierProvider.notifier).refresh();
          },
          child: SingleChildScrollView(
            physics: const AlwaysScrollableScrollPhysics(),
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // 개인화 인사
                  GreetingWidget(dashboardData: dashboardData),
                  const SizedBox(height: 24),

                  // 주간 목표 진행도
                  WeeklyProgressWidget(weeklyProgress: dashboardData.weeklyProgress),
                  const SizedBox(height: 24),

                  // 퀵 액션 버튼
                  QuickActionWidget(),
                  const SizedBox(height: 24),

                  // 다음 일정
                  NextScheduleWidget(nextSchedule: dashboardData.nextSchedule),
                  const SizedBox(height: 24),

                  // 주간 리포트
                  WeeklyReportWidget(weeklySummary: dashboardData.weeklySummary),
                  const SizedBox(height: 24),

                  // 치료 여정 타임라인
                  TimelineWidget(timeline: dashboardData.timeline),
                  const SizedBox(height: 24),

                  // 성취 뱃지
                  BadgeWidget(badges: dashboardData.badges),
                  const SizedBox(height: 32),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/dashboard/presentation/widgets/quick_action_widget.dart">
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

class QuickActionWidget extends StatelessWidget {
  const QuickActionWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          '빠른 기록',
          style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
        ),
        const SizedBox(height: 16),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          children: [
            _QuickActionButton(
              icon: Icons.scale,
              label: '체중 기록',
              color: Colors.blue,
              onTap: () => context.push('/tracking/weight'),
            ),
            _QuickActionButton(
              icon: Icons.favorite,
              label: '부작용 기록',
              color: Colors.pink,
              onTap: () => context.push('/tracking/symptom'),
            ),
            _QuickActionButton(
              icon: Icons.check_circle,
              label: '투여 완료',
              color: Colors.green,
              onTap: () {
                // 투여 완료 처리 (특정 라우트 없음, 다이얼로그나 inline 처리)
                ScaffoldMessenger.of(context).showSnackBar(
                  const SnackBar(content: Text('투여 완료 기능은 준비 중입니다')),
                );
              },
            ),
          ],
        ),
      ],
    );
  }
}

class _QuickActionButton extends StatelessWidget {
  final IconData icon;
  final String label;
  final Color color;
  final VoidCallback onTap;

  const _QuickActionButton({
    required this.icon,
    required this.label,
    required this.color,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Column(
        children: [
          Container(
            decoration: BoxDecoration(
              color: color.withValues(alpha: 0.1),
              shape: BoxShape.circle,
            ),
            padding: const EdgeInsets.all(16),
            child: Icon(icon, color: color, size: 28),
          ),
          const SizedBox(height: 8),
          Text(
            label,
            style: const TextStyle(fontSize: 12, fontWeight: FontWeight.w500),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/onboarding/presentation/widgets/summary_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:n06/features/onboarding/domain/entities/escalation_step.dart';
import 'package:n06/features/onboarding/application/notifiers/onboarding_notifier.dart';

/// 온보딩 정보 요약 및 최종 확인 화면
class SummaryScreen extends ConsumerWidget {
  final String userId;
  final String name;
  final double currentWeight;
  final double targetWeight;
  final int? targetPeriodWeeks;
  final String medicationName;
  final DateTime startDate;
  final int cycleDays;
  final double initialDose;
  final List<EscalationStep>? escalationPlan;
  final VoidCallback? onComplete;

  const SummaryScreen({
    super.key,
    required this.userId,
    required this.name,
    required this.currentWeight,
    required this.targetWeight,
    required this.targetPeriodWeeks,
    required this.medicationName,
    required this.startDate,
    required this.cycleDays,
    required this.initialDose,
    required this.escalationPlan,
    this.onComplete,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final onboardingState = ref.watch(onboardingNotifierProvider);

    return Padding(
      padding: const EdgeInsets.all(24.0),
      child: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('정보 확인', style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
            const SizedBox(height: 32),
            _SummarySection(
              title: '기본 정보',
              items: [
                ('이름', name),
                ('현재 체중', '$currentWeight kg'),
                ('목표 체중', '$targetWeight kg'),
                ('감량 목표', '${(currentWeight - targetWeight).toStringAsFixed(1)} kg'),
              ],
            ),
            const SizedBox(height: 24),
            _SummarySection(
              title: '투여 계획',
              items: [
                ('약물명', medicationName),
                (
                  '시작일',
                  '${startDate.year}-${startDate.month.toString().padLeft(2, '0')}-${startDate.day.toString().padLeft(2, '0')}',
                ),
                ('주기', '$cycleDays일'),
                ('초기 용량', '$initialDose mg'),
              ],
            ),
            if (escalationPlan != null && escalationPlan!.isNotEmpty) ...[
              const SizedBox(height: 24),
              const Text('증량 계획', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
              const SizedBox(height: 8),
              ListView.builder(
                shrinkWrap: true,
                physics: const NeverScrollableScrollPhysics(),
                itemCount: escalationPlan!.length,
                itemBuilder: (context, index) {
                  final step = escalationPlan![index];
                  return ListTile(title: Text('${step.weeks}주차: ${step.doseMg} mg'));
                },
              ),
            ],
            const SizedBox(height: 32),
            if (onboardingState.isLoading)
              const Center(child: CircularProgressIndicator())
            else if (onboardingState.hasError)
              Column(
                children: [
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: Colors.red.shade50,
                      border: Border.all(color: Colors.red),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Text(
                      '저장 실패: ${onboardingState.error}',
                      style: TextStyle(color: Colors.red.shade700),
                    ),
                  ),
                  const SizedBox(height: 16),
                  SizedBox(
                    width: double.infinity,
                    child: ElevatedButton(
                      onPressed: () {
                        ref
                            .read(onboardingNotifierProvider.notifier)
                            .retrySave(
                              userId: userId,
                              name: name,
                              currentWeight: currentWeight,
                              targetWeight: targetWeight,
                              targetPeriodWeeks: targetPeriodWeeks,
                              medicationName: medicationName,
                              startDate: startDate,
                              cycleDays: cycleDays,
                              initialDose: initialDose,
                              escalationPlan: escalationPlan,
                            );
                      },
                      child: const Text('재시도'),
                    ),
                  ),
                ],
              )
            else
              SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () async {
                    await ref
                        .read(onboardingNotifierProvider.notifier)
                        .saveOnboardingData(
                          userId: userId,
                          name: name,
                          currentWeight: currentWeight,
                          targetWeight: targetWeight,
                          targetPeriodWeeks: targetPeriodWeeks,
                          medicationName: medicationName,
                          startDate: startDate,
                          cycleDays: cycleDays,
                          initialDose: initialDose,
                          escalationPlan: escalationPlan,
                        );

                    if (context.mounted) {
                      if (onComplete != null) {
                        onComplete!();
                      } else {
                        context.go('/home');
                      }
                    }
                  },
                  child: const Text('확인'),
                ),
              ),
          ],
        ),
      ),
    );
  }
}

/// 요약 섹션 위젯
class _SummarySection extends StatelessWidget {
  final String title;
  final List<(String, String)> items;

  const _SummarySection({super.key, required this.title, required this.items});

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
        const SizedBox(height: 8),
        Container(
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            border: Border.all(color: Colors.grey.shade300),
            borderRadius: BorderRadius.circular(8),
          ),
          child: ListView.separated(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: items.length,
            separatorBuilder: (_, __) => const Divider(),
            itemBuilder: (context, index) {
              final (label, value) = items[index];
              return Padding(
                padding: const EdgeInsets.symmetric(vertical: 4),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(label, style: const TextStyle(fontWeight: FontWeight.w500)),
                    Text(value),
                  ],
                ),
              );
            },
          ),
        ),
      ],
    );
  }
}
</file>

<file path="lib/features/profile/application/notifiers/profile_notifier.dart">
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:n06/features/onboarding/domain/entities/user_profile.dart';
import 'package:n06/features/profile/domain/repositories/profile_repository.dart';
import 'package:n06/features/profile/domain/usecases/update_profile_usecase.dart';
import 'package:n06/features/authentication/application/notifiers/auth_notifier.dart';
import 'package:n06/features/dashboard/application/notifiers/dashboard_notifier.dart';
import 'package:n06/features/tracking/application/providers.dart';

part 'profile_notifier.g.dart';

/// Profile state notifier
///
/// Manages user profile state including:
/// - Loading user profile
/// - Updating user profile
/// - Profile data caching
@riverpod
class ProfileNotifier extends _$ProfileNotifier {
  @override
  Future<UserProfile?> build() async {
    // Load current user profile on initialization
    final authState = ref.watch(authNotifierProvider);

    if (!authState.hasValue || authState.value == null) {
      return null;
    }

    try {
      final repository = ref.read(profileRepositoryProvider);
      return await repository.getUserProfile(authState.value!.id);
    } catch (e) {
      // Re-throw as AsyncValue will handle error state
      rethrow;
    }
  }

  /// Load profile for a specific user
  Future<void> loadProfile(String userId) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(profileRepositoryProvider);
      return await repository.getUserProfile(userId);
    });
  }

  /// Update user profile using UpdateProfileUseCase
  ///
  /// Also invalidates dashboard notifier to refresh dashboard data
  Future<void> updateProfile(UserProfile profile) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(profileRepositoryProvider);
      final trackingRepository = ref.read(trackingRepositoryProvider);
      final useCase = UpdateProfileUseCase(
        profileRepository: repository,
        trackingRepository: trackingRepository,
      );

      await useCase.execute(profile);

      // Invalidate dashboard to refresh dashboard data
      ref.invalidate(dashboardNotifierProvider);

      return profile;
    });
  }

  /// Update weekly recording goals
  ///
  /// Updates the target number of weight logs and symptom logs per week.
  /// Goals must be in range 0-7.
  ///
  /// Invalidates dashboard notifier to refresh weekly progress data.
  ///
  /// Throws [Exception] if user profile not found
  Future<void> updateWeeklyGoals(
    int weeklyWeightRecordGoal,
    int weeklySymptomRecordGoal,
  ) async {
    final currentState = state;

    // Get current profile to extract userId
    if (!currentState.hasValue || currentState.value == null) {
      throw Exception('User profile not loaded');
    }

    final userId = currentState.value!.userId;

    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(profileRepositoryProvider);

      // Update weekly goals in repository
      await repository.updateWeeklyGoals(
        userId,
        weeklyWeightRecordGoal,
        weeklySymptomRecordGoal,
      );

      // Fetch updated profile
      final updatedProfile = await repository.getUserProfile(userId);

      // Invalidate dashboard to refresh weekly progress
      ref.invalidate(dashboardNotifierProvider);

      return updatedProfile;
    });
  }
}

/// Provider for ProfileRepository
///
/// Phase 0: Returns IsarProfileRepository
/// Phase 1: Will return SupabaseProfileRepository
@riverpod
ProfileRepository profileRepository(ProfileRepositoryRef ref) {
  throw UnimplementedError(
    'profileRepositoryProvider must be overridden in ProviderScope',
  );
}
</file>

<file path="lib/features/tracking/domain/repositories/medication_repository.dart">
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';
import 'package:n06/features/tracking/domain/entities/plan_change_history.dart';

/// Repository interface for medication-related data
///
/// This repository handles:
/// - Dose records (actual medication administration)
/// - Dose schedules (scheduled medication times)
/// - Dosage plans (medication plans)
/// - Plan change history (audit trail)
///
/// Note: For cleaner separation of concerns, consider using:
/// - DosagePlanRepository for dosage plan-specific operations
/// - DoseScheduleRepository for schedule-specific operations
abstract class MedicationRepository {
  // DoseRecord operations
  Future<List<DoseRecord>> getDoseRecords(String planId);
  Future<List<DoseRecord>> getRecentDoseRecords(String planId, int days);
  Future<void> saveDoseRecord(DoseRecord record);
  Future<void> deleteDoseRecord(String recordId);
  Future<bool> isDuplicateDoseRecord(String planId, DateTime scheduledDate);
  Future<DoseRecord?> getDoseRecordByDate(String planId, DateTime date);
  Future<DoseRecord?> getDoseRecord(String recordId);
  Future<void> updateDoseRecord(String recordId, double doseMg, String injectionSite, String? note);

  // DoseSchedule operations
  Future<List<DoseSchedule>> getDoseSchedules(String planId);
  Future<void> saveDoseSchedules(List<DoseSchedule> schedules);
  Future<void> deleteDoseSchedulesFrom(String planId, DateTime fromDate);
  Future<void> updateDoseSchedule(DoseSchedule schedule);

  // DosagePlan operations (backward compatibility)
  Future<DosagePlan?> getActiveDosagePlan(String userId);
  Future<void> saveDosagePlan(DosagePlan plan);
  Future<void> updateDosagePlan(DosagePlan plan);
  Future<DosagePlan?> getDosagePlan(String planId);

  // Plan Change History operations (backward compatibility)
  Future<void> savePlanChangeHistory(
    String planId,
    Map<String, dynamic> oldPlan,
    Map<String, dynamic> newPlan,
  );
  Future<List<PlanChangeHistory>> getPlanChangeHistory(String planId);

  // Streams (real-time)
  Stream<List<DoseRecord>> watchDoseRecords(String planId);
  Stream<DosagePlan?> watchActiveDosagePlan(String userId);
  Stream<List<DoseSchedule>> watchDoseSchedules(String planId);
}
</file>

<file path="lib/features/tracking/domain/repositories/tracking_repository.dart">
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';

abstract class TrackingRepository {
  // 체중 기록
  Future<void> saveWeightLog(WeightLog log);
  Future<WeightLog?> getWeightLog(String userId, DateTime logDate);
  Future<WeightLog?> getWeightLogById(String id);
  Future<List<WeightLog>> getWeightLogs(
    String userId, {
    DateTime? startDate,
    DateTime? endDate,
  });
  Future<void> deleteWeightLog(String id);
  Future<void> updateWeightLog(String id, double newWeight);
  Future<void> updateWeightLogWithDate(String id, double newWeight, DateTime newDate);
  Stream<List<WeightLog>> watchWeightLogs(String userId);

  // 증상 기록
  Future<void> saveSymptomLog(SymptomLog log);
  Future<SymptomLog?> getSymptomLogById(String id);
  Future<List<SymptomLog>> getSymptomLogs(
    String userId, {
    DateTime? startDate,
    DateTime? endDate,
  });
  Future<void> deleteSymptomLog(String id, {bool cascade = true});
  Future<void> updateSymptomLog(String id, SymptomLog updatedLog);
  Stream<List<SymptomLog>> watchSymptomLogs(String userId);

  // 태그 기반 조회
  Future<List<SymptomLog>> getSymptomLogsByTag(String tagName);
  Future<List<String>> getAllTags(String userId);

  // 경과일 계산을 위한 최근 증량일 조회
  Future<DateTime?> getLatestDoseEscalationDate(String userId);
}
</file>

<file path="lib/features/tracking/infrastructure/repositories/isar_tracking_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/tracking/domain/entities/weight_log.dart';
import 'package:n06/features/tracking/domain/entities/symptom_log.dart';
import 'package:n06/features/tracking/domain/repositories/tracking_repository.dart';
import 'package:n06/features/tracking/infrastructure/dtos/weight_log_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/symptom_log_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/symptom_context_tag_dto.dart';

class IsarTrackingRepository implements TrackingRepository {
  final Isar _isar;

  IsarTrackingRepository(this._isar);

  // ============ 체중 기록 ============

  @override
  Future<void> saveWeightLog(WeightLog log) async {
    final dto = WeightLogDto.fromEntity(log);
    await _isar.writeTxn(() async {
      // 같은 날짜의 기존 기록이 있으면 삭제
      final existing = await _isar.weightLogDtos
          .filter()
          .userIdEqualTo(log.userId)
          .logDateEqualTo(log.logDate)
          .findAll();

      if (existing.isNotEmpty) {
        await _isar.weightLogDtos.deleteAll(existing.map((e) => e.id).toList());
      }

      await _isar.weightLogDtos.put(dto);
    });
  }

  @override
  Future<WeightLog?> getWeightLog(String userId, DateTime logDate) async {
    final dto = await _isar.weightLogDtos
        .filter()
        .userIdEqualTo(userId)
        .logDateEqualTo(logDate)
        .findFirst();

    return dto?.toEntity();
  }

  @override
  Future<List<WeightLog>> getWeightLogs(
    String userId, {
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    final dtos = await _isar.weightLogDtos
        .filter()
        .userIdEqualTo(userId)
        .sortByLogDateDesc()
        .findAll();

    // 메모리에서 날짜 필터링
    var filteredDtos = dtos;
    if (startDate != null) {
      final startOfDay = DateTime(startDate.year, startDate.month, startDate.day);
      filteredDtos = filteredDtos.where((dto) => dto.logDate.isAfter(startOfDay) || dto.logDate.day == startOfDay.day && dto.logDate.month == startOfDay.month && dto.logDate.year == startOfDay.year).toList();
    }
    if (endDate != null) {
      final endOfDay = DateTime(endDate.year, endDate.month, endDate.day, 23, 59, 59);
      filteredDtos = filteredDtos.where((dto) => dto.logDate.isBefore(endOfDay.add(Duration(seconds: 1)))).toList();
    }

    return filteredDtos.map((dto) => dto.toEntity()).toList();
  }

  @override
  Future<void> deleteWeightLog(String id) async {
    final weightLogId = int.tryParse(id);
    if (weightLogId != null) {
      await _isar.writeTxn(() => _isar.weightLogDtos.delete(weightLogId));
    }
  }

  @override
  Future<void> updateWeightLog(String id, double newWeight) async {
    final weightLogId = int.tryParse(id);
    if (weightLogId != null) {
      final dto = await _isar.weightLogDtos.get(weightLogId);
      if (dto != null) {
        dto.weightKg = newWeight;
        await _isar.writeTxn(() => _isar.weightLogDtos.put(dto));
      }
    }
  }

  @override
  Future<WeightLog?> getWeightLogById(String id) async {
    final weightLogId = int.tryParse(id);
    if (weightLogId == null) return null;
    final dto = await _isar.weightLogDtos.get(weightLogId);
    return dto?.toEntity();
  }

  @override
  Future<void> updateWeightLogWithDate(String id, double newWeight, DateTime newDate) async {
    final weightLogId = int.tryParse(id);
    if (weightLogId != null) {
      final dto = await _isar.weightLogDtos.get(weightLogId);
      if (dto != null) {
        dto.weightKg = newWeight;
        dto.logDate = newDate;
        await _isar.writeTxn(() => _isar.weightLogDtos.put(dto));
      }
    }
  }

  @override
  Stream<List<WeightLog>> watchWeightLogs(String userId) {
    return _isar.weightLogDtos
        .filter()
        .userIdEqualTo(userId)
        .sortByLogDateDesc()
        .watch(fireImmediately: true)
        .map((dtos) => dtos.map((dto) => dto.toEntity()).toList());
  }

  // ============ 증상 기록 ============

  @override
  Future<void> saveSymptomLog(SymptomLog log) async {
    final dto = SymptomLogDto.fromEntity(log);

    await _isar.writeTxn(() async {
      // SymptomLogDto 저장
      final symptomLogId = await _isar.symptomLogDtos.put(dto);

      // 태그 저장
      if (log.tags.isNotEmpty) {
        final tagDtos = log.tags.map((tagName) {
          return SymptomContextTagDto()
            ..symptomLogIsarId = symptomLogId
            ..tagName = tagName;
        }).toList();

        await _isar.symptomContextTagDtos.putAll(tagDtos);
      }
    });
  }

  @override
  Future<List<SymptomLog>> getSymptomLogs(
    String userId, {
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    final dtos = await _isar.symptomLogDtos
        .filter()
        .userIdEqualTo(userId)
        .sortByLogDateDesc()
        .findAll();

    // 메모리에서 날짜 필터링
    var filteredDtos = dtos;
    if (startDate != null) {
      final startOfDay = DateTime(startDate.year, startDate.month, startDate.day);
      filteredDtos = filteredDtos.where((dto) => dto.logDate.isAfter(startOfDay) || (dto.logDate.day == startOfDay.day && dto.logDate.month == startOfDay.month && dto.logDate.year == startOfDay.year)).toList();
    }
    if (endDate != null) {
      final endOfDay = DateTime(endDate.year, endDate.month, endDate.day, 23, 59, 59);
      filteredDtos = filteredDtos.where((dto) => dto.logDate.isBefore(endOfDay.add(Duration(seconds: 1)))).toList();
    }

    final logs = <SymptomLog>[];
    for (final dto in filteredDtos) {
      final tags = await _isar.symptomContextTagDtos
          .filter()
          .symptomLogIsarIdEqualTo(dto.id)
          .findAll();

      final tagNames = tags.map((t) => t.tagName).toList();
      logs.add(dto.toEntity(tags: tagNames));
    }

    return logs;
  }

  @override
  Future<SymptomLog?> getSymptomLogById(String id) async {
    final symptomLogId = int.tryParse(id);
    if (symptomLogId == null) return null;

    final dto = await _isar.symptomLogDtos.get(symptomLogId);
    if (dto == null) return null;

    final tags = await _isar.symptomContextTagDtos
        .filter()
        .symptomLogIsarIdEqualTo(symptomLogId)
        .findAll();

    final tagNames = tags.map((t) => t.tagName).toList();
    return dto.toEntity(tags: tagNames);
  }

  @override
  Future<void> deleteSymptomLog(String id, {bool cascade = true}) async {
    final symptomLogId = int.tryParse(id);
    if (symptomLogId != null) {
      await _isar.writeTxn(() async {
        // 태그 삭제
        final tags = await _isar.symptomContextTagDtos
            .filter()
            .symptomLogIsarIdEqualTo(symptomLogId)
            .findAll();
        await _isar.symptomContextTagDtos.deleteAll(tags.map((t) => t.id).toList());

        // 증상 로그 삭제
        await _isar.symptomLogDtos.delete(symptomLogId);
      });
    }
  }

  @override
  Future<void> updateSymptomLog(String id, SymptomLog updatedLog) async {
    final symptomLogId = int.tryParse(id);
    if (symptomLogId != null) {
      await _isar.writeTxn(() async {
        // 기존 태그 삭제
        final oldTags = await _isar.symptomContextTagDtos
            .filter()
            .symptomLogIsarIdEqualTo(symptomLogId)
            .findAll();
        await _isar.symptomContextTagDtos.deleteAll(oldTags.map((t) => t.id).toList());

        // 증상 로그 업데이트
        final dto = SymptomLogDto.fromEntity(updatedLog);
        dto.id = symptomLogId;
        await _isar.symptomLogDtos.put(dto);

        // 새 태그 추가
        if (updatedLog.tags.isNotEmpty) {
          final newTagDtos = updatedLog.tags.map((tagName) {
            return SymptomContextTagDto()
              ..symptomLogIsarId = symptomLogId
              ..tagName = tagName;
          }).toList();
          await _isar.symptomContextTagDtos.putAll(newTagDtos);
        }
      });
    }
  }

  @override
  Stream<List<SymptomLog>> watchSymptomLogs(String userId) {
    return _isar.symptomLogDtos
        .filter()
        .userIdEqualTo(userId)
        .sortByLogDateDesc()
        .watch(fireImmediately: true)
        .asyncMap((dtos) async {
          final logs = <SymptomLog>[];
          for (final dto in dtos) {
            final tags = await _isar.symptomContextTagDtos
                .filter()
                .symptomLogIsarIdEqualTo(dto.id)
                .findAll();

            final tagNames = tags.map((t) => t.tagName).toList();
            logs.add(dto.toEntity(tags: tagNames));
          }
          return logs;
        });
  }

  // ============ 태그 기반 조회 ============

  @override
  Future<List<SymptomLog>> getSymptomLogsByTag(String tagName) async {
    final tagDtos = await _isar.symptomContextTagDtos
        .filter()
        .tagNameEqualTo(tagName)
        .findAll();

    final logs = <SymptomLog>[];
    for (final tagDto in tagDtos) {
      final symptomDto = await _isar.symptomLogDtos.get(tagDto.symptomLogIsarId);
      if (symptomDto != null) {
        final tags = await _isar.symptomContextTagDtos
            .filter()
            .symptomLogIsarIdEqualTo(symptomDto.id)
            .findAll();

        final tagNames = tags.map((t) => t.tagName).toList();
        logs.add(symptomDto.toEntity(tags: tagNames));
      }
    }

    return logs;
  }

  @override
  Future<List<String>> getAllTags(String userId) async {
    final symptomDtos = await _isar.symptomLogDtos
        .filter()
        .userIdEqualTo(userId)
        .findAll();

    final tagSet = <String>{};
    for (final symptomDto in symptomDtos) {
      final tags = await _isar.symptomContextTagDtos
          .filter()
          .symptomLogIsarIdEqualTo(symptomDto.id)
          .findAll();

      tagSet.addAll(tags.map((t) => t.tagName));
    }

    return tagSet.toList();
  }

  // ============ 경과일 계산 ============

  @override
  Future<DateTime?> getLatestDoseEscalationDate(String userId) async {
    // 투여 기록에서 가장 최근의 증량 시점을 찾음
    // 이는 MedicationRepository를 통해 구현됨
    // 현재는 구현 생략 (F001의 DosagePlan에서 증량 계획 추출)
    return null;
  }
}
</file>

<file path="lib/features/tracking/presentation/screens/edit_dosage_plan_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/tracking/application/providers.dart';
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';
import 'package:n06/features/tracking/domain/usecases/analyze_plan_change_impact_usecase.dart';

class EditDosagePlanScreen extends ConsumerWidget {
  final DosagePlan? initialPlan;

  const EditDosagePlanScreen({
    super.key,
    this.initialPlan,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('투여 계획 수정'),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(16),
          child: _EditDosagePlanForm(initialPlan: initialPlan),
        ),
      ),
    );
  }
}

class _EditDosagePlanForm extends ConsumerStatefulWidget {
  final DosagePlan? initialPlan;

  const _EditDosagePlanForm({
    // ignore: unused_element_parameter
    super.key,
    this.initialPlan,
  });

  @override
  ConsumerState<_EditDosagePlanForm> createState() => _EditDosagePlanFormState();
}

class _EditDosagePlanFormState extends ConsumerState<_EditDosagePlanForm> {
  late TextEditingController _medicationNameController;
  late TextEditingController _cycleDaysController;
  late TextEditingController _initialDoseController;
  late DateTime _selectedStartDate;

  @override
  void initState() {
    super.initState();
    final plan = widget.initialPlan;
    _medicationNameController = TextEditingController(
      text: plan?.medicationName ?? '',
    );
    _cycleDaysController = TextEditingController(
      text: plan?.cycleDays.toString() ?? '7',
    );
    _initialDoseController = TextEditingController(
      text: plan?.initialDoseMg.toString() ?? '0.25',
    );
    _selectedStartDate = plan?.startDate ?? DateTime.now();
  }

  @override
  void dispose() {
    _medicationNameController.dispose();
    _cycleDaysController.dispose();
    _initialDoseController.dispose();
    super.dispose();
  }

  Future<void> _handleSave() async {
    try {
      // Validate inputs
      if (_medicationNameController.text.trim().isEmpty) {
        _showErrorSnackBar('약물명을 입력하세요');
        return;
      }

      final cycleDays = int.tryParse(_cycleDaysController.text);
      if (cycleDays == null || cycleDays < 1) {
        _showErrorSnackBar('투여 주기는 1일 이상이어야 합니다');
        return;
      }

      final initialDose = double.tryParse(_initialDoseController.text);
      if (initialDose == null || initialDose <= 0) {
        _showErrorSnackBar('초기 용량은 0보다 커야 합니다');
        return;
      }

      final plan = widget.initialPlan;
      if (plan == null) {
        _showErrorSnackBar('투여 계획이 로드되지 않았습니다');
        return;
      }

      // Create updated plan
      final updatedPlan = plan.copyWith(
        medicationName: _medicationNameController.text.trim(),
        cycleDays: cycleDays,
        initialDoseMg: initialDose,
        startDate: _selectedStartDate,
        updatedAt: DateTime.now(),
      );

      // Get analyze impact usecase
      final analyzeImpactUseCase = ref.read(analyzePlanChangeImpactUseCaseProvider);

      // Analyze impact
      final impact = analyzeImpactUseCase.execute(
        oldPlan: plan,
        newPlan: updatedPlan,
        fromDate: DateTime.now(),
      );

      // Show confirmation dialog if there are changes
      if (impact.hasChanges) {
        final confirmed = await _showImpactConfirmationDialog(context, impact);
        if (!confirmed) return;
      }

      // Update using usecase
      final updateUseCase = ref.read(updateDosagePlanUseCaseProvider);
      final result = await updateUseCase.execute(
        oldPlan: plan,
        newPlan: updatedPlan,
      );

      if (result.isSuccess) {
        _showSuccessSnackBar('투여 계획이 수정되었습니다');
        if (mounted) {
          Navigator.of(context).pop();
        }
      } else {
        _showErrorSnackBar(result.errorMessage ?? '업데이트 실패');
      }
    } catch (e) {
      _showErrorSnackBar('오류 발생: $e');
    }
  }

  Future<bool> _showImpactConfirmationDialog(
    BuildContext context,
    PlanChangeImpact impact,
  ) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('투여 계획 변경'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('투여 계획 변경 시 이후 스케줄이 재계산됩니다.'),
            const SizedBox(height: 16),
            if (impact.affectedScheduleCount > 0)
              Text('영향받는 스케줄: ${impact.affectedScheduleCount}개'),
            if (impact.changedFields.isNotEmpty)
              Text('변경되는 항목: ${impact.changedFields.join(', ')}'),
            if (impact.warningMessage != null)
              Padding(
                padding: const EdgeInsets.only(top: 12),
                child: Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: Colors.amber.shade100,
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Text(
                    impact.warningMessage!,
                    style: const TextStyle(fontSize: 12),
                  ),
                ),
              ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('취소'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('확인'),
          ),
        ],
      ),
    );

    return confirmed ?? false;
  }

  void _showErrorSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
      ),
    );
  }

  void _showSuccessSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.green,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Medication Name
        TextField(
          controller: _medicationNameController,
          decoration: InputDecoration(
            labelText: '약물명',
            border: OutlineInputBorder(),
          ),
        ),
        const SizedBox(height: 16),

        // Start Date
        ListTile(
          title: const Text('시작일'),
          subtitle: Text(
            '${_selectedStartDate.year}-${_selectedStartDate.month.toString().padLeft(2, '0')}-${_selectedStartDate.day.toString().padLeft(2, '0')}',
          ),
          onTap: () async {
            final picked = await showDatePicker(
              context: context,
              initialDate: _selectedStartDate,
              firstDate: DateTime(2020),
              lastDate: DateTime.now(),
            );
            if (picked != null) {
              setState(() => _selectedStartDate = picked);
            }
          },
        ),
        const SizedBox(height: 16),

        // Cycle Days
        TextField(
          controller: _cycleDaysController,
          keyboardType: TextInputType.number,
          decoration: InputDecoration(
            labelText: '투여 주기 (일)',
            border: OutlineInputBorder(),
          ),
        ),
        const SizedBox(height: 16),

        // Initial Dose
        TextField(
          controller: _initialDoseController,
          keyboardType: TextInputType.numberWithOptions(decimal: true),
          decoration: InputDecoration(
            labelText: '초기 용량 (mg)',
            border: OutlineInputBorder(),
          ),
        ),
        const SizedBox(height: 32),

        // Save Button
        ElevatedButton(
          onPressed: _handleSave,
          child: const Padding(
            padding: EdgeInsets.all(12),
            child: Text(
              '저장',
              style: TextStyle(fontSize: 16),
            ),
          ),
        ),
      ],
    );
  }
}
</file>

<file path="supabase/migrations/01_initial_schema.sql">
-- Initial Schema for GLP-1 Treatment Management MVP
-- Phase 0: Isar local DB structure
-- Phase 1: Supabase PostgreSQL migration

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================
-- 1. Authentication & User Management
-- ============================================

-- users table
CREATE TABLE users (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    oauth_provider varchar(20) NOT NULL,
    oauth_user_id varchar(255) NOT NULL,
    name varchar(100) NOT NULL,
    email varchar(255) NOT NULL,
    profile_image_url text,
    created_at timestamptz NOT NULL DEFAULT now(),
    last_login_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT unique_oauth_user UNIQUE (oauth_provider, oauth_user_id)
);

CREATE INDEX idx_users_oauth ON users(oauth_provider, oauth_user_id);

-- consent_records table
CREATE TABLE consent_records (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    terms_of_service boolean NOT NULL,
    privacy_policy boolean NOT NULL,
    agreed_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_consent_user ON consent_records(user_id);

-- ============================================
-- 2. User Profile & Goals
-- ============================================

-- user_profiles table
CREATE TABLE user_profiles (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    target_weight_kg numeric(5,2) NOT NULL,
    target_period_weeks integer,
    weekly_loss_goal_kg numeric(4,2),
    weekly_weight_record_goal integer NOT NULL DEFAULT 7,
    weekly_symptom_record_goal integer NOT NULL DEFAULT 7,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT unique_user_profile UNIQUE (user_id),
    CONSTRAINT check_target_weight CHECK (target_weight_kg > 0 AND target_weight_kg < 500),
    CONSTRAINT check_weekly_goals CHECK (weekly_weight_record_goal >= 0 AND weekly_weight_record_goal <= 7 AND weekly_symptom_record_goal >= 0 AND weekly_symptom_record_goal <= 7)
);

CREATE INDEX idx_user_profiles_user ON user_profiles(user_id);

-- ============================================
-- 3. Dosage Management
-- ============================================

-- dosage_plans table
CREATE TABLE dosage_plans (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    medication_name varchar(100) NOT NULL,
    start_date date NOT NULL,
    cycle_days integer NOT NULL,
    initial_dose_mg numeric(6,2) NOT NULL,
    escalation_plan jsonb,
    is_active boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT check_cycle_days CHECK (cycle_days > 0),
    CONSTRAINT check_initial_dose CHECK (initial_dose_mg > 0)
);

CREATE INDEX idx_dosage_plans_user ON dosage_plans(user_id, is_active);

-- plan_change_history table
CREATE TABLE plan_change_history (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dosage_plan_id uuid NOT NULL REFERENCES dosage_plans(id) ON DELETE CASCADE,
    changed_at timestamptz NOT NULL DEFAULT now(),
    old_plan jsonb NOT NULL,
    new_plan jsonb NOT NULL
);

CREATE INDEX idx_plan_history_plan ON plan_change_history(dosage_plan_id, changed_at DESC);

-- dose_schedules table
CREATE TABLE dose_schedules (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dosage_plan_id uuid NOT NULL REFERENCES dosage_plans(id) ON DELETE CASCADE,
    scheduled_date date NOT NULL,
    scheduled_dose_mg numeric(6,2) NOT NULL,
    notification_time time,
    created_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT check_scheduled_dose CHECK (scheduled_dose_mg > 0)
);

CREATE INDEX idx_dose_schedules_plan_date ON dose_schedules(dosage_plan_id, scheduled_date);

-- dose_records table
CREATE TABLE dose_records (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dose_schedule_id uuid REFERENCES dose_schedules(id) ON DELETE SET NULL,
    dosage_plan_id uuid NOT NULL REFERENCES dosage_plans(id) ON DELETE CASCADE,
    administered_at timestamptz NOT NULL,
    actual_dose_mg numeric(6,2) NOT NULL,
    injection_site varchar(20),
    is_completed boolean NOT NULL DEFAULT true,
    note text,
    created_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT check_actual_dose CHECK (actual_dose_mg > 0),
    CONSTRAINT check_injection_site CHECK (injection_site IN ('복부', '허벅지', '상완') OR injection_site IS NULL)
);

CREATE INDEX idx_dose_records_plan_date ON dose_records(dosage_plan_id, administered_at DESC);
CREATE INDEX idx_dose_records_injection_site ON dose_records(injection_site, administered_at DESC);

-- ============================================
-- 4. Weight & Symptom Tracking
-- ============================================

-- weight_logs table
CREATE TABLE weight_logs (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    log_date date NOT NULL,
    weight_kg numeric(5,2) NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT unique_weight_log UNIQUE (user_id, log_date),
    CONSTRAINT check_weight CHECK (weight_kg > 0 AND weight_kg < 500)
);

CREATE INDEX idx_weight_logs_user_date ON weight_logs(user_id, log_date DESC);

-- symptom_logs table
CREATE TABLE symptom_logs (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    log_date date NOT NULL,
    symptom_name varchar(50) NOT NULL,
    severity integer NOT NULL,
    days_since_escalation integer,
    is_persistent_24h boolean,
    note text,
    created_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT check_severity CHECK (severity >= 1 AND severity <= 10),
    CONSTRAINT check_symptom_name CHECK (symptom_name IN ('메스꺼움', '구토', '변비', '설사', '복통', '두통', '피로'))
);

CREATE INDEX idx_symptom_logs_user_date ON symptom_logs(user_id, log_date DESC);
CREATE INDEX idx_symptom_logs_symptom ON symptom_logs(symptom_name);

-- symptom_context_tags table
CREATE TABLE symptom_context_tags (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    symptom_log_id uuid NOT NULL REFERENCES symptom_logs(id) ON DELETE CASCADE,
    tag_name varchar(50) NOT NULL
);

CREATE INDEX idx_symptom_tags_log ON symptom_context_tags(symptom_log_id);
CREATE INDEX idx_symptom_tags_name ON symptom_context_tags(tag_name);

-- ============================================
-- 5. Emergency Symptom Checks
-- ============================================

-- emergency_symptom_checks table
CREATE TABLE emergency_symptom_checks (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    checked_at timestamptz NOT NULL DEFAULT now(),
    checked_symptoms jsonb NOT NULL
);

CREATE INDEX idx_emergency_checks_user_date ON emergency_symptom_checks(user_id, checked_at DESC);

-- ============================================
-- 6. Achievement & Badges
-- ============================================

-- badge_definitions table (static data)
CREATE TABLE badge_definitions (
    id varchar(50) PRIMARY KEY,
    name varchar(100) NOT NULL,
    description text NOT NULL,
    category varchar(20) NOT NULL,
    achievement_condition jsonb NOT NULL,
    icon_url text,
    display_order integer NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT check_badge_category CHECK (category IN ('streak', 'weight', 'dose', 'record'))
);

CREATE INDEX idx_badge_definitions_category ON badge_definitions(category, display_order);

-- user_badges table
CREATE TABLE user_badges (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    badge_id varchar(50) NOT NULL REFERENCES badge_definitions(id) ON DELETE CASCADE,
    status varchar(20) NOT NULL,
    progress_percentage integer NOT NULL DEFAULT 0,
    achieved_at timestamptz,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT unique_user_badge UNIQUE (user_id, badge_id),
    CONSTRAINT check_badge_status CHECK (status IN ('locked', 'in_progress', 'achieved')),
    CONSTRAINT check_progress CHECK (progress_percentage >= 0 AND progress_percentage <= 100)
);

CREATE INDEX idx_user_badges_user_status ON user_badges(user_id, status);
CREATE INDEX idx_user_badges_user_achieved ON user_badges(user_id, achieved_at DESC);

-- ============================================
-- 7. Updated At Trigger
-- ============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Apply trigger to user_profiles
CREATE TRIGGER update_user_profiles_updated_at BEFORE UPDATE ON user_profiles
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Apply trigger to dosage_plans
CREATE TRIGGER update_dosage_plans_updated_at BEFORE UPDATE ON dosage_plans
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Apply trigger to user_badges
CREATE TRIGGER update_user_badges_updated_at BEFORE UPDATE ON user_badges
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- 8. Comments
-- ============================================

COMMENT ON TABLE users IS 'User account information from OAuth providers';
COMMENT ON TABLE consent_records IS 'User consent records for terms and privacy policy';
COMMENT ON TABLE user_profiles IS 'User profiles including treatment goals';
COMMENT ON TABLE dosage_plans IS 'Medication dosage plans with escalation schedule';
COMMENT ON TABLE plan_change_history IS 'History of changes to dosage plans';
COMMENT ON TABLE dose_schedules IS 'Auto-generated dosage schedule';
COMMENT ON TABLE dose_records IS 'Actual dose administration records';
COMMENT ON TABLE weight_logs IS 'Daily weight tracking records';
COMMENT ON TABLE symptom_logs IS 'Side effect and symptom logs';
COMMENT ON TABLE symptom_context_tags IS 'Context tags for symptoms (e.g., oily food, stress)';
COMMENT ON TABLE emergency_symptom_checks IS 'Emergency symptom checklist records';
COMMENT ON TABLE badge_definitions IS 'Badge definitions for achievement system (static data)';
COMMENT ON TABLE user_badges IS 'User badge achievement status and progress';

-- ============================================
-- 9. RLS Policies (Phase 1)
-- ============================================

-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE consent_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE dosage_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE plan_change_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE dose_schedules ENABLE ROW LEVEL SECURITY;
ALTER TABLE dose_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE weight_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE symptom_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE symptom_context_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE emergency_symptom_checks ENABLE ROW LEVEL SECURITY;
ALTER TABLE badge_definitions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_badges ENABLE ROW LEVEL SECURITY;

-- RLS Policy: Users can only access their own profile
CREATE POLICY users_policy ON users
    FOR ALL
    USING (id = auth.uid());

-- RLS Policy: Users can only access their own consent records
CREATE POLICY consent_records_policy ON consent_records
    FOR ALL
    USING (user_id = auth.uid());

-- RLS Policy: Users can only access their own profile
CREATE POLICY user_profiles_policy ON user_profiles
    FOR ALL
    USING (user_id = auth.uid());

-- RLS Policy: Users can only access their own dosage plans
CREATE POLICY dosage_plans_policy ON dosage_plans
    FOR ALL
    USING (user_id = auth.uid());

-- RLS Policy: Users can only access their own plan history
CREATE POLICY plan_change_history_policy ON plan_change_history
    FOR ALL
    USING (dosage_plan_id IN (SELECT id FROM dosage_plans WHERE user_id = auth.uid()));

-- RLS Policy: Users can only access their own dose schedules
CREATE POLICY dose_schedules_policy ON dose_schedules
    FOR ALL
    USING (dosage_plan_id IN (SELECT id FROM dosage_plans WHERE user_id = auth.uid()));

-- RLS Policy: Users can only access their own dose records
CREATE POLICY dose_records_policy ON dose_records
    FOR ALL
    USING (dosage_plan_id IN (SELECT id FROM dosage_plans WHERE user_id = auth.uid()));

-- RLS Policy: Users can only access their own weight logs
CREATE POLICY weight_logs_policy ON weight_logs
    FOR ALL
    USING (user_id = auth.uid());

-- RLS Policy: Users can only access their own symptom logs
CREATE POLICY symptom_logs_policy ON symptom_logs
    FOR ALL
    USING (user_id = auth.uid());

-- RLS Policy: Users can only access their own symptom tags
CREATE POLICY symptom_context_tags_policy ON symptom_context_tags
    FOR ALL
    USING (symptom_log_id IN (SELECT id FROM symptom_logs WHERE user_id = auth.uid()));

-- RLS Policy: Users can only access their own emergency checks
CREATE POLICY emergency_symptom_checks_policy ON emergency_symptom_checks
    FOR ALL
    USING (user_id = auth.uid());

-- RLS Policy: Badge definitions are readable by all authenticated users
CREATE POLICY badge_definitions_policy ON badge_definitions
    FOR SELECT
    USING (auth.role() = 'authenticated');

-- RLS Policy: Users can only access their own badges
CREATE POLICY user_badges_policy ON user_badges
    FOR ALL
    USING (user_id = auth.uid());
</file>

<file path="test/features/tracking/presentation/screens/weight_record_screen_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/presentation/screens/weight_record_screen.dart';

void main() {
  group('WeightRecordScreen', () {

    group('TC-WRS-01: Screen Rendering', () {
      testWidgets('should render WeightRecordScreen with all elements',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Assert
        expect(find.text('체중 기록'), findsOneWidget);
        expect(find.text('날짜 선택'), findsOneWidget);
        expect(find.text('체중 입력'), findsOneWidget);
        expect(find.text('저장'), findsOneWidget);
      });

      testWidgets('should render date selection widget with quick buttons',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Assert
        expect(find.text('오늘'), findsOneWidget);
        expect(find.text('어제'), findsOneWidget);
        expect(find.text('2일 전'), findsOneWidget);
      });

      testWidgets('should render weight input field with label',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Assert
        expect(find.byType(TextField), findsWidgets);
        expect(find.text('체중 (kg)'), findsOneWidget);
      });

      testWidgets('should render save button',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Assert
        expect(find.byType(ElevatedButton), findsOneWidget);
      });
    });

    group('TC-WRS-02: Date Selection', () {
      testWidgets('should select today date by default',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Assert
        expect(find.text('오늘'), findsOneWidget);
      });

      testWidgets('should allow selecting today with quick button',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Act
        await tester.tap(find.text('오늘'));
        await tester.pump();

        // Assert - 날짜가 선택된 것으로 간주
        expect(find.text('오늘'), findsOneWidget);
      });

      testWidgets('should allow selecting yesterday',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Act
        await tester.tap(find.text('어제'));
        await tester.pump();

        // Assert
        expect(find.text('어제'), findsOneWidget);
      });

      testWidgets('should open date picker on calendar button click',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Act
        await tester.tap(find.byIcon(Icons.calendar_today));
        await tester.pumpAndSettle();

        // Assert
        expect(find.byType(CalendarDatePicker), findsOneWidget);
      });
    });

    group('TC-WRS-03: Weight Input Validation', () {
      testWidgets('should accept valid weight between 20 and 300',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Act
        await tester.enterText(
          find.byType(TextField).first,
          '75.5',
        );
        await tester.pump();

        // Assert
        expect(find.byIcon(Icons.check), findsOneWidget);
      });

      testWidgets('should reject weight below 20kg',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Act
        await tester.enterText(
          find.byType(TextField).first,
          '15.0',
        );
        await tester.pump();

        // Assert
        expect(find.byIcon(Icons.close), findsOneWidget);
        expect(find.text('20kg 이상이어야 합니다'), findsOneWidget);
      });

      testWidgets('should reject weight above 300kg',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Act
        await tester.enterText(
          find.byType(TextField).first,
          '350.0',
        );
        await tester.pump();

        // Assert
        expect(find.byIcon(Icons.close), findsOneWidget);
        expect(find.text('300kg 이하여야 합니다'), findsOneWidget);
      });

      testWidgets('should accept decimal weight values',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Act
        await tester.enterText(
          find.byType(TextField).first,
          '75.5',
        );
        await tester.pump();

        // Assert
        expect(find.byIcon(Icons.check), findsOneWidget);
      });

      testWidgets('should accept integer weight values',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Act
        await tester.enterText(
          find.byType(TextField).first,
          '75',
        );
        await tester.pump();

        // Assert
        expect(find.byIcon(Icons.check), findsOneWidget);
      });

      testWidgets('should handle non-numeric input',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Act
        await tester.enterText(
          find.byType(TextField).first,
          'abc',
        );
        await tester.pump();

        // Assert
        expect(find.text('숫자를 입력하세요'), findsOneWidget);
      });

      testWidgets('should show no error for empty input',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Act
        await tester.enterText(
          find.byType(TextField).first,
          '',
        );
        await tester.pump();

        // Assert
        expect(find.byIcon(Icons.close), findsNothing);
      });
    });

    group('TC-WRS-04: Save Button Functionality', () {
      testWidgets('should enable save button when valid data is entered',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Act
        await tester.enterText(
          find.byType(TextField).first,
          '75.5',
        );
        await tester.pump();

        // Assert
        expect(find.byType(ElevatedButton), findsOneWidget);
      });

      testWidgets('should disable save button when no weight is entered',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Act & Assert
        final button = find.byType(ElevatedButton);
        expect(button, findsOneWidget);
      });
    });

    group('TC-WRS-05: Success Message', () {
      testWidgets('should display weight record screen',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: Scaffold(
                body: WeightRecordScreen(),
              ),
            ),
          ),
        );

        // Act
        await tester.enterText(
          find.byType(TextField).first,
          '75.5',
        );
        await tester.pumpAndSettle();

        // Assert
        expect(find.byType(WeightRecordScreen), findsOneWidget);
      });
    });

    group('TC-WRS-06: Duplicate Record Handling', () {
      testWidgets('should display weight record screen with validation',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Act & Assert
        expect(find.byType(WeightRecordScreen), findsOneWidget);
        expect(find.text('체중 기록'), findsOneWidget);
      });
    });

    group('TC-WRS-07: Date Picker Integration', () {
      testWidgets('should display calendar picker on icon tap',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Act
        await tester.tap(find.byIcon(Icons.calendar_today));
        await tester.pumpAndSettle();

        // Assert
        expect(find.byType(CalendarDatePicker), findsOneWidget);
      });
    });

    group('TC-WRS-08: Weight History Display', () {
      testWidgets('should render weight record screen',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Assert
        expect(find.text('체중 기록'), findsOneWidget);
      });
    });

    group('TC-WRS-09: Back Navigation', () {
      testWidgets('should display cancel button',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Assert
        expect(find.byType(WeightRecordScreen), findsOneWidget);
      });
    });

    group('TC-WRS-10: Loading State', () {
      testWidgets('should show loading indicator during save',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          ProviderScope(
            child: MaterialApp(
              home: WeightRecordScreen(),
            ),
          ),
        );

        // Assert
        expect(find.byType(CircularProgressIndicator), findsNothing);
      });
    });
  });
}
</file>

<file path="test/features/tracking/presentation/widgets/coping_guide_widget_test.dart">
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:n06/features/tracking/presentation/widgets/coping_guide_widget.dart';

void main() {
  group('CopingGuideWidget', () {
    group('TC-CGW-01: Symptom-Specific Guides', () {
      testWidgets('should render nausea coping guide',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '메스꺼움',
                severity: 5,
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('메스꺼움 대처 가이드'), findsOneWidget);
        expect(find.text('심각도: 5/10'), findsOneWidget);
      });

      testWidgets('should display correct guide for vomiting symptom',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '구토',
                severity: 7,
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('구토 대처 가이드'), findsOneWidget);
      });

      testWidgets('should display correct guide for constipation',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '변비',
                severity: 4,
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('변비 대처 가이드'), findsOneWidget);
      });

      testWidgets('should display correct guide for diarrhea',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '설사',
                severity: 6,
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('설사 대처 가이드'), findsOneWidget);
      });

      testWidgets('should display correct guide for abdominal pain',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '복통',
                severity: 5,
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('복통 대처 가이드'), findsOneWidget);
      });

      testWidgets('should display correct guide for headache',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '두통',
                severity: 4,
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('두통 대처 가이드'), findsOneWidget);
      });

      testWidgets('should display correct guide for fatigue',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '피로',
                severity: 6,
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('피로 대처 가이드'), findsOneWidget);
      });
    });

    group('TC-CGW-02: Feedback Selection', () {
      testWidgets('should allow selecting helpful feedback',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '메스꺼움',
                severity: 5,
              ),
            ),
          ),
        );

        // Act
        await tester.tap(find.text('예'));
        await tester.pump();

        // Assert
        expect(find.text('피드백해주셔서 감사합니다!'), findsOneWidget);
      });

      testWidgets('should allow selecting not helpful feedback',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '메스꺼움',
                severity: 5,
              ),
            ),
          ),
        );

        // Act
        await tester.tap(find.text('아니오'));
        await tester.pump();

        // Assert
        expect(find.byType(CopingGuideWidget), findsOneWidget);
      });
    });

    group('TC-CGW-03: Save Feedback to Repository', () {
      testWidgets('should display widget after feedback',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '메스꺼움',
                severity: 5,
              ),
            ),
          ),
        );

        // Act
        await tester.tap(find.text('예'));
        await tester.pump();

        // Assert
        expect(find.text('피드백해주셔서 감사합니다!'), findsOneWidget);
      });
    });

    group('TC-CGW-04: Rate Guide Usefulness', () {
      testWidgets('should display feedback options',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '메스꺼움',
                severity: 5,
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('도움이 되었나요?'), findsOneWidget);
        expect(find.text('예'), findsOneWidget);
        expect(find.text('아니오'), findsOneWidget);
      });

      testWidgets('should handle user rating feedback',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '메스꺼움',
                severity: 5,
              ),
            ),
          ),
        );

        // Act
        await tester.tap(find.text('예'));
        await tester.pump();

        // Assert
        expect(find.text('피드백해주셔서 감사합니다!'), findsOneWidget);
      });
    });

    group('TC-CGW-05: Scroll Through Guides', () {
      testWidgets('should be scrollable if content is long',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '메스꺼움',
                severity: 5,
              ),
            ),
          ),
        );

        // Assert
        expect(find.byType(CopingGuideWidget), findsOneWidget);
      });
    });

    group('TC-CGW-06: Close Widget on Dismiss', () {
      testWidgets('should have close button',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '메스꺼움',
                severity: 5,
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('닫기'), findsOneWidget);
      });

      testWidgets('should call onClose callback when close button is tapped',
          (tester) async {
        // Arrange
        bool closed = false;
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '메스꺼움',
                severity: 5,
                onClose: () => closed = true,
              ),
            ),
          ),
        );

        // Act
        await tester.tap(find.text('닫기'));
        await tester.pump();

        // Assert
        expect(closed, true);
      });

      testWidgets('should dismiss widget on close action',
          (tester) async {
        // Arrange
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '메스꺼움',
                severity: 5,
              ),
            ),
          ),
        );

        // Assert
        expect(find.byType(CopingGuideWidget), findsOneWidget);
      });
    });

    group('TC-CGW-07: Load Coping Guides on Init', () {
      testWidgets('should render coping guide on initialization',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '메스꺼움',
                severity: 5,
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('메스꺼움 대처 가이드'), findsOneWidget);
        expect(find.text('심각도: 5/10'), findsOneWidget);
      });

      testWidgets('should handle unknown symptom gracefully',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '미지의증상',
                severity: 5,
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('대처 가이드'), findsOneWidget);
      });

      testWidgets('should display guide content for known symptoms',
          (tester) async {
        // Arrange & Act
        await tester.pumpWidget(
          MaterialApp(
            home: Scaffold(
              body: CopingGuideWidget(
                symptomName: '메스꺼움',
                severity: 4,
              ),
            ),
          ),
        );

        // Assert
        expect(find.text('메스꺼움 대처 가이드'), findsOneWidget);
      });
    });
  });
}
</file>

<file path="android/app/src/main/kotlin/com/glp1/n06/MainActivity.kt">
package com.glp1.n06

import android.content.Intent
import android.os.Bundle
import android.util.Log
import io.flutter.embedding.android.FlutterActivity

/**
 * MainActivity for Kakao OAuth.
 *
 * Changed from FlutterFragmentActivity to FlutterActivity
 * to resolve Intent handling issues with Kakao SDK.
 */
class MainActivity : FlutterActivity() {
    companion object {
        private const val TAG = "MainActivity"
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.d(TAG, "🔍 [HEALTH CHECK] onCreate called")
    }

    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        Log.d(TAG, "🔍 [HEALTH CHECK] onNewIntent called with URI: ${intent.data}")

        // Set the intent so it's available for the engine
        setIntent(intent)
    }
}
</file>

<file path="android/app/src/main/AndroidManifest.xml">
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">
    <application
        android:label="n06"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>

        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />

        <!-- Kakao SDK -->
        <meta-data
            android:name="com.kakao.sdk.AppKey"
            android:value="32dfc3999b53af153dbcefa7014093bc" />

        <!-- Kakao OAuth callback handler -->
        <activity
            android:name="com.kakao.sdk.flutter.AuthCodeCustomTabsActivity"
            android:exported="true"
            android:launchMode="singleTask"
            tools:replace="android:launchMode">
            <intent-filter android:label="flutter_web_auth">
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
                <data
                    android:scheme="kakao32dfc3999b53af153dbcefa7014093bc"
                    android:host="oauth" />
            </intent-filter>
        </activity>
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>
</file>

<file path="lib/features/authentication/presentation/screens/login_screen.dart">
import 'dart:developer' as developer;
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:n06/features/authentication/application/notifiers/auth_notifier.dart';
import 'package:n06/features/authentication/domain/exceptions/auth_exceptions.dart';

/// Login screen with social authentication options
///
/// Features:
/// - Kakao login button
/// - Naver login button
/// - Terms of service and privacy policy checkboxes
/// - Login buttons disabled until agreements are checked
/// - Navigation to onboarding (first login) or home dashboard (returning user)
class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  bool _agreedToTerms = false;
  bool _agreedToPrivacy = false;
  bool _isLoading = false;

  bool get _canLogin => _agreedToTerms && _agreedToPrivacy && !_isLoading;

  Future<void> _handleKakaoLogin() async {
    debugPrint('🔍 [LOGIN SCREEN] _handleKakaoLogin() called');

    if (kDebugMode) {
      developer.log(
        '🔐 Kakao login button clicked',
        name: 'LoginScreen',
      );
      developer.log(
        'Can login: $_canLogin (terms: $_agreedToTerms, privacy: $_agreedToPrivacy, loading: $_isLoading)',
        name: 'LoginScreen',
      );
    }

    if (!_canLogin) {
      if (kDebugMode) {
        developer.log(
          '⚠️ Login blocked - conditions not met',
          name: 'LoginScreen',
          level: 900,
        );
      }
      return;
    }

    setState(() => _isLoading = true);

    if (kDebugMode) {
      developer.log('📱 Starting Kakao login...', name: 'LoginScreen');
    }

    try {
      final notifier = ref.read(authNotifierProvider.notifier);

      debugPrint('🔍 [LOGIN SCREEN] Got notifier, calling loginWithKakao...');

      if (kDebugMode) {
        developer.log('🔄 Calling notifier.loginWithKakao()...', name: 'LoginScreen');
      }

      final isFirstLogin = await notifier.loginWithKakao(
        agreedToTerms: _agreedToTerms,
        agreedToPrivacy: _agreedToPrivacy,
      );

      debugPrint('🔍 [LOGIN SCREEN] loginWithKakao returned: $isFirstLogin');

      if (kDebugMode) {
        developer.log(
          '✅ Login completed. First login: $isFirstLogin',
          name: 'LoginScreen',
        );
      }

      if (!mounted) {
        debugPrint('🔍 [LOGIN SCREEN] ⚠️ Widget unmounted after login');
        if (kDebugMode) {
          developer.log('⚠️ Widget unmounted', name: 'LoginScreen', level: 900);
        }
        return;
      }

      debugPrint('🔍 [LOGIN SCREEN] Verifying auth state...');

      // Verify auth state before navigation
      final authState = ref.read(authNotifierProvider);

      debugPrint('🔍 [LOGIN SCREEN] Auth state: $authState');

      // Check for errors first (before accessing value)
      if (authState.hasError) {
        if (kDebugMode) {
          authState.whenOrNull(
            error: (error, stack) {
              developer.log(
                '❌ Auth state has error after login',
                name: 'LoginScreen',
                error: error,
                stackTrace: stack,
                level: 1000,
              );
            },
          );
        }
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('로그인에 실패했습니다. 다시 시도해주세요.'),
              backgroundColor: Colors.red,
            ),
          );
        }
        return;
      }

      // Safe to access value now (no error)
      final user = authState.valueOrNull;

      if (user == null) {
        if (kDebugMode) {
          developer.log(
            '❌ User is null after login',
            name: 'LoginScreen',
            level: 1000,
          );
        }
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('로그인 정보를 가져올 수 없습니다.'),
              backgroundColor: Colors.red,
            ),
          );
        }
        return;
      }

      if (kDebugMode) {
        developer.log(
          '✅ Auth state verified. User: ${user.id}',
          name: 'LoginScreen',
        );
      }

      if (mounted) {
        if (isFirstLogin) {
          if (kDebugMode) {
            developer.log('🚀 Navigating to onboarding...', name: 'LoginScreen');
          }
          context.go('/onboarding', extra: user.id);
        } else {
          if (kDebugMode) {
            developer.log('🏠 Navigating to home dashboard...', name: 'LoginScreen');
          }
          context.go('/home');
        }
      }
    } on OAuthCancelledException catch (e, stack) {
      if (kDebugMode) {
        developer.log(
          '🚫 OAuth cancelled by user',
          name: 'LoginScreen',
          error: e,
          stackTrace: stack,
          level: 900,
        );
      }
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('로그인이 취소되었습니다. 다시 시도해주세요.'),
            backgroundColor: Colors.orange,
          ),
        );
      }
    } on MaxRetriesExceededException catch (e, stack) {
      if (kDebugMode) {
        developer.log(
          '🌐 Network error - max retries exceeded',
          name: 'LoginScreen',
          error: e,
          stackTrace: stack,
          level: 1000,
        );
      }
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('네트워크 연결을 확인해주세요.'),
            backgroundColor: Colors.red,
            action: SnackBarAction(
              label: '재시도',
              textColor: Colors.white,
              onPressed: () => _handleKakaoLogin(),
            ),
          ),
        );
      }
    } catch (e, stack) {
      if (kDebugMode) {
        developer.log(
          '❌ Unexpected error during login',
          name: 'LoginScreen',
          error: e,
          stackTrace: stack,
          level: 1000,
        );
      }
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('로그인 중 오류가 발생했습니다: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
        if (kDebugMode) {
          developer.log('🏁 Login process completed', name: 'LoginScreen');
        }
      }
    }
  }

  Future<void> _handleNaverLogin() async {
    if (!_canLogin) return;

    setState(() => _isLoading = true);

    try {
      final notifier = ref.read(authNotifierProvider.notifier);
      final isFirstLogin = await notifier.loginWithNaver(
        agreedToTerms: _agreedToTerms,
        agreedToPrivacy: _agreedToPrivacy,
      );

      if (kDebugMode) {
        developer.log(
          '✅ Login completed. First login: $isFirstLogin',
          name: 'LoginScreen',
        );
      }

      if (!mounted) {
        if (kDebugMode) {
          developer.log('⚠️ Widget unmounted', name: 'LoginScreen', level: 900);
        }
        return;
      }

      // Verify auth state before navigation
      final authState = ref.read(authNotifierProvider);

      // Check for errors first (before accessing value)
      if (authState.hasError) {
        if (kDebugMode) {
          authState.whenOrNull(
            error: (error, stack) {
              developer.log(
                '❌ Auth state has error after login',
                name: 'LoginScreen',
                error: error,
                stackTrace: stack,
                level: 1000,
              );
            },
          );
        }
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('로그인에 실패했습니다. 다시 시도해주세요.'),
              backgroundColor: Colors.red,
            ),
          );
        }
        return;
      }

      // Safe to access value now (no error)
      final user = authState.valueOrNull;

      if (user == null) {
        if (kDebugMode) {
          developer.log(
            '❌ User is null after login',
            name: 'LoginScreen',
            level: 1000,
          );
        }
        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(
              content: Text('로그인 정보를 가져올 수 없습니다.'),
              backgroundColor: Colors.red,
            ),
          );
        }
        return;
      }

      if (kDebugMode) {
        developer.log(
          '✅ Auth state verified. User: ${user.id}',
          name: 'LoginScreen',
        );
      }

      if (mounted) {
        if (isFirstLogin) {
          if (kDebugMode) {
            developer.log('🚀 Navigating to onboarding...', name: 'LoginScreen');
          }
          context.go('/onboarding', extra: user.id);
        } else {
          if (kDebugMode) {
            developer.log('🏠 Navigating to home dashboard...', name: 'LoginScreen');
          }
          context.go('/home');
        }
      }
    } on OAuthCancelledException {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('로그인이 취소되었습니다. 다시 시도해주세요.'),
            backgroundColor: Colors.orange,
          ),
        );
      }
    } on MaxRetriesExceededException {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('네트워크 연결을 확인해주세요.'),
            backgroundColor: Colors.red,
            action: SnackBarAction(
              label: '재시도',
              textColor: Colors.white,
              onPressed: () => _handleNaverLogin(),
            ),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('로그인 중 오류가 발생했습니다: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Logo or Title
              const Icon(
                Icons.medication,
                size: 80,
                color: Colors.blue,
              ),
              const SizedBox(height: 24),
              const Text(
                'GLP-1 치료 관리',
                textAlign: TextAlign.center,
                style: TextStyle(
                  fontSize: 28,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 8),
              const Text(
                '안전하고 효과적인 치료를 위해',
                textAlign: TextAlign.center,
                style: TextStyle(
                  fontSize: 16,
                  color: Colors.grey,
                ),
              ),
              const SizedBox(height: 48),

              // Terms checkboxes
              CheckboxListTile(
                key: const Key('terms_checkbox'),
                title: const Text('이용약관 동의 (필수)'),
                value: _agreedToTerms,
                onChanged: _isLoading
                    ? null
                    : (value) {
                        setState(() => _agreedToTerms = value ?? false);
                      },
                controlAffinity: ListTileControlAffinity.leading,
              ),
              CheckboxListTile(
                key: const Key('privacy_checkbox'),
                title: const Text('개인정보처리방침 동의 (필수)'),
                value: _agreedToPrivacy,
                onChanged: _isLoading
                    ? null
                    : (value) {
                        setState(() => _agreedToPrivacy = value ?? false);
                      },
                controlAffinity: ListTileControlAffinity.leading,
              ),

              const SizedBox(height: 32),

              // Kakao Login Button
              ElevatedButton.icon(
                key: const Key('kakao_login_button'),
                onPressed: _canLogin ? _handleKakaoLogin : null,
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFFFEE500),
                  foregroundColor: Colors.black87,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
                icon: _isLoading
                    ? const SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          color: Colors.black87,
                        ),
                      )
                    : const Icon(Icons.chat_bubble),
                label: const Text(
                  '카카오 로그인',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),

              const SizedBox(height: 12),

              // Naver Login Button
              ElevatedButton.icon(
                key: const Key('naver_login_button'),
                onPressed: _canLogin ? _handleNaverLogin : null,
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF03C75A),
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
                icon: _isLoading
                    ? const SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(
                          strokeWidth: 2,
                          color: Colors.white,
                        ),
                      )
                    : const Icon(Icons.language),
                label: const Text(
                  '네이버 로그인',
                  style: TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),

              const SizedBox(height: 24),

              // Helper text
              if (!_canLogin && !_isLoading)
                const Text(
                  '로그인하려면 약관에 동의해주세요',
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    fontSize: 14,
                    color: Colors.grey,
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}
</file>

<file path="lib/features/data_sharing/presentation/screens/data_sharing_screen.dart">
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:n06/features/data_sharing/application/notifiers/data_sharing_notifier.dart';
import 'package:n06/features/data_sharing/domain/repositories/date_range.dart';

class DataSharingScreen extends ConsumerStatefulWidget {
  final String? userId;

  const DataSharingScreen({super.key, this.userId});

  @override
  ConsumerState<DataSharingScreen> createState() => _DataSharingScreenState();
}

class _DataSharingScreenState extends ConsumerState<DataSharingScreen> {
  DateRange _selectedPeriod = DateRange.lastMonth;

  @override
  void initState() {
    super.initState();
    // Enter sharing mode on screen initialization
    Future.microtask(() {
      final userId = widget.userId;
      if (userId != null) {
        ref.read(dataSharingNotifierProvider.notifier).enterSharingMode(userId, _selectedPeriod);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(dataSharingNotifierProvider);

    return PopScope(
      canPop: false,
      onPopInvokedWithResult: (didPop, result) async {
        if (didPop) return;
        _showExitDialog(context);
      },
      child: Scaffold(
        appBar: AppBar(
          title: const Text('기록 보여주기'),
          leading: IconButton(
            icon: const Icon(Icons.close),
            onPressed: () => _showExitDialog(context),
          ),
          automaticallyImplyLeading: false,
        ),
        body: state.isLoading
            ? const Center(child: CircularProgressIndicator())
            : state.error != null
            ? _buildErrorState(state.error!)
            : _buildReportContent(state, context),
      ),
    );
  }

  Widget _buildErrorState(String error) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.error_outline, size: 48, color: Colors.red),
          const SizedBox(height: 16),
          Text('오류가 발생했습니다: $error'),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed: () {
              ref
                  .read(dataSharingNotifierProvider.notifier)
                  .enterSharingMode(widget.userId ?? '', _selectedPeriod);
            },
            child: const Text('다시 시도'),
          ),
        ],
      ),
    );
  }

  Widget _buildReportContent(DataSharingState state, BuildContext context) {
    final report = state.report;
    if (report == null) {
      return const Center(child: Text('데이터를 불러올 수 없습니다.'));
    }

    if (!report.hasData()) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.inbox_outlined, size: 48, color: Colors.grey),
            const SizedBox(height: 16),
            const Text('선택된 기간에 기록이 없습니다.'),
          ],
        ),
      );
    }

    return SingleChildScrollView(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Period Selector
            _buildPeriodSelector(state),
            const SizedBox(height: 24),

            // Dose Records Section
            if (report.doseRecords.isNotEmpty) ...[
              _buildSectionTitle('투여 기록'),
              _buildDoseRecordsSection(report),
              const SizedBox(height: 24),
            ],

            // Adherence Rate
            _buildAdherenceRateSection(report),
            const SizedBox(height: 24),

            // Injection Site History
            if (report.getInjectionSiteHistory().isNotEmpty) ...[
              _buildSectionTitle('주사 부위 순환 이력'),
              _buildInjectionSiteSection(report),
              const SizedBox(height: 24),
            ],

            // Weight Logs Section
            if (report.weightLogs.isNotEmpty) ...[
              _buildSectionTitle('체중 변화'),
              _buildWeightLogsSection(report),
              const SizedBox(height: 24),
            ],

            // Symptom Logs Section
            if (report.symptomLogs.isNotEmpty) ...[
              _buildSectionTitle('부작용 기록'),
              _buildSymptomLogsSection(report),
              const SizedBox(height: 24),
            ],

            // Exit Sharing Mode Button
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: () {
                  ref.read(dataSharingNotifierProvider.notifier).exitSharingMode();
                  Navigator.of(context).pop();
                },
                icon: const Icon(Icons.exit_to_app),
                label: const Text('공유 종료'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.orange,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildPeriodSelector(DataSharingState state) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('표시 기간', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
        const SizedBox(height: 12),
        Row(
          children: DateRange.values.map((period) {
            return Expanded(
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 4),
                child: ChoiceChip(
                  label: Text(period.label, textAlign: TextAlign.center),
                  selected: _selectedPeriod == period,
                  onSelected: (selected) {
                    setState(() => _selectedPeriod = period);
                    if (selected) {
                      ref
                          .read(dataSharingNotifierProvider.notifier)
                          .changePeriod(widget.userId ?? '', period);
                    }
                  },
                ),
              ),
            );
          }).toList(),
        ),
      ],
    );
  }

  Widget _buildSectionTitle(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Text(title, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
    );
  }

  Widget _buildDoseRecordsSection(dynamic report) {
    final records = report.getDoseRecordsSorted();
    return Column(
      children: records.map((record) {
        return Card(
          child: ListTile(
            leading: const Icon(Icons.medical_services),
            title: Text('${record.actualDoseMg} mg'),
            subtitle: Text(
              '${record.administeredAt.toLocal().toString().split('.')[0]} | ${record.injectionSite ?? '부위 미지정'}',
            ),
          ),
        );
      }).toList(),
    );
  }

  Widget _buildAdherenceRateSection(dynamic report) {
    final rate = report.calculateAdherenceRate();
    return Card(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('투여 순응도', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
            const SizedBox(height: 12),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  '${rate.toStringAsFixed(1)}%',
                  style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                ),
                Expanded(
                  child: Padding(
                    padding: const EdgeInsets.only(left: 16),
                    child: LinearProgressIndicator(value: rate / 100, minHeight: 8),
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildInjectionSiteSection(dynamic report) {
    final sites = report.getInjectionSiteHistory();
    return Column(
      children: sites.entries.map((entry) {
        return ListTile(
          title: Text(entry.key),
          trailing: Text('${entry.value}회', style: const TextStyle(fontWeight: FontWeight.bold)),
        );
      }).toList(),
    );
  }

  Widget _buildWeightLogsSection(dynamic report) {
    final logs = report.getWeightLogsSorted();
    return Column(
      children: logs.map((log) {
        return ListTile(
          leading: const Icon(Icons.scale),
          title: Text('${log.weightKg} kg'),
          subtitle: Text(log.logDate.toString().split(' ')[0]),
        );
      }).toList(),
    );
  }

  Widget _buildSymptomLogsSection(dynamic report) {
    final logs = report.getSymptomLogsSorted();
    return Column(
      children: logs.map((log) {
        return Card(
          child: ListTile(
            leading: const Icon(Icons.warning),
            title: Text(log.symptomName),
            subtitle: Text('심각도: ${log.severity}/10'),
            trailing: Text(log.logDate.toString().split(' ')[0]),
          ),
        );
      }).toList(),
    );
  }

  void _showExitDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('공유 종료'),
        content: const Text('공유를 종료하시겠습니까?'),
        actions: [
          TextButton(onPressed: () => Navigator.of(context).pop(), child: const Text('취소')),
          TextButton(
            onPressed: () {
              ref.read(dataSharingNotifierProvider.notifier).exitSharingMode();
              Navigator.of(context).pop();
              Navigator.of(context).pop();
            },
            child: const Text('종료'),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="lib/features/tracking/infrastructure/repositories/isar_medication_repository.dart">
import 'package:isar/isar.dart';
import 'package:n06/features/tracking/domain/entities/dosage_plan.dart';
import 'package:n06/features/tracking/domain/entities/dose_record.dart';
import 'package:n06/features/tracking/domain/entities/dose_schedule.dart';
import 'package:n06/features/tracking/domain/entities/plan_change_history.dart';
import 'package:n06/features/tracking/domain/repositories/medication_repository.dart';
import 'package:n06/features/tracking/infrastructure/dtos/dosage_plan_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/dose_record_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/dose_schedule_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/plan_change_history_dto.dart';

/// Isar-based implementation of MedicationRepository
///
/// Handles dose records, dose schedules, dosage plans, and change history.
/// For cleaner separation of concerns, consider using the dedicated repositories:
/// - IsarDosagePlanRepository for dosage plan operations
/// - IsarDoseScheduleRepository for schedule operations
class IsarMedicationRepository implements MedicationRepository {
  final Isar isar;

  IsarMedicationRepository(this.isar);

  // ===== DosagePlan (Backward Compatibility) =====

  @override
  Future<DosagePlan?> getActiveDosagePlan(String userId) async {
    final dto = await isar.dosagePlanDtos
        .filter()
        .userIdEqualTo(userId)
        .isActiveEqualTo(true)
        .findFirst();

    return dto?.toEntity();
  }

  @override
  Future<DosagePlan?> getDosagePlan(String planId) async {
    final dto = await isar.dosagePlanDtos
        .filter()
        .planIdEqualTo(planId)
        .findFirst();

    return dto?.toEntity();
  }

  @override
  Future<void> saveDosagePlan(DosagePlan plan) async {
    final dto = DosagePlanDto.fromEntity(plan);
    await isar.writeTxn(() => isar.dosagePlanDtos.put(dto));
  }

  @override
  Future<void> updateDosagePlan(DosagePlan plan) async {
    final dto = DosagePlanDto.fromEntity(plan);
    await isar.writeTxn(() => isar.dosagePlanDtos.put(dto));
  }

  // ===== DoseSchedule (Backward Compatibility) =====

  @override
  Future<List<DoseSchedule>> getDoseSchedules(String planId) async {
    final dtos = await isar.doseScheduleDtos
        .filter()
        .dosagePlanIdEqualTo(planId)
        .findAll();

    return dtos.map((dto) => dto.toEntity()).toList();
  }

  @override
  Future<void> saveDoseSchedules(List<DoseSchedule> schedules) async {
    final dtos =
        schedules.map((schedule) => DoseScheduleDto.fromEntity(schedule)).toList();

    await isar.writeTxn(() => isar.doseScheduleDtos.putAll(dtos));
  }

  @override
  Future<void> deleteDoseSchedulesFrom(String planId, DateTime fromDate) async {
    await isar.writeTxn(() async {
      final dtos = await isar.doseScheduleDtos
          .filter()
          .dosagePlanIdEqualTo(planId)
          .scheduledDateGreaterThan(fromDate)
          .findAll();

      await isar.doseScheduleDtos.deleteAll(dtos.map((dto) => dto.id!).toList());
    });
  }

  @override
  Future<void> updateDoseSchedule(DoseSchedule schedule) async {
    final dto = DoseScheduleDto.fromEntity(schedule);
    await isar.writeTxn(() => isar.doseScheduleDtos.put(dto));
  }

  // ===== DoseRecord =====

  @override
  Future<List<DoseRecord>> getDoseRecords(String planId) async {
    final dtos = await isar.doseRecordDtos
        .filter()
        .dosagePlanIdEqualTo(planId)
        .findAll();

    return dtos.map((dto) => dto.toEntity()).toList();
  }

  @override
  Future<List<DoseRecord>> getRecentDoseRecords(String planId, int days) async {
    final since = DateTime.now().subtract(Duration(days: days));

    final dtos = await isar.doseRecordDtos
        .filter()
        .dosagePlanIdEqualTo(planId)
        .administeredAtGreaterThan(since)
        .findAll();

    return dtos.map((dto) => dto.toEntity()).toList();
  }

  @override
  Future<void> saveDoseRecord(DoseRecord record) async {
    final dto = DoseRecordDto.fromEntity(record);
    await isar.writeTxn(() => isar.doseRecordDtos.put(dto));
  }

  @override
  Future<void> deleteDoseRecord(String recordId) async {
    await isar.writeTxn(() async {
      final dto = await isar.doseRecordDtos
          .filter()
          .recordIdEqualTo(recordId)
          .findFirst();

      if (dto != null && dto.id != null) {
        await isar.doseRecordDtos.delete(dto.id!);
      }
    });
  }

  @override
  Future<bool> isDuplicateDoseRecord(
    String planId,
    DateTime scheduledDate,
  ) async {
    final date = DateTime(
      scheduledDate.year,
      scheduledDate.month,
      scheduledDate.day,
    );

    final endDate = date.add(Duration(days: 1));

    final exists = await isar.doseRecordDtos
        .filter()
        .dosagePlanIdEqualTo(planId)
        .administeredAtBetween(date, endDate)
        .findFirst();

    return exists != null;
  }

  @override
  Future<DoseRecord?> getDoseRecordByDate(
    String planId,
    DateTime date,
  ) async {
    final startDate = DateTime(date.year, date.month, date.day);
    final endDate = startDate.add(Duration(days: 1));

    final dto = await isar.doseRecordDtos
        .filter()
        .dosagePlanIdEqualTo(planId)
        .administeredAtBetween(startDate, endDate)
        .findFirst();

    return dto?.toEntity();
  }

  @override
  Future<DoseRecord?> getDoseRecord(String recordId) async {
    final dto = await isar.doseRecordDtos
        .filter()
        .recordIdEqualTo(recordId)
        .findFirst();

    return dto?.toEntity();
  }

  @override
  Future<void> updateDoseRecord(
    String recordId,
    double doseMg,
    String injectionSite,
    String? note,
  ) async {
    await isar.writeTxn(() async {
      final dto = await isar.doseRecordDtos
          .filter()
          .recordIdEqualTo(recordId)
          .findFirst();

      if (dto != null) {
        dto.actualDoseMg = doseMg;
        dto.injectionSite = injectionSite;
        dto.note = note;
        await isar.doseRecordDtos.put(dto);
      }
    });
  }

  // ===== Plan Change History =====

  @override
  Future<void> savePlanChangeHistory(
    String planId,
    Map<String, dynamic> oldPlan,
    Map<String, dynamic> newPlan,
  ) async {
    final history = PlanChangeHistory(
      id: 'history_${DateTime.now().millisecondsSinceEpoch}',
      dosagePlanId: planId,
      changedAt: DateTime.now(),
      oldPlan: oldPlan,
      newPlan: newPlan,
    );

    final dto = PlanChangeHistoryDto.fromEntity(history);
    await isar.writeTxn(() => isar.planChangeHistoryDtos.put(dto));
  }

  @override
  Future<List<PlanChangeHistory>> getPlanChangeHistory(String planId) async {
    final dtos = await isar.planChangeHistoryDtos
        .filter()
        .dosagePlanIdEqualTo(planId)
        .sortByIndexedChangedAtDesc()
        .findAll();

    return dtos.map((dto) => dto.toEntity()).toList();
  }

  // ===== Streams =====

  @override
  Stream<List<DoseRecord>> watchDoseRecords(String planId) {
    return isar.doseRecordDtos
        .filter()
        .dosagePlanIdEqualTo(planId)
        .watch(fireImmediately: true)
        .map((dtos) => dtos.map((dto) => dto.toEntity()).toList());
  }

  @override
  Stream<DosagePlan?> watchActiveDosagePlan(String userId) {
    return isar.dosagePlanDtos
        .filter()
        .userIdEqualTo(userId)
        .isActiveEqualTo(true)
        .watch(fireImmediately: true)
        .map((dtos) => dtos.isNotEmpty ? dtos.first.toEntity() : null);
  }

  @override
  Stream<List<DoseSchedule>> watchDoseSchedules(String planId) {
    return isar.doseScheduleDtos
        .filter()
        .dosagePlanIdEqualTo(planId)
        .watch(fireImmediately: true)
        .map((dtos) => dtos.map((dto) => dto.toEntity()).toList());
  }
}
</file>

<file path=".gitignore">
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.build/
.buildlog/
.history
.svn/
.swiftpm/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.packages
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release

# Code Generation
*.g.dart
*.freezed.dart
*.gr.dart
*.config.dart

# Isar Database
*.isar
*.isar.lock
isar_inspector/

# Firebase
# Keep firebase config templates but ignore actual config files with keys
**/firebase_options.dart
**/google-services.json
**/GoogleService-Info.plist
.firebase/
firebase-debug.log
firestore-debug.log
ui-debug.log

# Environment Variables
.env
.env.local
.env.*.local
.envrc

# Secrets & Keys
secrets.json
credentials.json
*.pem
*.key
*.p12
*.mobileprovision
*.cert
**/key.properties

# Test Coverage
coverage/
test/.test_coverage.dart
.test_coverage.dart
lcov.info

# Patrol E2E Testing
patrol_cli.log
.patrol/

# iOS
**/ios/**/*.mode1v3
**/ios/**/*.mode2v3
**/ios/**/*.moved-aside
**/ios/**/*.pbxuser
**/ios/**/*.perspectivev3
**/ios/**/Pods/
**/ios/**/Podfile.lock
**/ios/**/.symlinks/
**/ios/**/profile
**/ios/**/xcuserdata
**/ios/.generated/
**/ios/Flutter/.last_build_id
**/ios/Flutter/App.framework
**/ios/Flutter/Flutter.framework
**/ios/Flutter/Flutter.podspec
**/ios/Flutter/Generated.xcconfig
**/ios/Flutter/app.flx
**/ios/Flutter/app.zip
**/ios/Flutter/flutter_assets/
**/ios/Flutter/flutter_export_environment.sh
**/ios/ServiceDefinitions.json
**/ios/Runner/GeneratedPluginRegistrant.*

# macOS
**/macos/Flutter/GeneratedPluginRegistrant.swift
**/macos/Flutter/Flutter-Debug.xcconfig
**/macos/Flutter/Flutter-Release.xcconfig

# Android
**/android/**/gradle-wrapper.jar
**/android/.gradle
**/android/captures/
**/android/gradlew
**/android/gradlew.bat
**/android/local.properties
**/android/**/GeneratedPluginRegistrant.java
**/android/**/GeneratedPluginRegistrant.kt
**/android/key.properties
**/android/build/
*.jks
*.keystore

# Windows
**/windows/flutter/generated_plugin_registrant.cc
**/windows/flutter/generated_plugin_registrant.h
**/windows/flutter/generated_plugins.cmake

# Linux
**/linux/flutter/generated_plugin_registrant.cc
**/linux/flutter/generated_plugin_registrant.h
**/linux/flutter/generated_plugins.cmake

# Web
**/web/flutter_bootstrap.js
**/web/flutter_service_worker.js
**/web/version.json

# Supabase
.supabase/

# Temporary files
*.tmp
*.temp
*.bak
*.backup

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Editor directories and files
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
!.vscode/*.code-snippets
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
*~

# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon
._*
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

# Windows
Thumbs.db
Thumbs.db:encryptable
ehthumbs.db
ehthumbs_vista.db
*.stackdump
[Dd]esktop.ini
$RECYCLE.BIN/
*.cab
*.msi
*.msix
*.msm
*.msp
*.lnk

# Linux
*~
.fuse_hidden*
.directory
.Trash-*
.nfs*

# Custom Project Specific
# Add any project-specific ignores below this line
TEST_SETUP_COMPLETE.md
</file>

<file path="lib/features/authentication/application/notifiers/auth_notifier.dart">
import 'dart:developer' as developer;
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart' show debugPrint;
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:n06/features/authentication/domain/entities/user.dart';
import 'package:n06/features/authentication/domain/repositories/auth_repository.dart';
import 'package:n06/features/authentication/application/providers.dart';

part 'auth_notifier.g.dart';

/// Authentication state notifier
///
/// Manages authentication state including:
/// - Login/logout operations
/// - Current user state
/// - Token validation and refresh
/// - First login detection
@Riverpod(keepAlive: true)  // 인증 상태는 글로벌 상태이므로 keepAlive 필수
class AuthNotifier extends _$AuthNotifier {
  @override
  Future<User?> build() async {
    // Load current user on initialization
    final repository = ref.read(authRepositoryProvider);
    return await repository.getCurrentUser();
  }

  /// Login with Kakao OAuth
  ///
  /// [agreedToTerms] User agreed to terms of service
  /// [agreedToPrivacy] User agreed to privacy policy
  ///
  /// Throws [OAuthCancelledException] if user cancels
  /// Throws [MaxRetriesExceededException] if network fails after 3 retries
  Future<bool> loginWithKakao({
    required bool agreedToTerms,
    required bool agreedToPrivacy,
  }) async {
    debugPrint('🔍 [HEALTH CHECK] AuthNotifier.loginWithKakao() called');
    if (kDebugMode) {
      developer.log(
        '🔐 loginWithKakao called (terms: $agreedToTerms, privacy: $agreedToPrivacy)',
        name: 'AuthNotifier',
      );
    }

    debugPrint('🔍 [HEALTH CHECK] Setting state to loading...');
    state = const AsyncValue.loading();

    debugPrint('🔍 [HEALTH CHECK] State is now loading');
    if (kDebugMode) {
      developer.log('⏳ State set to loading', name: 'AuthNotifier');
    }

    // Use try-catch instead of AsyncValue.guard
    try {
      debugPrint('🔍 [HEALTH CHECK] Getting authRepositoryProvider...');
      final repository = ref.read(authRepositoryProvider);

      debugPrint('🔍 [HEALTH CHECK] Calling repository.loginWithKakao()...');
      if (kDebugMode) {
        developer.log('📞 Calling repository.loginWithKakao()...', name: 'AuthNotifier');
      }

      final user = await repository.loginWithKakao(
        agreedToTerms: agreedToTerms,
        agreedToPrivacy: agreedToPrivacy,
      );

      debugPrint('🔍 [HEALTH CHECK] repository.loginWithKakao() returned user: ${user.id}');
      if (kDebugMode) {
        developer.log(
          '✅ Repository returned user: ${user.id}',
          name: 'AuthNotifier',
        );
      }

      // CRITICAL FIX: Explicitly set state with AsyncValue.data
      state = AsyncValue.data(user);
      debugPrint('🔍 [HEALTH CHECK] State updated with AsyncValue.data(user)');

      // Debug: Check state immediately after setting
      debugPrint('🔍 [HEALTH CHECK] Current state after update: $state');
      debugPrint('🔍 [HEALTH CHECK] State hasValue: ${state.hasValue}');
      debugPrint('🔍 [HEALTH CHECK] State value: ${state.valueOrNull}');

      // Check if this is first login
      debugPrint('🔍 [HEALTH CHECK] Checking if first login...');
      final isFirstLogin = await repository.isFirstLogin();

      debugPrint('🔍 [HEALTH CHECK] isFirstLogin result: $isFirstLogin');
      if (kDebugMode) {
        developer.log(
          '✅ Is first login: $isFirstLogin',
          name: 'AuthNotifier',
        );
      }

      debugPrint('🔍 [HEALTH CHECK] AuthNotifier.loginWithKakao() returning: $isFirstLogin');
      return isFirstLogin;

    } catch (error, stackTrace) {
      debugPrint('🔍 [HEALTH CHECK] ❌ Error occurred: $error');

      // Set error state
      state = AsyncValue.error(error, stackTrace);

      if (kDebugMode) {
        developer.log(
          '❌ Login failed with error',
          name: 'AuthNotifier',
          error: error,
          stackTrace: stackTrace,
          level: 1000,
        );
      }

      return false;
    }
  }

  /// Login with Naver OAuth
  ///
  /// [agreedToTerms] User agreed to terms of service
  /// [agreedToPrivacy] User agreed to privacy policy
  ///
  /// Throws exceptions on failure
  Future<bool> loginWithNaver({
    required bool agreedToTerms,
    required bool agreedToPrivacy,
  }) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(authRepositoryProvider);
      final user = await repository.loginWithNaver(
        agreedToTerms: agreedToTerms,
        agreedToPrivacy: agreedToPrivacy,
      );
      return user;
    });

    // Return isFirstLogin status
    if (state.hasValue) {
      final repository = ref.read(authRepositoryProvider);
      return await repository.isFirstLogin();
    }
    return false;
  }

  /// Logout current user
  ///
  /// Always succeeds even if network request fails (local cleanup guaranteed)
  Future<void> logout() async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final useCase = ref.read(logoutUseCaseProvider);
      await useCase.execute();
      return null;
    });
  }

  /// Ensure access token is valid, refresh if needed
  ///
  /// Returns true if token is valid or successfully refreshed
  /// Returns false if refresh fails (user needs to re-login)
  Future<bool> ensureValidToken() async {
    final repository = ref.read(authRepositoryProvider);
    final isValid = await repository.isAccessTokenValid();

    if (!isValid) {
      // Token expired, need to re-login
      // In Phase 0, we don't have token refresh
      // User will need to re-login
      await logout();
      return false;
    }

    return true;
  }
}

/// Provider for AuthRepository
///
/// Phase 0: Returns IsarAuthRepository
/// Phase 1: Will return SupabaseMedicationRepository
@riverpod
AuthRepository authRepository(AuthRepositoryRef ref) {
  // This will be injected properly through providers in main.dart
  throw UnimplementedError(
    'authRepositoryProvider must be overridden in ProviderScope',
  );
}
</file>

<file path="lib/features/onboarding/presentation/screens/onboarding_screen.dart">
import 'package:flutter/material.dart';
import 'package:n06/features/onboarding/domain/entities/escalation_step.dart';
import 'package:n06/features/onboarding/presentation/widgets/basic_profile_form.dart';
import 'package:n06/features/onboarding/presentation/widgets/weight_goal_form.dart';
import 'package:n06/features/onboarding/presentation/widgets/dosage_plan_form.dart';
import 'package:n06/features/onboarding/presentation/widgets/summary_screen.dart';

/// 온보딩 4단계 화면 네비게이션
class OnboardingScreen extends StatefulWidget {
  final String? userId;
  final VoidCallback? onComplete;

  const OnboardingScreen({super.key, this.userId, this.onComplete});

  @override
  State<OnboardingScreen> createState() => _OnboardingScreenState();
}

class _OnboardingScreenState extends State<OnboardingScreen> {
  late PageController _pageController;
  int _currentStep = 0;

  // Step 1 데이터
  String _name = '';

  // Step 2 데이터
  double _currentWeight = 0;
  double _targetWeight = 0;
  int? _targetPeriodWeeks;

  // Step 3 데이터
  String _medicationName = '';
  DateTime _startDate = DateTime.now();
  int _cycleDays = 7;
  double _initialDose = 0.25;
  List<EscalationStep>? _escalationPlan;

  @override
  void initState() {
    super.initState();
    _pageController = PageController();
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  void _nextStep() {
    if (_currentStep < 3) {
      _pageController.nextPage(
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
    }
  }

  void _onStepChanged(int index) {
    setState(() {
      _currentStep = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('온보딩'),
        elevation: 0,
        leading: _currentStep == 0
            ? null
            : IconButton(
                icon: const Icon(Icons.arrow_back),
                onPressed: () {
                  if (_currentStep > 0) {
                    _pageController.previousPage(
                      duration: const Duration(milliseconds: 300),
                      curve: Curves.easeInOut,
                    );
                  }
                },
              ),
      ),
      body: Column(
        children: [
          // 진행 표시기
          LinearProgressIndicator(value: (_currentStep + 1) / 4, minHeight: 4),
          const SizedBox(height: 8),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24),
            child: Text(
              '${_currentStep + 1}/4단계',
              style: const TextStyle(fontSize: 14, color: Colors.grey),
            ),
          ),
          const SizedBox(height: 16),
          // 페이지 뷰
          Expanded(
            child: PageView(
              controller: _pageController,
              onPageChanged: _onStepChanged,
              physics: const NeverScrollableScrollPhysics(),
              children: [
                // Step 1: 기본 프로필
                BasicProfileForm(onNameChanged: (name) => _name = name, onNext: _nextStep),
                // Step 2: 체중 및 목표
                WeightGoalForm(
                  onDataChanged: (current, target, period) {
                    _currentWeight = current;
                    _targetWeight = target;
                    _targetPeriodWeeks = period;
                  },
                  onNext: _nextStep,
                ),
                // Step 3: 투여 계획
                DosagePlanForm(
                  onDataChanged: (medication, date, cycle, dose, escalation) {
                    _medicationName = medication;
                    _startDate = date;
                    _cycleDays = cycle;
                    _initialDose = dose;
                    _escalationPlan = escalation;
                  },
                  onNext: _nextStep,
                ),
                // Step 4: 요약 및 확인
                SummaryScreen(
                  userId: widget.userId ?? '',
                  name: _name,
                  currentWeight: _currentWeight,
                  targetWeight: _targetWeight,
                  targetPeriodWeeks: _targetPeriodWeeks,
                  medicationName: _medicationName,
                  startDate: _startDate,
                  cycleDays: _cycleDays,
                  initialDose: _initialDose,
                  escalationPlan: _escalationPlan,
                  onComplete: widget.onComplete,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}
</file>

<file path="pubspec.lock">
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
  _fe_analyzer_shared:
    dependency: transitive
    description:
      name: _fe_analyzer_shared
      sha256: ae92f5d747aee634b87f89d9946000c2de774be1d6ac3e58268224348cd0101a
      url: "https://pub.dev"
    source: hosted
    version: "61.0.0"
  _flutterfire_internals:
    dependency: transitive
    description:
      name: _flutterfire_internals
      sha256: "37a42d06068e2fe3deddb2da079a8c4d105f241225ba27b7122b37e9865fd8f7"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.35"
  analyzer:
    dependency: transitive
    description:
      name: analyzer
      sha256: ea3d8652bda62982addfd92fdc2d0214e5f82e43325104990d4f4c4a2a313562
      url: "https://pub.dev"
    source: hosted
    version: "5.13.0"
  analyzer_plugin:
    dependency: transitive
    description:
      name: analyzer_plugin
      sha256: c1d5f167683de03d5ab6c3b53fc9aeefc5d59476e7810ba7bbddff50c6f4392d
      url: "https://pub.dev"
    source: hosted
    version: "0.11.2"
  args:
    dependency: transitive
    description:
      name: args
      sha256: d0481093c50b1da8910eb0bb301626d4d8eb7284aa739614d2b394ee09e3ea04
      url: "https://pub.dev"
    source: hosted
    version: "2.7.0"
  asn1lib:
    dependency: transitive
    description:
      name: asn1lib
      sha256: "9a8f69025044eb466b9b60ef3bc3ac99b4dc6c158ae9c56d25eeccf5bc56d024"
      url: "https://pub.dev"
    source: hosted
    version: "1.6.5"
  async:
    dependency: transitive
    description:
      name: async
      sha256: "758e6d74e971c3e5aceb4110bfd6698efc7f501675bcfe0c775459a8140750eb"
      url: "https://pub.dev"
    source: hosted
    version: "2.13.0"
  boolean_selector:
    dependency: transitive
    description:
      name: boolean_selector
      sha256: "8aab1771e1243a5063b8b0ff68042d67334e3feab9e95b9490f9a6ebf73b42ea"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  build:
    dependency: transitive
    description:
      name: build
      sha256: "80184af8b6cb3e5c1c4ec6d8544d27711700bc3e6d2efad04238c7b5290889f0"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  build_config:
    dependency: transitive
    description:
      name: build_config
      sha256: "4ae2de3e1e67ea270081eaee972e1bd8f027d459f249e0f1186730784c2e7e33"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  build_daemon:
    dependency: transitive
    description:
      name: build_daemon
      sha256: "409002f1adeea601018715d613115cfaf0e31f512cb80ae4534c79867ae2363d"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.0"
  build_resolvers:
    dependency: transitive
    description:
      name: build_resolvers
      sha256: "339086358431fa15d7eca8b6a36e5d783728cf025e559b834f4609a1fcfb7b0a"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.2"
  build_runner:
    dependency: "direct dev"
    description:
      name: build_runner
      sha256: "028819cfb90051c6b5440c7e574d1896f8037e3c96cf17aaeb054c9311cfbf4d"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.13"
  build_runner_core:
    dependency: transitive
    description:
      name: build_runner_core
      sha256: f8126682b87a7282a339b871298cc12009cb67109cfa1614d6436fb0289193e0
      url: "https://pub.dev"
    source: hosted
    version: "7.3.2"
  built_collection:
    dependency: transitive
    description:
      name: built_collection
      sha256: "376e3dd27b51ea877c28d525560790aee2e6fbb5f20e2f85d5081027d94e2100"
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  built_value:
    dependency: transitive
    description:
      name: built_value
      sha256: a30f0a0e38671e89a492c44d005b5545b830a961575bbd8336d42869ff71066d
      url: "https://pub.dev"
    source: hosted
    version: "8.12.0"
  characters:
    dependency: transitive
    description:
      name: characters
      sha256: f71061c654a3380576a52b451dd5532377954cf9dbd272a78fc8479606670803
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  checked_yaml:
    dependency: transitive
    description:
      name: checked_yaml
      sha256: "959525d3162f249993882720d52b7e0c833978df229be20702b33d48d91de70f"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.4"
  clock:
    dependency: transitive
    description:
      name: clock
      sha256: fddb70d9b5277016c77a80201021d40a2247104d9f4aa7bab7157b7e3f05b84b
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  code_builder:
    dependency: transitive
    description:
      name: code_builder
      sha256: "11654819532ba94c34de52ff5feb52bd81cba1de00ef2ed622fd50295f9d4243"
      url: "https://pub.dev"
    source: hosted
    version: "4.11.0"
  collection:
    dependency: transitive
    description:
      name: collection
      sha256: "2f5709ae4d3d59dd8f7cd309b4e023046b57d8a6c82130785d2b0e5868084e76"
      url: "https://pub.dev"
    source: hosted
    version: "1.19.1"
  convert:
    dependency: transitive
    description:
      name: convert
      sha256: b30acd5944035672bc15c6b7a8b47d773e41e2f17de064350988c5d02adb1c68
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
  crypto:
    dependency: transitive
    description:
      name: crypto
      sha256: c8ea0233063ba03258fbcf2ca4d6dadfefe14f02fab57702265467a19f27fadf
      url: "https://pub.dev"
    source: hosted
    version: "3.0.7"
  cupertino_icons:
    dependency: "direct main"
    description:
      name: cupertino_icons
      sha256: ba631d1c7f7bef6b729a622b7b752645a2d076dba9976925b8f25725a30e1ee6
      url: "https://pub.dev"
    source: hosted
    version: "1.0.8"
  custom_lint_core:
    dependency: transitive
    description:
      name: custom_lint_core
      sha256: a85e8f78f4c52f6c63cdaf8c872eb573db0231dcdf3c3a5906d493c1f8bc20e6
      url: "https://pub.dev"
    source: hosted
    version: "0.6.3"
  dart_style:
    dependency: transitive
    description:
      name: dart_style
      sha256: "1efa911ca7086affd35f463ca2fc1799584fb6aa89883cf0af8e3664d6a02d55"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  dartx:
    dependency: transitive
    description:
      name: dartx
      sha256: "8b25435617027257d43e6508b5fe061012880ddfdaa75a71d607c3de2a13d244"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.0"
  dbus:
    dependency: transitive
    description:
      name: dbus
      sha256: "79e0c23480ff85dc68de79e2cd6334add97e48f7f4865d17686dd6ea81a47e8c"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.11"
  dio:
    dependency: transitive
    description:
      name: dio
      sha256: d90ee57923d1828ac14e492ca49440f65477f4bb1263575900be731a3dac66a9
      url: "https://pub.dev"
    source: hosted
    version: "5.9.0"
  dio_web_adapter:
    dependency: transitive
    description:
      name: dio_web_adapter
      sha256: "7586e476d70caecaf1686d21eee7247ea43ef5c345eab9e0cc3583ff13378d78"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  dispose_scope:
    dependency: transitive
    description:
      name: dispose_scope
      sha256: "48ec38ca2631c53c4f8fa96b294c801e55c335db5e3fb9f82cede150cfe5a2af"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.0"
  encrypt:
    dependency: transitive
    description:
      name: encrypt
      sha256: "62d9aa4670cc2a8798bab89b39fc71b6dfbacf615de6cf5001fb39f7e4a996a2"
      url: "https://pub.dev"
    source: hosted
    version: "5.0.3"
  equatable:
    dependency: "direct main"
    description:
      name: equatable
      sha256: "567c64b3cb4cf82397aac55f4f0cbd3ca20d77c6c03bedbc4ceaddc08904aef7"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.7"
  fake_async:
    dependency: "direct dev"
    description:
      name: fake_async
      sha256: "5368f224a74523e8d2e7399ea1638b37aecfca824a3cc4dfdf77bf1fa905ac44"
      url: "https://pub.dev"
    source: hosted
    version: "1.3.3"
  ffi:
    dependency: transitive
    description:
      name: ffi
      sha256: "289279317b4b16eb2bb7e271abccd4bf84ec9bdcbe999e278a94b804f5630418"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  file:
    dependency: transitive
    description:
      name: file
      sha256: a3b4f84adafef897088c160faf7dfffb7696046cb13ae90b508c2cbc95d3b8d4
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  firebase_analytics:
    dependency: "direct main"
    description:
      name: firebase_analytics
      sha256: dbf1e7ab22cfb1f4a4adb103b46a26276b4edc593d4a78ef6fb942bafc92e035
      url: "https://pub.dev"
    source: hosted
    version: "10.10.7"
  firebase_analytics_platform_interface:
    dependency: transitive
    description:
      name: firebase_analytics_platform_interface
      sha256: "3729b74f8cf1d974a27ba70332ecb55ff5ff560edc8164a6469f4a055b429c37"
      url: "https://pub.dev"
    source: hosted
    version: "3.10.8"
  firebase_analytics_web:
    dependency: transitive
    description:
      name: firebase_analytics_web
      sha256: "019cd7eee74254d33fbd2e29229367ce33063516bf6b3258a341d89e3b0f1655"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.7+7"
  firebase_core:
    dependency: "direct main"
    description:
      name: firebase_core
      sha256: "26de145bb9688a90962faec6f838247377b0b0d32cc0abecd9a4e43525fc856c"
      url: "https://pub.dev"
    source: hosted
    version: "2.32.0"
  firebase_core_platform_interface:
    dependency: transitive
    description:
      name: firebase_core_platform_interface
      sha256: "8bcfad6d7033f5ea951d15b867622a824b13812178bfec0c779b9d81de011bbb"
      url: "https://pub.dev"
    source: hosted
    version: "5.4.2"
  firebase_core_web:
    dependency: transitive
    description:
      name: firebase_core_web
      sha256: eb3afccfc452b2b2075acbe0c4b27de62dd596802b4e5e19869c1e926cbb20b3
      url: "https://pub.dev"
    source: hosted
    version: "2.24.0"
  fixnum:
    dependency: transitive
    description:
      name: fixnum
      sha256: b6dc7065e46c974bc7c5f143080a6764ec7a4be6da1285ececdc37be96de53be
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  fl_chart:
    dependency: "direct main"
    description:
      name: fl_chart
      sha256: "00b74ae680df6b1135bdbea00a7d1fc072a9180b7c3f3702e4b19a9943f5ed7d"
      url: "https://pub.dev"
    source: hosted
    version: "0.66.2"
  flutter:
    dependency: "direct main"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_lints:
    dependency: "direct dev"
    description:
      name: flutter_lints
      sha256: "5398f14efa795ffb7a33e9b6a08798b26a180edac4ad7db3f231e40f82ce11e1"
      url: "https://pub.dev"
    source: hosted
    version: "5.0.0"
  flutter_local_notifications:
    dependency: "direct main"
    description:
      name: flutter_local_notifications
      sha256: "674173fd3c9eda9d4c8528da2ce0ea69f161577495a9cc835a2a4ecd7eadeb35"
      url: "https://pub.dev"
    source: hosted
    version: "17.2.4"
  flutter_local_notifications_linux:
    dependency: transitive
    description:
      name: flutter_local_notifications_linux
      sha256: c49bd06165cad9beeb79090b18cd1eb0296f4bf4b23b84426e37dd7c027fc3af
      url: "https://pub.dev"
    source: hosted
    version: "4.0.1"
  flutter_local_notifications_platform_interface:
    dependency: transitive
    description:
      name: flutter_local_notifications_platform_interface
      sha256: "85f8d07fe708c1bdcf45037f2c0109753b26ae077e9d9e899d55971711a4ea66"
      url: "https://pub.dev"
    source: hosted
    version: "7.2.0"
  flutter_naver_login:
    dependency: "direct main"
    description:
      name: flutter_naver_login
      sha256: "6acac40088d4d05cdb8d7dceb0cf690a80833de7bdbb7c53209fc1c1442add1c"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  flutter_riverpod:
    dependency: "direct main"
    description:
      name: flutter_riverpod
      sha256: "9532ee6db4a943a1ed8383072a2e3eeda041db5657cdf6d2acecf3c21ecbe7e1"
      url: "https://pub.dev"
    source: hosted
    version: "2.6.1"
  flutter_secure_storage:
    dependency: "direct main"
    description:
      name: flutter_secure_storage
      sha256: "9cad52d75ebc511adfae3d447d5d13da15a55a92c9410e50f67335b6d21d16ea"
      url: "https://pub.dev"
    source: hosted
    version: "9.2.4"
  flutter_secure_storage_linux:
    dependency: transitive
    description:
      name: flutter_secure_storage_linux
      sha256: be76c1d24a97d0b98f8b54bce6b481a380a6590df992d0098f868ad54dc8f688
      url: "https://pub.dev"
    source: hosted
    version: "1.2.3"
  flutter_secure_storage_macos:
    dependency: transitive
    description:
      name: flutter_secure_storage_macos
      sha256: "6c0a2795a2d1de26ae202a0d78527d163f4acbb11cde4c75c670f3a0fc064247"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
  flutter_secure_storage_platform_interface:
    dependency: transitive
    description:
      name: flutter_secure_storage_platform_interface
      sha256: cf91ad32ce5adef6fba4d736a542baca9daf3beac4db2d04be350b87f69ac4a8
      url: "https://pub.dev"
    source: hosted
    version: "1.1.2"
  flutter_secure_storage_web:
    dependency: transitive
    description:
      name: flutter_secure_storage_web
      sha256: f4ebff989b4f07b2656fb16b47852c0aab9fed9b4ec1c70103368337bc1886a9
      url: "https://pub.dev"
    source: hosted
    version: "1.2.1"
  flutter_secure_storage_windows:
    dependency: transitive
    description:
      name: flutter_secure_storage_windows
      sha256: b20b07cb5ed4ed74fc567b78a72936203f587eba460af1df11281c9326cd3709
      url: "https://pub.dev"
    source: hosted
    version: "3.1.2"
  flutter_test:
    dependency: "direct dev"
    description: flutter
    source: sdk
    version: "0.0.0"
  flutter_web_plugins:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  freezed_annotation:
    dependency: transitive
    description:
      name: freezed_annotation
      sha256: c2e2d632dd9b8a2b7751117abcfc2b4888ecfe181bd9fca7170d9ef02e595fe2
      url: "https://pub.dev"
    source: hosted
    version: "2.4.4"
  frontend_server_client:
    dependency: transitive
    description:
      name: frontend_server_client
      sha256: f64a0333a82f30b0cca061bc3d143813a486dc086b574bfb233b7c1372427694
      url: "https://pub.dev"
    source: hosted
    version: "4.0.0"
  glob:
    dependency: transitive
    description:
      name: glob
      sha256: c3f1ee72c96f8f78935e18aa8cecced9ab132419e8625dc187e1c2408efc20de
      url: "https://pub.dev"
    source: hosted
    version: "2.1.3"
  go_router:
    dependency: "direct main"
    description:
      name: go_router
      sha256: b465e99ce64ba75e61c8c0ce3d87b66d8ac07f0b35d0a7e0263fcfc10f99e836
      url: "https://pub.dev"
    source: hosted
    version: "13.2.5"
  graphs:
    dependency: transitive
    description:
      name: graphs
      sha256: "741bbf84165310a68ff28fe9e727332eef1407342fca52759cb21ad8177bb8d0"
      url: "https://pub.dev"
    source: hosted
    version: "2.3.2"
  http:
    dependency: transitive
    description:
      name: http
      sha256: bb2ce4590bc2667c96f318d68cac1b5a7987ec819351d32b1c987239a815e007
      url: "https://pub.dev"
    source: hosted
    version: "1.5.0"
  http_multi_server:
    dependency: transitive
    description:
      name: http_multi_server
      sha256: aa6199f908078bb1c5efb8d8638d4ae191aac11b311132c3ef48ce352fb52ef8
      url: "https://pub.dev"
    source: hosted
    version: "3.2.2"
  http_parser:
    dependency: transitive
    description:
      name: http_parser
      sha256: "178d74305e7866013777bab2c3d8726205dc5a4dd935297175b19a23a2e66571"
      url: "https://pub.dev"
    source: hosted
    version: "4.1.2"
  intl:
    dependency: "direct main"
    description:
      name: intl
      sha256: d6f56758b7d3014a48af9701c085700aac781a92a87a62b1333b46d8879661cf
      url: "https://pub.dev"
    source: hosted
    version: "0.19.0"
  io:
    dependency: transitive
    description:
      name: io
      sha256: dfd5a80599cf0165756e3181807ed3e77daf6dd4137caaad72d0b7931597650b
      url: "https://pub.dev"
    source: hosted
    version: "1.0.5"
  isar:
    dependency: "direct main"
    description:
      name: isar
      sha256: "99165dadb2cf2329d3140198363a7e7bff9bbd441871898a87e26914d25cf1ea"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.0+1"
  isar_flutter_libs:
    dependency: "direct main"
    description:
      name: isar_flutter_libs
      sha256: bc6768cc4b9c61aabff77152e7f33b4b17d2fc93134f7af1c3dd51500fe8d5e8
      url: "https://pub.dev"
    source: hosted
    version: "3.1.0+1"
  isar_generator:
    dependency: "direct dev"
    description:
      name: isar_generator
      sha256: "76c121e1295a30423604f2f819bc255bc79f852f3bc8743a24017df6068ad133"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.0+1"
  js:
    dependency: transitive
    description:
      name: js
      sha256: f2c445dce49627136094980615a031419f7f3eb393237e4ecd97ac15dea343f3
      url: "https://pub.dev"
    source: hosted
    version: "0.6.7"
  json_annotation:
    dependency: transitive
    description:
      name: json_annotation
      sha256: "1ce844379ca14835a50d2f019a3099f419082cfdd231cd86a142af94dd5c6bb1"
      url: "https://pub.dev"
    source: hosted
    version: "4.9.0"
  kakao_flutter_sdk:
    dependency: "direct main"
    description:
      name: kakao_flutter_sdk
      sha256: "63ef8b145593d2e0180c507958856e63e4e78e6be545b8428cf411b273ff2683"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.7+3"
  kakao_flutter_sdk_auth:
    dependency: transitive
    description:
      name: kakao_flutter_sdk_auth
      sha256: "028d8803b7545cc5f41d20cda43b813683700e45c6c13aa4ca56f4b9c673305c"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.7+3"
  kakao_flutter_sdk_common:
    dependency: transitive
    description:
      name: kakao_flutter_sdk_common
      sha256: "1c4944cc50c363d4626e9006ab39ee496c8f5ca602b96154272b90d40544aaca"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.7+3"
  kakao_flutter_sdk_friend:
    dependency: transitive
    description:
      name: kakao_flutter_sdk_friend
      sha256: "822866e9c9987f766dec09d103f2e5d4de9d919781f6c38c309d1a1a7bab7d60"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.7+3"
  kakao_flutter_sdk_navi:
    dependency: transitive
    description:
      name: kakao_flutter_sdk_navi
      sha256: c865cf94c7c0a1287844dc4b3def56360f227352ade99bdbb08b1bdeff5f7657
      url: "https://pub.dev"
    source: hosted
    version: "1.9.7+3"
  kakao_flutter_sdk_share:
    dependency: transitive
    description:
      name: kakao_flutter_sdk_share
      sha256: "04e1fcd44c47d98782dfb7d13f93ed6a4e4da700b580da37c30bb9f24058ed63"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.7+3"
  kakao_flutter_sdk_talk:
    dependency: transitive
    description:
      name: kakao_flutter_sdk_talk
      sha256: "5c61373beb9a3d5a8d7425cb0af13ba443c5077f7bbca09376c799a63c83e4c3"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.7+3"
  kakao_flutter_sdk_template:
    dependency: transitive
    description:
      name: kakao_flutter_sdk_template
      sha256: ee330ad9a4ebed85ec214a7f58dd25eca0d0e5680168db5a04426a217973ac9f
      url: "https://pub.dev"
    source: hosted
    version: "1.9.7+3"
  kakao_flutter_sdk_user:
    dependency: transitive
    description:
      name: kakao_flutter_sdk_user
      sha256: "5157feeafe58d677d314baa5ccdcb435fd9680c485c3b23e9ad7d97a0c93694f"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.7+3"
  leak_tracker:
    dependency: transitive
    description:
      name: leak_tracker
      sha256: "33e2e26bdd85a0112ec15400c8cbffea70d0f9c3407491f672a2fad47915e2de"
      url: "https://pub.dev"
    source: hosted
    version: "11.0.2"
  leak_tracker_flutter_testing:
    dependency: transitive
    description:
      name: leak_tracker_flutter_testing
      sha256: "1dbc140bb5a23c75ea9c4811222756104fbcd1a27173f0c34ca01e16bea473c1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.10"
  leak_tracker_testing:
    dependency: transitive
    description:
      name: leak_tracker_testing
      sha256: "8d5a2d49f4a66b49744b23b018848400d23e54caf9463f4eb20df3eb8acb2eb1"
      url: "https://pub.dev"
    source: hosted
    version: "3.0.2"
  lints:
    dependency: transitive
    description:
      name: lints
      sha256: c35bb79562d980e9a453fc715854e1ed39e24e7d0297a880ef54e17f9874a9d7
      url: "https://pub.dev"
    source: hosted
    version: "5.1.1"
  logging:
    dependency: transitive
    description:
      name: logging
      sha256: c8245ada5f1717ed44271ed1c26b8ce85ca3228fd2ffdb75468ab01979309d61
      url: "https://pub.dev"
    source: hosted
    version: "1.3.0"
  matcher:
    dependency: transitive
    description:
      name: matcher
      sha256: dc58c723c3c24bf8d3e2d3ad3f2f9d7bd9cf43ec6feaa64181775e60190153f2
      url: "https://pub.dev"
    source: hosted
    version: "0.12.17"
  material_color_utilities:
    dependency: transitive
    description:
      name: material_color_utilities
      sha256: f7142bb1154231d7ea5f96bc7bde4bda2a0945d2806bb11670e30b850d56bdec
      url: "https://pub.dev"
    source: hosted
    version: "0.11.1"
  meta:
    dependency: transitive
    description:
      name: meta
      sha256: e3641ec5d63ebf0d9b41bd43201a66e3fc79a65db5f61fc181f04cd27aab950c
      url: "https://pub.dev"
    source: hosted
    version: "1.16.0"
  mime:
    dependency: transitive
    description:
      name: mime
      sha256: "41a20518f0cb1256669420fdba0cd90d21561e560ac240f26ef8322e45bb7ed6"
      url: "https://pub.dev"
    source: hosted
    version: "2.0.0"
  mockito:
    dependency: "direct dev"
    description:
      name: mockito
      sha256: "6841eed20a7befac0ce07df8116c8b8233ed1f4486a7647c7fc5a02ae6163917"
      url: "https://pub.dev"
    source: hosted
    version: "5.4.4"
  mocktail:
    dependency: "direct dev"
    description:
      name: mocktail
      sha256: "890df3f9688106f25755f26b1c60589a92b3ab91a22b8b224947ad041bf172d8"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.4"
  package_config:
    dependency: transitive
    description:
      name: package_config
      sha256: f096c55ebb7deb7e384101542bfba8c52696c1b56fca2eb62827989ef2353bbc
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  path:
    dependency: transitive
    description:
      name: path
      sha256: "75cca69d1490965be98c73ceaea117e8a04dd21217b37b292c9ddbec0d955bc5"
      url: "https://pub.dev"
    source: hosted
    version: "1.9.1"
  path_provider:
    dependency: "direct main"
    description:
      name: path_provider
      sha256: "50c5dd5b6e1aaf6fb3a78b33f6aa3afca52bf903a8a5298f53101fdaee55bbcd"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.5"
  path_provider_android:
    dependency: transitive
    description:
      name: path_provider_android
      sha256: e122c5ea805bb6773bb12ce667611265980940145be920cd09a4b0ec0285cb16
      url: "https://pub.dev"
    source: hosted
    version: "2.2.20"
  path_provider_foundation:
    dependency: transitive
    description:
      name: path_provider_foundation
      sha256: efaec349ddfc181528345c56f8eda9d6cccd71c177511b132c6a0ddaefaa2738
      url: "https://pub.dev"
    source: hosted
    version: "2.4.3"
  path_provider_linux:
    dependency: transitive
    description:
      name: path_provider_linux
      sha256: f7a1fe3a634fe7734c8d3f2766ad746ae2a2884abe22e241a8b301bf5cac3279
      url: "https://pub.dev"
    source: hosted
    version: "2.2.1"
  path_provider_platform_interface:
    dependency: transitive
    description:
      name: path_provider_platform_interface
      sha256: "88f5779f72ba699763fa3a3b06aa4bf6de76c8e5de842cf6f29e2e06476c2334"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.2"
  path_provider_windows:
    dependency: transitive
    description:
      name: path_provider_windows
      sha256: bd6f00dbd873bfb70d0761682da2b3a2c2fccc2b9e84c495821639601d81afe7
      url: "https://pub.dev"
    source: hosted
    version: "2.3.0"
  patrol:
    dependency: "direct dev"
    description:
      name: patrol
      sha256: "782988d05af24427296e48417c36c520598656e00ba73c401a19ecd65262ee0b"
      url: "https://pub.dev"
    source: hosted
    version: "3.19.0"
  patrol_finders:
    dependency: transitive
    description:
      name: patrol_finders
      sha256: "4a658d7d560de523f92deb3fa3326c78747ca0bf7e7f4b8788c012463138b628"
      url: "https://pub.dev"
    source: hosted
    version: "2.9.0"
  patrol_log:
    dependency: transitive
    description:
      name: patrol_log
      sha256: "9fed4143980df1e3bbcfa00d0b443c7d68f04f9132317b7698bbc37f8a5a58c5"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.0"
  permission_handler:
    dependency: "direct main"
    description:
      name: permission_handler
      sha256: "59adad729136f01ea9e35a48f5d1395e25cba6cea552249ddbe9cf950f5d7849"
      url: "https://pub.dev"
    source: hosted
    version: "11.4.0"
  permission_handler_android:
    dependency: transitive
    description:
      name: permission_handler_android
      sha256: d3971dcdd76182a0c198c096b5db2f0884b0d4196723d21a866fc4cdea057ebc
      url: "https://pub.dev"
    source: hosted
    version: "12.1.0"
  permission_handler_apple:
    dependency: transitive
    description:
      name: permission_handler_apple
      sha256: f000131e755c54cf4d84a5d8bd6e4149e262cc31c5a8b1d698de1ac85fa41023
      url: "https://pub.dev"
    source: hosted
    version: "9.4.7"
  permission_handler_html:
    dependency: transitive
    description:
      name: permission_handler_html
      sha256: "38f000e83355abb3392140f6bc3030660cfaef189e1f87824facb76300b4ff24"
      url: "https://pub.dev"
    source: hosted
    version: "0.1.3+5"
  permission_handler_platform_interface:
    dependency: transitive
    description:
      name: permission_handler_platform_interface
      sha256: eb99b295153abce5d683cac8c02e22faab63e50679b937fa1bf67d58bb282878
      url: "https://pub.dev"
    source: hosted
    version: "4.3.0"
  permission_handler_windows:
    dependency: transitive
    description:
      name: permission_handler_windows
      sha256: "1a790728016f79a41216d88672dbc5df30e686e811ad4e698bfc51f76ad91f1e"
      url: "https://pub.dev"
    source: hosted
    version: "0.2.1"
  petitparser:
    dependency: transitive
    description:
      name: petitparser
      sha256: "1a97266a94f7350d30ae522c0af07890c70b8e62c71e8e3920d1db4d23c057d1"
      url: "https://pub.dev"
    source: hosted
    version: "7.0.1"
  platform:
    dependency: transitive
    description:
      name: platform
      sha256: "5d6b1b0036a5f331ebc77c850ebc8506cbc1e9416c27e59b439f917a902a4984"
      url: "https://pub.dev"
    source: hosted
    version: "3.1.6"
  plugin_platform_interface:
    dependency: transitive
    description:
      name: plugin_platform_interface
      sha256: "4820fbfdb9478b1ebae27888254d445073732dae3d6ea81f0b7e06d5dedc3f02"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.8"
  pointycastle:
    dependency: transitive
    description:
      name: pointycastle
      sha256: "4be0097fcf3fd3e8449e53730c631200ebc7b88016acecab2b0da2f0149222fe"
      url: "https://pub.dev"
    source: hosted
    version: "3.9.1"
  pool:
    dependency: transitive
    description:
      name: pool
      sha256: "978783255c543aa3586a1b3c21f6e9d720eb315376a915872c61ef8b5c20177d"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.2"
  pub_semver:
    dependency: transitive
    description:
      name: pub_semver
      sha256: "5bfcf68ca79ef689f8990d1160781b4bad40a3bd5e5218ad4076ddb7f4081585"
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  pubspec_parse:
    dependency: transitive
    description:
      name: pubspec_parse
      sha256: "0560ba233314abbed0a48a2956f7f022cce7c3e1e73df540277da7544cad4082"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.0"
  riverpod:
    dependency: transitive
    description:
      name: riverpod
      sha256: "59062512288d3056b2321804332a13ffdd1bf16df70dcc8e506e411280a72959"
      url: "https://pub.dev"
    source: hosted
    version: "2.6.1"
  riverpod_analyzer_utils:
    dependency: transitive
    description:
      name: riverpod_analyzer_utils
      sha256: "8b71f03fc47ae27d13769496a1746332df4cec43918aeba9aff1e232783a780f"
      url: "https://pub.dev"
    source: hosted
    version: "0.5.1"
  riverpod_annotation:
    dependency: "direct main"
    description:
      name: riverpod_annotation
      sha256: e14b0bf45b71326654e2705d462f21b958f987087be850afd60578fcd502d1b8
      url: "https://pub.dev"
    source: hosted
    version: "2.6.1"
  riverpod_generator:
    dependency: "direct dev"
    description:
      name: riverpod_generator
      sha256: d451608bf17a372025fc36058863737636625dfdb7e3cbf6142e0dfeb366ab22
      url: "https://pub.dev"
    source: hosted
    version: "2.4.0"
  shared_preferences:
    dependency: transitive
    description:
      name: shared_preferences
      sha256: "6e8bf70b7fef813df4e9a36f658ac46d107db4b4cfe1048b477d4e453a8159f5"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.3"
  shared_preferences_android:
    dependency: transitive
    description:
      name: shared_preferences_android
      sha256: "34266009473bf71d748912da4bf62d439185226c03e01e2d9687bc65bbfcb713"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.15"
  shared_preferences_foundation:
    dependency: transitive
    description:
      name: shared_preferences_foundation
      sha256: "1c33a907142607c40a7542768ec9badfd16293bac51da3a4482623d15845f88b"
      url: "https://pub.dev"
    source: hosted
    version: "2.5.5"
  shared_preferences_linux:
    dependency: transitive
    description:
      name: shared_preferences_linux
      sha256: "580abfd40f415611503cae30adf626e6656dfb2f0cee8f465ece7b6defb40f2f"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_platform_interface:
    dependency: transitive
    description:
      name: shared_preferences_platform_interface
      sha256: "57cbf196c486bc2cf1f02b85784932c6094376284b3ad5779d1b1c6c6a816b80"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shared_preferences_web:
    dependency: transitive
    description:
      name: shared_preferences_web
      sha256: c49bd060261c9a3f0ff445892695d6212ff603ef3115edbb448509d407600019
      url: "https://pub.dev"
    source: hosted
    version: "2.4.3"
  shared_preferences_windows:
    dependency: transitive
    description:
      name: shared_preferences_windows
      sha256: "94ef0f72b2d71bc3e700e025db3710911bd51a71cefb65cc609dd0d9a982e3c1"
      url: "https://pub.dev"
    source: hosted
    version: "2.4.1"
  shelf:
    dependency: transitive
    description:
      name: shelf
      sha256: e7dd780a7ffb623c57850b33f43309312fc863fb6aa3d276a754bb299839ef12
      url: "https://pub.dev"
    source: hosted
    version: "1.4.2"
  shelf_web_socket:
    dependency: transitive
    description:
      name: shelf_web_socket
      sha256: cc36c297b52866d203dbf9332263c94becc2fe0ceaa9681d07b6ef9807023b67
      url: "https://pub.dev"
    source: hosted
    version: "2.0.1"
  sky_engine:
    dependency: transitive
    description: flutter
    source: sdk
    version: "0.0.0"
  source_gen:
    dependency: transitive
    description:
      name: source_gen
      sha256: "14658ba5f669685cd3d63701d01b31ea748310f7ab854e471962670abcf57832"
      url: "https://pub.dev"
    source: hosted
    version: "1.5.0"
  source_span:
    dependency: transitive
    description:
      name: source_span
      sha256: "254ee5351d6cb365c859e20ee823c3bb479bf4a293c22d17a9f1bf144ce86f7c"
      url: "https://pub.dev"
    source: hosted
    version: "1.10.1"
  stack_trace:
    dependency: transitive
    description:
      name: stack_trace
      sha256: "8b27215b45d22309b5cddda1aa2b19bdfec9df0e765f2de506401c071d38d1b1"
      url: "https://pub.dev"
    source: hosted
    version: "1.12.1"
  state_notifier:
    dependency: transitive
    description:
      name: state_notifier
      sha256: b8677376aa54f2d7c58280d5a007f9e8774f1968d1fb1c096adcb4792fba29bb
      url: "https://pub.dev"
    source: hosted
    version: "1.0.0"
  stream_channel:
    dependency: transitive
    description:
      name: stream_channel
      sha256: "969e04c80b8bcdf826f8f16579c7b14d780458bd97f56d107d3950fdbeef059d"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.4"
  stream_transform:
    dependency: transitive
    description:
      name: stream_transform
      sha256: ad47125e588cfd37a9a7f86c7d6356dde8dfe89d071d293f80ca9e9273a33871
      url: "https://pub.dev"
    source: hosted
    version: "2.1.1"
  string_scanner:
    dependency: transitive
    description:
      name: string_scanner
      sha256: "921cd31725b72fe181906c6a94d987c78e3b98c2e205b397ea399d4054872b43"
      url: "https://pub.dev"
    source: hosted
    version: "1.4.1"
  term_glyph:
    dependency: transitive
    description:
      name: term_glyph
      sha256: "7f554798625ea768a7518313e58f83891c7f5024f88e46e7182a4558850a4b8e"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.2"
  test_api:
    dependency: transitive
    description:
      name: test_api
      sha256: "522f00f556e73044315fa4585ec3270f1808a4b186c936e612cab0b565ff1e00"
      url: "https://pub.dev"
    source: hosted
    version: "0.7.6"
  time:
    dependency: transitive
    description:
      name: time
      sha256: "370572cf5d1e58adcb3e354c47515da3f7469dac3a95b447117e728e7be6f461"
      url: "https://pub.dev"
    source: hosted
    version: "2.1.5"
  timezone:
    dependency: "direct main"
    description:
      name: timezone
      sha256: "2236ec079a174ce07434e89fcd3fcda430025eb7692244139a9cf54fdcf1fc7d"
      url: "https://pub.dev"
    source: hosted
    version: "0.9.4"
  timing:
    dependency: transitive
    description:
      name: timing
      sha256: "62ee18aca144e4a9f29d212f5a4c6a053be252b895ab14b5821996cff4ed90fe"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.2"
  typed_data:
    dependency: transitive
    description:
      name: typed_data
      sha256: f9049c039ebfeb4cf7a7104a675823cd72dba8297f264b6637062516699fa006
      url: "https://pub.dev"
    source: hosted
    version: "1.4.0"
  uuid:
    dependency: "direct main"
    description:
      name: uuid
      sha256: a11b666489b1954e01d992f3d601b1804a33937b5a8fe677bd26b8a9f96f96e8
      url: "https://pub.dev"
    source: hosted
    version: "4.5.2"
  vector_math:
    dependency: transitive
    description:
      name: vector_math
      sha256: d530bd74fea330e6e364cda7a85019c434070188383e1cd8d9777ee586914c5b
      url: "https://pub.dev"
    source: hosted
    version: "2.2.0"
  vm_service:
    dependency: transitive
    description:
      name: vm_service
      sha256: "45caa6c5917fa127b5dbcfbd1fa60b14e583afdc08bfc96dda38886ca252eb60"
      url: "https://pub.dev"
    source: hosted
    version: "15.0.2"
  watcher:
    dependency: transitive
    description:
      name: watcher
      sha256: "592ab6e2892f67760543fb712ff0177f4ec76c031f02f5b4ff8d3fc5eb9fb61a"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.4"
  web:
    dependency: transitive
    description:
      name: web
      sha256: "868d88a33d8a87b18ffc05f9f030ba328ffefba92d6c127917a2ba740f9cfe4a"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.1"
  web_socket:
    dependency: transitive
    description:
      name: web_socket
      sha256: "34d64019aa8e36bf9842ac014bb5d2f5586ca73df5e4d9bf5c936975cae6982c"
      url: "https://pub.dev"
    source: hosted
    version: "1.0.1"
  web_socket_channel:
    dependency: transitive
    description:
      name: web_socket_channel
      sha256: d645757fb0f4773d602444000a8131ff5d48c9e47adfe9772652dd1a4f2d45c8
      url: "https://pub.dev"
    source: hosted
    version: "3.0.3"
  webview_flutter:
    dependency: transitive
    description:
      name: webview_flutter
      sha256: c3e4fe614b1c814950ad07186007eff2f2e5dd2935eba7b9a9a1af8e5885f1ba
      url: "https://pub.dev"
    source: hosted
    version: "4.13.0"
  webview_flutter_android:
    dependency: transitive
    description:
      name: webview_flutter_android
      sha256: e5201c620eb2637dca88a756961fae4a7191bb30b4f2271e08b746405ffdf3fd
      url: "https://pub.dev"
    source: hosted
    version: "4.10.5"
  webview_flutter_platform_interface:
    dependency: transitive
    description:
      name: webview_flutter_platform_interface
      sha256: "63d26ee3aca7256a83ccb576a50272edd7cfc80573a4305caa98985feb493ee0"
      url: "https://pub.dev"
    source: hosted
    version: "2.14.0"
  webview_flutter_wkwebview:
    dependency: transitive
    description:
      name: webview_flutter_wkwebview
      sha256: "5de608fdea144d4370c21d4c80f0528135529e0180aa129790064c345e457a43"
      url: "https://pub.dev"
    source: hosted
    version: "3.23.2"
  win32:
    dependency: transitive
    description:
      name: win32
      sha256: d7cb55e04cd34096cd3a79b3330245f54cb96a370a1c27adb3c84b917de8b08e
      url: "https://pub.dev"
    source: hosted
    version: "5.15.0"
  xdg_directories:
    dependency: transitive
    description:
      name: xdg_directories
      sha256: "7a3f37b05d989967cdddcbb571f1ea834867ae2faa29725fd085180e0883aa15"
      url: "https://pub.dev"
    source: hosted
    version: "1.1.0"
  xml:
    dependency: transitive
    description:
      name: xml
      sha256: "971043b3a0d3da28727e40ed3e0b5d18b742fa5a68665cca88e74b7876d5e025"
      url: "https://pub.dev"
    source: hosted
    version: "6.6.1"
  xxh3:
    dependency: transitive
    description:
      name: xxh3
      sha256: "399a0438f5d426785723c99da6b16e136f4953fb1e9db0bf270bd41dd4619916"
      url: "https://pub.dev"
    source: hosted
    version: "1.2.0"
  yaml:
    dependency: transitive
    description:
      name: yaml
      sha256: b9da305ac7c39faa3f030eccd175340f968459dae4af175130b3fc47e40d76ce
      url: "https://pub.dev"
    source: hosted
    version: "3.1.3"
sdks:
  dart: ">=3.9.2 <4.0.0"
  flutter: ">=3.35.0"
</file>

<file path="pubspec.yaml">
name: n06
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.9.2

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8

  # State Management
  flutter_riverpod: ^2.4.0
  riverpod_annotation: ^2.3.0

  # Local Database (Phase 0)
  isar: ^3.1.0+1
  isar_flutter_libs: ^3.1.0+1

  # Internationalization & Localization
  intl: ^0.19.0

  # Authentication
  kakao_flutter_sdk: ^1.7.0
  flutter_naver_login: ^2.1.1
  flutter_secure_storage: ^9.0.0

  # Utils
  equatable: ^2.0.5
  uuid: ^4.0.0
  path_provider: ^2.1.0

  # Analytics & Crashlytics
  firebase_core: ^2.24.0
  firebase_analytics: ^10.8.0
  # firebase_crashlytics: ^3.4.0  # Temporarily disabled due to build issue

  # UI Components
  fl_chart: ^0.66.0

  # Navigation
  go_router: ^13.0.0

  # Notifications
  flutter_local_notifications: ^17.0.0
  permission_handler: ^11.4.0
  timezone: ^0.9.2

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^5.0.0

  # Test Framework
  mocktail: ^1.0.4
  fake_async: ^1.3.1
  patrol: ^3.13.1

  # Code Generation
  build_runner: ^2.4.0
  riverpod_generator: ^2.3.0
  isar_generator: ^3.1.0+1

  # Mocking
  mockito: ^5.4.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package
</file>

<file path="lib/features/tracking/application/providers.dart">
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:n06/core/providers.dart';
import 'package:n06/features/tracking/application/notifiers/emergency_check_notifier.dart';
import 'package:n06/features/tracking/application/notifiers/medication_notifier.dart';
import 'package:n06/features/tracking/application/notifiers/tracking_notifier.dart';
import 'package:n06/features/tracking/application/notifiers/weight_record_edit_notifier.dart';
import 'package:n06/features/tracking/application/notifiers/symptom_record_edit_notifier.dart';
import 'package:n06/features/tracking/application/notifiers/dose_record_edit_notifier.dart';
import 'package:n06/features/tracking/application/usecases/update_dosage_plan_usecase.dart';
import 'package:n06/features/tracking/domain/entities/emergency_symptom_check.dart';
import 'package:n06/features/tracking/domain/repositories/dosage_plan_repository.dart';
import 'package:n06/features/tracking/domain/repositories/dose_schedule_repository.dart';
import 'package:n06/features/tracking/domain/repositories/emergency_check_repository.dart';
import 'package:n06/features/tracking/domain/repositories/medication_repository.dart';
import 'package:n06/features/tracking/domain/repositories/tracking_repository.dart';
import 'package:n06/features/tracking/domain/usecases/analyze_plan_change_impact_usecase.dart';
import 'package:n06/features/tracking/domain/usecases/injection_site_rotation_usecase.dart';
import 'package:n06/features/tracking/domain/usecases/missed_dose_analyzer_usecase.dart';
import 'package:n06/features/tracking/domain/usecases/recalculate_dose_schedule_usecase.dart';
import 'package:n06/features/tracking/domain/usecases/schedule_generator_usecase.dart';
import 'package:n06/features/tracking/domain/usecases/validate_dosage_plan_usecase.dart';
import 'package:n06/features/tracking/infrastructure/services/notification_service.dart';
import 'package:n06/features/tracking/infrastructure/repositories/isar_tracking_repository.dart';
import 'package:n06/features/tracking/infrastructure/repositories/isar_medication_repository.dart';
import 'package:n06/features/tracking/infrastructure/repositories/isar_dosage_plan_repository.dart';
import 'package:n06/features/tracking/infrastructure/repositories/isar_dose_schedule_repository.dart';
import 'package:n06/features/tracking/infrastructure/repositories/isar_emergency_check_repository.dart';
import 'package:n06/features/tracking/infrastructure/repositories/isar_audit_repository.dart';

part 'providers.g.dart';

// Repository Providers with Code Generation
@riverpod
MedicationRepository medicationRepository(MedicationRepositoryRef ref) {
  final isar = ref.watch(isarProvider);
  return IsarMedicationRepository(isar);
}

@riverpod
DosagePlanRepository dosagePlanRepository(DosagePlanRepositoryRef ref) {
  final isar = ref.watch(isarProvider);
  return IsarDosagePlanRepository(isar);
}

@riverpod
DoseScheduleRepository doseScheduleRepository(DoseScheduleRepositoryRef ref) {
  final isar = ref.watch(isarProvider);
  return IsarDoseScheduleRepository(isar);
}

@riverpod
TrackingRepository trackingRepository(TrackingRepositoryRef ref) {
  final isar = ref.watch(isarProvider);
  return IsarTrackingRepository(isar);
}

@riverpod
EmergencyCheckRepository emergencyCheckRepository(EmergencyCheckRepositoryRef ref) {
  final isar = ref.watch(isarProvider);
  return IsarEmergencyCheckRepository(isar);
}

@riverpod
IsarAuditRepository auditRepository(AuditRepositoryRef ref) {
  final isar = ref.watch(isarProvider);
  return IsarAuditRepository(isar);
}

// UseCase Providers with Code Generation
@riverpod
ScheduleGeneratorUseCase scheduleGeneratorUseCase(ScheduleGeneratorUseCaseRef ref) {
  return ScheduleGeneratorUseCase();
}

@riverpod
InjectionSiteRotationUseCase injectionSiteRotationUseCase(InjectionSiteRotationUseCaseRef ref) {
  return InjectionSiteRotationUseCase();
}

@riverpod
MissedDoseAnalyzerUseCase missedDoseAnalyzerUseCase(MissedDoseAnalyzerUseCaseRef ref) {
  return MissedDoseAnalyzerUseCase();
}

// UF-009: UpdateDosagePlan UseCase Providers
@riverpod
ValidateDosagePlanUseCase validateDosagePlanUseCase(ValidateDosagePlanUseCaseRef ref) {
  return ValidateDosagePlanUseCase();
}

@riverpod
RecalculateDoseScheduleUseCase recalculateDoseScheduleUseCase(RecalculateDoseScheduleUseCaseRef ref) {
  return RecalculateDoseScheduleUseCase();
}

@riverpod
AnalyzePlanChangeImpactUseCase analyzePlanChangeImpactUseCase(AnalyzePlanChangeImpactUseCaseRef ref) {
  return AnalyzePlanChangeImpactUseCase();
}

@riverpod
UpdateDosagePlanUseCase updateDosagePlanUseCase(UpdateDosagePlanUseCaseRef ref) {
  final medicationRepository = ref.watch(medicationRepositoryProvider);
  final validateUseCase = ref.watch(validateDosagePlanUseCaseProvider);
  final analyzeImpactUseCase = ref.watch(analyzePlanChangeImpactUseCaseProvider);
  final recalculateScheduleUseCase = ref.watch(recalculateDoseScheduleUseCaseProvider);

  return UpdateDosagePlanUseCase(
    medicationRepository: medicationRepository,
    validateUseCase: validateUseCase,
    analyzeImpactUseCase: analyzeImpactUseCase,
    recalculateScheduleUseCase: recalculateScheduleUseCase,
  );
}

// Service Providers with Code Generation
@riverpod
NotificationService notificationService(NotificationServiceRef ref) {
  return NotificationService();
}

// Notifier Provider - requires userId from auth state
final medicationNotifierProvider = StateNotifierProvider.autoDispose<
    MedicationNotifier,
    MedicationState>((ref) {
  final repository = ref.watch(medicationRepositoryProvider);
  final scheduleGenerator = ref.watch(scheduleGeneratorUseCaseProvider);
  final injectionSiteRotation = ref.watch(injectionSiteRotationUseCaseProvider);
  final missedDoseAnalyzer = ref.watch(missedDoseAnalyzerUseCaseProvider);
  final notificationService = ref.watch(notificationServiceProvider);

  return MedicationNotifier(
    repository: repository,
    scheduleGeneratorUseCase: scheduleGenerator,
    injectionSiteRotationUseCase: injectionSiteRotation,
    missedDoseAnalyzerUseCase: missedDoseAnalyzer,
    notificationService: notificationService,
  );
});

// Tracking Notifier Provider
final trackingNotifierProvider =
    StateNotifierProvider.autoDispose<TrackingNotifier, AsyncValue<TrackingState>>(
  (ref) {
    final repository = ref.watch(trackingRepositoryProvider);
    // userId는 AuthNotifier에서 가져와야 함
    // 현재는 null로 설정
    return TrackingNotifier(
      repository: repository,
      userId: null,
    );
  },
);

// Emergency Check Notifier Provider (F005)
final emergencyCheckNotifierProvider =
    AsyncNotifierProvider.autoDispose<EmergencyCheckNotifier, List<EmergencySymptomCheck>>(
  () => EmergencyCheckNotifier(),
);

// UF-011: Weight Record Edit Notifier Provider
final weightRecordEditNotifierProvider = AsyncNotifierProvider<WeightRecordEditNotifier, void>(
  () => WeightRecordEditNotifier(),
);

// UF-011: Symptom Record Edit Notifier Provider
final symptomRecordEditNotifierProvider = AsyncNotifierProvider<SymptomRecordEditNotifier, void>(
  () => SymptomRecordEditNotifier(),
);

// UF-011: Dose Record Edit Notifier Provider
final doseRecordEditNotifierProvider = AsyncNotifierProvider<DoseRecordEditNotifier, void>(
  () => DoseRecordEditNotifier(),
);
</file>

<file path="lib/main.dart">
import 'dart:async';
import 'dart:developer' as developer;
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:isar/isar.dart';
import 'package:kakao_flutter_sdk/kakao_flutter_sdk.dart';
import 'package:n06/core/providers.dart';
import 'package:n06/core/routing/app_router.dart';
import 'package:n06/core/services/secure_storage_service.dart';
import 'package:path_provider/path_provider.dart';
import 'package:n06/features/authentication/application/notifiers/auth_notifier.dart';
import 'package:n06/features/authentication/infrastructure/datasources/kakao_auth_datasource.dart';
import 'package:n06/features/authentication/infrastructure/datasources/naver_auth_datasource.dart';
import 'package:n06/features/authentication/infrastructure/dtos/consent_record_dto.dart';
import 'package:n06/features/authentication/infrastructure/dtos/user_dto.dart';
import 'package:n06/features/authentication/infrastructure/repositories/isar_auth_repository.dart';
import 'package:n06/features/tracking/infrastructure/dtos/dosage_plan_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/dose_schedule_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/dose_record_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/plan_change_history_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/weight_log_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/symptom_log_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/symptom_context_tag_dto.dart';
import 'package:n06/features/tracking/infrastructure/dtos/emergency_symptom_check_dto.dart';
import 'package:n06/features/dashboard/infrastructure/dtos/user_badge_dto.dart';
import 'package:n06/features/dashboard/infrastructure/dtos/badge_definition_dto.dart';
import 'package:n06/features/onboarding/infrastructure/dtos/user_profile_dto.dart';
import 'package:n06/features/coping_guide/infrastructure/dtos/guide_feedback_dto.dart';
import 'package:n06/features/notification/infrastructure/dtos/notification_settings_dto.dart';

void main() async {
  // Run app in error zone to catch all errors
  runZonedGuarded(
    () async {
      WidgetsFlutterBinding.ensureInitialized();

      // Setup error handlers
      _setupErrorHandlers();

      await _initializeAndRunApp();
    },
    (error, stackTrace) {
      _logError('Uncaught error in root zone', error, stackTrace);
    },
  );
}

void _setupErrorHandlers() {
  // Catch Flutter framework errors
  FlutterError.onError = (FlutterErrorDetails details) {
    // Check if this is a Kakao OAuth callback GoRouter parsing error
    final exception = details.exception;
    if (exception is StateError &&
        exception.message.contains('Origin is only applicable to schemes http and https')) {
      // This is expected - Kakao SDK handles the callback, not GoRouter
      debugPrint('🔍 [HEALTH CHECK] Kakao GoRouter parsing error (expected, ignoring)');
      if (kDebugMode) {
        developer.log(
          '🔍 Kakao OAuth callback caused GoRouter parsing error (expected behavior)',
          name: 'HealthCheck',
        );
      }
      // Don't present this error to user
      return;
    }

    FlutterError.presentError(details);
    _logError(
      'Flutter Error',
      details.exception,
      details.stack,
      context: details.context?.toString(),
    );
  };

  // Catch platform errors
  PlatformDispatcher.instance.onError = (error, stackTrace) {
    _logError('Platform Error', error, stackTrace);
    return true;
  };

  if (kDebugMode) {
    developer.log(
      '🔧 Error handlers initialized',
      name: 'ErrorHandler',
    );
  }
}

void _logError(
  String title,
  Object error,
  StackTrace? stackTrace, {
  String? context,
}) {
  final message = StringBuffer();
  message.writeln('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
  message.writeln('🚨 $title');
  message.writeln('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
  if (context != null) {
    message.writeln('Context: $context');
  }
  message.writeln('Error: $error');
  if (stackTrace != null) {
    message.writeln('StackTrace:\n$stackTrace');
  }
  message.writeln('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');

  if (kDebugMode) {
    // Use developer.log for better visibility in DevTools
    developer.log(
      message.toString(),
      name: 'Error',
      error: error,
      stackTrace: stackTrace,
      level: 1000, // Error level
    );
  }

  // Also print to console
  debugPrint(message.toString());
}

Future<void> _initializeAndRunApp() async {
  if (kDebugMode) {
    developer.log('🚀 Initializing app...', name: 'Main');
  }

  try {
    // Initialize Kakao SDK with debug logging enabled
    if (kDebugMode) {
      developer.log('📱 Initializing Kakao SDK with debug logging...', name: 'Main');
    }
    KakaoSdk.init(
      nativeAppKey: '32dfc3999b53af153dbcefa7014093bc',
      loggingEnabled: true,  // Enable detailed debug logging
    );

    // Initialize Isar with all required collection schemas
    if (kDebugMode) {
      developer.log('💾 Opening Isar database...', name: 'Main');
    }
    final dir = await getApplicationDocumentsDirectory();
    final isar = await Isar.open(
      [
        UserDtoSchema,
        ConsentRecordDtoSchema,
        DosagePlanDtoSchema,
        DoseScheduleDtoSchema,
        DoseRecordDtoSchema,
        PlanChangeHistoryDtoSchema,
        WeightLogDtoSchema,
        SymptomLogDtoSchema,
        SymptomContextTagDtoSchema,
        EmergencySymptomCheckDtoSchema,
        UserBadgeDtoSchema,
        BadgeDefinitionDtoSchema,
        UserProfileDtoSchema,
        GuideFeedbackDtoSchema,
        NotificationSettingsDtoSchema,
      ],
      directory: dir.path,
      inspector: true,
    );

    if (kDebugMode) {
      developer.log('✅ Isar database initialized', name: 'Main');
      developer.log('🎯 Launching app...', name: 'Main');
    }

    runApp(
      ProviderScope(
        observers: kDebugMode ? [_ProviderLogger()] : null,
        overrides: [
          // Override isarProvider with initialized instance
          isarProvider.overrideWithValue(isar),
          // Override authRepositoryProvider with IsarAuthRepository
          authRepositoryProvider.overrideWithValue(
            IsarAuthRepository(
              isar,
              KakaoAuthDataSource(),
              NaverAuthDataSource(),
              SecureStorageService(),
            ),
          ),
        ],
        child: const MyApp(),
      ),
    );
  } catch (error, stackTrace) {
    _logError('Initialization error', error, stackTrace);
    rethrow;
  }
}

// Riverpod logger for debugging
class _ProviderLogger extends ProviderObserver {
  @override
  void didUpdateProvider(
    ProviderBase<Object?> provider,
    Object? previousValue,
    Object? newValue,
    ProviderContainer container,
  ) {
    developer.log(
      '${provider.name ?? provider.runtimeType} updated: $newValue',
      name: 'Riverpod',
    );
  }

  @override
  void providerDidFail(
    ProviderBase<Object?> provider,
    Object error,
    StackTrace stackTrace,
    ProviderContainer container,
  ) {
    _logError(
      'Provider Error: ${provider.name ?? provider.runtimeType}',
      error,
      stackTrace,
    );
  }
}

class MyApp extends StatefulWidget {
  const MyApp({super.key});

  @override
  State<MyApp> createState() => _MyAppState();
}

class _MyAppState extends State<MyApp> with WidgetsBindingObserver {
  @override
  void initState() {
    super.initState();
    // Register as observer to intercept deep links
    WidgetsBinding.instance.addObserver(this);

    // Use debugPrint to ensure visibility
    debugPrint('🔗 Deep link observer registered');
    if (kDebugMode) {
      developer.log('🔗 Deep link observer registered', name: 'MyApp');
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  Future<bool> didPushRouteInformation(RouteInformation routeInformation) async {
    final uri = routeInformation.uri;

    // Detect Kakao OAuth callbacks and handle them
    if (uri.scheme.startsWith('kakao')) {
      debugPrint('✅ Intercepting Kakao OAuth callback: $uri');
      debugPrint('   Blocking GoRouter and allowing Kakao SDK to handle it');
      if (kDebugMode) {
        developer.log(
          '✅ Kakao OAuth callback intercepted - blocking GoRouter',
          name: 'MyApp',
        );
      }

      // Return true to indicate we've handled it and prevent GoRouter from processing
      // The Kakao SDK will still receive it through the native platform channel
      return true;
    }

    // Let other routes be handled normally
    debugPrint('📍 Allowing route: $uri');
    return await super.didPushRouteInformation(routeInformation);
  }

  @override
  Widget build(BuildContext context) {
    return MaterialApp.router(
      title: 'GLP-1 치료 관리',
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      routerConfig: appRouter,
    );
  }
}
</file>

</files>
