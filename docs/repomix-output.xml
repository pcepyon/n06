This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
001/
  plan.md
  spec.md
002/
  plan.md
  spec.md
003/
  plan.md
  spec.md
004/
  plan.md
  spec.md
005/
  plan.md
  spec.md
006/
  plan.md
  spec.md
007/
  plan.md
  spec.md
008/
  plan.md
  spec.md
009/
  plan.md
  spec.md
010/
  plan.md
  spec.md
011/
  plan.md
  spec.md
012/
  plan.md
  spec.md
013/
  plan.md
  spec.md
014/
  plan.md
  spec.md
015/
  plan.md
  spec.md
external/
  auth_guide.md
01_initial_schema.sql
code_structure.md
database.md
persona.md
prd.md
requirements.md
state-management.md
tdd.md
userflow.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="001/plan.md">
# 소셜 로그인 및 인증 Implementation Plan

## 1. 개요

**Feature**: UF-F-001 소셜 로그인 및 인증
**TDD 전략**: Outside-In (UI → Application → Domain → Infrastructure)
**핵심 목표**: OAuth 2.0 기반 네이버/카카오 로그인 구현 및 토큰 기반 세션 관리

### 모듈 목록

| 모듈 | 위치 | 책임 | TDD 적용 |
|------|------|------|----------|
| User Entity | `features/authentication/domain/entities/user.dart` | 사용자 도메인 모델 | Unit |
| Consent Entity | `features/authentication/domain/entities/consent_record.dart` | 동의 정보 도메인 모델 | Unit |
| AuthRepository Interface | `features/authentication/domain/repositories/auth_repository.dart` | 인증 데이터 접근 계약 | Unit |
| AuthNotifier | `features/authentication/application/notifiers/auth_notifier.dart` | 인증 상태 관리 | Unit + Integration |
| LoginScreen | `features/authentication/presentation/screens/login_screen.dart` | 로그인 UI | Widget + Acceptance |
| UserDto | `features/authentication/infrastructure/dtos/user_dto.dart` | 사용자 DTO (Isar) | Unit |
| ConsentDto | `features/authentication/infrastructure/dtos/consent_record_dto.dart` | 동의 정보 DTO | Unit |
| IsarAuthRepository | `features/authentication/infrastructure/repositories/isar_auth_repository.dart` | Isar 기반 인증 저장소 | Integration |
| KakaoAuthDataSource | `features/authentication/infrastructure/datasources/kakao_auth_datasource.dart` | Kakao SDK 통신 | Integration |
| NaverAuthDataSource | `features/authentication/infrastructure/datasources/naver_auth_datasource.dart` | Naver SDK 통신 | Integration |
| SecureStorageService | `core/services/secure_storage_service.dart` | 토큰 암호화 저장 | Unit |

---

## 2. Architecture Diagram

```mermaid
graph TB
    subgraph Presentation
        LoginScreen[LoginScreen<br/>로그인 UI]
    end

    subgraph Application
        AuthNotifier[AuthNotifier<br/>인증 상태 관리]
        AuthProvider[authNotifierProvider]
    end

    subgraph Domain
        User[User Entity<br/>사용자 모델]
        Consent[ConsentRecord Entity<br/>동의 정보 모델]
        AuthRepo[AuthRepository Interface<br/>인증 데이터 계약]
    end

    subgraph Infrastructure
        IsarAuthRepo[IsarAuthRepository<br/>Isar 저장소 구현]
        KakaoDataSource[KakaoAuthDataSource<br/>Kakao SDK 통신]
        NaverDataSource[NaverAuthDataSource<br/>Naver SDK 통신]
        SecureStorage[SecureStorageService<br/>토큰 암호화 저장]
        UserDto[UserDto<br/>Isar DTO]
        ConsentDto[ConsentRecordDto<br/>Isar DTO]
    end

    LoginScreen -->|ref.read| AuthProvider
    AuthProvider -->|provides| AuthNotifier
    AuthNotifier -->|depends on| AuthRepo
    AuthRepo -.implements.- IsarAuthRepo
    IsarAuthRepo -->|uses| KakaoDataSource
    IsarAuthRepo -->|uses| NaverDataSource
    IsarAuthRepo -->|uses| SecureStorage
    IsarAuthRepo -->|converts| UserDto
    IsarAuthRepo -->|converts| ConsentDto
    UserDto -->|toEntity| User
    ConsentDto -->|toEntity| Consent

    style User fill:#e1f5ff
    style Consent fill:#e1f5ff
    style AuthRepo fill:#fff4e1
    style AuthNotifier fill:#ffe1f5
    style LoginScreen fill:#e1ffe1
    style IsarAuthRepo fill:#f5e1ff
```

---

## 3. Implementation Plan

### 3.1. Domain Layer

#### User Entity
- **Location**: `features/authentication/domain/entities/user.dart`
- **Responsibility**: 사용자 계정 정보를 표현하는 불변 모델
- **Test Strategy**: Unit Test
- **Test Scenarios**:
  ```dart
  // Red Phase
  test('should create User with all required fields', () {
    // Arrange
    final user = User(
      id: 'user123',
      oauthProvider: 'kakao',
      oauthUserId: 'kakao_123',
      name: '홍길동',
      email: 'test@example.com',
      lastLoginAt: DateTime.now(),
    );

    // Assert
    expect(user.id, 'user123');
    expect(user.oauthProvider, 'kakao');
    expect(user.lastLoginAt, isNotNull);
  });

  test('should create User with optional profileImageUrl', () {});
  test('should create User with null lastLoginAt for first login', () {});
  test('should support copyWith for immutability', () {});
  test('should support equality comparison', () {});
  ```
- **Implementation Order**:
  1. 기본 생성자 및 필드 정의 (lastLoginAt 포함)
  2. copyWith 메서드
  3. Equatable 구현
- **Dependencies**: None

---

#### ConsentRecord Entity
- **Location**: `features/authentication/domain/entities/consent_record.dart`
- **Responsibility**: 이용약관 동의 정보 표현
- **Test Strategy**: Unit Test
- **Test Scenarios**:
  ```dart
  // Red Phase
  test('should create ConsentRecord with agreement flags', () {
    final consent = ConsentRecord(
      id: 'consent123',
      userId: 'user123',
      termsOfService: true,
      privacyPolicy: true,
      agreedAt: DateTime.now(),
    );

    expect(consent.termsOfService, true);
    expect(consent.privacyPolicy, true);
  });

  test('should allow partial consent (false flags)', () {});
  test('should record agreedAt timestamp', () {});
  ```
- **Implementation Order**: Entity 생성 → 필드 검증
- **Dependencies**: None

---

#### AuthRepository Interface
- **Location**: `features/authentication/domain/repositories/auth_repository.dart`
- **Responsibility**: 인증 데이터 접근 계약 정의
- **Test Strategy**: Unit Test (Mock 사용)
- **Test Scenarios**:
  ```dart
  // Red Phase
  test('should define loginWithKakao method signature', () async {
    // Arrange
    final mockRepo = MockAuthRepository();
    when(mockRepo.loginWithKakao(
      agreedToTerms: true,
      agreedToPrivacy: true,
    )).thenAnswer((_) async => mockUser);

    // Act
    final user = await mockRepo.loginWithKakao(
      agreedToTerms: true,
      agreedToPrivacy: true,
    );

    // Assert
    expect(user, isA<User>());
  });

  test('should define loginWithNaver method signature', () {});
  test('should define logout method signature', () {});
  test('should define getCurrentUser method signature', () {});
  test('should define isFirstLogin method signature', () async {
    final mockRepo = MockAuthRepository();
    when(mockRepo.isFirstLogin()).thenAnswer((_) async => true);

    final isFirst = await mockRepo.isFirstLogin();

    expect(isFirst, isA<bool>());
  });
  test('should define isAccessTokenValid method signature', () {});
  test('should define refreshAccessToken method signature', () {});
  ```
- **Method Signatures**:
  ```dart
  abstract class AuthRepository {
    Future<User> loginWithKakao({
      required bool agreedToTerms,
      required bool agreedToPrivacy,
    });
    Future<User> loginWithNaver({
      required bool agreedToTerms,
      required bool agreedToPrivacy,
    });
    Future<void> logout();
    Future<User?> getCurrentUser();
    Future<bool> isFirstLogin();
    Future<bool> isAccessTokenValid();
    Future<String> refreshAccessToken(String refreshToken);
  }
  ```
- **Dependencies**: User, ConsentRecord

---

### 3.2. Infrastructure Layer

#### SecureStorageService
- **Location**: `core/services/secure_storage_service.dart`
- **Responsibility**: FlutterSecureStorage를 통한 토큰 암호화 저장 및 만료 시간 관리
- **Test Strategy**: Unit Test (MockSecureStorage)
- **Test Scenarios**:
  ```dart
  // Red Phase
  test('should save access token with expiry time', () async {
    // Arrange
    final service = SecureStorageService();
    final expiresAt = DateTime.now().add(Duration(hours: 2));

    // Act
    await service.saveAccessToken('token123', expiresAt);

    // Assert
    final token = await service.getAccessToken();
    expect(token, 'token123');
  });

  test('should save refresh token securely', () {});
  test('should delete all tokens on logout', () {});
  test('should return null when no token exists', () {});
  test('should detect expired access token', () async {
    final service = SecureStorageService();
    final expiredTime = DateTime.now().subtract(Duration(hours: 1));
    await service.saveAccessToken('token123', expiredTime);

    expect(await service.isAccessTokenExpired(), true);
  });
  test('should return null for expired token', () async {});
  test('should return token if still valid', () async {});
  ```
- **Implementation Order**:
  1. FlutterSecureStorage 인스턴스 생성
  2. saveAccessToken / getAccessToken (만료 시간 포함)
  3. saveRefreshToken / getRefreshToken
  4. isAccessTokenExpired / getAccessTokenIfValid
  5. deleteAllTokens
- **Dependencies**: flutter_secure_storage

---

#### KakaoAuthDataSource
- **Location**: `features/authentication/infrastructure/datasources/kakao_auth_datasource.dart`
- **Responsibility**: Kakao SDK를 통한 OAuth 2.0 인증 (공식 가이드 준수)
- **Test Strategy**: Integration Test (실제 SDK 또는 Mock)
- **Test Scenarios**:
  ```dart
  // Red Phase
  test('should authenticate with Kakao and return OAuthToken', () async {
    // Arrange
    final dataSource = KakaoAuthDataSource();

    // Act
    final token = await dataSource.login();

    // Assert
    expect(token, isA<OAuthToken>());
    expect(token.accessToken, isNotEmpty);
    expect(token.refreshToken, isNotEmpty);
    expect(token.expiresIn, greaterThan(0));
  });

  test('should get Kakao user information', () async {
    final dataSource = KakaoAuthDataSource();

    final user = await dataSource.getUser();

    expect(user, isA<User>());  // Kakao SDK User 타입
    expect(user.id, isNotNull);
    expect(user.kakaoAccount?.profile?.nickname, isNotEmpty);
  });

  test('should throw PlatformException with CANCELED code when user cancels', () async {
    // 사용자 취소 시나리오 모킹
    expect(
      () => dataSource.login(),
      throwsA(isA<PlatformException>()
        .having((e) => e.code, 'code', 'CANCELED')),
    );
  });

  test('should fallback to account login when KakaoTalk login fails', () async {
    // KakaoTalk 로그인 실패 → Account 로그인 성공 시나리오
    final token = await dataSource.login();
    expect(token.accessToken, isNotEmpty);
  });

  test('should check KakaoTalk installation', () async {
    final isInstalled = await isKakaoTalkInstalled();
    expect(isInstalled, isA<bool>());
  });

  test('should logout and discard SDK token', () async {
    await dataSource.logout();
    // 에러 발생해도 토큰은 항상 삭제됨
  });

  test('should validate token', () async {
    final isValid = await dataSource.isTokenValid();
    expect(isValid, isA<bool>());
  });
  ```
- **Implementation Details**:
  ```dart
  import 'package:kakao_flutter_sdk/kakao_flutter_sdk.dart';
  import 'package:flutter/services.dart';

  class KakaoAuthDataSource {
    /// 카카오 로그인 (공식 권장 패턴)
    /// - KakaoTalk 설치 확인
    /// - KakaoTalk 로그인 시도 → 실패 시 Account 로그인으로 fallback
    /// - 사용자 취소는 PlatformException(code: CANCELED) 발생
    Future<OAuthToken> login() async {
      if (await isKakaoTalkInstalled()) {
        try {
          return await UserApi.instance.loginWithKakaoTalk();
        } catch (error) {
          // 사용자 취소는 그대로 전파
          if (error is PlatformException && error.code == 'CANCELED') {
            rethrow;
          }
          // 그 외 에러는 Account 로그인으로 fallback
          return await UserApi.instance.loginWithKakaoAccount();
        }
      } else {
        return await UserApi.instance.loginWithKakaoAccount();
      }
    }

    /// 카카오 사용자 정보 조회
    Future<User> getUser() async {
      return await UserApi.instance.me();
    }

    /// 카카오 로그아웃 (SDK 토큰 삭제)
    /// SDK는 항상 토큰을 삭제하므로 에러 무시
    Future<void> logout() async {
      try {
        await UserApi.instance.logout();
      } catch (error) {
        print('Kakao logout completed: $error');
      }
    }

    /// 토큰 유효성 검증
    Future<bool> isTokenValid() async {
      if (await AuthApi.instance.hasToken()) {
        try {
          await UserApi.instance.accessTokenInfo();
          return true;
        } catch (error) {
          return false;
        }
      }
      return false;
    }
  }
  ```
- **Edge Cases**:
  - KakaoTalk 미설치: Account 로그인으로 자동 전환
  - KakaoTalk 로그인 실패: Account 로그인으로 fallback
  - 사용자 취소: `PlatformException(code: CANCELED)` 전파
- **Implementation Order**:
  1. login() 메서드 구현 (KakaoTalk 체크 + fallback)
  2. getUser() 메서드 구현
  3. logout() 메서드 구현
  4. isTokenValid() 메서드 구현
- **Dependencies**: kakao_flutter_sdk, flutter/services
- **Note**: 재시도 로직은 IsarAuthRepository에서 처리

---

#### NaverAuthDataSource
- **Location**: `features/authentication/infrastructure/datasources/naver_auth_datasource.dart`
- **Responsibility**: Naver SDK를 통한 OAuth 2.0 인증 (공식 패키지 준수)
- **Test Strategy**: Integration Test (실제 SDK 또는 Mock)
- **Test Scenarios**:
  ```dart
  // Red Phase
  test('should authenticate with Naver and return NaverLoginResult', () async {
    // Arrange
    final dataSource = NaverAuthDataSource();

    // Act
    final result = await dataSource.login();

    // Assert
    expect(result, isA<NaverLoginResult>());
    expect(result.status, NaverLoginStatus.loggedIn);
    expect(result.account, isNotNull);
  });

  test('should get Naver user information', () async {
    final dataSource = NaverAuthDataSource();

    final account = await dataSource.getUser();

    expect(account, isA<NaverAccountResult>());
    expect(account.name, isNotEmpty);
    expect(account.email, isNotEmpty);
  });

  test('should get current access token', () async {
    final dataSource = NaverAuthDataSource();

    final token = await dataSource.getCurrentToken();

    expect(token, isA<NaverToken>());
    expect(token.isValid(), true);
    expect(token.accessToken, isNotEmpty);
    expect(token.refreshToken, isNotEmpty);
  });

  test('should throw exception when login fails', () async {
    // 로그인 실패 시나리오 모킹
    expect(
      () => dataSource.login(),
      throwsA(isA<Exception>()),
    );
  });

  test('should logout and delete token', () async {
    final dataSource = NaverAuthDataSource();

    await dataSource.logout();
    // 로컬 토큰은 항상 삭제됨
  });

  test('should handle NaverLoginStatus.error', () async {
    // status가 error인 경우 예외 발생
    expect(
      () => dataSource.login(),
      throwsA(contains('Naver login failed')),
    );
  });
  ```
- **Implementation Details**:
  ```dart
  import 'package:flutter_naver_login/flutter_naver_login.dart';

  class NaverAuthDataSource {
    /// 네이버 로그인
    /// - NaverLoginStatus 체크
    /// - loggedIn이 아니면 예외 발생
    Future<NaverLoginResult> login() async {
      final NaverLoginResult result = await FlutterNaverLogin.logIn();

      if (result.status == NaverLoginStatus.error) {
        throw Exception('Naver login failed');
      } else if (result.status != NaverLoginStatus.loggedIn) {
        throw Exception('Naver login cancelled or failed');
      }

      return result;
    }

    /// 네이버 로그아웃 및 토큰 삭제
    /// 로컬 토큰은 항상 삭제되므로 에러 무시
    Future<void> logout() async {
      try {
        await FlutterNaverLogin.logOutAndDeleteToken();
      } catch (error) {
        print('Naver logout completed: $error');
      }
    }

    /// 네이버 사용자 정보 조회
    /// 파라미터 없음 - SDK가 자동으로 현재 토큰 사용
    Future<NaverAccountResult> getUser() async {
      return await FlutterNaverLogin.getCurrentAccount();
    }

    /// 현재 토큰 정보 가져오기
    Future<NaverToken> getCurrentToken() async {
      final NaverToken token =
        await FlutterNaverLogin.getCurrentAccessToken();

      if (!token.isValid()) {
        throw Exception('Naver token expired');
      }

      return token;
    }
  }
  ```
- **Edge Cases**:
  - 로그인 실패: `NaverLoginStatus.error` 체크
  - 사용자 취소: status가 loggedIn이 아닌 경우
  - 토큰 만료: `NaverToken.isValid()` 체크
- **Implementation Order**:
  1. login() 메서드 구현 (status 검증)
  2. getUser() 메서드 구현
  3. getCurrentToken() 메서드 구현
  4. logout() 메서드 구현
- **Dependencies**: flutter_naver_login
- **Note**: 재시도 로직은 IsarAuthRepository에서 처리

---

#### UserDto / ConsentRecordDto
- **Location**: `features/authentication/infrastructure/dtos/`
- **Responsibility**: Isar 저장을 위한 DTO 변환
- **Test Strategy**: Unit Test
- **Test Scenarios**:
  ```dart
  // UserDto
  test('should convert UserDto to User entity', () {
    final dto = UserDto()
      ..id = 'user123'
      ..oauthProvider = 'kakao'
      ..oauthUserId = 'kakao_123'
      ..name = '홍길동'
      ..email = 'test@example.com';

    final entity = dto.toEntity();

    expect(entity.id, 'user123');
    expect(entity.name, '홍길동');
  });

  test('should convert User entity to UserDto', () {});
  test('should handle null profileImageUrl', () {});

  // ConsentRecordDto
  test('should convert ConsentRecordDto to ConsentRecord entity', () {});
  test('should convert ConsentRecord entity to ConsentRecordDto', () {});
  ```
- **Implementation Order**: DTO 클래스 정의 → toEntity → fromEntity
- **Dependencies**: Isar, User, ConsentRecord

---

#### IsarAuthRepository
- **Location**: `features/authentication/infrastructure/repositories/isar_auth_repository.dart`
- **Responsibility**: AuthRepository 인터페이스 구현 (Isar + DataSource + 재시도 로직)
- **Test Strategy**: Integration Test (실제 Isar 인스턴스)
- **Test Scenarios**:
  ```dart
  // Red Phase
  testWidgets('should login with Kakao and save user with consent to Isar', () async {
    // Arrange
    final isar = await openTestIsar();
    final kakaoDataSource = MockKakaoAuthDataSource();
    final naverDataSource = MockNaverAuthDataSource();
    final secureStorage = MockSecureStorageService();
    final repo = IsarAuthRepository(
      isar,
      kakaoDataSource,
      naverDataSource,
      secureStorage,
    );

    final mockToken = OAuthToken(
      accessToken: 'kakao_access_token',
      refreshToken: 'kakao_refresh_token',
      expiresIn: 7200,
    );
    final mockUser = User(
      id: 123456789,
      kakaoAccount: KakaoAccount(
        profile: Profile(nickname: '홍길동'),
        email: 'test@kakao.com',
      ),
    );

    when(kakaoDataSource.login()).thenAnswer((_) async => mockToken);
    when(kakaoDataSource.getUser()).thenAnswer((_) async => mockUser);

    // Act
    final user = await repo.loginWithKakao(
      agreedToTerms: true,
      agreedToPrivacy: true,
    );

    // Assert
    expect(user.oauthProvider, 'kakao');
    expect(user.lastLoginAt, isNotNull);
    verify(secureStorage.saveAccessToken(any, any)).called(1);
    verify(secureStorage.saveRefreshToken(any)).called(1);
    final savedUser = await isar.userDtos.get(user.id);
    expect(savedUser, isNotNull);
    final consent = await isar.consentRecordDtos.filter().userIdEqualTo(user.id).findFirst();
    expect(consent, isNotNull);
    expect(consent?.termsOfService, true);
  });

  testWidgets('should login with Naver and save user to Isar', () async {
    final isar = await openTestIsar();
    final kakaoDataSource = MockKakaoAuthDataSource();
    final naverDataSource = MockNaverAuthDataSource();
    final secureStorage = MockSecureStorageService();
    final repo = IsarAuthRepository(
      isar,
      kakaoDataSource,
      naverDataSource,
      secureStorage,
    );

    final mockResult = NaverLoginResult(
      status: NaverLoginStatus.loggedIn,
      account: NaverAccountResult(
        id: 'naver_123',
        name: '김철수',
        email: 'test@naver.com',
      ),
    );
    final mockToken = NaverToken(
      accessToken: 'naver_access_token',
      refreshToken: 'naver_refresh_token',
      expiresAt: DateTime.now().add(Duration(hours: 2)),
    );

    when(naverDataSource.login()).thenAnswer((_) async => mockResult);
    when(naverDataSource.getCurrentToken()).thenAnswer((_) async => mockToken);

    final user = await repo.loginWithNaver(
      agreedToTerms: true,
      agreedToPrivacy: true,
    );

    expect(user.oauthProvider, 'naver');
    verify(secureStorage.saveAccessToken(any, any)).called(1);
  });

  testWidgets('should update lastLoginAt for returning user', () {});
  testWidgets('should return true for first login', () async {
    final repo = IsarAuthRepository(
      isar,
      kakaoDataSource,
      naverDataSource,
      secureStorage,
    );

    expect(await repo.isFirstLogin(), true);
  });
  testWidgets('should return false for returning user', () async {});
  testWidgets('should logout and delete all tokens even on network error', () async {
    final kakaoDataSource = MockKakaoAuthDataSource();
    when(kakaoDataSource.logout()).thenThrow(Exception('Network error'));

    final repo = IsarAuthRepository(
      isar,
      kakaoDataSource,
      naverDataSource,
      secureStorage,
    );

    await repo.logout(); // 예외 발생하지 않아야 함

    verify(secureStorage.deleteAllTokens()).called(1);
  });
  testWidgets('should get current user from Isar', () {});
  testWidgets('should refresh access token and update storage', () {});
  testWidgets('should throw exception on OAuth failure', () {});
  testWidgets('should retry exactly 3 times on network error', () async {
    final kakaoDataSource = MockKakaoAuthDataSource();
    when(kakaoDataSource.login())
        .thenThrow(Exception('Network error'));

    final repo = IsarAuthRepository(
      isar,
      kakaoDataSource,
      naverDataSource,
      secureStorage,
    );

    expect(
      () => repo.loginWithKakao(agreedToTerms: true, agreedToPrivacy: true),
      throwsA(isA<MaxRetriesExceededException>()),
    );

    verify(kakaoDataSource.login()).called(3);
  });
  testWidgets('should succeed on second retry', () async {
    final kakaoDataSource = MockKakaoAuthDataSource();
    final mockToken = OAuthToken(
      accessToken: 'token',
      refreshToken: 'refresh',
      expiresIn: 7200,
    );
    final mockUser = User(id: 123);

    when(kakaoDataSource.login())
        .thenThrow(Exception('Network error'))
        .thenAnswer((_) async => mockToken);
    when(kakaoDataSource.getUser()).thenAnswer((_) async => mockUser);

    final user = await repo.loginWithKakao(agreedToTerms: true, agreedToPrivacy: true);

    expect(user, isNotNull);
    verify(kakaoDataSource.login()).called(2);
  });
  testWidgets('should handle PlatformException CANCELED without retry', () async {
    final kakaoDataSource = MockKakaoAuthDataSource();
    when(kakaoDataSource.login())
        .thenThrow(PlatformException(code: 'CANCELED'));

    final repo = IsarAuthRepository(
      isar,
      kakaoDataSource,
      naverDataSource,
      secureStorage,
    );

    expect(
      () => repo.loginWithKakao(agreedToTerms: true, agreedToPrivacy: true),
      throwsA(isA<OAuthCancelledException>()),
    );

    verify(kakaoDataSource.login()).called(1); // 재시도 없음
  });
  testWidgets('should validate access token expiry', () {});
  ```
- **Edge Cases**:
  - OAuth 취소 (PlatformException CANCELED): 재시도 없이 예외 전파
  - 네트워크 오류: 정확히 3회 재시도 (exponential backoff)
  - 토큰 갱신 실패: 재로그인 유도
  - 로그아웃 중 네트워크 오류: 로컬 토큰 삭제는 반드시 수행
- **Implementation Order**:
  1. loginWithKakao 구현 (DataSource 호출, 토큰 저장, 동의 정보 저장, 재시도 로직)
  2. loginWithNaver 구현 (DataSource 호출, 토큰 저장, 동의 정보 저장, 재시도 로직)
  3. isFirstLogin 구현
  4. logout 구현 (네트워크 오류 무시)
  5. getCurrentUser 구현
  6. isAccessTokenValid 구현
  7. refreshAccessToken 구현
- **Implementation Details**:
  ```dart
  class IsarAuthRepository implements AuthRepository {
    final Isar _isar;
    final KakaoAuthDataSource _kakaoDataSource;
    final NaverAuthDataSource _naverDataSource;
    final SecureStorageService _secureStorage;

    IsarAuthRepository(
      this._isar,
      this._kakaoDataSource,
      this._naverDataSource,
      this._secureStorage,
    );

    @override
    Future<User> loginWithKakao({
      required bool agreedToTerms,
      required bool agreedToPrivacy,
    }) async {
      // 재시도 로직 (PlatformException CANCELED는 재시도 제외)
      return await _retryOnNetworkError(() async {
        // 1. DataSource에서 로그인
        final token = await _kakaoDataSource.login();

        // 2. 토큰 저장
        await _secureStorage.saveAccessToken(
          token.accessToken,
          DateTime.now().add(Duration(seconds: token.expiresIn)),
        );
        await _secureStorage.saveRefreshToken(token.refreshToken);

        // 3. 사용자 정보 가져오기
        final kakaoUser = await _kakaoDataSource.getUser();

        // 4. Domain Entity로 변환
        final user = User(
          id: kakaoUser.id.toString(),
          oauthProvider: 'kakao',
          oauthUserId: kakaoUser.id.toString(),
          name: kakaoUser.kakaoAccount?.profile?.nickname ?? '',
          email: kakaoUser.kakaoAccount?.email ?? '',
          profileImageUrl: kakaoUser.kakaoAccount?.profile?.profileImageUrl,
          lastLoginAt: DateTime.now(),
        );

        // 5. Isar에 저장
        await _saveUserToIsar(user);
        await _saveConsentToIsar(user.id, agreedToTerms, agreedToPrivacy);

        return user;
      }, shouldRetry: (error) {
        // PlatformException CANCELED는 재시도하지 않음
        if (error is PlatformException && error.code == 'CANCELED') {
          return false;
        }
        return true;
      });
    }

    @override
    Future<User> loginWithNaver({
      required bool agreedToTerms,
      required bool agreedToPrivacy,
    }) async {
      return await _retryOnNetworkError(() async {
        // 1. DataSource에서 로그인
        final result = await _naverDataSource.login();

        // 2. 토큰 가져오기
        final token = await _naverDataSource.getCurrentToken();

        // 3. 토큰 저장
        await _secureStorage.saveAccessToken(
          token.accessToken,
          token.expiresAt,
        );
        await _secureStorage.saveRefreshToken(token.refreshToken);

        // 4. 사용자 정보 가져오기 (result.account 사용 가능)
        final account = result.account!;

        // 5. Domain Entity로 변환
        final user = User(
          id: account.id,
          oauthProvider: 'naver',
          oauthUserId: account.id,
          name: account.name ?? '',
          email: account.email ?? '',
          profileImageUrl: account.profileImage,
          lastLoginAt: DateTime.now(),
        );

        // 6. Isar에 저장
        await _saveUserToIsar(user);
        await _saveConsentToIsar(user.id, agreedToTerms, agreedToPrivacy);

        return user;
      });
    }

    @override
    Future<void> logout() async {
      try {
        // 현재 사용자 확인 후 적절한 DataSource 호출
        final user = await getCurrentUser();
        if (user?.oauthProvider == 'kakao') {
          await _kakaoDataSource.logout();
        } else if (user?.oauthProvider == 'naver') {
          await _naverDataSource.logout();
        }
      } catch (error) {
        // 네트워크 오류 무시
        print('Logout network error ignored: $error');
      } finally {
        // 로컬 토큰은 반드시 삭제
        await _secureStorage.deleteAllTokens();
      }
    }

    // 재시도 로직 헬퍼 메서드
    Future<T> _retryOnNetworkError<T>(
      Future<T> Function() operation, {
      bool Function(dynamic)? shouldRetry,
      int maxRetries = 3,
    }) async {
      for (int i = 0; i < maxRetries; i++) {
        try {
          return await operation();
        } catch (error) {
          if (shouldRetry != null && !shouldRetry(error)) {
            rethrow;
          }
          if (i == maxRetries - 1) {
            throw MaxRetriesExceededException('Max retries exceeded');
          }
          await Future.delayed(Duration(milliseconds: 100 * (i + 1)));
        }
      }
      throw MaxRetriesExceededException('Max retries exceeded');
    }
  }
  ```
- **Dependencies**: Isar, KakaoAuthDataSource, NaverAuthDataSource, SecureStorageService, UserDto, ConsentRecordDto

---

### 3.3. Application Layer

#### AuthNotifier
- **Location**: `features/authentication/application/notifiers/auth_notifier.dart`
- **Responsibility**: 인증 상태 관리, 최초 로그인 판단, 토큰 갱신 오케스트레이션
- **Test Strategy**: Unit Test (MockAuthRepository)
- **Test Scenarios**:
  ```dart
  // Red Phase
  test('should initialize with loading state', () {
    final container = ProviderContainer(
      overrides: [
        authRepositoryProvider.overrideWithValue(mockRepo),
      ],
    );

    final state = container.read(authNotifierProvider);

    expect(state, isA<AsyncLoading>());
  });

  test('should load current user on build', () async {
    when(mockRepo.getCurrentUser()).thenAnswer((_) async => mockUser);

    final container = ProviderContainer(
      overrides: [authRepositoryProvider.overrideWithValue(mockRepo)],
    );

    await container.read(authNotifierProvider.future);

    final state = container.read(authNotifierProvider);
    expect(state.value, mockUser);
  });

  test('should login with Kakao and update state', () async {
    when(mockRepo.loginWithKakao(
      agreedToTerms: true,
      agreedToPrivacy: true,
    )).thenAnswer((_) async => mockUser);

    final container = ProviderContainer(
      overrides: [authRepositoryProvider.overrideWithValue(mockRepo)],
    );
    final notifier = container.read(authNotifierProvider.notifier);

    await notifier.loginWithKakao(
      agreedToTerms: true,
      agreedToPrivacy: true,
    );

    final state = container.read(authNotifierProvider);
    expect(state.value, mockUser);
  });

  test('should login with Naver and update state', () async {
    when(mockRepo.loginWithNaver(
      agreedToTerms: true,
      agreedToPrivacy: true,
    )).thenAnswer((_) async => mockNaverUser);

    await notifier.loginWithNaver(
      agreedToTerms: true,
      agreedToPrivacy: true,
    );

    final state = container.read(authNotifierProvider);
    expect(state.value?.oauthProvider, 'naver');
  });

  test('should logout and clear state', () {});
  test('should handle OAuth cancellation gracefully', () {});
  test('should handle network error and show message', () {});
  test('should refresh token automatically before expiry', () async {
    when(mockRepo.isAccessTokenValid()).thenAnswer((_) async => false);
    when(mockRepo.refreshAccessToken(any)).thenAnswer((_) async => 'newToken');

    await notifier.ensureValidToken();

    verify(mockRepo.refreshAccessToken(any)).called(1);
  });
  test('should logout if refresh token is also expired', () async {});
  ```
- **Implementation Order**:
  1. build() 메서드 (getCurrentUser 호출)
  2. loginWithKakao() (동의 정보 파라미터 포함)
  3. loginWithNaver() (동의 정보 파라미터 포함)
  4. logout()
  5. ensureValidToken() (자동 토큰 갱신)
  6. 에러 핸들링
- **Dependencies**: AuthRepository

---

### 3.4. Presentation Layer

#### LoginScreen
- **Location**: `features/authentication/presentation/screens/login_screen.dart`
- **Responsibility**: 로그인 UI 렌더링, 사용자 입력 처리, 최초 로그인 여부에 따른 네비게이션
- **Test Strategy**: Widget Test + Acceptance Test
- **Test Scenarios**:
  ```dart
  // Widget Test - Red Phase
  testWidgets('should display Kakao and Naver login buttons', (tester) async {
    await tester.pumpWidget(
      ProviderScope(
        child: MaterialApp(home: LoginScreen()),
      ),
    );

    expect(find.text('카카오 로그인'), findsOneWidget);
    expect(find.text('네이버 로그인'), findsOneWidget);
  });

  testWidgets('should display terms of service checkbox', (tester) async {});
  testWidgets('should disable login buttons when terms not agreed', (tester) async {});
  testWidgets('should enable login buttons when terms agreed', (tester) async {});

  testWidgets('should call loginWithKakao with consent when button pressed', (tester) async {
    final mockNotifier = MockAuthNotifier();

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          authNotifierProvider.overrideWith(() => mockNotifier),
        ],
        child: MaterialApp(home: LoginScreen()),
      ),
    );

    // 동의 체크박스 선택
    await tester.tap(find.byKey(Key('terms_checkbox')));
    await tester.tap(find.byKey(Key('privacy_checkbox')));
    await tester.pump();

    await tester.tap(find.byKey(Key('kakao_login_button')));
    await tester.pump();

    verify(mockNotifier.loginWithKakao(
      agreedToTerms: true,
      agreedToPrivacy: true,
    )).called(1);
  });

  testWidgets('should call loginWithNaver when button pressed', (tester) async {
    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          authNotifierProvider.overrideWith(() => mockNotifier),
        ],
        child: MaterialApp(home: LoginScreen()),
      ),
    );

    await tester.tap(find.byKey(Key('terms_checkbox')));
    await tester.tap(find.byKey(Key('privacy_checkbox')));
    await tester.pump();

    await tester.tap(find.byKey(Key('naver_login_button')));
    await tester.pump();

    verify(mockNotifier.loginWithNaver(
      agreedToTerms: true,
      agreedToPrivacy: true,
    )).called(1);
  });

  testWidgets('should navigate to onboarding on first login', (tester) async {
    when(mockRepo.isFirstLogin()).thenAnswer((_) async => true);

    await tester.tap(find.byKey(Key('kakao_login_button')));
    await tester.pumpAndSettle();

    expect(find.byType(OnboardingScreen), findsOneWidget);
  });
  testWidgets('should navigate to home dashboard on returning user', (tester) async {
    when(mockRepo.isFirstLogin()).thenAnswer((_) async => false);

    await tester.tap(find.byKey(Key('kakao_login_button')));
    await tester.pumpAndSettle();

    expect(find.byType(HomeDashboardScreen), findsOneWidget);
  });
  testWidgets('should show error message on OAuth cancellation', (tester) async {});
  testWidgets('should show network error message and retry option', (tester) async {});
  ```
- **QA Sheet** (수동 테스트):
  | 항목 | 체크 |
  |------|------|
  | 카카오 로그인 버튼 클릭 시 카카오 인증 페이지로 이동 | ☐ |
  | 네이버 로그인 버튼 클릭 시 네이버 인증 페이지로 이동 | ☐ |
  | 동의 체크박스 미선택 시 버튼 비활성화 | ☐ |
  | 동의 체크박스 선택 시 버튼 활성화 | ☐ |
  | OAuth 취소 시 안내 메시지 표시 | ☐ |
  | 네트워크 오류 시 재시도 옵션 표시 | ☐ |
  | 최초 로그인 시 온보딩 화면으로 이동 | ☐ |
  | 재방문 사용자 로그인 후 홈 대시보드로 이동 | ☐ |
- **Implementation Order**:
  1. UI 레이아웃 구성
  2. 동의 체크박스 상태 관리
  3. 로그인 버튼 활성화 로직
  4. AuthNotifier 연동 (동의 정보 전달)
  5. 최초 로그인 여부 확인 및 네비게이션 분기 로직
  6. 에러 처리 UI
- **Dependencies**: AuthNotifier

---

## 4. TDD Workflow

### Phase 1: Domain Layer (Inside-Out)
1. **시작**: User Entity 테스트 작성
2. **Red → Green → Refactor**:
   - User Entity 구현
   - ConsentRecord Entity 구현
   - AuthRepository Interface 정의
3. **Commit**: "feat(auth): add domain entities and repository interface"

### Phase 2: Infrastructure Layer
1. **시작**: SecureStorageService 테스트 작성
2. **Red → Green → Refactor**:
   - SecureStorageService 구현 (토큰 만료 시간 관리 포함)
   - KakaoAuthDataSource 구현 (공식 패턴 준수: KakaoTalk 체크, fallback, PlatformException 처리)
   - NaverAuthDataSource 구현 (공식 패턴 준수: NaverLoginStatus 체크, getCurrentAccount)
   - UserDto / ConsentRecordDto 구현
   - IsarAuthRepository 구현 (DataSource 통합, 재시도 로직, 동의 정보 저장)
3. **Commit**: "feat(auth): implement infrastructure layer with Kakao/Naver DataSources"

### Phase 3: Application Layer
1. **시작**: AuthNotifier 테스트 작성
2. **Red → Green → Refactor**:
   - AuthNotifier build() 구현
   - loginWithKakao / loginWithNaver 구현 (동의 정보 파라미터 포함)
   - ensureValidToken() 구현 (자동 토큰 갱신)
   - logout 구현
3. **Commit**: "feat(auth): add authentication state management"

### Phase 4: Presentation Layer
1. **시작**: LoginScreen 위젯 테스트 작성
2. **Red → Green → Refactor**:
   - LoginScreen UI 구현
   - 동의 체크박스 로직
   - AuthNotifier 연동 (동의 정보 전달)
   - 최초 로그인 여부 확인 및 네비게이션 분기 로직
3. **Commit**: "feat(auth): implement login screen UI"

### Phase 5: Acceptance Testing
1. **시작**: E2E 시나리오 작성
2. **Red → Green → Refactor**:
   - 최초 로그인 (Kakao/Naver) → 온보딩 플로우
   - 재방문 로그인 → 홈 대시보드 플로우
   - OAuth 취소 처리
   - 네트워크 오류 3회 재시도
   - 로그아웃 중 네트워크 오류 처리
3. **Commit**: "test(auth): add acceptance tests for login flows"

### Phase 6: Refactoring
1. 중복 코드 제거
2. 에러 메시지 상수화
3. 토큰 만료 검증 로직 최적화
4. **Commit**: "refactor(auth): optimize token validation and error handling"

---

## 5. 핵심 원칙

### Repository Pattern
- Application/Presentation은 **AuthRepository Interface**만 의존
- Infrastructure는 **IsarAuthRepository 구현체** 제공
- Phase 1 전환 시 **SupabaseAuthRepository**로 1줄 변경

### Test Pyramid
- **Unit Tests (70%)**: Entity, DTO, SecureStorage, AuthNotifier
- **Integration Tests (20%)**: IsarAuthRepository, OAuthService
- **Acceptance Tests (10%)**: LoginScreen E2E 플로우

### TDD 사이클
1. **Red**: 실패하는 테스트 작성
2. **Green**: 최소한의 코드로 통과
3. **Refactor**: 중복 제거 및 최적화

### Edge Case 처리
- OAuth 취소: 사용자 친화적 메시지
- 네트워크 오류: Repository에서 정확히 3회 재시도 (exponential backoff)
- 토큰 만료: SecureStorageService에서 만료 시간 검증, 자동 갱신 또는 재로그인 유도
- 로그아웃 중 네트워크 오류: 로컬 토큰 삭제는 반드시 수행
- 최초 로그인 판단: lastLoginAt 필드로 확인, 온보딩/홈 네비게이션 분기
- 동의 정보 저장: 로그인 프로세스 내 통합 처리

---

## 6. 성공 기준

### 기능 요구사항
- [ ] 카카오/네이버 OAuth 2.0 로그인 성공 (동의 정보 포함)
- [ ] 토큰 암호화 저장 (FlutterSecureStorage, 만료 시간 포함)
- [ ] 동의 정보 로그인 시점에 Isar DB 저장
- [ ] 최초 로그인 판단 (lastLoginAt 필드 기반)
- [ ] 최초 로그인 시 온보딩 화면 이동
- [ ] 재방문 사용자 홈 대시보드 이동
- [ ] 토큰 만료 자동 검증 및 갱신 처리
- [ ] 네트워크 오류 정확히 3회 재시도
- [ ] 로그아웃 중 네트워크 오류 발생해도 로컬 토큰 삭제

### 비기능 요구사항
- [ ] 모든 테스트 통과 (Unit + Integration + Acceptance)
- [ ] Layer 간 의존성 규칙 준수
- [ ] Repository Pattern 엄격히 적용
- [ ] 보안: HTTPS 통신, 토큰 암호화
- [ ] 성능: OAuth 흐름 3초 이내 완료

### 코드 품질
- [ ] Test Coverage > 80%
- [ ] No warnings (flutter analyze)
- [ ] TDD 사이클 완료 (모든 모듈)
- [ ] Commit 메시지 규칙 준수

### 검증 항목 (공식 문서 기반)
- [ ] User Entity에 lastLoginAt 필드 추가
- [ ] AuthRepository에 isFirstLogin() 및 isAccessTokenValid() 메서드 추가
- [ ] 로그인 메서드에 동의 정보 파라미터 추가 (agreedToTerms, agreedToPrivacy)
- [ ] SecureStorageService에 토큰 만료 시간 저장 및 검증 메서드 추가
- [ ] KakaoAuthDataSource: OAuthToken 반환 (nullable 아님)
- [ ] KakaoAuthDataSource: isKakaoTalkInstalled() 체크 및 fallback 로직 구현
- [ ] KakaoAuthDataSource: PlatformException(code: CANCELED) 처리
- [ ] NaverAuthDataSource: NaverLoginResult 반환 및 status 검증
- [ ] NaverAuthDataSource: getCurrentAccount() 메서드 (파라미터 없음)
- [ ] NaverAuthDataSource: getCurrentToken()으로 NaverToken 가져오기
- [ ] IsarAuthRepository: 2개 DataSource 의존성 주입
- [ ] IsarAuthRepository: PlatformException CANCELED는 재시도 제외
- [ ] IsarAuthRepository에서 동의 정보 자동 저장
- [ ] 네이버 OAuth 관련 상세 테스트 케이스 추가
- [ ] 로그아웃 네트워크 오류 처리 테스트 추가
- [ ] LoginScreen에서 최초 로그인 여부에 따른 네비게이션 분기
</file>

<file path="001/spec.md">
# UF-F-001: 소셜 로그인 및 인증 상세 명세

## Use Case Overview

**Use Case ID**: UF-F-001
**Use Case Name**: 소셜 로그인 및 인증
**Primary Actor**: GLP-1 치료 관리 앱 사용자
**Level**: User Goal
**Scope**: 소셜 인증을 통한 앱 접근 권한 획득 및 사용자 계정 관리

---

## Precondition

- 사용자가 앱을 다운로드하여 설치 완료
- 사용자가 네이버 또는 카카오 계정 보유
- 디바이스가 인터넷에 연결됨
- 앱이 네트워크 접근 권한 보유

---

## Trigger

- 사용자가 앱을 최초 실행
- 사용자가 로그아웃 후 재로그인 시도
- 세션 만료 후 자동 로그인 실패

---

## Main Scenario

### 최초 로그인 플로우

1. 사용자가 앱 실행
2. 앱이 저장된 인증 토큰 확인
3. 유효한 토큰이 없음을 감지하고 로그인 화면 표시
4. 로그인 화면에 네이버/카카오 로그인 버튼과 이용약관 동의 체크박스 표시
5. 사용자가 이용약관 및 개인정보처리방침 동의 체크박스 선택
6. 사용자가 카카오 로그인 버튼 클릭
7. 앱이 카카오 OAuth 인증 페이지로 리디렉션
8. 사용자가 카카오 계정 정보 입력 및 앱 권한 승인
9. 카카오 인증 성공 후 Access Token 및 Refresh Token 수신
10. 앱이 사용자 프로필 정보 수신 (이름, 이메일, 프로필 이미지 URL)
11. 앱이 토큰 및 프로필 정보를 안전한 저장소에 저장
12. 앱이 동의 정보를 내부 DB에 기록
13. 앱이 최초 로그인임을 확인하고 온보딩 화면으로 전환

### 재방문 자동 로그인 플로우

1. 사용자가 앱 실행
2. 앱이 저장된 인증 토큰 확인
3. Access Token이 유효함을 확인
4. 마지막 로그인 일시 업데이트
5. 홈 대시보드 화면으로 직접 이동

### 토큰 갱신 플로우

1. 사용자가 앱 실행 또는 API 요청 수행
2. 앱이 Access Token 만료 감지
3. 저장된 Refresh Token으로 새 Access Token 요청
4. 새 Access Token 수신 및 저장
5. 사용자 세션 유지하며 요청 재시도

---

## Edge Cases

### E1: 사용자가 OAuth 인증 과정 취소

**Condition**: 사용자가 소셜 로그인 화면에서 취소 버튼 클릭
**Action**: 로그인 화면 유지, 안내 메시지 표시 ("로그인이 취소되었습니다. 다시 시도해주세요.")

### E2: Access Token 만료

**Condition**: API 요청 시 Access Token 만료 응답 수신
**Action**: Refresh Token으로 자동 갱신 시도, 갱신 성공 시 요청 재시도

### E3: Refresh Token 만료

**Condition**: Refresh Token 갱신 시도 실패
**Action**: 저장된 토큰 모두 삭제, 로그인 화면으로 이동, 재로그인 유도 메시지 표시

### E4: 네트워크 연결 오류

**Condition**: OAuth 인증 요청 중 네트워크 오류 발생
**Action**: 최대 3회 재시도, 실패 시 "네트워크 연결을 확인해주세요" 메시지 표시

### E5: OAuth 제공자 서버 오류

**Condition**: 카카오 또는 네이버 서버 응답 없음 또는 오류
**Action**: "현재 로그인 서비스에 일시적인 문제가 발생했습니다. 잠시 후 다시 시도해주세요." 메시지 표시, 다른 로그인 방법 제안

### E6: 동의 체크박스 미선택

**Condition**: 사용자가 이용약관 동의하지 않음
**Action**: 로그인 버튼 비활성화 유지, 체크박스 옆에 안내 메시지 표시

### E7: 동일 계정 여러 기기 로그인

**Condition**: 사용자가 동시에 여러 기기에서 로그인
**Action**: 각 기기의 세션 독립적으로 유지, 제한 없음

### E8: 로그아웃 중 네트워크 오류

**Condition**: 로그아웃 요청 중 네트워크 오류
**Action**: 로컬 토큰 삭제 후 로그인 화면 이동 (로컬 로그아웃)

---

## Business Rules

### BR1: 인증 제공자 제한

- 네이버 OAuth 2.0과 카카오 OAuth 2.0만 지원
- 이메일/비밀번호 로그인 미지원

### BR2: 토큰 저장 보안

- Access Token 및 Refresh Token은 FlutterSecureStorage를 통해 암호화 저장
- 평문 저장 금지
- 디바이스 잠금 해제 시에만 접근 가능

### BR3: 동의 정보 저장

- 이용약관 및 개인정보처리방침 동의 여부 및 일시를 내부 DB에 영구 기록
- 동의 철회 시 별도 처리 절차 필요 (MVP 범위 외)

### BR4: 자동 로그인

- 유효한 토큰이 존재하면 자동 로그인 수행
- 최초 로그인 여부에 따라 온보딩 또는 홈 대시보드로 이동

### BR5: 토큰 갱신 정책

- Access Token 만료 시 자동으로 Refresh Token으로 갱신 시도
- Refresh Token 만료 시 재로그인 필수
- 갱신 실패 시 사용자에게 명확히 안내

### BR6: 네트워크 오류 재시도

- OAuth 인증 요청 실패 시 최대 3회 자동 재시도
- 3회 실패 후 사용자에게 에러 메시지 표시

### BR7: HTTPS 통신 필수

- 모든 OAuth 통신은 HTTPS를 통해 암호화
- HTTP 통신 차단

---

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE as "Frontend\n(Flutter)"
participant BE as "Backend\n(Supabase Auth)"
participant Database as "Database\n(Isar/Supabase)"

== 최초 로그인 플로우 ==

User -> FE: 앱 실행
FE -> FE: 토큰 존재 확인
FE -> User: 로그인 화면 표시

User -> FE: 이용약관 동의 체크
User -> FE: 카카오 로그인 버튼 클릭

FE -> BE: OAuth 인증 요청 (카카오)
BE -> User: 카카오 인증 페이지 리디렉션

User -> BE: 계정 정보 입력 및 권한 승인
BE -> BE: 인증 처리
BE -> FE: Access Token, Refresh Token 반환

FE -> BE: 사용자 프로필 정보 요청
BE -> FE: 프로필 정보 반환 (이름, 이메일, 이미지)

FE -> Database: 토큰 암호화 저장 (FlutterSecureStorage)
FE -> Database: 사용자 계정 정보 저장 (users 테이블)
FE -> Database: 동의 정보 저장 (consent_records 테이블)

FE -> FE: 최초 로그인 여부 확인
FE -> User: 온보딩 화면으로 이동

== 재방문 자동 로그인 플로우 ==

User -> FE: 앱 실행
FE -> Database: 저장된 Access Token 조회
Database -> FE: Access Token 반환

FE -> FE: Token 유효성 검증
FE -> Database: 마지막 로그인 일시 업데이트
FE -> User: 홈 대시보드로 이동

== 토큰 갱신 플로우 ==

User -> FE: API 요청 수행
FE -> BE: API 요청 (Access Token 포함)
BE -> FE: 401 Unauthorized (Token 만료)

FE -> Database: Refresh Token 조회
Database -> FE: Refresh Token 반환

FE -> BE: Token 갱신 요청 (Refresh Token)
BE -> BE: Refresh Token 검증
BE -> FE: 새 Access Token 반환

FE -> Database: 새 Access Token 저장
FE -> BE: API 요청 재시도 (새 Token)
BE -> FE: 요청 성공 응답

FE -> User: 요청 결과 표시

== Edge Case: Refresh Token 만료 ==

User -> FE: 앱 실행
FE -> Database: Access Token 조회
Database -> FE: Access Token 반환

FE -> BE: API 요청 (Access Token 포함)
BE -> FE: 401 Unauthorized

FE -> Database: Refresh Token 조회
Database -> FE: Refresh Token 반환

FE -> BE: Token 갱신 요청
BE -> FE: 400 Bad Request (Refresh Token 만료)

FE -> Database: 저장된 토큰 모두 삭제
FE -> User: 로그인 화면으로 이동
FE -> User: 재로그인 안내 메시지 표시

== Edge Case: 네트워크 오류 ==

User -> FE: 카카오 로그인 시도
FE -> BE: OAuth 인증 요청

note over FE, BE: 네트워크 오류 발생

FE -> FE: 재시도 1회차
FE -> BE: OAuth 인증 요청

note over FE, BE: 네트워크 오류 발생

FE -> FE: 재시도 2회차
FE -> BE: OAuth 인증 요청

note over FE, BE: 네트워크 오류 발생

FE -> FE: 재시도 3회차
FE -> BE: OAuth 인증 요청

note over FE, BE: 네트워크 오류 발생

FE -> User: 네트워크 연결 확인 메시지 표시

@enduml
```

---

## Postcondition

### Success

- 사용자 인증 완료 및 세션 생성
- Access Token 및 Refresh Token이 안전한 저장소에 저장
- 사용자 계정 정보가 내부 DB에 저장
- 동의 정보가 내부 DB에 기록
- 최초 로그인 시 온보딩 화면으로 이동
- 재방문 시 홈 대시보드로 이동

### Failure

- 로그인 화면 유지
- 적절한 에러 메시지 표시
- 재시도 옵션 제공
</file>

<file path="002/plan.md">
# UF-F000: 온보딩 및 목표 설정 - Implementation Plan

## 1. 개요

온보딩 기능은 신규 사용자가 치료 프로필과 목표를 설정하여 앱 사용을 시작하는 핵심 기능이다. Repository Pattern을 적용하여 Phase 1 전환을 준비하며, TDD 사이클을 통해 각 모듈을 독립적으로 검증한다.

### 모듈 목록
- **Domain Layer**: 비즈니스 로직 및 엔티티 정의 (User, UserProfile, DosagePlan, WeightLog, DoseSchedule)
- **Infrastructure Layer**: Isar 기반 Repository 구현 및 DTO
- **Application Layer**: Riverpod 기반 상태 관리 및 UseCase 오케스트레이션
- **Presentation Layer**: Flutter UI 및 사용자 입력 처리

### TDD 적용 범위
- Unit Tests: Domain, Infrastructure, Application (70%)
- Integration Tests: Repository ↔ Application (20%)
- Acceptance Tests: Presentation 시나리오 (10%)

---

## 2. Architecture Diagram

```mermaid
graph TB
    subgraph Presentation
        OnboardingScreen[OnboardingScreen]
        BasicProfileForm[BasicProfileForm Widget]
        WeightGoalForm[WeightGoalForm Widget]
        DosagePlanForm[DosagePlanForm Widget]
        SummaryScreen[SummaryScreen Widget]
    end

    subgraph Application
        OnboardingNotifier[OnboardingNotifier]
        OnboardingStatusNotifier[OnboardingStatusNotifier]
        TransactionService[TransactionService]
    end

    subgraph Domain
        User[User Entity]
        UserProfile[UserProfile Entity]
        DosagePlan[DosagePlan Entity]
        WeightLog[WeightLog Entity]
        DoseSchedule[DoseSchedule Entity]

        Weight[Weight Value Object]
        MedicationName[MedicationName Value Object]
        StartDate[StartDate Value Object]

        UserRepository[UserRepository Interface]
        ProfileRepository[ProfileRepository Interface]
        MedicationRepository[MedicationRepository Interface]
        TrackingRepository[TrackingRepository Interface]
        ScheduleRepository[ScheduleRepository Interface]

        CalculateWeeklyGoalUseCase[CalculateWeeklyGoalUseCase]
        ValidateDosagePlanUseCase[ValidateDosagePlanUseCase]
        GenerateDoseSchedulesUseCase[GenerateDoseSchedulesUseCase]
        CheckOnboardingStatusUseCase[CheckOnboardingStatusUseCase]
    end

    subgraph Infrastructure
        IsarUserRepository[IsarUserRepository]
        IsarProfileRepository[IsarProfileRepository]
        IsarMedicationRepository[IsarMedicationRepository]
        IsarTrackingRepository[IsarTrackingRepository]
        IsarScheduleRepository[IsarScheduleRepository]

        UserDto[UserDto]
        UserProfileDto[UserProfileDto]
        DosagePlanDto[DosagePlanDto]
        WeightLogDto[WeightLogDto]
        DoseScheduleDto[DoseScheduleDto]
    end

    OnboardingScreen --> OnboardingNotifier
    OnboardingScreen --> OnboardingStatusNotifier

    OnboardingNotifier --> TransactionService
    OnboardingNotifier --> CalculateWeeklyGoalUseCase
    OnboardingNotifier --> ValidateDosagePlanUseCase
    OnboardingNotifier --> GenerateDoseSchedulesUseCase
    OnboardingNotifier --> UserRepository
    OnboardingNotifier --> ProfileRepository
    OnboardingNotifier --> MedicationRepository
    OnboardingNotifier --> TrackingRepository
    OnboardingNotifier --> ScheduleRepository

    OnboardingStatusNotifier --> CheckOnboardingStatusUseCase
    CheckOnboardingStatusUseCase --> ProfileRepository

    UserProfile --> Weight
    DosagePlan --> MedicationName
    DosagePlan --> StartDate

    UserRepository -.implements.-> IsarUserRepository
    ProfileRepository -.implements.-> IsarProfileRepository
    MedicationRepository -.implements.-> IsarMedicationRepository
    TrackingRepository -.implements.-> IsarTrackingRepository
    ScheduleRepository -.implements.-> IsarScheduleRepository

    TransactionService --> IsarInstance[Isar Instance]

    IsarUserRepository --> UserDto
    IsarProfileRepository --> UserProfileDto
    IsarMedicationRepository --> DosagePlanDto
    IsarTrackingRepository --> WeightLogDto
    IsarScheduleRepository --> DoseScheduleDto

    UserDto -.toEntity.-> User
    UserProfileDto -.toEntity.-> UserProfile
    DosagePlanDto -.toEntity.-> DosagePlan
    WeightLogDto -.toEntity.-> WeightLog
    DoseScheduleDto -.toEntity.-> DoseSchedule
```

---

## 3. Implementation Plan

### 3.1 Domain Layer

#### 3.1.1 User Entity
- **Location**: `lib/features/onboarding/domain/entities/user.dart`
- **Responsibility**: 사용자 기본 정보 모델
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. User 생성 시 필수 필드 검증
     - Arrange: id, name, createdAt 값 준비
     - Act: User 생성
     - Assert: 모든 필드가 올바르게 할당됨
  2. Edge: id가 빈 문자열인 경우 ArgumentError
  3. Edge: name이 빈 문자열인 경우 ArgumentError
- **Implementation Order**:
  1. 기본 생성자 및 필드 정의 (Test 1)
  2. 검증 로직 추가 (Test 2, 3)
  3. Refactor: copyWith, equality

#### 3.1.2 UserProfile Entity
- **Location**: `lib/features/onboarding/domain/entities/user_profile.dart`
- **Responsibility**: 사용자 프로필 및 목표 데이터 모델
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. UserProfile 생성 시 필수 필드 검증
     - Arrange: targetWeightKg, weeklyWeightRecordGoal, weeklySymptomRecordGoal 값 준비
     - Act: UserProfile 생성
     - Assert: 모든 필드가 올바르게 할당됨
  2. weeklyLossGoalKg 계산 로직 검증
     - Arrange: currentWeight=80kg, targetWeight=70kg, periodWeeks=10
     - Act: UserProfile.calculateWeeklyGoal() 호출
     - Assert: 1.0kg/주 반환
  3. 기본값 설정 검증
     - Arrange: weeklyWeightRecordGoal, weeklySymptomRecordGoal 미입력
     - Act: UserProfile 생성
     - Assert: 각각 7로 설정됨
  4. Weight Value Object 사용 검증
     - Arrange: currentWeight, targetWeight를 Weight Value Object로 생성
     - Act: UserProfile 생성
     - Assert: Weight 검증 통과 확인
- **Implementation Order**:
  1. 기본 생성자 및 필드 정의 (Test 1)
  2. 기본값 로직 추가 (Test 3)
  3. Value Object 통합 (Test 4)
  4. Refactor: copyWith, equality

#### 3.1.3 Weight Value Object
- **Location**: `lib/features/onboarding/domain/value_objects/weight.dart`
- **Responsibility**: 체중 데이터 검증 및 캡슐화
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. 정상 체중 생성 검증
     - Arrange: kg = 70.5
     - Act: Weight.create(kg)
     - Assert: Weight 인스턴스 반환
  2. Edge: kg < 20인 경우 ValidationError 반환
  3. Edge: kg > 300인 경우 ValidationError 반환
  4. Edge: 경계값 (20, 300) 허용 확인
- **Implementation Order**:
  1. factory create() 메서드 및 검증 (Test 1, 2, 3, 4)
  2. Refactor: equality, toString

#### 3.1.4 MedicationName Value Object
- **Location**: `lib/features/onboarding/domain/value_objects/medication_name.dart`
- **Responsibility**: 약물명 검증 및 캡슐화
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. 정상 약물명 생성 검증
     - Arrange: name = "Ozempic"
     - Act: MedicationName.create(name)
     - Assert: MedicationName 인스턴스 반환
  2. Edge: 빈 문자열인 경우 ValidationError 반환
  3. Edge: 공백만 있는 경우 ValidationError 반환
- **Implementation Order**:
  1. factory create() 메서드 및 검증
  2. Refactor: equality, toString

#### 3.1.5 StartDate Value Object
- **Location**: `lib/features/onboarding/domain/value_objects/start_date.dart`
- **Responsibility**: 시작일 검증 및 캡슐화
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. 정상 시작일 생성 검증
     - Arrange: date = DateTime.now()
     - Act: StartDate.create(date)
     - Assert: StartDate 인스턴스 반환
  2. Edge: 7일 이상 과거인 경우 경고 (허용)
     - Arrange: date = DateTime.now().subtract(Duration(days: 10))
     - Act: StartDate.create(date)
     - Assert: StartDate 반환 + warning 플래그
  3. Edge: 30일 이상 과거인 경우 ValidationError 반환
- **Implementation Order**:
  1. factory create() 메서드 및 기본 검증
  2. 경고 및 에러 로직
  3. Refactor: warning 플래그 처리

#### 3.1.6 DosagePlan Entity
- **Location**: `lib/features/onboarding/domain/entities/dosage_plan.dart`
- **Responsibility**: 투여 계획 데이터 모델
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. DosagePlan 생성 시 필수 필드 검증
     - Arrange: medicationName, startDate, cycleDays, initialDoseMg
     - Act: DosagePlan 생성
     - Assert: 모든 필드 할당 확인
  2. escalationPlan null 허용 검증
     - Arrange: escalationPlan 미입력
     - Act: DosagePlan 생성
     - Assert: null로 저장됨
  3. MedicationName 및 StartDate Value Object 사용 검증
     - Arrange: MedicationName, StartDate Value Object 생성
     - Act: DosagePlan 생성
     - Assert: Value Object 검증 통과 확인
  4. Edge: cycleDays가 0 이하인 경우 ArgumentError
  5. Edge: initialDoseMg가 0 이하인 경우 ArgumentError
- **Implementation Order**:
  1. 기본 생성자 및 필드 (Test 1, 2)
  2. Value Object 통합 (Test 3)
  3. 검증 로직 (Test 4, 5)
  4. Refactor: equality, toString

#### 3.1.7 EscalationStep Value Object
- **Location**: `lib/features/onboarding/domain/entities/escalation_step.dart`
- **Responsibility**: 증량 계획 단계 데이터
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. EscalationStep 생성 검증
     - Arrange: weeks=4, doseMg=0.5
     - Act: EscalationStep 생성
     - Assert: 필드 확인
  2. Edge: weeks가 0 이하인 경우 ArgumentError
  3. Edge: doseMg가 0 이하인 경우 ArgumentError
- **Implementation Order**:
  1. 생성자 및 검증 (Test 1, 2, 3)
  2. Refactor: equality

#### 3.1.8 WeightLog Entity
- **Location**: `lib/features/onboarding/domain/entities/weight_log.dart`
- **Responsibility**: 체중 기록 (온보딩 시 초기 기록 생성용)
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. WeightLog 생성 검증
     - Arrange: userId, logDate, weightKg
     - Act: WeightLog 생성
     - Assert: 필드 확인
  2. Weight Value Object 사용 검증
     - Arrange: Weight Value Object로 weightKg 생성
     - Act: WeightLog 생성
     - Assert: Weight 검증 통과 확인
- **Implementation Order**:
  1. 생성자 및 기본 검증 (Test 1)
  2. Value Object 통합 (Test 2)
  3. Refactor: equality

#### 3.1.9 DoseSchedule Entity
- **Location**: `lib/features/onboarding/domain/entities/dose_schedule.dart`
- **Responsibility**: 투여 스케줄 데이터 모델
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. DoseSchedule 생성 검증
     - Arrange: userId, dosagePlanId, scheduledDate, doseMg, status
     - Act: DoseSchedule 생성
     - Assert: 모든 필드 할당 확인
  2. Edge: doseMg가 0 이하인 경우 ArgumentError
  3. Edge: scheduledDate가 null인 경우 ArgumentError
- **Implementation Order**:
  1. 기본 생성자 및 필드 (Test 1)
  2. 검증 로직 (Test 2, 3)
  3. Refactor: equality, toString

#### 3.1.10 CalculateWeeklyGoalUseCase
- **Location**: `lib/features/onboarding/domain/usecases/calculate_weekly_goal_usecase.dart`
- **Responsibility**: 주간 감량 목표 계산 비즈니스 로직
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. 정상 계산 검증
     - Arrange: currentWeight=80, targetWeight=70, periodWeeks=10
     - Act: execute()
     - Assert: 1.0kg/주 반환
  2. 소수점 처리 검증
     - Arrange: currentWeight=80.5, targetWeight=75.2, periodWeeks=7
     - Act: execute()
     - Assert: 0.76kg/주 (소수점 2자리 반올림)
  3. Edge: periodWeeks가 null인 경우 null 반환
  4. Edge: 주간 목표가 1kg 초과 시 경고 플래그 반환
  5. Edge: currentWeight <= targetWeight인 경우 ArgumentError
- **Implementation Order**:
  1. 기본 계산 로직 (Test 1, 2)
  2. null 처리 (Test 3)
  3. 안전성 검증 (Test 4, 5)
  4. Refactor: 계산 함수 분리

#### 3.1.11 ValidateDosagePlanUseCase
- **Location**: `lib/features/onboarding/domain/usecases/validate_dosage_plan_usecase.dart`
- **Responsibility**: 투여 계획 논리 검증
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. 증량 계획 순서 검증
     - Arrange: escalationPlan = [{weeks:4, dose:0.5}, {weeks:8, dose:1.0}]
     - Act: execute()
     - Assert: valid 반환
  2. Edge: 용량이 감소하는 경우 invalid 반환
  3. Edge: 시기가 역순인 경우 invalid 반환
  4. Edge: 중복 시기인 경우 invalid 반환
  5. Edge: escalationPlan이 null인 경우 valid 반환
- **Implementation Order**:
  1. 순서 검증 로직 (Test 1, 2, 3)
  2. 중복 검증 (Test 4)
  3. null 처리 (Test 5)
  4. Refactor: 검증 규칙 분리

#### 3.1.12 GenerateDoseSchedulesUseCase
- **Location**: `lib/features/onboarding/domain/usecases/generate_dose_schedules_usecase.dart`
- **Responsibility**: DosagePlan 기반 투여 스케줄 생성
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. 기본 스케줄 생성 검증
     - Arrange: DosagePlan (startDate: 2025-01-01, cycleDays: 7, initialDose: 0.25mg)
     - Act: execute(dosagePlan, daysToGenerate: 28)
     - Assert: 4개의 DoseSchedule 생성 (매주 1회)
  2. 증량 계획이 있는 경우 스케줄 생성
     - Arrange: escalationPlan = [{weeks:4, dose:0.5}, {weeks:8, dose:1.0}]
     - Act: execute(dosagePlan, daysToGenerate: 56)
     - Assert: 각 단계별 올바른 doseMg로 스케줄 생성
  3. Edge: daysToGenerate가 0인 경우 빈 리스트 반환
  4. Edge: cycleDays가 1인 경우 매일 스케줄 생성
- **Implementation Order**:
  1. 기본 생성 로직 (Test 1)
  2. 증량 계획 반영 (Test 2)
  3. Edge case 처리 (Test 3, 4)
  4. Refactor: 날짜 계산 함수 분리

#### 3.1.13 CheckOnboardingStatusUseCase
- **Location**: `lib/features/onboarding/domain/usecases/check_onboarding_status_usecase.dart`
- **Responsibility**: 사용자 온보딩 완료 여부 확인
- **Test Strategy**: Unit (Repository Mock)
- **Test Scenarios (Red Phase)**:
  1. 온보딩 완료된 사용자 확인
     - Arrange: Mock ProfileRepository (userId로 프로필 존재)
     - Act: execute(userId)
     - Assert: true 반환
  2. 온보딩 미완료 사용자 확인
     - Arrange: Mock ProfileRepository (userId로 프로필 없음)
     - Act: execute(userId)
     - Assert: false 반환
  3. Edge: Repository 에러 시 false 반환
- **Implementation Order**:
  1. 기본 확인 로직 (Test 1, 2)
  2. 에러 처리 (Test 3)
  3. Refactor

#### 3.1.14 Repository Interfaces
- **Location**:
  - `lib/features/onboarding/domain/repositories/user_repository.dart`
  - `lib/features/onboarding/domain/repositories/profile_repository.dart`
  - `lib/features/onboarding/domain/repositories/medication_repository.dart`
  - `lib/features/onboarding/domain/repositories/tracking_repository.dart`
  - `lib/features/onboarding/domain/repositories/schedule_repository.dart`
- **Responsibility**: 데이터 접근 계약 정의
- **Test Strategy**: Interface는 구현체에서 테스트
- **Method Signatures**:
  - UserRepository:
    - updateUserName(userId, name): Future<void>
  - ScheduleRepository:
    - saveAll(schedules): Future<void>
    - getSchedulesByDateRange(userId, startDate, endDate): Future<List<DoseSchedule>>
- **Implementation Order**:
  1. 메서드 시그니처 정의
  2. Refactor: 문서화 주석 추가

---

### 3.2 Infrastructure Layer

#### 3.2.1 UserDto
- **Location**: `lib/features/onboarding/infrastructure/dtos/user_dto.dart`
- **Responsibility**: Isar ↔ User 변환
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. toEntity() 정상 변환 검증
     - Arrange: UserDto 인스턴스
     - Act: toEntity() 호출
     - Assert: User 필드 일치
  2. fromEntity() 정상 변환 검증
     - Arrange: User 인스턴스
     - Act: fromEntity() 호출
     - Assert: Dto 필드 일치
- **Implementation Order**:
  1. @collection 및 필드 정의
  2. toEntity() 구현 (Test 1)
  3. fromEntity() 구현 (Test 2)
  4. Refactor: 코드 중복 제거

#### 3.2.2 UserProfileDto
- **Location**: `lib/features/onboarding/infrastructure/dtos/user_profile_dto.dart`
- **Responsibility**: Isar ↔ UserProfile 변환
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. toEntity() 정상 변환 검증
     - Arrange: UserProfileDto 인스턴스
     - Act: toEntity() 호출
     - Assert: UserProfile 필드 일치
  2. fromEntity() 정상 변환 검증
     - Arrange: UserProfile 인스턴스
     - Act: fromEntity() 호출
     - Assert: Dto 필드 일치
  3. Edge: null 필드 변환 (targetPeriodWeeks, weeklyLossGoalKg)
- **Implementation Order**:
  1. @collection 및 필드 정의
  2. toEntity() 구현 (Test 1)
  3. fromEntity() 구현 (Test 2)
  4. null 처리 (Test 3)
  5. Refactor: 코드 중복 제거

#### 3.2.3 DosagePlanDto
- **Location**: `lib/features/onboarding/infrastructure/dtos/dosage_plan_dto.dart`
- **Responsibility**: Isar ↔ DosagePlan 변환
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. toEntity() 검증
  2. fromEntity() 검증
  3. Edge: escalationPlan JSON 직렬화/역직렬화
- **Implementation Order**:
  1. @collection 및 필드
  2. toEntity(), fromEntity()
  3. JSON 변환 로직
  4. Refactor: 변환 유틸 분리

#### 3.2.4 WeightLogDto
- **Location**: `lib/features/onboarding/infrastructure/dtos/weight_log_dto.dart`
- **Responsibility**: Isar ↔ WeightLog 변환
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. toEntity() 검증
  2. fromEntity() 검증
- **Implementation Order**:
  1. @collection, 필드, 변환 메서드
  2. Refactor: 공통 DTO 패턴 추출

#### 3.2.5 DoseScheduleDto
- **Location**: `lib/features/onboarding/infrastructure/dtos/dose_schedule_dto.dart`
- **Responsibility**: Isar ↔ DoseSchedule 변환
- **Test Strategy**: Unit
- **Test Scenarios (Red Phase)**:
  1. toEntity() 검증
  2. fromEntity() 검증
  3. Edge: status enum 변환 검증
- **Implementation Order**:
  1. @collection 및 필드
  2. toEntity(), fromEntity()
  3. enum 변환 로직
  4. Refactor

#### 3.2.6 IsarUserRepository
- **Location**: `lib/features/onboarding/infrastructure/repositories/isar_user_repository.dart`
- **Responsibility**: UserRepository 구현 (Isar 기반)
- **Test Strategy**: Integration (Isar 의존)
- **Test Scenarios (Red Phase)**:
  1. updateUserName() 정상 업데이트 검증
     - Arrange: Mock Isar, userId, name
     - Act: updateUserName(userId, name) 호출
     - Assert: Isar.writeTxn() 호출됨, name 업데이트 확인
  2. Edge: 존재하지 않는 userId 업데이트 시 Exception throw
- **Implementation Order**:
  1. updateUserName 구현 (Test 1)
  2. 예외 처리 (Test 2)
  3. Refactor

#### 3.2.7 IsarProfileRepository
- **Location**: `lib/features/onboarding/infrastructure/repositories/isar_profile_repository.dart`
- **Responsibility**: ProfileRepository 구현 (Isar 기반)
- **Test Strategy**: Integration (Isar 의존)
- **Test Scenarios (Red Phase)**:
  1. saveUserProfile() 정상 저장 검증
     - Arrange: Mock Isar, UserProfile 인스턴스
     - Act: saveUserProfile() 호출
     - Assert: Isar.writeTxn() 호출됨, Dto로 변환 확인
  2. getUserProfile() 정상 조회 검증
     - Arrange: Dto가 Isar에 저장된 상태
     - Act: getUserProfile(userId) 호출
     - Assert: Entity 반환 확인
  3. updateUserProfile() 수정 검증
  4. Edge: 존재하지 않는 userId 조회 시 null 반환
  5. Edge: Isar writeTxn 실패 시 Exception throw
- **Implementation Order**:
  1. save 구현 (Test 1)
  2. get 구현 (Test 2, 4)
  3. update 구현 (Test 3)
  4. 예외 처리 (Test 5)
  5. Refactor: 중복 코드 제거

#### 3.2.8 IsarMedicationRepository (온보딩 관련 메서드만)
- **Location**: `lib/features/onboarding/infrastructure/repositories/isar_medication_repository.dart`
- **Responsibility**: DosagePlan 저장
- **Test Strategy**: Integration
- **Test Scenarios (Red Phase)**:
  1. saveDosagePlan() 정상 저장
  2. getActiveDosagePlan() 조회
  3. Edge: 중복 활성 플랜 시 가장 최근 플랜 반환
- **Implementation Order**:
  1. save 구현
  2. get 구현
  3. 중복 처리 로직
  4. Refactor

#### 3.2.9 IsarTrackingRepository (온보딩 관련 메서드만)
- **Location**: `lib/features/onboarding/infrastructure/repositories/isar_tracking_repository.dart`
- **Responsibility**: 초기 WeightLog 저장
- **Test Strategy**: Integration
- **Test Scenarios (Red Phase)**:
  1. saveWeightLog() 정상 저장
  2. Edge: 같은 날짜 중복 저장 시 덮어쓰기
- **Implementation Order**:
  1. save 구현
  2. 중복 처리
  3. Refactor

#### 3.2.10 IsarScheduleRepository
- **Location**: `lib/features/onboarding/infrastructure/repositories/isar_schedule_repository.dart`
- **Responsibility**: DoseSchedule 저장 및 조회
- **Test Strategy**: Integration
- **Test Scenarios (Red Phase)**:
  1. saveAll() 정상 저장 검증
     - Arrange: List<DoseSchedule>
     - Act: saveAll(schedules) 호출
     - Assert: 모든 스케줄 저장 확인
  2. getSchedulesByDateRange() 조회 검증
     - Arrange: 여러 스케줄 저장
     - Act: getSchedulesByDateRange(userId, startDate, endDate) 호출
     - Assert: 범위 내 스케줄만 반환
  3. Edge: saveAll 중 일부 실패 시 트랜잭션 롤백
- **Implementation Order**:
  1. saveAll 구현 (Test 1)
  2. getSchedulesByDateRange 구현 (Test 2)
  3. 트랜잭션 처리 (Test 3)
  4. Refactor

#### 3.2.11 TransactionService
- **Location**: `lib/features/onboarding/infrastructure/services/transaction_service.dart`
- **Responsibility**: Isar 트랜잭션 관리
- **Test Strategy**: Integration
- **Test Scenarios (Red Phase)**:
  1. executeInTransaction() 정상 실행 검증
     - Arrange: Mock Isar, 정상 operation
     - Act: executeInTransaction(operation) 호출
     - Assert: operation 실행됨, 결과 반환
  2. Edge: operation 실패 시 트랜잭션 롤백
     - Arrange: 실패하는 operation
     - Act: executeInTransaction(operation) 호출
     - Assert: 예외 발생, 데이터 롤백 확인
  3. Edge: 중첩 트랜잭션 방지
- **Implementation Order**:
  1. 기본 트랜잭션 로직 (Test 1)
  2. 롤백 처리 (Test 2)
  3. 중첩 방지 (Test 3)
  4. Refactor

---

### 3.3 Application Layer

#### 3.3.1 OnboardingStatusNotifier
- **Location**: `lib/features/onboarding/application/notifiers/onboarding_status_notifier.dart`
- **Responsibility**: 온보딩 상태 확인 및 관리
- **Test Strategy**: Integration (Repository Mock)
- **Test Scenarios (Red Phase)**:
  1. checkStatus() 온보딩 완료 확인
     - Arrange: Mock CheckOnboardingStatusUseCase (true 반환)
     - Act: checkStatus(userId)
     - Assert: true 반환, state 업데이트
  2. checkStatus() 온보딩 미완료 확인
     - Arrange: Mock CheckOnboardingStatusUseCase (false 반환)
     - Act: checkStatus(userId)
     - Assert: false 반환
  3. Edge: UseCase 에러 시 state가 AsyncValue.error로 전환
- **Implementation Order**:
  1. 기본 상태 확인 로직 (Test 1, 2)
  2. 에러 처리 (Test 3)
  3. Refactor

#### 3.3.2 OnboardingNotifier
- **Location**: `lib/features/onboarding/application/notifiers/onboarding_notifier.dart`
- **Responsibility**: 온보딩 상태 관리 및 저장 오케스트레이션
- **Test Strategy**: Integration (Repository Mock)
- **Test Scenarios (Red Phase)**:
  1. saveOnboardingData() 정상 저장 시나리오
     - Arrange: 모든 필수 입력값, Mock Repository, Mock TransactionService
     - Act: saveOnboardingData() 호출
     - Assert:
       - TransactionService.executeInTransaction() 호출됨
       - UserRepository.updateUserName() 호출됨
       - ProfileRepository.save() 호출됨
       - MedicationRepository.save() 호출됨
       - TrackingRepository.save() 호출됨 (초기 체중)
       - GenerateDoseSchedulesUseCase 호출됨
       - ScheduleRepository.saveAll() 호출됨
       - state가 AsyncValue.data(void)로 전환
  2. Edge: 저장 중 Repository 실패 시 트랜잭션 롤백
     - Arrange: Mock Repository (에러 throw)
     - Act: saveOnboardingData() 호출
     - Assert: 모든 데이터 저장 안 됨, state가 AsyncValue.error로 전환
  3. Edge: 주간 목표가 1kg 초과 시 경고 플래그 설정
  4. 투여 계획 검증 실패 시 저장 차단
  5. 재시도 로직 검증
     - Arrange: 저장 실패 상태
     - Act: retrySave() 호출
     - Assert: saveOnboardingData() 재호출
- **Dependencies**:
  - TransactionService
  - UserRepository
  - ProfileRepository
  - MedicationRepository
  - TrackingRepository
  - ScheduleRepository
  - CalculateWeeklyGoalUseCase
  - ValidateDosagePlanUseCase
  - GenerateDoseSchedulesUseCase
- **Implementation Order**:
  1. 기본 save 흐름 with 트랜잭션 (Test 1)
  2. 예외 처리 및 롤백 (Test 2)
  3. 검증 로직 통합 (Test 3, 4)
  4. 재시도 로직 (Test 5)
  5. Refactor: 상태 전환 로직 분리

#### 3.3.3 Providers
- **Location**: `lib/features/onboarding/application/providers.dart`
- **Responsibility**: DI 및 Provider 정의
- **Test Strategy**: Integration
- **Test Scenarios (Red Phase)**:
  1. onboardingNotifierProvider 정상 생성
  2. onboardingStatusNotifierProvider 정상 생성
  3. transactionServiceProvider 정상 생성
  4. 각 Repository Provider 정상 생성
  5. 각 UseCase Provider 정상 생성
- **Implementation Order**:
  1. Provider 정의
  2. DI 연결
  3. Refactor: 문서화

---

### 3.4 Presentation Layer

#### 3.4.1 OnboardingScreen
- **Location**: `lib/features/onboarding/presentation/screens/onboarding_screen.dart`
- **Responsibility**: 온보딩 단계 네비게이션
- **Test Strategy**: Acceptance (Widget Test)
- **Test Scenarios (Red Phase)**:
  1. 초기 화면 렌더링 검증
     - Arrange: Widget 준비
     - Act: pumpWidget()
     - Assert: 진행 표시기, BasicProfileForm 표시됨
  2. 다음 단계 이동 시나리오
     - Arrange: BasicProfileForm에서 이름 입력
     - Act: 다음 버튼 클릭
     - Assert: WeightGoalForm 표시됨
  3. 최종 저장 시나리오
     - Arrange: 모든 단계 완료
     - Act: 확인 버튼 클릭
     - Assert: OnboardingNotifier.saveOnboardingData() 호출됨
  4. Edge: 필수 입력 누락 시 다음 버튼 비활성화
- **Implementation Order**:
  1. StatefulWidget 및 PageView 구조 (Test 1)
  2. 단계 전환 로직 (Test 2)
  3. 저장 연동 (Test 3)
  4. 검증 연동 (Test 4)
  5. Refactor: 상태 관리 개선

#### 3.4.2 BasicProfileForm
- **Location**: `lib/features/onboarding/presentation/widgets/basic_profile_form.dart`
- **Responsibility**: 이름 입력 폼
- **Test Strategy**: Acceptance
- **Test Scenarios (Red Phase)**:
  1. TextFormField 렌더링 검증
  2. 입력값 변경 시 콜백 호출 검증
  3. Edge: 빈 문자열 입력 시 에러 메시지 표시
- **Implementation Order**:
  1. UI 구조 (Test 1)
  2. 입력 핸들링 (Test 2)
  3. 검증 연동 (Test 3)
  4. Refactor

#### 3.4.3 WeightGoalForm
- **Location**: `lib/features/onboarding/presentation/widgets/weight_goal_form.dart`
- **Responsibility**: 체중 및 목표 입력 폼
- **Test Strategy**: Acceptance
- **Test Scenarios (Red Phase)**:
  1. 현재 체중, 목표 체중, 목표 기간 필드 렌더링
  2. 입력 시 주간 감량 목표 자동 계산 및 표시
  3. Edge: 목표 체중 > 현재 체중 시 에러 메시지
  4. Edge: 주간 목표 > 1kg 시 경고 메시지
- **Implementation Order**:
  1. UI 구조 (Test 1)
  2. 계산 로직 연동 (Test 2)
  3. 검증 및 경고 (Test 3, 4)
  4. Refactor

#### 3.4.4 DosagePlanForm
- **Location**: `lib/features/onboarding/presentation/widgets/dosage_plan_form.dart`
- **Responsibility**: 투여 계획 입력 폼
- **Test Strategy**: Acceptance
- **Test Scenarios (Red Phase)**:
  1. 약물명, 시작일, 주기, 초기 용량 필드 렌더링
  2. 증량 계획 동적 추가/삭제
  3. Edge: 시작일이 과거 7일 이상인 경우 경고
  4. Edge: 증량 계획 순서 오류 시 에러 메시지
- **Implementation Order**:
  1. 기본 필드 (Test 1)
  2. 증량 계획 UI (Test 2)
  3. 검증 연동 (Test 3, 4)
  4. Refactor

#### 3.4.5 SummaryScreen
- **Location**: `lib/features/onboarding/presentation/widgets/summary_screen.dart`
- **Responsibility**: 입력 정보 요약 및 확인
- **Test Strategy**: Acceptance
- **Test Scenarios (Red Phase)**:
  1. 모든 입력 정보 표시 검증
  2. 확인 버튼 클릭 시 저장 트리거
  3. Edge: 저장 실패 시 에러 메시지 및 재시도 버튼 표시
  4. Edge: 재시도 버튼 클릭 시 retrySave() 호출
- **Implementation Order**:
  1. UI 구조 (Test 1)
  2. 저장 연동 (Test 2)
  3. 에러 처리 및 재시도 UI (Test 3, 4)
  4. Refactor

#### 3.4.6 QA Sheet (Presentation Layer 수동 테스트)
- 진행 표시기 애니메이션 확인
- 단계별 전환 제스처 확인
- 키보드 입력 UX 확인
- 로딩 인디케이터 표시 확인
- 성공 메시지 표시 확인
- 홈 대시보드로 자동 이동 확인

---

## 4. TDD Workflow

### 시작점
1. **첫 번째 테스트**: `Weight Value Object 생성 검증`
2. **이유**: Value Object는 외부 의존성이 없고 검증 로직이 명확하여 테스트하기 가장 쉬움

### 진행 순서 (Inside-Out 전략)

#### Phase 1: Domain Layer (Unit Tests)
1. Value Objects
   - Weight → MedicationName → StartDate
2. Entities
   - User Entity
   - UserProfile Entity (Weight Value Object 사용)
   - DosagePlan Entity (MedicationName, StartDate Value Object 사용)
   - EscalationStep Value Object
   - WeightLog Entity (Weight Value Object 사용)
   - DoseSchedule Entity
3. UseCases
   - CalculateWeeklyGoalUseCase
   - ValidateDosagePlanUseCase
   - GenerateDoseSchedulesUseCase
   - CheckOnboardingStatusUseCase
4. Repository Interfaces 정의

**Commit Point 1**: Domain Layer 완료 (모든 Unit Test 통과)

#### Phase 2: Infrastructure Layer (Integration Tests)
1. DTOs
   - UserDto
   - UserProfileDto
   - DosagePlanDto
   - WeightLogDto
   - DoseScheduleDto
2. Repositories
   - IsarUserRepository
   - IsarProfileRepository
   - IsarMedicationRepository
   - IsarTrackingRepository
   - IsarScheduleRepository
3. Services
   - TransactionService

**Commit Point 2**: Infrastructure Layer 완료 (Integration Test 통과)

#### Phase 3: Application Layer (Integration Tests with Mock)
1. OnboardingStatusNotifier
2. OnboardingNotifier (TransactionService 통합)
3. Providers

**Commit Point 3**: Application Layer 완료 (Mock 기반 Test 통과)

#### Phase 4: Presentation Layer (Acceptance Tests)
1. BasicProfileForm → WeightGoalForm → DosagePlanForm → SummaryScreen
2. OnboardingScreen (통합)

**Commit Point 4**: Presentation Layer 완료 (Widget Test 통과)

#### Phase 5: End-to-End Integration
1. 전체 온보딩 플로우
   - Given: 신규 사용자가 소셜 로그인 완료
   - When: 온보딩 4단계 모두 입력 후 확인
   - Then: Isar에 User, UserProfile, DosagePlan, WeightLog, DoseSchedule 저장됨
2. 저장 실패 및 재시도
   - When: Isar 저장 실패 시뮬레이션
   - Then: 에러 메시지 표시 → 재시도 성공
3. 온보딩 상태 확인
   - Given: 온보딩 완료된 사용자
   - When: 앱 재실행
   - Then: 홈 대시보드로 바로 이동
4. QA Sheet 수동 테스트

**Final Commit**: UF-F000 완료 (모든 테스트 통과)

### Refactoring Checkpoints
- Phase 1 완료 후: Value Object 공통 패턴 추출, Entity 중복 제거
- Phase 2 완료 후: DTO 변환 로직 통합, Repository 중복 제거
- Phase 3 완료 후: Notifier 상태 전환 로직 분리
- Phase 4 완료 후: Form 위젯 공통 컴포넌트 추출

---

## 5. 핵심 원칙

### Test First
- 코드보다 테스트를 먼저 작성
- 실패하는 테스트 확인 후 구현

### Small Steps
- 한 번에 하나의 시나리오만 구현
- 각 테스트는 독립적으로 실행 가능

### FIRST
- Fast: 모든 Unit Test는 1ms 이내
- Independent: 테스트 간 의존성 없음
- Repeatable: 항상 동일한 결과
- Self-validating: Pass/Fail 명확
- Timely: 구현 직전에 작성

### Test Pyramid
- Unit: 70% (Domain, Infrastructure, Application)
- Integration: 20% (Repository ↔ Application)
- Acceptance: 10% (Presentation 시나리오)

### Architecture
- Repository Pattern 엄격히 준수
- Domain은 Infrastructure 의존 금지
- Application은 Repository Interface만 의존
- Presentation은 Application만 의존
- 검증 로직은 Value Object를 통해 Domain Layer에 캡슐화
- 트랜잭션은 TransactionService를 통해 Infrastructure Layer에서 관리

---

## 6. Edge Cases Summary

### 데이터 검증 (Value Objects로 구현)
- 체중 범위: 20kg ~ 300kg (Weight Value Object)
- 약물명: 비어있지 않음 (MedicationName Value Object)
- 시작일: 30일 이상 과거 시 에러, 7-29일 과거 시 경고 (StartDate Value Object)
- 주간 감량 목표: 1kg 초과 시 경고 (CalculateWeeklyGoalUseCase)
- 증량 계획: 순서, 중복, 용량 감소 검증 (ValidateDosagePlanUseCase)

### 트랜잭션 (TransactionService로 구현)
- 모든 온보딩 데이터는 원자적 저장
  1. User 이름 업데이트
  2. UserProfile 저장
  3. DosagePlan 저장
  4. 초기 WeightLog 저장
  5. DoseSchedule 생성 및 저장
- 일부 실패 시 전체 롤백
- 재시도 로직 제공 (OnboardingNotifier.retrySave())

### 온보딩 상태 관리
- 온보딩 완료 여부 확인: CheckOnboardingStatusUseCase
- 완료 시 홈 대시보드로 이동
- 미완료 시 온보딩 화면 표시
- 온보딩 중 앱 종료 시 데이터 폐기, 다음 실행 시 재시작

### 저장 오류 처리
- 저장 실패 시 명확한 에러 메시지 (SummaryScreen)
- 재시도 버튼 제공 (SummaryScreen)
- 재시도 시 전체 트랜잭션 재실행
</file>

<file path="002/spec.md">
# UF-F000: 온보딩 및 목표 설정 - 상세 유스케이스

## Primary Actor
소셜 로그인(F-001)을 완료하고 치료 프로필 및 목표를 설정해야 하는 신규 사용자

## Precondition
- 사용자가 소셜 로그인을 성공적으로 완료함
- 사용자가 이용약관 및 개인정보처리방침에 동의함
- 사용자가 앱을 처음 실행함(온보딩 미완료 상태)

## Trigger
사용자가 최초 소셜 로그인 인증을 완료하면 자동으로 온보딩 화면으로 이동

## Main Scenario

### 단계 1: 기본 프로필 설정
1. 시스템이 진행 표시기와 함께 온보딩 환영 화면을 표시
2. 사용자가 이름 입력 필드에 이름 입력
3. 시스템이 이름이 비어있지 않은지 검증
4. 사용자가 다음 단계로 진행

### 단계 2: 체중 및 목표 입력
1. 시스템이 체중 및 목표 입력 화면 표시
2. 사용자가 현재 체중(kg) 입력
3. 사용자가 목표 체중(kg) 입력
4. 사용자가 목표 기간(주 단위) 입력(선택 사항)
5. 시스템이 다음 항목 검증:
   - 현재 체중이 양수이며 현실적인 범위(20-300kg) 내에 있는지
   - 목표 체중이 양수이며 현실적인 범위(20-300kg) 내에 있는지
   - 목표 체중이 현재 체중보다 작은지
   - 목표 기간이 입력된 경우 양수인지
6. 목표 기간이 입력된 경우, 시스템이 주간 감량 목표 자동 계산:
   - 계산식: (현재 체중 - 목표 체중) / 목표 기간
7. 시스템이 계산된 주간 감량 목표 표시
8. 주간 감량 목표가 안전 기준(주당 1kg)을 초과하는 경우, 시스템이 경고 메시지 표시하되 진행 허용
9. 사용자가 다음 단계로 진행

### 단계 3: 투여 계획 설정
1. 시스템이 투여 계획 입력 화면 표시
2. 사용자가 약물명 입력
3. 사용자가 캘린더 피커를 통해 시작일 선택
4. 사용자가 투여 주기(일 단위) 입력
5. 사용자가 초기 용량(mg) 입력
6. 사용자가 증량 계획 입력:
   - 각 증량 단계마다 다음 항목 지정:
     - 목표 용량(mg)
     - 시작 시점(시작일로부터 주 단위)
7. 시스템이 다음 항목 검증:
   - 약물명이 비어있지 않은지
   - 시작일이 현재 또는 미래 날짜인지
   - 투여 주기가 양의 정수인지
   - 초기 용량이 양수인지
   - 증량 계획이 논리적 순서를 따르는지(용량 증가, 기간 순차적)
8. 사용자가 최종 단계로 진행

### 단계 4: 확인 및 완료
1. 시스템이 입력된 정보 요약 표시:
   - 이름
   - 현재 체중 및 목표 체중
   - 주간 감량 목표(해당하는 경우)
   - 투여 계획 세부 정보
2. 사용자가 정보를 검토하고 확인
3. 시스템이 Repository 패턴을 통해 모든 데이터 저장:
   - 사용자 프로필(이름, 생성일시)
   - 사용자 목표(목표 체중, 목표 기간, 주간 감량 목표)
   - 투여 계획(약물명, 시작일, 주기, 초기 용량, 증량 계획)
   - 현재 체중과 오늘 날짜로 초기 체중 기록 생성
4. 시스템이 투여 스케줄 생성 트리거(F001 연동)
5. 시스템이 완료 메시지 표시
6. 시스템이 홈 대시보드(F006)로 이동

## Edge Cases

### 입력 오류
- **이름이 비어있는 경우**: 에러 메시지 표시, 진행 차단
- **목표 체중이 현재 체중보다 큰 경우**: 에러 메시지 표시, 진행 차단
- **비현실적인 체중 값(<20kg 또는 >300kg)**: 확인 다이얼로그 표시
- **과도한 주간 감량 목표(주당 1kg 초과)**: 경고 메시지 표시, 확인 후 진행 허용

### 날짜 및 기간 문제
- **시작일이 과거인 경우**: 현재 날짜로 조정 제안, 사용자가 재정의 가능
- **목표 기간 미입력**: 주간 감량 목표 계산 건너뛰기, 진행 허용

### 증량 계획 문제
- **용량이 감소하는 경우**: 에러 메시지 표시, 진행 차단
- **중복 시기**: 에러 메시지 표시, 수정 요청
- **증량 계획 미입력**: 초기 용량만으로 진행 허용

### 세션 중단
- **온보딩 중 앱 종료**: 데이터가 저장되지 않음, 다음 실행 시 온보딩 재시작
- **저장 중 네트워크 오류**: 에러 메시지 표시, 재시도 허용

### 데이터 저장
- **저장 작업 실패**: 에러 메시지 표시, 재시도 또는 취소 허용
- **일부 데이터만 저장**: 트랜잭션을 구현하여 전체 저장 또는 저장 없음을 보장

## Business Rules

### BR-1: 체중 검증
- 현재 체중과 목표 체중은 20-300kg 범위 내여야 함
- 목표 체중은 현재 체중보다 작아야 함
- 주간 감량 목표가 1kg/주를 초과하는 경우 경고하되 진행 허용

### BR-2: 투여 계획 요구사항
- 약물명은 필수
- 시작일은 과거 7일 이내여야 함
- 투여 주기는 양의 정수여야 함(GLP-1의 경우 일반적으로 7일)
- 초기 용량은 양수여야 함
- 증량 계획은 점진적 용량 증가를 보여야 함

### BR-3: 데이터 무결성
- 모든 온보딩 데이터는 원자적으로 저장되어야 함(전체 저장 또는 저장 없음)
- 현재 체중으로 초기 체중 기록이 자동 생성됨
- 온보딩 완료 후 투여 스케줄이 자동 생성됨

### BR-4: 목표 계산
- 주간 감량 목표는 목표 기간이 입력된 경우에만 계산됨
- 계산식: (현재 체중 - 목표 체중) / 목표 기간
- 주간 목표는 저장되지만 설정에서 수정 가능

### BR-5: 사용자 경험
- 최초 로그인 후 모든 신규 사용자에게 온보딩 필수
- 온보딩은 한 번만 완료 가능
- 모든 온보딩 데이터는 설정(F000)을 통해 수정 가능
- 진행 표시기가 온보딩 흐름에서 사용자의 위치를 표시

### BR-6: 주간 기록 목표
- 기본 주간 체중 기록 목표: 주당 7회
- 기본 주간 증상 기록 목표: 주당 7회
- 이러한 기본값은 온보딩 중 적용되지만 설정(UF-013)에서 조정 가능

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE
participant BE
participant Database

User -> FE: 소셜 로그인 완료(F-001)
FE -> BE: 온보딩 상태 확인
BE -> Database: user_profiles 조회
Database --> BE: 프로필 없음
BE --> FE: 온보딩 화면으로 리디렉션

FE -> User: 환영 화면 표시

User -> FE: 이름 입력
FE -> FE: 이름이 비어있지 않은지 검증
FE -> User: 다음 버튼 활성화

User -> FE: 다음 클릭
FE -> User: 체중 및 목표 화면 표시

User -> FE: 현재 체중 입력
User -> FE: 목표 체중 입력
User -> FE: 목표 기간 입력(선택)
FE -> BE: 체중 입력 검증
BE --> FE: 검증 결과
FE -> BE: 주간 감량 목표 계산(기간 입력 시)
BE --> FE: 주간 감량 목표
FE -> User: 계산된 목표 표시
alt 주간 감량 목표 > 1kg/주
    FE -> User: 안전 경고 표시
end
FE -> User: 다음 버튼 활성화

User -> FE: 다음 클릭
FE -> User: 투여 계획 화면 표시

User -> FE: 약물명 입력
User -> FE: 시작일 선택
User -> FE: 투여 주기 입력
User -> FE: 초기 용량 입력
User -> FE: 증량 계획 입력
FE -> BE: 투여 계획 검증
BE --> FE: 검증 결과
alt 시작일이 과거인 경우
    FE -> User: 현재 날짜 조정 제안
end
FE -> User: 다음 버튼 활성화

User -> FE: 다음 클릭
FE -> User: 요약 화면 표시

User -> FE: 정보 확인
FE -> BE: 온보딩 데이터 저장
BE -> Database: 트랜잭션 시작
BE -> Database: users 업데이트(필요 시 이름 갱신)
BE -> Database: user_profiles 삽입
BE -> Database: dosage_plans 삽입
BE -> Database: weight_logs 삽입(초기 기록)
Database --> BE: 저장 성공
BE -> Database: 트랜잭션 커밋
BE -> BE: 투여 스케줄 생성 트리거
BE -> Database: dose_schedules 삽입
Database --> BE: 스케줄 생성 완료
BE --> FE: 온보딩 완료

FE -> User: 성공 메시지 표시
FE -> User: 홈 대시보드(F006)로 이동

alt 저장 실패
    Database --> BE: 에러
    BE -> Database: 트랜잭션 롤백
    BE --> FE: 에러 메시지
    FE -> User: 에러 표시, 재시도 제안
end
@enduml
```
</file>

<file path="003/plan.md">
# Medication Schedule Management Implementation Plan

## 1. 개요

투여 스케줄 자동 생성 및 관리 기능의 TDD 기반 모듈화 설계

### 모듈 목록
- **DosagePlan Entity**: 투여 계획 비즈니스 모델
- **DoseSchedule Entity**: 개별 투여 스케줄 비즈니스 모델
- **DoseRecord Entity**: 투여 완료 기록 비즈니스 모델
- **ScheduleGeneratorUseCase**: 스케줄 자동 생성 로직
- **InjectionSiteRotationUseCase**: 주사 부위 순환 검증 로직
- **MissedDoseAnalyzerUseCase**: 누락 용량 분석 로직
- **DoseNotificationUseCase**: 투여 알림 스케줄링 로직
- **MedicationRepository Interface**: 데이터 접근 추상화
- **IsarMedicationRepository**: Isar 기반 저장소 구현
- **NotificationService**: 플랫폼별 푸시 알림 구현
- **MedicationNotifier**: 상태 관리 및 UseCase 조율
- **MedicationScreen**: 스케줄 조회 및 투여 기록 UI
- **DoseRecordDialog**: 투여 완료 기록 입력 UI
- **PlanHistoryDialog**: 증량 계획 변경 이력 조회 UI

### TDD 적용 범위
- **Domain Layer**: 100% (모든 Entity, UseCase)
- **Infrastructure Layer**: 80% (Repository 구현체, DTO)
- **Application Layer**: 60% (Notifier 핵심 로직)
- **Presentation Layer**: QA Sheet (수동 테스트)

---

## 2. Architecture Diagram

```mermaid
graph TB
    subgraph Presentation Layer
        MS[MedicationScreen]
        DRD[DoseRecordDialog]
        DPD[DosagePlanDialog]
    end

    subgraph Application Layer
        MN[MedicationNotifier]
    end

    subgraph Domain Layer
        DP[DosagePlan Entity]
        DS[DoseSchedule Entity]
        DR[DoseRecord Entity]
        SGU[ScheduleGeneratorUseCase]
        ISRU[InjectionSiteRotationUseCase]
        MDAU[MissedDoseAnalyzerUseCase]
        DNU[DoseNotificationUseCase]
        MRI[MedicationRepository Interface]
    end

    subgraph Infrastructure Layer
        IMR[IsarMedicationRepository]
        NS[NotificationService]
        DPDto[DosagePlanDto]
        DSDto[DoseScheduleDto]
        DRDto[DoseRecordDto]
        Isar[(Isar DB)]
    end

    MS --> MN
    DRD --> MN
    DPD --> MN

    MN --> SGU
    MN --> ISRU
    MN --> MDAU
    MN --> DNU
    MN --> MRI

    SGU --> DP
    SGU --> DS
    ISRU --> DR
    MDAU --> DS
    MDAU --> DR
    DNU --> DS
    DNU --> NS

    MRI -.implements.-> IMR
    IMR --> DPDto
    IMR --> DSDto
    IMR --> DRDto
    IMR --> Isar

    DPDto -.toEntity.-> DP
    DSDto -.toEntity.-> DS
    DRDto -.toEntity.-> DR
```

---

## 3. Implementation Plan

### 3.1. DosagePlan Entity

**Location**: `lib/features/tracking/domain/entities/dosage_plan.dart`

**Responsibility**: 투여 계획 비즈니스 규칙 및 데이터 캡슐화

**Test Strategy**: Unit Test

**Test Scenarios**:
```dart
// Red Phase Tests
test('should create valid dosage plan with required fields')
test('should throw exception when start date is in future')
test('should throw exception when cycle days is less than 1')
test('should throw exception when initial dose is negative')
test('should validate escalation plan is monotonically increasing')
test('should throw exception when escalation plan has decreasing doses')
test('should throw exception when escalation exceeds max dose (2.4mg for Ozempic)')
test('should validate escalation time order is maintained')
test('should calculate current dose based on elapsed weeks')
test('should return initial dose when no escalation plan exists')
test('should return correct dose during escalation period')
test('should return max dose after escalation completes')
test('should detect if plan is active')
test('should copy plan with updated fields')
```

**Implementation Order**:
1. 기본 생성자 및 필수 필드 검증
2. 증량 계획 검증 로직:
   - `validateEscalationPlan()` 메서드 구현
   - 단조 증가 검증
   - 시간 순서 검증
   - 최대 용량 범위 검증 (MAX_DOSE = 2.4mg 상수 정의)
3. 현재 용량 계산 메서드
4. copyWith 메서드

**Dependencies**:
- `EscalationStep` value object

**Business Rules**:
- BR-004: 증량은 단조 증가만 허용 (감량 불가)
- 증량 시점은 시간 순서 유지 필수
- 증량 단계는 최대 용량 범위 내 제한 (Ozempic: 2.4mg)

**Edge Cases**:
- 시작일이 미래인 경우
- 증량 계획이 역순인 경우
- 주기가 0 이하인 경우
- 음수 용량
- 최대 용량 초과

---

### 3.2. DoseSchedule Entity

**Location**: `lib/features/tracking/domain/entities/dose_schedule.dart`

**Responsibility**: 개별 스케줄 항목 표현

**Test Strategy**: Unit Test

**Test Scenarios**:
```dart
// Red Phase Tests
test('should create dose schedule with valid data')
test('should compare schedules by date')
test('should detect if schedule is overdue')
test('should detect if schedule is today')
test('should detect if schedule is upcoming')
test('should calculate days until scheduled date')
test('should copy schedule with updated fields')
```

**Implementation Order**:
1. 기본 생성자 및 필드
2. 날짜 비교 메서드 (Comparable 구현)
3. 상태 검증 메서드 (overdue, today, upcoming)
4. copyWith 메서드

**Dependencies**: 없음

---

### 3.3. DoseRecord Entity

**Location**: `lib/features/tracking/domain/entities/dose_record.dart`

**Responsibility**: 투여 완료 기록 및 검증

**Test Strategy**: Unit Test

**Test Scenarios**:
```dart
// Red Phase Tests
test('should create dose record with required fields')
test('should throw exception when administered date is in future')
test('should throw exception when actual dose is negative')
test('should validate injection site is valid')
test('should throw exception for invalid injection site')
test('should throw exception when recording duplicate dose for same date')
test('should detect if record is completed')
test('should calculate days since administration')
test('should copy record with updated fields')
```

**Implementation Order**:
1. 기본 생성자 및 필수 필드 검증
2. 주사 부위 enum 정의 (abdomen, thigh, arm)
3. 날짜 검증 (미래 날짜 불가)
4. 중복 투여 검증 (same planId + scheduledDate)
5. copyWith 메서드

**Dependencies**:
- `InjectionSite` enum

**Business Rules**:
- BR-005: 각 투여일은 1회만 완료 기록 허용

**Edge Cases**:
- 투여일이 미래인 경우
- 잘못된 주사 부위 문자열
- 음수 용량
- 같은 날 중복 투여 기록 시도

---

### 3.4. ScheduleGeneratorUseCase

**Location**: `lib/features/tracking/domain/usecases/schedule_generator_usecase.dart`

**Responsibility**: 투여 계획 기반 전체 스케줄 자동 생성

**Test Strategy**: Unit Test

**Test Scenarios**:
```dart
// Red Phase Tests
test('should generate schedule for simple plan without escalation')
  // Arrange: plan with 7-day cycle, 0.25mg, no escalation
  // Act: generateSchedules(plan, endDate)
  // Assert: schedules every 7 days with 0.25mg

test('should generate schedule with escalation plan')
  // Arrange: plan with escalation [4 weeks: 0.5mg, 8 weeks: 1.0mg]
  // Act: generateSchedules(plan, 12 weeks)
  // Assert:
  //   - Weeks 1-4: 0.25mg
  //   - Weeks 5-8: 0.5mg
  //   - Weeks 9-12: 1.0mg

test('should complete generation within 1 second for 6 months')
  // Arrange: plan with complex escalation
  // Act: time = measureTime { generateSchedules(plan, 6 months) }
  // Assert: time < 1000ms

test('should recalculate schedules from specific date')
  // Arrange: existing schedules, plan changed at week 5
  // Act: recalculateFrom(plan, changeDate, endDate)
  // Assert: schedules before changeDate unchanged, after recalculated

test('should handle edge case when change date matches schedule date')
test('should generate empty list when end date before start date')
test('should apply notification time to all schedules')
```

**Implementation Order**:
1. 단순 반복 스케줄 생성 (증량 없음)
2. 증량 계획 적용 로직
3. 재계산 로직 (변경 시점 이후만)
4. 성능 최적화 (1초 이내)

**Dependencies**:
- `DosagePlan`
- `DoseSchedule`

**Performance Requirement**: 6개월 스케줄 생성 < 1초

---

### 3.5. InjectionSiteRotationUseCase

**Location**: `lib/features/tracking/domain/usecases/injection_site_rotation_usecase.dart`

**Responsibility**: 주사 부위 순환 규칙 검증 및 경고

**Test Strategy**: Unit Test

**Test Scenarios**:
```dart
// Red Phase Tests
test('should return no warning when no recent records')
  // Arrange: newSite = abdomen, recentRecords = []
  // Act: result = checkRotation(newSite, recentRecords)
  // Assert: result.needsWarning == false

test('should return warning when same site used within 7 days')
  // Arrange: newSite = abdomen, recentRecords = [abdomen 3 days ago]
  // Act: result = checkRotation(newSite, recentRecords)
  // Assert:
  //   - result.needsWarning == true
  //   - result.message contains "3일"

test('should return no warning when same site used 8 days ago')
  // Arrange: newSite = abdomen, recentRecords = [abdomen 8 days ago]
  // Act: result = checkRotation(newSite, recentRecords)
  // Assert: result.needsWarning == false

test('should return no warning when different site used recently')
  // Arrange: newSite = thigh, recentRecords = [abdomen 2 days ago]
  // Act: result = checkRotation(newSite, recentRecords)
  // Assert: result.needsWarning == false

test('should handle multiple recent records of same site')
  // Arrange: newSite = arm, recentRecords = [arm 2d ago, arm 5d ago]
  // Act: result = checkRotation(newSite, recentRecords)
  // Assert: result.message mentions most recent (2d ago)

test('should visualize site usage for last 30 days')
  // Arrange: records with various sites over 30 days
  // Act: siteHistory = getSiteHistory(allRecords)
  // Assert: siteHistory grouped by site, sorted by date
```

**Implementation Order**:
1. 기본 7일 간격 검증
2. 경고 메시지 생성 로직
3. 부위별 사용 이력 시각화 데이터 생성

**Dependencies**:
- `DoseRecord`
- `InjectionSite`

**Business Rules**:
- 같은 부위 최소 7일 간격 권장
- 경고 표시하되 진행 허용
- 최근 30일 이력 시각화

---

### 3.6. MissedDoseAnalyzerUseCase

**Location**: `lib/features/tracking/domain/usecases/missed_dose_analyzer_usecase.dart`

**Responsibility**: 누락 용량 분석 및 안내 생성

**Test Strategy**: Unit Test

**Test Scenarios**:
```dart
// Red Phase Tests
test('should return no missed doses when all completed')
  // Arrange: schedules all have matching records
  // Act: result = analyzeMissedDoses(schedules, records)
  // Assert: result.missedDoses.isEmpty

test('should detect missed dose within 5 days')
  // Arrange: schedule 3 days ago, no record
  // Act: result = analyzeMissedDoses(schedules, records)
  // Assert:
  //   - result.missedDoses.length == 1
  //   - result.guidanceType == GuidanceType.immediateAdministration

test('should detect missed dose over 5 days')
  // Arrange: schedule 7 days ago, no record
  // Act: result = analyzeMissedDoses(schedules, records)
  // Assert:
  //   - result.missedDoses.length == 1
  //   - result.guidanceType == GuidanceType.waitForNext

test('should recommend expert consultation for 7+ days missed')
  // Arrange: schedule 10 days ago, no record
  // Act: result = analyzeMissedDoses(schedules, records)
  // Assert: result.requiresExpertConsultation == true

test('should handle multiple missed doses')
  // Arrange: 3 schedules missed (2d, 6d, 11d ago)
  // Act: result = analyzeMissedDoses(schedules, records)
  // Assert: result.missedDoses.length == 3, sorted by date

test('should calculate days elapsed for each missed dose')
```

**Implementation Order**:
1. 누락 감지 로직 (스케줄-기록 매칭)
2. 일수 계산 및 분류 (5일 기준)
3. 안내 메시지 생성 로직

**Dependencies**:
- `DoseSchedule`
- `DoseRecord`

**Business Rules**:
- 5일 이내: 즉시 투여 안내
- 5일 초과: 다음 예정일 대기
- 7일 이상: 전문가 상담 권장

---

### 3.7. DoseNotificationUseCase

**Location**: `lib/features/tracking/domain/usecases/dose_notification_usecase.dart`

**Responsibility**: 투여 알림 스케줄링 및 페이로드 생성

**Test Strategy**: Unit Test

**Test Scenarios**:
```dart
// Red Phase Tests
test('should schedule notification for dose schedule')
  // Arrange: schedule with notificationTime
  // Act: result = scheduleNotification(schedule)
  // Assert: notification scheduled with correct time and payload

test('should include dose amount in notification message')
  // Arrange: schedule with 0.5mg
  // Act: payload = createNotificationPayload(schedule)
  // Assert: payload.message contains "0.5mg"

test('should create deep link to dose scheduler screen')
  // Arrange: schedule with id
  // Act: payload = createNotificationPayload(schedule)
  // Assert: payload.deepLink == "/medication/schedule/{id}"

test('should cancel notification when schedule deleted')
  // Arrange: existing notification
  // Act: cancelNotification(scheduleId)
  // Assert: notification removed from system

test('should reschedule notification when schedule updated')
  // Arrange: existing schedule with notification
  // Act: rescheduleNotification(updatedSchedule)
  // Assert: old notification cancelled, new one scheduled

test('should not schedule notification for past schedules')
  // Arrange: schedule date in past
  // Act: result = scheduleNotification(schedule)
  // Assert: result.skipped == true
```

**Implementation Order**:
1. 알림 페이로드 생성 로직
2. 스케줄링 인터페이스 정의
3. 취소 로직
4. 재스케줄링 로직

**Dependencies**:
- `DoseSchedule`
- `NotificationService` (Infrastructure Layer)

**Business Rules**:
- 투여 예정일 당일 지정 시간에 알림 발송
- 알림 메시지에 예정 용량 정보 포함
- 알림 클릭 시 투여 스케줄러 화면 이동

---

### 3.8. NotificationService

**Location**: `lib/features/tracking/infrastructure/services/notification_service.dart`

**Responsibility**: 플랫폼별 푸시 알림 구현

**Test Strategy**: Integration Test (플랫폼 의존)

**Test Scenarios**:
```dart
// Integration Tests
test('should request notification permission')
test('should schedule local notification at specific time')
test('should cancel scheduled notification by id')
test('should handle notification click and return deep link')
test('should persist notifications across app restarts')
```

**Implementation Order**:
1. 권한 요청 로직
2. 로컬 알림 스케줄링 (flutter_local_notifications)
3. 알림 취소 로직
4. 딥링크 핸들링

**Dependencies**:
- `flutter_local_notifications` package

**Platform Support**:
- iOS: UNUserNotificationCenter
- Android: NotificationManager

---

### 3.9. MedicationRepository Interface

**Location**: `lib/features/tracking/domain/repositories/medication_repository.dart`

**Responsibility**: 투여 데이터 접근 추상화

**Test Strategy**: Integration Test (구현체 테스트)

**Test Scenarios**: N/A (인터페이스)

**Implementation Order**:
```dart
abstract class MedicationRepository {
  // DosagePlan
  Future<DosagePlan?> getActiveDosagePlan(String userId);
  Future<void> saveDosagePlan(DosagePlan plan);
  Future<void> updateDosagePlan(DosagePlan plan);

  // DoseSchedule
  Future<List<DoseSchedule>> getDoseSchedules(String planId);
  Future<void> saveDoseSchedules(List<DoseSchedule> schedules);
  Future<void> deleteDoseSchedulesFrom(String planId, DateTime fromDate);

  // DoseRecord
  Future<List<DoseRecord>> getDoseRecords(String planId);
  Future<List<DoseRecord>> getRecentDoseRecords(String planId, int days);
  Future<void> saveDoseRecord(DoseRecord record);
  Future<void> deleteDoseRecord(String recordId);
  Future<bool> isDuplicateDoseRecord(String planId, DateTime scheduledDate);

  // Plan Change History
  Future<void> savePlanChangeHistory(String planId, Map<String, dynamic> oldPlan, Map<String, dynamic> newPlan);
  Future<List<PlanChangeHistory>> getPlanChangeHistory(String planId);

  // Streams (real-time)
  Stream<List<DoseRecord>> watchDoseRecords(String planId);
  Stream<DosagePlan?> watchActiveDosagePlan(String userId);
}
```

**Dependencies**: Domain entities

---

### 3.10. IsarMedicationRepository

**Location**: `lib/features/tracking/infrastructure/repositories/isar_medication_repository.dart`

**Responsibility**: Isar 기반 데이터 저장 및 조회

**Test Strategy**: Integration Test

**Test Scenarios**:
```dart
// Red Phase Tests
test('should save and retrieve dosage plan')
  // Arrange: plan entity
  // Act: await repo.saveDosagePlan(plan)
  //      result = await repo.getActiveDosagePlan(userId)
  // Assert: result == plan

test('should return null when no active plan exists')
test('should update existing dosage plan')
test('should save batch dose schedules efficiently')
  // Arrange: 100 schedules
  // Act: time = measureTime { await repo.saveDoseSchedules(schedules) }
  // Assert: time < 500ms

test('should delete schedules from specific date')
  // Arrange: 20 schedules, delete from date at index 10
  // Act: await repo.deleteDoseSchedulesFrom(planId, date)
  // Assert: only first 10 remain

test('should get recent dose records within N days')
  // Arrange: records from 30 days ago to today
  // Act: recent = await repo.getRecentDoseRecords(planId, 7)
  // Assert: recent.length matches last 7 days only

test('should watch dose records stream updates')
  // Arrange: subscription to stream
  // Act: save new record
  // Assert: stream emits updated list

test('should save plan change history')
test('should retrieve plan change history ordered by date')
  // Arrange: multiple history entries
  // Act: history = await repo.getPlanChangeHistory(planId)
  // Assert: history ordered by date DESC

test('should detect duplicate dose record')
  // Arrange: existing record for planId + date
  // Act: isDup = await repo.isDuplicateDoseRecord(planId, date)
  // Assert: isDup == true

test('should return false for non-duplicate dose record')
  // Arrange: no existing record for planId + date
  // Act: isDup = await repo.isDuplicateDoseRecord(planId, date)
  // Assert: isDup == false

test('should convert DTO to Entity correctly')
test('should convert Entity to DTO correctly')
```

**Implementation Order**:
1. DTO 정의 (DosagePlanDto, DoseScheduleDto, DoseRecordDto, PlanChangeHistoryDto)
2. 기본 CRUD 구현
3. 중복 방지 로직 (Unique Index: planId + scheduledDate)
4. 이력 조회 구현
5. 배치 저장 최적화
6. Stream 구현
7. toEntity/fromEntity 변환

**Dependencies**:
- `Isar`
- DTO classes
- Domain entities
- `MedicationRepository` interface

**Performance Requirements**:
- 배치 저장 (100개) < 500ms
- 조회 쿼리 < 100ms

---

### 3.11. DTOs

**Location**: `lib/features/tracking/infrastructure/dtos/`

**Files**:
- `dosage_plan_dto.dart`
- `dose_schedule_dto.dart`
- `dose_record_dto.dart`
- `plan_change_history_dto.dart`

**Test Strategy**: Unit Test

**Test Scenarios**:
```dart
// DosagePlanDto
test('should convert entity to DTO preserving all fields')
test('should convert DTO to entity preserving all fields')
test('should serialize escalation plan to JSON')
test('should deserialize escalation plan from JSON')

// DoseScheduleDto
test('should convert entity to DTO')
test('should convert DTO to entity')
test('should handle null notification time')

// DoseRecordDto
test('should convert entity to DTO')
test('should convert DTO to entity')
test('should handle optional fields (site, note)')
test('should enforce unique index on planId + scheduledDate')

// PlanChangeHistoryDto
test('should convert history to DTO')
test('should convert DTO to history entity')
test('should serialize old/new plan data to JSON')
```

**Implementation Order**:
1. Isar annotations 정의
2. Unique Index 설정 (DoseRecordDto: planId + scheduledDate)
3. fromEntity 메서드
4. toEntity 메서드
5. JSON 직렬화 (escalation_plan, plan change history)

---

### 3.12. MedicationNotifier

**Location**: `lib/features/tracking/application/notifiers/medication_notifier.dart`

**Responsibility**: 상태 관리 및 UseCase 조율

**Test Strategy**: Unit Test (mocked repository)

**Test Scenarios**:
```dart
// Red Phase Tests
test('should load medication state on build')
  // Arrange: mock repo returns plan, schedules, records
  // Act: state = await notifier.build()
  // Assert: state contains plan, schedules, records

test('should record dose and update state')
  // Arrange: initial state with schedules
  // Act: await notifier.recordDose(record)
  // Assert:
  //   - repo.isDuplicateDoseRecord checked
  //   - repo.saveDoseRecord called
  //   - state updated with new record

test('should throw exception when recording duplicate dose')
  // Arrange: existing record for same date
  // Act & Assert: expect(() => notifier.recordDose(record), throwsException)

test('should check injection site rotation before recording')
  // Arrange: recent record with same site
  // Act: warning = await notifier.checkInjectionSite(newSite)
  // Assert: warning.needsWarning == true

test('should update dosage plan and recalculate schedules')
  // Arrange: existing plan and schedules
  // Act: await notifier.updateDosagePlan(newPlan)
  // Assert:
  //   - ScheduleGeneratorUseCase called
  //   - Old schedules from change date deleted
  //   - New schedules saved
  //   - Change history saved

test('should analyze missed doses')
  // Arrange: schedules with some missed
  // Act: analysis = notifier.getMissedDoseAnalysis()
  // Assert: analysis contains missed doses and guidance

test('should schedule notification when creating dose schedule')
  // Arrange: new schedule
  // Act: await notifier.createDoseSchedule(schedule)
  // Assert:
  //   - DoseNotificationUseCase.scheduleNotification called
  //   - schedule saved to repo

test('should cancel notification when deleting dose schedule')
  // Arrange: existing schedule with notification
  // Act: await notifier.deleteDoseSchedule(scheduleId)
  // Assert: DoseNotificationUseCase.cancelNotification called

test('should get plan change history')
  // Arrange: plan with history
  // Act: history = await notifier.getPlanHistory()
  // Assert: history contains all changes ordered by date

test('should delete dose record and refresh state')
test('should handle errors gracefully')
  // Arrange: repo throws exception
  // Act: await notifier.recordDose(record)
  // Assert: state.hasError == true
```

**Implementation Order**:
1. build 메서드 (초기 로드)
2. recordDose 메서드 (중복 체크 + 부위 검증 포함)
3. updateDosagePlan 메서드 (재계산 로직)
4. getMissedDoseAnalysis computed property
5. scheduleNotification/cancelNotification 메서드
6. getPlanHistory 메서드
7. deleteDoseRecord 메서드

**Dependencies**:
- `MedicationRepository`
- `ScheduleGeneratorUseCase`
- `InjectionSiteRotationUseCase`
- `MissedDoseAnalyzerUseCase`
- `DoseNotificationUseCase`

---

### 3.13. MedicationScreen (Presentation)

**Location**: `lib/features/tracking/presentation/screens/medication_screen.dart`

**Responsibility**: 스케줄 조회 및 투여 기록 UI

**Test Strategy**: Manual QA (QA Sheet)

**QA Sheet**:
```markdown
## 스케줄 조회
- [ ] 앱 실행 시 활성 투여 계획의 스케줄이 로드됨
- [ ] 캘린더 뷰에서 투여 예정일에 마커 표시
- [ ] 리스트 뷰에서 날짜순 정렬된 스케줄 표시
- [ ] 각 스케줄에 예정 용량, 완료 상태 표시
- [ ] 다음 투여 예정일이 강조 표시됨
- [ ] 완료된 투여는 체크 표시
- [ ] 누락된 투여는 경고 색상 표시

## 투여 완료 기록
- [ ] 투여 완료 버튼 클릭 시 부위 선택 화면 표시
- [ ] 복부/허벅지/상완 선택 가능
- [ ] 7일 이내 같은 부위 재사용 시 경고 표시
- [ ] 경고 무시하고 진행 가능
- [ ] 메모 입력 가능 (선택)
- [ ] 저장 시 완료 상태 즉시 UI 업데이트
- [ ] 부위별 투여 이력 시각화 확인 가능

## 스케줄 변경
- [ ] 특정 투여일 수정 가능
- [ ] 용량 수정 가능
- [ ] 변경 시 이후 스케줄 자동 재계산 (1초 이내)
- [ ] 재계산 완료 알림 표시
- [ ] 변경 이력 저장됨

## 누락 관리
- [ ] 5일 이내 누락 시 "즉시 투여" 알림 표시
- [ ] 5일 초과 누락 시 "다음 예정일 대기" 안내
- [ ] 7일 이상 누락 시 전문가 상담 권장 표시

## 투여 알림
- [ ] 투여 예정일 알림이 지정 시간에 발송됨
- [ ] 알림 메시지에 예정 용량 표시
- [ ] 알림 클릭 시 투여 스케줄러 화면 이동
- [ ] 알림 권한 요청 표시

## 계획 변경 이력
- [ ] 계획 변경 이력 조회 가능
- [ ] 이력에 날짜, 변경 전/후 계획 표시
- [ ] 이력은 날짜 역순 정렬

## 성능
- [ ] 스케줄 생성 1초 이내
- [ ] 스케줄 재계산 1초 이내
- [ ] UI 반응 즉시 (로딩 없음)
```

**Implementation Order**:
1. 스케줄 리스트 뷰
2. 캘린더 뷰
3. 투여 완료 다이얼로그 연동
4. 누락 안내 UI
5. 부위별 이력 시각화
6. 계획 변경 이력 다이얼로그 연동
7. 알림 권한 요청 UI

**Dependencies**:
- `MedicationNotifier`

---

### 3.14. DoseRecordDialog (Presentation)

**Location**: `lib/features/tracking/presentation/widgets/dose_record_dialog.dart`

**Responsibility**: 투여 완료 기록 입력 UI

**Test Strategy**: Manual QA (QA Sheet)

**QA Sheet**:
```markdown
## 부위 선택
- [ ] 복부/허벅지/상완 버튼 표시
- [ ] 선택 시 버튼 강조 표시
- [ ] 경고 메시지 표시 영역 존재
- [ ] 경고 무시 가능

## 메모 입력
- [ ] 선택적 메모 입력 필드
- [ ] 100자 제한
- [ ] 멀티라인 지원

## 저장
- [ ] 부위 미선택 시 저장 버튼 비활성화
- [ ] 저장 중 로딩 인디케이터
- [ ] 성공 시 다이얼로그 닫힘
- [ ] 실패 시 에러 메시지 표시
```

**Dependencies**:
- `MedicationNotifier`

---

### 3.15. PlanHistoryDialog (Presentation)

**Location**: `lib/features/tracking/presentation/widgets/plan_history_dialog.dart`

**Responsibility**: 증량 계획 변경 이력 조회 UI

**Test Strategy**: Manual QA (QA Sheet)

**QA Sheet**:
```markdown
## 이력 조회
- [ ] 계획 변경 이력 버튼 클릭 시 다이얼로그 표시
- [ ] 이력이 날짜 역순으로 정렬됨
- [ ] 각 이력에 변경 날짜 표시
- [ ] 각 이력에 변경 전/후 계획 표시 (용량, 주기 등)
- [ ] 이력이 없을 경우 "변경 이력이 없습니다" 메시지 표시
- [ ] 스크롤 가능 (이력이 많을 경우)

## 이력 내용
- [ ] 변경된 필드만 강조 표시
- [ ] 날짜 포맷 일관성 (YYYY-MM-DD HH:mm)
- [ ] 증량 계획 변경 시 전/후 비교 표시
```

**Implementation Order**:
1. 이력 리스트 뷰
2. 변경 전/후 비교 UI
3. 빈 상태 처리

**Dependencies**:
- `MedicationNotifier`

---

## 4. TDD Workflow

### Phase 1: Domain Layer (Week 1)
1. **Day 1-2**: Entities
   - DosagePlan Entity 테스트 작성 → 구현 → 리팩토링
   - DoseSchedule Entity 테스트 작성 → 구현 → 리팩토링
   - DoseRecord Entity 테스트 작성 → 구현 → 리팩토링
   - **Commit**: "feat: add medication domain entities"

2. **Day 3**: ScheduleGeneratorUseCase
   - 단순 반복 테스트 → 구현
   - 증량 계획 테스트 → 구현
   - 성능 테스트 → 최적화
   - **Commit**: "feat: add schedule generator use case"

3. **Day 4**: InjectionSiteRotationUseCase
   - 7일 간격 검증 테스트 → 구현
   - 경고 메시지 테스트 → 구현
   - 이력 시각화 테스트 → 구현
   - **Commit**: "feat: add injection site rotation use case"

4. **Day 5**: MissedDoseAnalyzerUseCase
   - 누락 감지 테스트 → 구현
   - 안내 타입 분류 테스트 → 구현
   - 전문가 상담 조건 테스트 → 구현
   - **Commit**: "feat: add missed dose analyzer use case"

5. **Day 6**: DoseNotificationUseCase
   - 알림 페이로드 생성 테스트 → 구현
   - 스케줄링 로직 테스트 → 구현
   - 취소/재스케줄 테스트 → 구현
   - **Commit**: "feat: add dose notification use case"

### Phase 2: Infrastructure Layer (Week 2)
1. **Day 1-2**: DTOs
   - DosagePlanDto 테스트 → 구현
   - DoseScheduleDto 테스트 → 구현
   - DoseRecordDto 테스트 → 구현 (Unique Index 포함)
   - PlanChangeHistoryDto 테스트 → 구현
   - **Commit**: "feat: add medication DTOs"

2. **Day 3-4**: Repository 구현
   - IsarMedicationRepository 기본 CRUD 테스트 → 구현
   - 중복 방지 로직 테스트 → 구현
   - 이력 조회 테스트 → 구현
   - 배치 저장 테스트 → 구현
   - Stream 테스트 → 구현
   - **Commit**: "feat: add Isar medication repository"

3. **Day 5**: NotificationService
   - 알림 권한 요청 구현
   - 로컬 알림 스케줄링 구현
   - 딥링크 핸들링 구현
   - **Commit**: "feat: add notification service"

4. **Day 6**: Repository 최적화
   - 성능 테스트 통과
   - 인덱스 최적화
   - **Commit**: "perf: optimize medication repository"

### Phase 3: Application Layer (Week 3)
1. **Day 1-3**: MedicationNotifier
   - 초기 로드 테스트 → 구현
   - recordDose 테스트 → 구현 (중복 체크 포함)
   - updateDosagePlan 테스트 → 구현
   - getMissedDoseAnalysis 테스트 → 구현
   - scheduleNotification/cancelNotification 테스트 → 구현
   - getPlanHistory 테스트 → 구현
   - **Commit**: "feat: add medication notifier"

2. **Day 4-5**: Notifier 리팩토링 및 에러 핸들링
   - 에러 처리 테스트 → 구현
   - 중복 투여 에러 핸들링 테스트 → 구현
   - 상태 일관성 테스트 → 구현
   - **Commit**: "refactor: improve medication notifier error handling"

### Phase 4: Presentation Layer (Week 4)
1. **Day 1-2**: MedicationScreen
   - 스케줄 리스트 뷰 구현
   - 캘린더 뷰 구현
   - 알림 권한 요청 UI 구현
   - **Commit**: "feat: add medication screen"

2. **Day 3**: DoseRecordDialog & PlanHistoryDialog
   - 부위 선택 UI 구현
   - 메모 입력 UI 구현
   - 계획 변경 이력 다이얼로그 구현
   - **Commit**: "feat: add dose record and plan history dialogs"

3. **Day 4**: 통합 및 QA
   - 전체 플로우 수동 테스트
   - 알림 기능 테스트
   - 중복 투여 방지 테스트
   - 이력 조회 테스트
   - QA Sheet 체크리스트 검증
   - 버그 수정

4. **Day 5**: 최종 리팩토링 및 문서화
   - 코드 정리
   - 주석 추가
   - **Commit**: "docs: add medication feature documentation"

---

## 5. Commit Strategy

### Commit 포인트
- 각 Entity 완성 시
- 각 UseCase 완성 시
- 각 DTO 완성 시
- Repository 기능 그룹 완성 시 (CRUD, Stream 등)
- Notifier 메서드 완성 시
- 각 UI 컴포넌트 완성 시

### Commit Message 규칙
```
feat: add [component name]
test: add [test description]
refactor: improve [component name]
perf: optimize [performance aspect]
fix: resolve [bug description]
docs: update [documentation]
```

---

## 6. Performance Targets

| 작업 | 목표 | 측정 방법 |
|------|------|-----------|
| 스케줄 생성 (6개월) | < 1초 | Stopwatch |
| 스케줄 재계산 | < 1초 | Stopwatch |
| 배치 저장 (100개) | < 500ms | Stopwatch |
| 단일 조회 | < 100ms | Stopwatch |
| UI 반응 | < 100ms | Manual |

---

## 7. Test Coverage Goals

- **Domain Layer**: 100%
- **Infrastructure Layer**: 80%
- **Application Layer**: 60%
- **Overall**: 70%

---

## 8. Integration Points

### 온보딩 (F000)
- 온보딩 완료 시 `MedicationNotifier.createInitialPlan()` 호출
- 투여 계획 정보 전달

### 대시보드 (F006)
- 다음 투여 예정일 조회: `MedicationNotifier.getNextScheduledDose()`
- 투여 완료율 조회: `MedicationNotifier.getCompletionRate()`

### 알림 (UF-012)
- 투여 예정일 알림 스케줄링: `DoseSchedule.notificationTime` 기반

---

## 9. Risk Mitigation

### 성능 리스크
- **위험**: 대량 스케줄 생성 시 1초 초과
- **완화**: 알고리즘 최적화, 배치 처리, 성능 테스트 조기 작성

### 데이터 일관성 리스크
- **위험**: 스케줄-기록 불일치
- **완화**: 트랜잭션 처리, 재계산 시 검증 로직

### 사용자 경험 리스크
- **위험**: 부위 순환 경고 무시 시 안전성
- **완화**: 경고 메시지 명확화, 진행 허용하되 로그 기록

---

## 10. Definition of Done

각 모듈 완료 조건:
- [ ] 모든 테스트 통과 (coverage 목표 달성)
- [ ] 코드 리뷰 완료
- [ ] 성능 요구사항 충족
- [ ] 문서 업데이트
- [ ] QA Sheet 검증 (Presentation Layer)
- [ ] 컴파일 경고 없음
- [ ] Layer 의존성 규칙 준수
</file>

<file path="003/spec.md">
# UF-F001: 투여 스케줄 관리

## Use Case Overview

**Primary Actor**: GLP-1 사용자

**Precondition**:
- 사용자가 로그인 완료
- 온보딩에서 투여 계획 정보 입력 완료 (약물명, 시작일, 주기, 초기 용량, 증량 계획)

**Trigger**:
- 온보딩 완료 시 자동 스케줄 생성
- 사용자가 투여 스케줄러 화면 진입
- 투여 예정일 당일 지정 시간 도래
- 사용자가 투여일/용량 수동 변경
- 사용자가 증량 계획 변경

---

## Main Scenario

### 1. 자동 스케줄 생성
1. 사용자가 온보딩에서 투여 계획 정보 입력 완료
2. 시스템이 입력된 계획을 기반으로 전체 투여 스케줄 자동 생성 (1초 이내)
3. 각 투여일에 예정 용량 매핑
4. 증량 계획에 따라 특정 시점부터 용량 자동 증가
5. 생성된 스케줄을 DB에 저장
6. 사용자에게 스케줄 생성 완료 피드백 제공

### 2. 스케줄 조회
1. 사용자가 투여 스케줄러 화면 진입
2. 시스템이 활성 투여 계획의 스케줄 조회
3. 캘린더 뷰 또는 리스트 뷰로 스케줄 렌더링
4. 각 투여일에 예정 용량, 완료 상태, 주사 부위 표시
5. 다음 투여 예정일 강조 표시

### 3. 투여 완료 기록
1. 사용자가 특정 투여일의 "투여 완료" 버튼 클릭
2. 투여 부위 선택 화면 표시 (복부/허벅지/상완)
3. 시스템이 최근 7일 이내 같은 부위 사용 여부 확인
4. 같은 부위 사용 이력 있으면 경고 메시지 표시하되 진행 허용
5. 사용자가 부위 선택 및 메모 입력 (선택 사항)
6. 투여 완료 기록 저장 (투여일시, 실제 용량, 부위, 메모)
7. 완료 상태 UI 업데이트
8. 부위별 투여 이력 시각화 갱신

### 4. 투여 알림
1. 투여 예정일 당일 지정 시간 도래
2. 시스템이 푸시 알림 생성
3. 알림 메시지에 예정 용량 정보 포함
4. 사용자가 알림 클릭 시 투여 스케줄러 화면으로 이동

### 5. 스케줄 수동 변경
1. 사용자가 특정 투여일 또는 용량 수정 요청
2. 수정 가능 항목 표시 (날짜, 용량)
3. 사용자가 새로운 값 입력
4. 시스템이 입력 검증 (날짜 논리, 용량 범위)
5. 변경 지점 이후 모든 스케줄 재계산 (1초 이내)
6. 재계산된 스케줄 DB에 저장
7. 업데이트된 스케줄 UI에 반영

### 6. 증량 계획 변경
1. 사용자가 설정 메뉴에서 투여 계획 수정 선택
2. 현재 증량 계획 표시
3. 사용자가 새로운 증량 계획 입력
4. 시스템이 변경 전/후 계획 비교
5. 영향 범위 확인 메시지 표시
6. 사용자 확인 시 변경 이력 저장
7. 변경 지점 이후 스케줄 재계산
8. 업데이트된 스케줄 반영

### 7. 누락 용량 관리
1. 시스템이 매일 투여 완료 여부 확인
2. 예정일 경과 시 누락 일수 계산
3. 5일 이내 누락 시 "즉시 투여" 알림 생성
4. 5일 초과 누락 시 "다음 예정일까지 대기" 안내 표시
5. 누락 안내와 함께 전문가 상담 권장 메시지 제공

---

## Edge Cases

### 스케줄 생성 관련
- 증량 계획이 비논리적인 경우 (감량, 역순): 에러 메시지 표시 및 수정 유도
- 시작일이 과거인 경우: 현재 날짜로 자동 조정 제안
- 스케줄 생성 중 앱 종료: 다음 실행 시 자동 재생성

### 투여 기록 관련
- 같은 날 중복 투여 기록 시도: 중복 방지 확인 메시지 표시
- 부위 미선택: 선택 유도하되 진행 허용
- 과거 날짜에 투여 미완료 기록 추가: 누락 관리 로직 재실행
- 투여 완료 후 기록 삭제: 삭제 확인 대화상자 및 스케줄 재계산

### 스케줄 변경 관련
- 투여일 변경으로 증량 시점 앞당겨짐: 안전성 경고 표시하되 진행 허용
- 증량 계획 삭제: 현재 용량 유지 스케줄로 재계산
- 스케줄 재계산 중 앱 종료: 다음 실행 시 자동 재계산
- 이미 진행 중인 증량 계획 변경: 영향 범위 명확히 안내

### 알림 관련
- 앱 알림 권한 거부: 설정 변경 유도 또는 인앱 알림 대체
- 여러 투여 예정일이 같은 날: 한 번만 알림 발송
- 알림 시간이 투여 예정일 이후: 다음날 알림 또는 즉시 알림 선택 제공

### 데이터 동기화
- 네트워크 오류로 저장 실패: 로컬 저장 후 재시도 큐 추가
- 여러 기기 동시 변경: 최신 타임스탬프 우선 (Phase 1)

---

## Business Rules

### BR-001: 스케줄 생성 성능
- 전체 스케줄 생성은 1초 이내 완료 필수
- 스케줄 재계산은 1초 이내 완료 필수

### BR-002: 주사 부위 순환
- 같은 부위는 최소 7일 간격 권장
- 7일 미만 재사용 시 경고 표시하되 진행 허용
- 부위별 투여 이력 최근 30일 시각화

### BR-003: 누락 용량 관리
- 예정일로부터 5일 이내 누락: "즉시 투여" 안내
- 예정일로부터 5일 초과 누락: "다음 예정일까지 대기" 안내
- 7일 이상 누락: 전문가 상담 필수 권장

### BR-004: 증량 계획 논리
- 증량은 단조 증가만 허용 (감량 불가)
- 증량 시점은 시간 순서 유지 필수
- 증량 단계는 최대 용량 범위 내 제한

### BR-005: 투여 기록 무결성
- 각 투여일은 1회만 완료 기록 허용
- 완료 기록 삭제 시 확인 절차 필수
- 투여일시는 미래 날짜 불가

### BR-006: 알림 정책
- 투여 예정일 당일 지정 시간 1회 알림
- 알림 시간 기본값: 오전 9시 (사용자 설정 가능)
- 알림 클릭 시 투여 스케줄러 화면으로 직접 이동

### BR-007: 계획 변경 이력
- 모든 증량 계획 변경은 이력 기록 필수
- 변경 이력은 날짜, 변경 전/후 계획 포함
- 변경 이력은 영구 보관

---

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE as "Frontend"
participant BE as "Backend\n(Application Layer)"
participant DB as "Database"

== 자동 스케줄 생성 ==
User -> FE: 온보딩에서 투여 계획 입력 완료
FE -> BE: 투여 계획 저장 요청\n(약물명, 시작일, 주기, 초기 용량, 증량 계획)
BE -> DB: dosage_plans INSERT
DB --> BE: 계획 ID 반환
BE -> BE: 전체 스케줄 계산\n(1초 이내)
BE -> DB: dose_schedules BATCH INSERT
DB --> BE: 성공
BE --> FE: 스케줄 생성 완료
FE --> User: 완료 피드백 표시

== 스케줄 조회 ==
User -> FE: 투여 스케줄러 화면 진입
FE -> BE: 활성 스케줄 조회 요청
BE -> DB: SELECT dose_schedules\nWHERE dosage_plan_id = ? AND is_active = true
DB --> BE: 스케줄 목록 반환
BE -> DB: SELECT dose_records\nWHERE dosage_plan_id = ?
DB --> BE: 투여 기록 목록 반환
BE --> FE: 스케줄 + 기록 데이터
FE --> User: 캘린더/리스트 뷰 표시

== 투여 완료 기록 ==
User -> FE: 투여 완료 버튼 클릭
FE --> User: 부위 선택 화면 표시
User -> FE: 부위 선택 (복부/허벅지/상완)
FE -> BE: 최근 7일 같은 부위 사용 확인
BE -> DB: SELECT dose_records\nWHERE injection_site = ? AND administered_at >= NOW() - INTERVAL '7 days'
DB --> BE: 이력 반환
alt 같은 부위 7일 이내 사용
  BE --> FE: 경고 메시지 데이터
  FE --> User: 경고 표시 (진행 허용)
end
User -> FE: 확인 및 메모 입력
FE -> BE: 투여 완료 기록 저장 요청\n(투여일시, 용량, 부위, 메모)
BE -> DB: dose_records INSERT
DB --> BE: 성공
BE --> FE: 기록 완료
FE --> User: 완료 상태 UI 업데이트

== 투여 알림 ==
DB -> BE: 투여 예정일 당일 지정 시간 도래
BE -> BE: 알림 생성 (예정 용량 포함)
BE -> FE: 푸시 알림 전송
FE --> User: 알림 표시
User -> FE: 알림 클릭
FE --> User: 투여 스케줄러 화면 이동

== 스케줄 수동 변경 ==
User -> FE: 특정 투여일 수정 요청
FE --> User: 수정 폼 표시
User -> FE: 새로운 날짜/용량 입력
FE -> BE: 스케줄 변경 요청
BE -> BE: 입력 검증 (날짜 논리, 용량 범위)
alt 검증 실패
  BE --> FE: 에러 메시지
  FE --> User: 에러 표시 및 수정 유도
else 검증 성공
  BE -> BE: 변경 지점 이후 스케줄 재계산\n(1초 이내)
  BE -> DB: dose_schedules UPDATE (변경 지점 이후)
  DB --> BE: 성공
  BE --> FE: 재계산 완료
  FE --> User: 업데이트된 스케줄 표시
end

== 증량 계획 변경 ==
User -> FE: 설정 > 투여 계획 수정 선택
FE -> BE: 현재 계획 조회
BE -> DB: SELECT dosage_plans WHERE id = ?
DB --> BE: 계획 데이터
BE --> FE: 현재 계획
FE --> User: 수정 폼 표시
User -> FE: 새로운 증량 계획 입력
FE -> BE: 계획 변경 요청
BE -> BE: 변경 전/후 비교 및 영향 범위 분석
BE --> FE: 영향 범위 확인 메시지
FE --> User: 확인 메시지 표시
User -> FE: 변경 확인
FE -> BE: 변경 확정 요청
BE -> DB: plan_change_history INSERT\n(변경 전/후 계획)
DB --> BE: 성공
BE -> DB: dosage_plans UPDATE
DB --> BE: 성공
BE -> BE: 변경 지점 이후 스케줄 재계산
BE -> DB: dose_schedules UPDATE (변경 지점 이후)
DB --> BE: 성공
BE --> FE: 변경 완료
FE --> User: 업데이트된 계획 표시

== 누락 용량 관리 ==
DB -> BE: 매일 정기 체크 트리거
BE -> DB: SELECT dose_schedules\nWHERE scheduled_date < CURRENT_DATE\nAND NOT EXISTS (SELECT 1 FROM dose_records WHERE ...)
DB --> BE: 누락 스케줄 목록
loop 각 누락 스케줄
  BE -> BE: 경과 일수 계산
  alt 5일 이내 누락
    BE -> FE: "즉시 투여" 알림 생성
    FE --> User: 즉시 투여 알림 표시
  else 5일 초과 누락
    BE -> FE: "다음 예정일까지 대기" 안내 생성
    FE --> User: 대기 안내 표시
  end
end
@enduml
```
</file>

<file path="004/plan.md">
# UF-F002: 증상 및 체중 기록 구현 계획 (TDD)

## 1. 개요

### 모듈 목록
- **Domain Layer**
  - `WeightLog` Entity
  - `SymptomLog` Entity
  - `TrackingRepository` Interface
- **Infrastructure Layer**
  - `WeightLogDto` (Isar Collection)
  - `SymptomLogDto` (Isar Collection)
  - `IsarTrackingRepository` (구현체)
- **Application Layer**
  - `TrackingNotifier` (상태 관리)
  - `trackingNotifierProvider`
  - Derived Providers (경과일 계산 등)
- **Presentation Layer**
  - `WeightRecordScreen` (체중 기록 화면)
  - `SymptomRecordScreen` (증상 기록 화면)
  - Input Validation Widgets
  - Date Selection Widget

### TDD 적용 범위
- Unit Test: Domain 로직, Repository 구현
- Integration Test: Application Layer (Notifier + Repository)
- Widget Test: Presentation Layer (UI 로직)
- Acceptance Test: 전체 흐름 (UC-F002-01, 02, 03)

---

## 2. Architecture Diagram

```mermaid
graph TD
    %% Presentation Layer
    WeightScreen[WeightRecordScreen]
    SymptomScreen[SymptomRecordScreen]
    DatePicker[DateSelectionWidget]
    ValidationWidget[InputValidationWidget]

    %% Application Layer
    TrackingNotifier[TrackingNotifier]
    DerivedProvider[continuousRecordDaysProvider]

    %% Domain Layer
    WeightLog[WeightLog Entity]
    SymptomLog[SymptomLog Entity]
    TrackingRepo[TrackingRepository Interface]

    %% Infrastructure Layer
    IsarTrackingRepo[IsarTrackingRepository]
    WeightDto[WeightLogDto]
    SymptomDto[SymptomLogDto]
    IsarProvider[isarProvider]

    %% Dependencies
    WeightScreen --> TrackingNotifier
    SymptomScreen --> TrackingNotifier
    WeightScreen --> DatePicker
    SymptomScreen --> DatePicker
    WeightScreen --> ValidationWidget
    SymptomScreen --> ValidationWidget

    TrackingNotifier --> TrackingRepo
    TrackingNotifier --> DerivedProvider

    TrackingRepo -.implements.-> IsarTrackingRepo
    IsarTrackingRepo --> IsarProvider
    IsarTrackingRepo --> WeightDto
    IsarTrackingRepo --> SymptomDto

    WeightDto -.converts to.-> WeightLog
    SymptomDto -.converts to.-> SymptomLog
```

---

## 3. Implementation Plan

### 3.1. Domain Layer: WeightLog Entity

**Location**: `lib/features/tracking/domain/entities/weight_log.dart`

**Responsibility**: 체중 기록 비즈니스 로직

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```dart
// TC-WL-01: 정상 생성
test('should create WeightLog with valid data', () {
  // Arrange
  final id = 'wl-001';
  final userId = 'user-001';
  final logDate = DateTime(2025, 11, 7);
  final weightKg = 75.5;
  final createdAt = DateTime.now();

  // Act
  final weightLog = WeightLog(
    id: id,
    userId: userId,
    logDate: logDate,
    weightKg: weightKg,
    createdAt: createdAt,
  );

  // Assert
  expect(weightLog.id, id);
  expect(weightLog.userId, userId);
  expect(weightLog.logDate, logDate);
  expect(weightLog.weightKg, weightKg);
  expect(weightLog.createdAt, createdAt);
});

// TC-WL-02: copyWith 정상 동작
test('should copy WeightLog with updated weightKg', () {
  // Arrange
  final original = WeightLog(
    id: 'wl-001',
    userId: 'user-001',
    logDate: DateTime(2025, 11, 7),
    weightKg: 75.5,
    createdAt: DateTime.now(),
  );

  // Act
  final updated = original.copyWith(weightKg: 74.8);

  // Assert
  expect(updated.weightKg, 74.8);
  expect(updated.id, original.id);
  expect(updated.userId, original.userId);
});

// TC-WL-03: Equality 비교
test('should compare two WeightLog entities correctly', () {
  // Arrange
  final log1 = WeightLog(...);
  final log2 = WeightLog(...);

  // Act & Assert
  expect(log1 == log2, isTrue);
});
```

**Implementation Order**:
1. RED: TC-WL-01 작성 → 실패 확인
2. GREEN: `WeightLog` 클래스 최소 구현
3. REFACTOR: Equatable/Freezed 적용
4. RED: TC-WL-02 작성 → 실패 확인
5. GREEN: `copyWith` 구현
6. REFACTOR: 불필요한 코드 제거

**Dependencies**: 없음 (Pure Dart)

---

### 3.2. Domain Layer: SymptomLog Entity

**Location**: `lib/features/tracking/domain/entities/symptom_log.dart`

**Responsibility**: 증상 기록 비즈니스 로직

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```dart
// TC-SL-01: 정상 생성 (경증, 심각도 1-6점)
test('should create SymptomLog with severity 1-6', () {
  // Arrange & Act
  final symptomLog = SymptomLog(
    id: 'sl-001',
    userId: 'user-001',
    logDate: DateTime(2025, 11, 7),
    symptomName: '메스꺼움',
    severity: 4,
    daysSinceEscalation: 3,
    tags: ['기름진음식', '과식'],
  );

  // Assert
  expect(symptomLog.severity, 4);
  expect(symptomLog.isPersistent24h, isNull);
  expect(symptomLog.tags.length, 2);
});

// TC-SL-02: 중증 생성 (심각도 7-10점, 24시간 지속)
test('should create SymptomLog with severity 7-10 and persistent flag', () {
  // Arrange & Act
  final symptomLog = SymptomLog(
    id: 'sl-002',
    userId: 'user-001',
    logDate: DateTime(2025, 11, 7),
    symptomName: '구토',
    severity: 9,
    daysSinceEscalation: 5,
    isPersistent24h: true,
  );

  // Assert
  expect(symptomLog.severity, 9);
  expect(symptomLog.isPersistent24h, isTrue);
});

// TC-SL-03: 심각도 범위 검증 (1-10)
test('should throw exception for invalid severity', () {
  // Act & Assert
  expect(
    () => SymptomLog(
      id: 'sl-003',
      userId: 'user-001',
      logDate: DateTime.now(),
      symptomName: '메스꺼움',
      severity: 11, // 범위 초과
    ),
    throwsA(isA<ArgumentError>()),
  );
});

// TC-SL-04: 경과일 미계산 (증량 이력 없음)
test('should allow null daysSinceEscalation', () {
  // Arrange & Act
  final symptomLog = SymptomLog(
    id: 'sl-004',
    userId: 'user-001',
    logDate: DateTime.now(),
    symptomName: '복통',
    severity: 3,
    daysSinceEscalation: null,
  );

  // Assert
  expect(symptomLog.daysSinceEscalation, isNull);
});
```

**Implementation Order**:
1. RED: TC-SL-01, 02 작성
2. GREEN: `SymptomLog` 기본 구현
3. RED: TC-SL-03 작성 (검증 로직)
4. GREEN: Severity 범위 검증 추가
5. REFACTOR: Validation 로직 분리

**Dependencies**: 없음 (Pure Dart)

---

### 3.3. Domain Layer: TrackingRepository Interface

**Location**: `lib/features/tracking/domain/repositories/tracking_repository.dart`

**Responsibility**: 데이터 접근 인터페이스 정의

**Test Strategy**: Interface 정의 (구현은 Infrastructure에서 테스트)

**Implementation Order**:
1. Interface 정의 (테스트 불필요)
2. Method Signatures 명확화

```dart
abstract class TrackingRepository {
  // 체중 기록
  Future<void> saveWeightLog(WeightLog log);
  Future<WeightLog?> getWeightLog(String userId, DateTime logDate);
  Future<List<WeightLog>> getWeightLogs(String userId, {DateTime? startDate, DateTime? endDate});
  Future<void> deleteWeightLog(String id);
  Future<void> updateWeightLog(String id, double newWeight);
  Stream<List<WeightLog>> watchWeightLogs(String userId);

  // 증상 기록
  Future<void> saveSymptomLog(SymptomLog log);
  Future<List<SymptomLog>> getSymptomLogs(String userId, {DateTime? startDate, DateTime? endDate});
  Future<void> deleteSymptomLog(String id);
  Future<void> updateSymptomLog(String id, SymptomLog updatedLog);
  Stream<List<SymptomLog>> watchSymptomLogs(String userId);

  // 태그 기반 조회
  Future<List<SymptomLog>> getSymptomLogsByTag(String tagName);
  Future<List<String>> getAllTags(String userId);

  // 경과일 계산을 위한 최근 증량일 조회
  Future<DateTime?> getLatestDoseEscalationDate(String userId);
}
```

**Dependencies**: `WeightLog`, `SymptomLog` Entity

---

### 3.4. Infrastructure Layer: WeightLogDto

**Location**: `lib/features/tracking/infrastructure/dtos/weight_log_dto.dart`

**Responsibility**: Isar DB 매핑

**Test Strategy**: Unit Test (DTO ↔ Entity 변환)

**Test Scenarios (Red Phase)**:
```dart
// TC-WL-DTO-01: Entity → DTO 변환
test('should convert WeightLog entity to WeightLogDto', () {
  // Arrange
  final entity = WeightLog(
    id: 'wl-001',
    userId: 'user-001',
    logDate: DateTime(2025, 11, 7),
    weightKg: 75.5,
    createdAt: DateTime.now(),
  );

  // Act
  final dto = WeightLogDto.fromEntity(entity);

  // Assert
  expect(dto.userId, entity.userId);
  expect(dto.logDate, entity.logDate);
  expect(dto.weightKg, entity.weightKg);
});

// TC-WL-DTO-02: DTO → Entity 변환
test('should convert WeightLogDto to WeightLog entity', () {
  // Arrange
  final dto = WeightLogDto()
    ..id = 1
    ..userId = 'user-001'
    ..logDate = DateTime(2025, 11, 7)
    ..weightKg = 75.5
    ..createdAt = DateTime.now();

  // Act
  final entity = dto.toEntity();

  // Assert
  expect(entity.userId, dto.userId);
  expect(entity.weightKg, dto.weightKg);
});

// TC-WL-DTO-03: Round-trip 변환 (데이터 손실 없음)
test('should preserve data in round-trip conversion', () {
  // Arrange
  final original = WeightLog(...);

  // Act
  final dto = WeightLogDto.fromEntity(original);
  final converted = dto.toEntity();

  // Assert
  expect(converted, equals(original));
});
```

**Implementation Order**:
1. RED: TC-WL-DTO-01 작성
2. GREEN: `WeightLogDto` + `fromEntity` 구현
3. RED: TC-WL-DTO-02 작성
4. GREEN: `toEntity` 구현
5. REFACTOR: 중복 제거

**Dependencies**: Isar, `WeightLog` Entity

---

### 3.5. Infrastructure Layer: SymptomLogDto + SymptomContextTagDto

**Location**:
- `lib/features/tracking/infrastructure/dtos/symptom_log_dto.dart`
- `lib/features/tracking/infrastructure/dtos/symptom_context_tag_dto.dart`

**Responsibility**: Isar DB 매핑 (1:N 관계 처리)

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```dart
// TC-SL-DTO-01: Entity → DTO 변환 (태그 포함)
test('should convert SymptomLog entity to SymptomLogDto with tags', () {
  // Arrange
  final entity = SymptomLog(
    id: 'sl-001',
    userId: 'user-001',
    logDate: DateTime(2025, 11, 7),
    symptomName: '메스꺼움',
    severity: 4,
    tags: ['기름진음식', '과식'],
  );

  // Act
  final dto = SymptomLogDto.fromEntity(entity);

  // Assert
  expect(dto.symptomName, entity.symptomName);
  expect(dto.severity, entity.severity);
  // tags는 별도 테이블이므로 Repository에서 처리
});

// TC-SL-DTO-02: DTO → Entity 변환 (태그 결합)
test('should convert SymptomLogDto to entity with tags', () {
  // Arrange
  final dto = SymptomLogDto()..symptomName = '메스꺼움';
  final tagDtos = [
    SymptomContextTagDto()..tagName = '기름진음식',
    SymptomContextTagDto()..tagName = '과식',
  ];

  // Act
  final entity = dto.toEntity(tags: tagDtos);

  // Assert
  expect(entity.tags, ['기름진음식', '과식']);
});

// TC-SL-DTO-03: isPersistent24h 필드 변환
test('should preserve isPersistent24h in DTO conversion', () {
  // Arrange
  final entity = SymptomLog(
    id: 'sl-001',
    userId: 'user-001',
    logDate: DateTime.now(),
    symptomName: '구토',
    severity: 9,
    isPersistent24h: true,
  );

  // Act
  final dto = SymptomLogDto.fromEntity(entity);
  final converted = dto.toEntity();

  // Assert
  expect(converted.isPersistent24h, isTrue);
});
```

**Implementation Order**:
1. RED: TC-SL-DTO-01 작성
2. GREEN: `SymptomLogDto` 구현
3. RED: Tag 변환 테스트 작성
4. GREEN: `SymptomContextTagDto` + 결합 로직

**Dependencies**: Isar, `SymptomLog` Entity

---

### 3.6. Infrastructure Layer: IsarTrackingRepository

**Location**: `lib/features/tracking/infrastructure/repositories/isar_tracking_repository.dart`

**Responsibility**: TrackingRepository 구현 (Isar DB 접근)

**Test Strategy**: Integration Test (Isar in-memory)

**Test Scenarios (Red Phase)**:
```dart
// TC-ITR-01: 체중 기록 저장
test('should save WeightLog to Isar', () async {
  // Arrange
  final isar = await openIsarInMemory();
  final repository = IsarTrackingRepository(isar);
  final log = WeightLog(...);

  // Act
  await repository.saveWeightLog(log);

  // Assert
  final saved = await repository.getWeightLog(log.userId, log.logDate);
  expect(saved, isNotNull);
  expect(saved!.weightKg, log.weightKg);
});

// TC-ITR-02: 체중 중복 기록 (덮어쓰기)
test('should overwrite duplicate WeightLog', () async {
  // Arrange
  final repository = IsarTrackingRepository(isar);
  final log1 = WeightLog(..., weightKg: 75.5);
  final log2 = WeightLog(..., weightKg: 74.8, logDate: log1.logDate); // 같은 날짜

  // Act
  await repository.saveWeightLog(log1);
  await repository.saveWeightLog(log2);

  // Assert
  final saved = await repository.getWeightLog(log1.userId, log1.logDate);
  expect(saved!.weightKg, 74.8); // 덮어쓰기 확인
});

// TC-ITR-03: 증상 기록 저장 (태그 포함)
test('should save SymptomLog with tags to Isar', () async {
  // Arrange
  final repository = IsarTrackingRepository(isar);
  final log = SymptomLog(..., tags: ['기름진음식', '과식']);

  // Act
  await repository.saveSymptomLog(log);

  // Assert
  final saved = await repository.getSymptomLogs(log.userId);
  expect(saved.first.tags, ['기름진음식', '과식']);
});

// TC-ITR-04: 증상 기록 조회 (날짜 범위)
test('should get SymptomLogs in date range', () async {
  // Arrange
  final repository = IsarTrackingRepository(isar);
  await repository.saveSymptomLog(SymptomLog(..., logDate: DateTime(2025, 11, 1)));
  await repository.saveSymptomLog(SymptomLog(..., logDate: DateTime(2025, 11, 7)));
  await repository.saveSymptomLog(SymptomLog(..., logDate: DateTime(2025, 11, 15)));

  // Act
  final logs = await repository.getSymptomLogs(
    'user-001',
    startDate: DateTime(2025, 11, 5),
    endDate: DateTime(2025, 11, 10),
  );

  // Assert
  expect(logs.length, 1); // 11월 7일만 포함
});

// TC-ITR-05: Stream 실시간 동기화
test('should watch WeightLogs changes', () async {
  // Arrange
  final repository = IsarTrackingRepository(isar);
  final stream = repository.watchWeightLogs('user-001');

  // Act & Assert
  expectLater(
    stream,
    emitsInOrder([
      [], // 초기 빈 리스트
      [isA<WeightLog>()], // 추가 후
    ]),
  );

  await repository.saveWeightLog(WeightLog(...));
});

// TC-ITR-06: 경과일 계산용 최근 증량일 조회
test('should get latest dose escalation date', () async {
  // Arrange
  final repository = IsarTrackingRepository(isar);
  // MedicationRepository mock 필요 (의존성)

  // Act
  final escalationDate = await repository.getLatestDoseEscalationDate('user-001');

  // Assert
  expect(escalationDate, isNotNull);
});

// TC-ITR-07: 태그 정규화 (중복 방지)
test('should normalize context tags across multiple logs', () async {
  // Arrange
  final repository = IsarTrackingRepository(isar);
  final log1 = SymptomLog(
    id: 'sl-001',
    userId: 'user-001',
    logDate: DateTime.now(),
    symptomName: '메스꺼움',
    severity: 4,
    tags: ['기름진음식'],
  );
  final log2 = SymptomLog(
    id: 'sl-002',
    userId: 'user-001',
    logDate: DateTime.now(),
    symptomName: '복통',
    severity: 3,
    tags: ['기름진음식'],
  );

  // Act
  await repository.saveSymptomLog(log1);
  await repository.saveSymptomLog(log2);

  // Assert
  final tagDto = await isar.symptomContextTagDtos
      .filter()
      .tagNameEqualTo('기름진음식')
      .findAll();

  expect(tagDto.length, 2); // 2개의 연결 레코드
});

// TC-ITR-08: 태그 기반 조회
test('should get symptom logs by tag', () async {
  // Arrange
  final repository = IsarTrackingRepository(isar);
  await repository.saveSymptomLog(SymptomLog(..., tags: ['기름진음식']));
  await repository.saveSymptomLog(SymptomLog(..., tags: ['기름진음식']));
  await repository.saveSymptomLog(SymptomLog(..., tags: ['과식']));

  // Act
  final logs = await repository.getSymptomLogsByTag('기름진음식');

  // Assert
  expect(logs.length, 2);
});
```

**Implementation Order**:
1. RED: TC-ITR-01 작성
2. GREEN: `saveWeightLog` 최소 구현
3. RED: TC-ITR-02 작성 (중복 체크)
4. GREEN: Unique constraint 처리
5. RED: TC-ITR-03, 04 작성
6. GREEN: `saveSymptomLog` + 태그 처리
7. REFACTOR: 중복 로직 제거
8. RED: TC-ITR-05 작성 (Stream)
9. GREEN: `watchWeightLogs` 구현

**Dependencies**: Isar, DTO, MedicationRepository (경과일 계산)

---

### 3.7. Application Layer: TrackingNotifier

**Location**: `lib/features/tracking/application/notifiers/tracking_notifier.dart`

**Responsibility**: 상태 관리 및 UseCase 조율

**Test Strategy**: Integration Test (Mock Repository)

**Test Scenarios (Red Phase)**:
```dart
// TC-TN-01: 초기 상태 로딩
test('should load initial TrackingState', () async {
  // Arrange
  final mockRepo = MockTrackingRepository();
  when(() => mockRepo.getWeightLogs(any())).thenAnswer((_) async => []);
  when(() => mockRepo.getSymptomLogs(any())).thenAnswer((_) async => []);

  final container = ProviderContainer(
    overrides: [
      trackingRepositoryProvider.overrideWithValue(mockRepo),
    ],
  );

  // Act
  final state = await container.read(trackingNotifierProvider.future);

  // Assert
  expect(state.weights, isA<AsyncData<List<WeightLog>>>());
  expect(state.symptoms, isA<AsyncData<List<SymptomLog>>>());
});

// TC-TN-02: 체중 기록 추가
test('should save WeightLog and update state', () async {
  // Arrange
  final mockRepo = MockTrackingRepository();
  final log = WeightLog(...);
  when(() => mockRepo.saveWeightLog(log)).thenAnswer((_) async {});
  when(() => mockRepo.getWeightLogs(any())).thenAnswer((_) async => [log]);

  final container = ProviderContainer(
    overrides: [trackingRepositoryProvider.overrideWithValue(mockRepo)],
  );
  final notifier = container.read(trackingNotifierProvider.notifier);

  // Act
  await notifier.saveWeightLog(log);

  // Assert
  final state = container.read(trackingNotifierProvider).value;
  expect(state!.weights.value, [log]);
  verify(() => mockRepo.saveWeightLog(log)).called(1);
});

// TC-TN-03: 증상 기록 추가 (경과일 자동 계산)
test('should save SymptomLog with calculated daysSinceEscalation', () async {
  // Arrange
  final mockRepo = MockTrackingRepository();
  final escalationDate = DateTime(2025, 11, 1);
  when(() => mockRepo.getLatestDoseEscalationDate(any()))
      .thenAnswer((_) async => escalationDate);

  final log = SymptomLog(
    id: 'sl-001',
    userId: 'user-001',
    logDate: DateTime(2025, 11, 7),
    symptomName: '메스꺼움',
    severity: 4,
    daysSinceEscalation: null, // 자동 계산 대상
  );

  final container = ProviderContainer(
    overrides: [trackingRepositoryProvider.overrideWithValue(mockRepo)],
  );
  final notifier = container.read(trackingNotifierProvider.notifier);

  // Act
  await notifier.saveSymptomLog(log);

  // Assert
  final capturedLog = verify(() => mockRepo.saveSymptomLog(captureAny())).captured.single;
  expect(capturedLog.daysSinceEscalation, 6); // 11월 7일 - 11월 1일 = 6일
});

// TC-TN-04: 증량 이력 없을 때 경과일 null 유지
test('should keep daysSinceEscalation null when no escalation history', () async {
  // Arrange
  final mockRepo = MockTrackingRepository();
  when(() => mockRepo.getLatestDoseEscalationDate(any()))
      .thenAnswer((_) async => null); // 증량 이력 없음

  final log = SymptomLog(..., daysSinceEscalation: null);
  final notifier = ...;

  // Act
  await notifier.saveSymptomLog(log);

  // Assert
  final capturedLog = verify(() => mockRepo.saveSymptomLog(captureAny())).captured.single;
  expect(capturedLog.daysSinceEscalation, isNull);
});

// TC-TN-05: 중복 체중 기록 (덮어쓰기)
test('should handle duplicate WeightLog', () async {
  // Arrange
  final mockRepo = MockTrackingRepository();
  final log1 = WeightLog(..., weightKg: 75.5);
  final log2 = WeightLog(..., weightKg: 74.8, logDate: log1.logDate);

  // Act
  await notifier.saveWeightLog(log1);
  await notifier.saveWeightLog(log2);

  // Assert
  verify(() => mockRepo.saveWeightLog(any())).called(2);
});

// TC-TN-06: 기록 삭제
test('should delete WeightLog', () async {
  // Arrange
  final mockRepo = MockTrackingRepository();
  when(() => mockRepo.deleteWeightLog('wl-001')).thenAnswer((_) async {});

  // Act
  await notifier.deleteWeightLog('wl-001');

  // Assert
  verify(() => mockRepo.deleteWeightLog('wl-001')).called(1);
});

// TC-TN-07: 중복 체중 기록 확인
test('should check for existing weight log on date', () async {
  // Arrange
  final mockRepo = MockTrackingRepository();
  final existingLog = WeightLog(
    id: 'wl-001',
    userId: 'user-001',
    logDate: DateTime(2025, 11, 7),
    weightKg: 75.5,
    createdAt: DateTime.now(),
  );
  when(() => mockRepo.getWeightLog('user-001', DateTime(2025, 11, 7)))
      .thenAnswer((_) async => existingLog);

  final container = ProviderContainer(
    overrides: [trackingRepositoryProvider.overrideWithValue(mockRepo)],
  );
  final notifier = container.read(trackingNotifierProvider.notifier);

  // Act
  final hasLog = await notifier.hasWeightLogOnDate('user-001', DateTime(2025, 11, 7));

  // Assert
  expect(hasLog, isTrue);
  verify(() => mockRepo.getWeightLog('user-001', DateTime(2025, 11, 7))).called(1);
});

// TC-TN-08: 중복 없는 날짜 확인
test('should return false when no weight log exists on date', () async {
  // Arrange
  final mockRepo = MockTrackingRepository();
  when(() => mockRepo.getWeightLog('user-001', DateTime(2025, 11, 7)))
      .thenAnswer((_) async => null); // 기록 없음

  final container = ProviderContainer(
    overrides: [trackingRepositoryProvider.overrideWithValue(mockRepo)],
  );
  final notifier = container.read(trackingNotifierProvider.notifier);

  // Act
  final hasLog = await notifier.hasWeightLogOnDate('user-001', DateTime(2025, 11, 7));

  // Assert
  expect(hasLog, isFalse);
});

// NOTE: spec.md의 Sequence Diagram과 달리,
// 경과일 계산은 Application Layer(TrackingNotifier)에서 수행함.
// 이유: 비즈니스 로직이므로 Presentation Layer에 두면 안 됨.
```

**TrackingNotifier Methods**:
```dart
// 중복 체크 메서드 추가
Future<bool> hasWeightLogOnDate(String userId, DateTime date) async {
  final existing = await _repository.getWeightLog(userId, date);
  return existing != null;
}

Future<WeightLog?> getWeightLog(String userId, DateTime date) async {
  return await _repository.getWeightLog(userId, date);
}
```

**Implementation Order**:
1. RED: TC-TN-01 작성
2. GREEN: `TrackingNotifier` 기본 구조
3. RED: TC-TN-02 작성
4. GREEN: `saveWeightLog` 구현
5. RED: TC-TN-03, 04 작성 (경과일 계산)
6. GREEN: `_calculateDaysSinceEscalation` 로직 추가
7. RED: TC-TN-07, 08 작성 (중복 체크)
8. GREEN: `hasWeightLogOnDate`, `getWeightLog` 메서드 추가
9. REFACTOR: 중복 제거

**Dependencies**: `TrackingRepository`, `MedicationRepository` (경과일 계산)

---

### 3.8. Application Layer: Derived Providers

**Location**: `lib/features/tracking/application/providers.dart`

**Responsibility**: 파생 상태 계산

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```dart
// TC-DP-01: 연속 기록일 계산 (기록 있음)
test('should calculate continuous record days', () {
  // Arrange
  final today = DateTime(2025, 11, 7);
  final logs = [
    WeightLog(..., logDate: DateTime(2025, 11, 7)),
    SymptomLog(..., logDate: DateTime(2025, 11, 6)),
    WeightLog(..., logDate: DateTime(2025, 11, 5)),
    // 11월 4일 기록 없음 (중단)
    WeightLog(..., logDate: DateTime(2025, 11, 3)),
  ];

  final mockState = TrackingState(
    weights: AsyncData([logs[0], logs[2], logs[3]]),
    symptoms: AsyncData([logs[1]]),
  );

  // Act
  final days = calculateContinuousRecordDays(mockState, today);

  // Assert
  expect(days, 3); // 11/5, 11/6, 11/7
});

// TC-DP-02: 연속 기록일 계산 (기록 없음)
test('should return 0 when no records', () {
  // Arrange
  final mockState = TrackingState(
    weights: AsyncData([]),
    symptoms: AsyncData([]),
  );

  // Act
  final days = calculateContinuousRecordDays(mockState, DateTime.now());

  // Assert
  expect(days, 0);
});

// TC-DP-03: 오늘 기록 없으면 연속 중단
test('should reset continuous days when no record today', () {
  // Arrange
  final today = DateTime(2025, 11, 7);
  final logs = [
    WeightLog(..., logDate: DateTime(2025, 11, 5)),
    WeightLog(..., logDate: DateTime(2025, 11, 6)),
    // 11월 7일 (오늘) 기록 없음
  ];

  final mockState = TrackingState(
    weights: AsyncData(logs),
    symptoms: AsyncData([]),
  );

  // Act
  final days = calculateContinuousRecordDays(mockState, today);

  // Assert
  expect(days, 0);
});
```

**Implementation Order**:
1. RED: TC-DP-01 작성
2. GREEN: `continuousRecordDaysProvider` 기본 로직
3. RED: TC-DP-02, 03 작성 (엣지 케이스)
4. GREEN: 예외 처리 추가
5. REFACTOR: 로직 최적화

**Dependencies**: `TrackingNotifier`

---

### 3.9. Presentation Layer: WeightRecordScreen

**Location**: `lib/features/tracking/presentation/screens/weight_record_screen.dart`

**Responsibility**: 체중 기록 UI

**Test Strategy**: Widget Test

**Test Scenarios (Red Phase)**:
```dart
// TC-WRS-01: 화면 렌더링
testWidgets('should render WeightRecordScreen', (tester) async {
  // Arrange
  await tester.pumpWidget(
    ProviderScope(
      child: MaterialApp(home: WeightRecordScreen()),
    ),
  );

  // Act & Assert
  expect(find.text('체중 기록'), findsOneWidget);
  expect(find.byType(TextField), findsOneWidget); // 체중 입력 필드
  expect(find.text('저장'), findsOneWidget);
});

// TC-WRS-02: 날짜 선택 ("오늘" 퀵 버튼)
testWidgets('should select today date with quick button', (tester) async {
  // Arrange
  await tester.pumpWidget(...);

  // Act
  await tester.tap(find.text('오늘'));
  await tester.pump();

  // Assert
  final screen = tester.widget<WeightRecordScreen>(find.byType(WeightRecordScreen));
  expect(screen.selectedDate, DateTime.now().toDateOnly());
});

// TC-WRS-03: 체중 입력 검증 (실시간)
testWidgets('should validate weight input in real-time', (tester) async {
  // Arrange
  await tester.pumpWidget(...);

  // Act
  await tester.enterText(find.byType(TextField), '350'); // 비현실적
  await tester.pump();

  // Assert
  expect(find.text('300kg 이하로 입력하세요'), findsOneWidget);
});

// TC-WRS-04: 저장 버튼 클릭 (정상)
testWidgets('should save WeightLog on button tap', (tester) async {
  // Arrange
  final mockNotifier = MockTrackingNotifier();
  await tester.pumpWidget(
    ProviderScope(
      overrides: [
        trackingNotifierProvider.overrideWith(() => mockNotifier),
      ],
      child: MaterialApp(home: WeightRecordScreen()),
    ),
  );

  // Act
  await tester.enterText(find.byType(TextField), '75.5');
  await tester.tap(find.text('저장'));
  await tester.pumpAndSettle();

  // Assert
  verify(() => mockNotifier.saveWeightLog(any())).called(1);
  expect(find.text('저장 완료'), findsOneWidget); // 스낵바
});

// TC-WRS-05: 터치 횟수 확인 (3회 이내)
testWidgets('should complete recording within 3 touches', (tester) async {
  // Arrange
  await tester.pumpWidget(...);

  // Act
  await tester.tap(find.text('오늘')); // 1회
  await tester.enterText(find.byType(TextField), '75.5'); // 2회 (포커스 + 입력)
  await tester.tap(find.text('저장')); // 3회

  // Assert
  // 터치 카운터 검증 (실제로는 interaction 추적)
});

// TC-WRS-06: 중복 날짜 기록 시 확인 다이얼로그 표시
testWidgets('should show overwrite confirmation for duplicate date', (tester) async {
  // Arrange
  final mockNotifier = MockTrackingNotifier();
  when(() => mockNotifier.getWeightLog(any(), any()))
      .thenAnswer((_) async => WeightLog(...)); // 기존 기록 존재

  await tester.pumpWidget(
    ProviderScope(
      overrides: [trackingNotifierProvider.overrideWith(() => mockNotifier)],
      child: MaterialApp(home: WeightRecordScreen()),
    ),
  );

  // Act
  await tester.enterText(find.byType(TextField), '75.5');
  await tester.tap(find.text('저장'));
  await tester.pumpAndSettle();

  // Assert
  expect(find.text('이미 기록이 있습니다. 덮어쓰시겠어요?'), findsOneWidget);
  expect(find.text('취소'), findsOneWidget);
  expect(find.text('확인'), findsOneWidget);
});

// TC-WRS-07: 덮어쓰기 확인 시 업데이트 호출
testWidgets('should update WeightLog on overwrite confirmation', (tester) async {
  // Arrange
  final mockNotifier = MockTrackingNotifier();
  when(() => mockNotifier.getWeightLog(any(), any()))
      .thenAnswer((_) async => WeightLog(...));

  await tester.pumpWidget(
    ProviderScope(
      overrides: [trackingNotifierProvider.overrideWith(() => mockNotifier)],
      child: MaterialApp(home: WeightRecordScreen()),
    ),
  );

  await tester.enterText(find.byType(TextField), '75.5');
  await tester.tap(find.text('저장'));
  await tester.pumpAndSettle();

  // Act
  await tester.tap(find.text('확인')); // 덮어쓰기 확인
  await tester.pumpAndSettle();

  // Assert
  verify(() => mockNotifier.updateWeightLog(any(), any())).called(1);
});
```

**Implementation Order**:
1. RED: TC-WRS-01 작성
2. GREEN: 기본 UI 구조 구현
3. RED: TC-WRS-03 작성 (검증)
4. GREEN: `InputValidationWidget` 연동
5. RED: TC-WRS-04 작성 (저장)
6. GREEN: `TrackingNotifier` 연동
7. REFACTOR: UI 코드 정리

**Dependencies**: `TrackingNotifier`, `DateSelectionWidget`

**QA Sheet**:
- [ ] 날짜 선택 퀵 버튼 ("오늘", "어제", "2일 전") 동작 확인
- [ ] 캘린더 날짜 선택 동작 확인
- [ ] 체중 입력 시 실시간 검증 메시지 표시
- [ ] 저장 버튼 클릭 시 스낵바 표시
- [ ] 저장 완료 후 홈 화면으로 자동 이동
- [ ] 3회 터치 이내 기록 완료 확인
- [ ] 미래 날짜 선택 시 에러 표시
- [ ] 중복 날짜 기록 시 덮어쓰기 확인 메시지

---

### 3.10. Presentation Layer: SymptomRecordScreen

**Location**: `lib/features/tracking/presentation/screens/symptom_record_screen.dart`

**Responsibility**: 증상 기록 UI

**Test Strategy**: Widget Test

**Test Scenarios (Red Phase)**:
```dart
// TC-SRS-01: 화면 렌더링
testWidgets('should render SymptomRecordScreen', (tester) async {
  // Arrange & Act
  await tester.pumpWidget(...);

  // Assert
  expect(find.text('증상 기록'), findsOneWidget);
  expect(find.text('메스꺼움'), findsOneWidget); // 증상 목록
  expect(find.byType(Slider), findsOneWidget); // 심각도 선택
});

// TC-SRS-02: 증상 선택 (다중 선택)
testWidgets('should allow multiple symptom selection', (tester) async {
  // Arrange
  await tester.pumpWidget(...);

  // Act
  await tester.tap(find.text('메스꺼움'));
  await tester.tap(find.text('복통'));
  await tester.pump();

  // Assert
  expect(find.byIcon(Icons.check), findsNWidgets(2)); // 체크 아이콘 2개
});

// TC-SRS-03: 심각도 7-10점 선택 시 추가 질문
testWidgets('should show persistent 24h question for severity 7-10', (tester) async {
  // Arrange
  await tester.pumpWidget(...);

  // Act
  await tester.tap(find.text('구토'));
  await tester.drag(find.byType(Slider), Offset(100, 0)); // 심각도 9점
  await tester.pump();

  // Assert
  expect(find.text('24시간 이상 지속되고 있나요?'), findsOneWidget);
  expect(find.text('예'), findsOneWidget);
  expect(find.text('아니오'), findsOneWidget);
});

// TC-SRS-04: 컨텍스트 태그 선택
testWidgets('should allow context tag selection', (tester) async {
  // Arrange
  await tester.pumpWidget(...);

  // Act
  await tester.tap(find.text('#기름진음식'));
  await tester.tap(find.text('#과식'));
  await tester.pump();

  // Assert
  final screen = tester.widget<SymptomRecordScreen>(find.byType(SymptomRecordScreen));
  expect(screen.selectedTags, ['기름진음식', '과식']);
});

// TC-SRS-05: 저장 후 대처 가이드 표시
testWidgets('should show coping guide after saving', (tester) async {
  // Arrange
  await tester.pumpWidget(...);

  // Act
  await tester.tap(find.text('메스꺼움'));
  await tester.drag(find.byType(Slider), Offset(50, 0)); // 심각도 4점
  await tester.tap(find.text('저장'));
  await tester.pumpAndSettle();

  // Assert
  expect(find.text('메스꺼움 대처 가이드'), findsOneWidget);
  expect(find.text('도움이 되었나요?'), findsOneWidget);
});

// TC-SRS-06: 경과일 자동 표시
testWidgets('should display daysSinceEscalation automatically', (tester) async {
  // Arrange
  final mockNotifier = MockTrackingNotifier();
  when(() => mockNotifier.getLatestDoseEscalationDate())
      .thenAnswer((_) async => DateTime(2025, 11, 1));

  await tester.pumpWidget(
    ProviderScope(
      overrides: [trackingNotifierProvider.overrideWith(() => mockNotifier)],
      child: MaterialApp(home: SymptomRecordScreen()),
    ),
  );

  // Act
  await tester.pump(); // 경과일 계산 대기

  // Assert
  expect(find.text('용량 증량 후 6일째'), findsOneWidget); // 11/7 - 11/1 = 6일
});

// TC-SRS-07: 24시간 지속 여부 저장
testWidgets('should save isPersistent24h based on user selection', (tester) async {
  // Arrange
  final mockNotifier = MockTrackingNotifier();
  await tester.pumpWidget(
    ProviderScope(
      overrides: [trackingNotifierProvider.overrideWith(() => mockNotifier)],
      child: MaterialApp(home: SymptomRecordScreen()),
    ),
  );

  // Act
  await tester.tap(find.text('구토'));
  await tester.drag(find.byType(Slider), Offset(100, 0)); // 심각도 9점
  await tester.pumpAndSettle();
  await tester.tap(find.text('예')); // 24시간 지속 선택
  await tester.tap(find.text('저장'));
  await tester.pumpAndSettle();

  // Assert
  final capturedLog = verify(() => mockNotifier.saveSymptomLog(captureAny())).captured.single;
  expect(capturedLog.isPersistent24h, isTrue);
});

// TC-SRS-08: 중증 + 24시간 지속 시 증상 체크 화면 안내
testWidgets('should navigate to symptom check for severe persistent symptoms', (tester) async {
  // Arrange
  final mockNotifier = MockTrackingNotifier();
  await tester.pumpWidget(
    ProviderScope(
      overrides: [trackingNotifierProvider.overrideWith(() => mockNotifier)],
      child: MaterialApp(home: SymptomRecordScreen()),
    ),
  );

  // Act
  await tester.tap(find.text('구토'));
  await tester.drag(find.byType(Slider), Offset(100, 0)); // 심각도 9점
  await tester.pumpAndSettle();
  await tester.tap(find.text('예')); // 24시간 지속
  await tester.tap(find.text('저장'));
  await tester.pumpAndSettle();

  // Assert
  expect(find.text('증상 체크 화면으로 이동하시겠어요?'), findsOneWidget);
  expect(find.text('이동'), findsOneWidget);
  expect(find.text('나중에'), findsOneWidget);
});

// TC-SRS-09: 증상 체크 화면 이동
testWidgets('should navigate to F005 on confirmation', (tester) async {
  // Arrange
  final mockNotifier = MockTrackingNotifier();
  await tester.pumpWidget(
    ProviderScope(
      overrides: [trackingNotifierProvider.overrideWith(() => mockNotifier)],
      child: MaterialApp(
        home: SymptomRecordScreen(),
        routes: {
          '/symptom-check': (context) => SymptomCheckScreen(), // F005
        },
      ),
    ),
  );

  await tester.tap(find.text('구토'));
  await tester.drag(find.byType(Slider), Offset(100, 0));
  await tester.pumpAndSettle();
  await tester.tap(find.text('예'));
  await tester.tap(find.text('저장'));
  await tester.pumpAndSettle();

  // Act
  await tester.tap(find.text('이동'));
  await tester.pumpAndSettle();

  // Assert
  expect(find.byType(SymptomCheckScreen), findsOneWidget); // F005
});

// TC-SRS-10: 증상 체크 생략
testWidgets('should allow skipping symptom check', (tester) async {
  // Arrange
  final mockNotifier = MockTrackingNotifier();
  await tester.pumpWidget(
    ProviderScope(
      overrides: [trackingNotifierProvider.overrideWith(() => mockNotifier)],
      child: MaterialApp(
        home: SymptomRecordScreen(),
        routes: {
          '/home': (context) => HomeScreen(),
        },
      ),
    ),
  );

  await tester.tap(find.text('구토'));
  await tester.drag(find.byType(Slider), Offset(100, 0));
  await tester.pumpAndSettle();
  await tester.tap(find.text('예'));
  await tester.tap(find.text('저장'));
  await tester.pumpAndSettle();

  // Act
  await tester.tap(find.text('나중에'));
  await tester.pumpAndSettle();

  // Assert
  expect(find.byType(HomeScreen), findsOneWidget);
});
```

**Implementation Order**:
1. RED: TC-SRS-01 작성
2. GREEN: 기본 UI 구조
3. RED: TC-SRS-03 작성 (추가 질문)
4. GREEN: 심각도별 조건 분기
5. RED: TC-SRS-05 작성 (가이드 표시)
6. GREEN: F004 연동 (CopingGuide 표시)
7. RED: TC-SRS-07 작성 (isPersistent24h 저장)
8. GREEN: 24시간 지속 여부 저장 로직
9. RED: TC-SRS-08~10 작성 (F005 연동)
10. GREEN: severity >= 7 && isPersistent24h == true 시 증상 체크 화면 안내
11. REFACTOR: 중복 제거

**Dependencies**:
- `TrackingNotifier`
- `CopingGuideWidget` (F004)
- `SymptomCheckScreen` (F005)
- `HomeScreen`

**F005 Navigation Logic**:
- BR-F002-04에 따라 severity >= 7 && isPersistent24h == true일 때만 안내
- Navigator.push()로 SymptomCheckScreen으로 이동
- 사용자가 거부 시 HomeScreen으로 복귀

**QA Sheet**:
- [ ] 증상 다중 선택 동작 확인
- [ ] 심각도 슬라이더 정확도 (1-10점)
- [ ] 심각도 7-10점 시 추가 질문 표시
- [ ] 24시간 지속 여부 "예/아니오" 선택 동작
- [ ] isPersistent24h 필드 정확히 저장되는지 확인
- [ ] 컨텍스트 태그 선택 동작
- [ ] 저장 후 대처 가이드 자동 표시
- [ ] "도움이 되었나요?" 피드백 수집
- [ ] 경과일 자동 계산 및 표시
- [ ] 3회 터치 이내 기록 완료
- [ ] 증량 이력 없을 때 경과일 미표시
- [ ] severity >= 7 && isPersistent24h == true 시 증상 체크 화면 안내 표시
- [ ] 증상 체크 화면 이동 동작 확인
- [ ] 증상 체크 생략 시 홈 화면 이동 확인

---

### 3.11. Presentation Layer: DateSelectionWidget

**Location**: `lib/features/tracking/presentation/widgets/date_selection_widget.dart`

**Responsibility**: 날짜 선택 UI (재사용 가능)

**Test Strategy**: Widget Test

**Test Scenarios (Red Phase)**:
```dart
// TC-DSW-01: 퀵 버튼 렌더링
testWidgets('should render quick date buttons', (tester) async {
  // Arrange & Act
  await tester.pumpWidget(
    MaterialApp(home: Scaffold(body: DateSelectionWidget())),
  );

  // Assert
  expect(find.text('오늘'), findsOneWidget);
  expect(find.text('어제'), findsOneWidget);
  expect(find.text('2일 전'), findsOneWidget);
});

// TC-DSW-02: "오늘" 버튼 클릭
testWidgets('should select today on button tap', (tester) async {
  // Arrange
  DateTime? selectedDate;
  await tester.pumpWidget(
    MaterialApp(
      home: Scaffold(
        body: DateSelectionWidget(
          onDateSelected: (date) => selectedDate = date,
        ),
      ),
    ),
  );

  // Act
  await tester.tap(find.text('오늘'));
  await tester.pump();

  // Assert
  expect(selectedDate, DateTime.now().toDateOnly());
});

// TC-DSW-03: 캘린더 날짜 선택
testWidgets('should select date from calendar', (tester) async {
  // Arrange
  DateTime? selectedDate;
  await tester.pumpWidget(...);

  // Act
  await tester.tap(find.byIcon(Icons.calendar_today));
  await tester.pumpAndSettle();
  await tester.tap(find.text('15')); // 15일 선택
  await tester.tap(find.text('확인'));
  await tester.pumpAndSettle();

  // Assert
  expect(selectedDate!.day, 15);
});

// TC-DSW-04: 미래 날짜 선택 불가
testWidgets('should disable future dates in calendar', (tester) async {
  // Arrange
  await tester.pumpWidget(...);

  // Act
  await tester.tap(find.byIcon(Icons.calendar_today));
  await tester.pumpAndSettle();

  // Assert
  final calendarWidget = tester.widget<CalendarDatePicker>(find.byType(CalendarDatePicker));
  expect(calendarWidget.lastDate, DateTime.now().toDateOnly());
});
```

**Implementation Order**:
1. RED: TC-DSW-01, 02 작성
2. GREEN: 퀵 버튼 구현
3. RED: TC-DSW-03 작성
4. GREEN: 캘린더 통합
5. RED: TC-DSW-04 작성
6. GREEN: 미래 날짜 비활성화
7. REFACTOR: 코드 정리

**Dependencies**: 없음 (Pure Widget)

---

## 4. TDD Workflow

### 시작: 도메인 레이어부터 (Inside-Out)

```
1. WeightLog Entity (TC-WL-01~03)
   → RED: 테스트 작성
   → GREEN: 클래스 구현
   → REFACTOR: Equatable 적용
   → COMMIT: "feat: add WeightLog entity with tests"

2. SymptomLog Entity (TC-SL-01~04)
   → RED: 기본 + 검증 테스트
   → GREEN: Severity 검증 추가
   → REFACTOR: Validation 분리
   → COMMIT: "feat: add SymptomLog entity with validation"

3. TrackingRepository Interface
   → 정의만 (테스트 불필요)
   → COMMIT: "feat: define TrackingRepository interface"

4. WeightLogDto (TC-WL-DTO-01~03)
   → RED: 변환 테스트
   → GREEN: DTO 구현
   → REFACTOR: 중복 제거
   → COMMIT: "feat: add WeightLogDto with conversion tests"

5. SymptomLogDto + SymptomContextTagDto (TC-SL-DTO-01~02)
   → RED: 태그 결합 테스트
   → GREEN: 1:N 관계 처리
   → REFACTOR: 로직 정리
   → COMMIT: "feat: add SymptomLogDto with tag support"

6. IsarTrackingRepository (TC-ITR-01~08)
   → RED: 저장/조회 테스트
   → GREEN: Isar 연동
   → RED: Stream 테스트
   → GREEN: Watch 구현
   → RED: 태그 정규화 테스트 (TC-ITR-07~08)
   → GREEN: 태그 기반 조회 메서드 구현
   → REFACTOR: 중복 제거
   → COMMIT: "feat: implement IsarTrackingRepository with tag support"

7. TrackingNotifier (TC-TN-01~08)
   → RED: 상태 관리 테스트
   → GREEN: Notifier 구현
   → RED: 경과일 계산 테스트
   → GREEN: 로직 추가
   → RED: 중복 체크 테스트 (TC-TN-07~08)
   → GREEN: hasWeightLogOnDate 메서드 추가
   → REFACTOR: 코드 정리
   → COMMIT: "feat: add TrackingNotifier with duplicate check"

8. Derived Providers (TC-DP-01~03)
   → RED: 연속 기록일 테스트
   → GREEN: Provider 구현
   → REFACTOR: 최적화
   → COMMIT: "feat: add continuousRecordDaysProvider"

9. WeightRecordScreen (TC-WRS-01~07)
   → RED: 렌더링 테스트
   → GREEN: UI 구현
   → RED: 검증 테스트
   → GREEN: Validation 연동
   → RED: 중복 확인 다이얼로그 테스트 (TC-WRS-06~07)
   → GREEN: 중복 기록 확인 및 덮어쓰기 로직
   → REFACTOR: UI 정리
   → COMMIT: "feat: add WeightRecordScreen with duplicate handling"

10. SymptomRecordScreen (TC-SRS-01~10)
    → RED: 심각도 분기 테스트
    → GREEN: 조건 분기 구현
    → RED: 가이드 표시 테스트
    → GREEN: F004 연동
    → RED: isPersistent24h 저장 테스트 (TC-SRS-07)
    → GREEN: 24시간 지속 여부 저장 로직
    → RED: F005 연동 테스트 (TC-SRS-08~10)
    → GREEN: 증상 체크 화면 안내 및 네비게이션
    → REFACTOR: 코드 정리
    → COMMIT: "feat: add SymptomRecordScreen with F005 integration"

11. DateSelectionWidget (TC-DSW-01~04)
    → RED: 퀵 버튼 테스트
    → GREEN: 버튼 구현
    → RED: 캘린더 테스트
    → GREEN: 캘린더 통합
    → COMMIT: "feat: add DateSelectionWidget"
```

### Commit 포인트 제안
- 각 모듈의 TDD 사이클 완료 시 커밋
- Commit 메시지: `feat: <module> with tests` 또는 `test: <module> edge cases`
- 최소 단위: 1개 Entity/DTO/Repository 메서드

### 완료 조건
- [ ] 모든 Unit Test 통과 (70%)
- [ ] Integration Test 통과 (20%)
- [ ] Widget Test 통과 (10%)
- [ ] Acceptance Test 통과 (UC-F002-01, 02, 03)
- [ ] QA Sheet 수동 테스트 완료
- [ ] Code Coverage 80% 이상
- [ ] 성능 요구사항 충족 (3회 터치 이내 완료)

---

## 5. 핵심 원칙

### Test First
- 코드보다 테스트를 먼저 작성
- 실패하는 테스트를 보고 나서 구현 시작

### Small Steps
- 한 번에 하나의 시나리오만 구현
- 작은 단위로 빠른 피드백

### FIRST Principles
- Fast: 각 테스트 100ms 이내
- Independent: 테스트 순서 무관
- Repeatable: 항상 같은 결과
- Self-validating: Pass/Fail 명확
- Timely: 코드 작성 직전

### Test Pyramid
- Unit 70%: Entity, DTO, Repository 메서드
- Integration 20%: Notifier + Repository
- Widget 10%: Screen 렌더링, 인터랙션

### Strategy
- **Inside-Out**: Domain (Core Logic) → Infrastructure → Application → Presentation
- 이유: 비즈니스 로직이 명확하고, UI는 나중에 변경 가능성이 높음
</file>

<file path="004/spec.md">
# UF-F002: 증상 및 체중 기록 - 상세 유스케이스

## Primary Actor

GLP-1 치료를 받고 있는 사용자

## Precondition

- 사용자가 앱에 로그인되어 있음
- 온보딩을 완료하여 사용자 프로필과 투여 계획이 설정되어 있음
- 홈 대시보드 또는 기록 화면에 접근 가능함

## Trigger

- 사용자가 홈 대시보드의 "체중 기록" 또는 "증상 기록" 퀵 액션 버튼을 클릭
- 사용자가 메뉴에서 기록 화면으로 직접 이동

## Main Scenario

### UC-F002-01: 체중 기록
1. 사용자가 "체중 기록" 버튼을 클릭한다
2. 시스템이 체중 기록 화면을 표시한다
3. 사용자가 날짜를 선택한다 ("오늘", "어제", "2일 전" 퀵 버튼 또는 캘린더)
4. 사용자가 체중 값을 입력한다 (kg 단위)
5. 시스템이 입력값을 실시간으로 검증한다 (양수, 현실적 범위)
6. 사용자가 "저장" 버튼을 클릭한다 (총 3회 터치 이내)
7. 시스템이 날짜, 체중, 기록 시간을 저장한다
8. 시스템이 저장 완료 메시지를 표시한다
9. 시스템이 홈 대시보드로 복귀한다

### UC-F002-02: 부작용 기록 (경증)
1. 사용자가 "증상 기록" 버튼을 클릭한다
2. 시스템이 부작용 기록 화면을 표시한다
3. 사용자가 날짜를 선택한다 ("오늘", "어제", "2일 전" 퀵 버튼 또는 캘린더)
4. 사용자가 증상을 선택한다 (메스꺼움/구토/변비/설사/복통/두통/피로 중 하나 이상)
5. 사용자가 각 증상의 심각도를 선택한다 (1-10점 척도)
6. 심각도가 1-6점인 경우, 사용자가 선택적으로 컨텍스트 태그를 추가한다 (#기름진음식, #과식, #음주, #공복, #스트레스, #수면부족)
7. 사용자가 선택적으로 메모를 입력한다
8. 사용자가 "저장" 버튼을 클릭한다 (총 3회 터치 이내)
9. 시스템이 용량 증량 후 경과일을 자동 계산한다 (투여 스케줄 참조)
10. 시스템이 날짜, 증상명, 심각도, 경과일, 기록 시간, 메모, 태그를 저장한다
11. 시스템이 해당 증상의 간단한 대처 가이드를 자동으로 표시한다 (F004 연동)
12. 사용자가 대처 가이드를 확인한다
13. 시스템이 "도움이 되었나요?" 피드백을 요청한다
14. 사용자가 홈 대시보드로 복귀한다

### UC-F002-03: 부작용 기록 (중증)
1. 사용자가 "증상 기록" 버튼을 클릭한다
2. 시스템이 부작용 기록 화면을 표시한다
3. 사용자가 날짜를 선택한다
4. 사용자가 증상을 선택한다
5. 사용자가 심각도 7-10점을 선택한다
6. 시스템이 추가 확인 질문을 표시한다: "이 증상이 24시간 이상 지속되고 있나요?"
7. 사용자가 "예" 또는 "아니오"를 선택한다
8. 사용자가 선택적으로 컨텍스트 태그를 추가한다
9. 사용자가 선택적으로 메모를 입력한다
10. 사용자가 "저장" 버튼을 클릭한다
11. 시스템이 기록을 저장한다
12. 시스템이 대처 가이드를 표시한다 (F004 연동)
13. 만약 "예"를 선택했다면, 시스템이 "증상 체크" 화면으로 안내한다 (F005 연동)
14. 사용자가 필요 시 증상 체크를 진행하거나, 홈 대시보드로 복귀한다

## Edge Cases

### 입력 검증 오류
- 체중 값이 비현실적인 경우 (20kg 미만, 300kg 초과): 시스템이 확인 메시지를 표시한다
- 미래 날짜 선택: 시스템이 에러 메시지를 표시하고 오늘 날짜로 자동 조정한다

### 중복 기록
- 같은 날짜에 체중 중복 기록: 시스템이 덮어쓰기 확인 메시지를 표시한다
- 같은 날짜/증상 중복 기록: 시스템이 덮어쓰기 또는 별도 기록 선택 옵션을 제공한다

### 데이터 부재
- 증량 이력이 없는 경우: 시스템이 경과일 계산을 건너뛴다
- 투여 계획이 비활성화된 경우: 시스템이 경과일 계산을 건너뛴다

### 네트워크 오류
- 저장 중 네트워크 오류 발생: 시스템이 로컬에 임시 저장하고 재시도 큐에 추가한다
- Phase 0에서는 로컬 DB만 사용하므로 네트워크 오류 없음

### 사용자 이탈
- 입력 중 앱 종료: 시스템이 임시 저장 없이 변경사항을 폐기한다
- 입력 중 백 버튼 클릭: 시스템이 저장 확인 메시지를 표시한다

### 여러 증상 동시 기록
- 한 번에 여러 증상 기록: 시스템이 각 증상별로 심각도를 개별 입력받고, 대처 가이드는 순차적으로 표시한다

## Business Rules

### BR-F002-01: 체중 기록 제약
- 체중은 날짜당 1개 값만 저장 가능 (중복 시 덮어쓰기)
- 체중 값 범위: 20kg 이상, 300kg 이하
- 미래 날짜 기록 불가
- 과거 90일 이내 기록만 수정 가능 (MVP 제한)

### BR-F002-02: 부작용 기록 제약
- 같은 날짜에 같은 증상을 여러 번 기록 가능
- 심각도는 1-10점 범위 필수
- 심각도 7-10점일 때 24시간 지속 여부 확인 필수
- 미래 날짜 기록 불가
- 과거 90일 이내 기록만 수정 가능 (MVP 제한)

### BR-F002-03: 경과일 계산
- 용량 증량 후 경과일은 투여 스케줄의 가장 최근 증량일 기준으로 계산
- 증량 이력이 없으면 경과일 표시 안 함
- 투여 계획이 비활성화되면 경과일 계산 안 함

### BR-F002-04: 대처 가이드 연동
- 부작용 기록 저장 시 자동으로 대처 가이드 표시 (F004)
- 심각도 7-10점이고 24시간 이상 지속 시 증상 체크 화면으로 안내 (F005)
- 사용자가 대처 가이드를 건너뛰고 바로 나갈 수 있음

### BR-F002-05: 입력 편의성
- 체중 기록은 3회 터치 이내 완료 가능해야 함
- 부작용 기록은 3회 터치 이내 완료 가능해야 함 (컨텍스트 태그 제외)
- 날짜 선택은 "오늘", "어제", "2일 전" 퀵 버튼 제공 필수

### BR-F002-06: 데이터 정합성
- 기록 저장 시 user_id는 현재 로그인한 사용자 ID 사용
- 모든 timestamp는 UTC로 저장하고, 표시 시 로컬 timezone 적용
- 컨텍스트 태그는 symptom_context_tags 테이블에 정규화하여 저장

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE
participant BE
database Database

== UC-F002-01: 체중 기록 ==
User -> FE: 체중 기록 버튼 클릭
FE -> User: 체중 기록 화면 표시
User -> FE: 날짜 선택 (오늘/어제/캘린더)
User -> FE: 체중 값 입력 (kg)
FE -> FE: 입력값 실시간 검증
User -> FE: 저장 버튼 클릭
FE -> BE: saveWeightLog(userId, date, weightKg)
BE -> Database: INSERT INTO weight_logs
Database -> BE: 저장 완료
BE -> FE: 성공 응답
FE -> User: 저장 완료 메시지 표시
FE -> User: 홈 대시보드로 이동

== UC-F002-02: 부작용 기록 (경증) ==
User -> FE: 증상 기록 버튼 클릭
FE -> User: 부작용 기록 화면 표시
User -> FE: 날짜 선택
User -> FE: 증상 선택 (메스꺼움/구토/...)
User -> FE: 심각도 선택 (1-6점)
User -> FE: 컨텍스트 태그 선택 (선택적)
User -> FE: 메모 입력 (선택적)
User -> FE: 저장 버튼 클릭
FE -> BE: getLatestDoseEscalationDate(userId)
BE -> Database: SELECT FROM dosage_plans, dose_schedules
Database -> BE: 가장 최근 증량일
BE -> FE: 증량일 반환
FE -> FE: 경과일 계산
FE -> BE: saveSymptomLog(userId, date, symptomName, severity, daysSinceEscalation, tags, note)
BE -> Database: INSERT INTO symptom_logs
Database -> BE: symptom_log_id
BE -> Database: INSERT INTO symptom_context_tags (for each tag)
Database -> BE: 저장 완료
BE -> FE: 성공 응답
FE -> FE: 해당 증상 대처 가이드 조회
FE -> User: 대처 가이드 카드 표시
FE -> User: "도움이 되었나요?" 피드백 요청
User -> FE: 피드백 선택 (예/아니오)
FE -> User: 홈 대시보드로 이동

== UC-F002-03: 부작용 기록 (중증) ==
User -> FE: 증상 기록 버튼 클릭
FE -> User: 부작용 기록 화면 표시
User -> FE: 날짜 선택
User -> FE: 증상 선택
User -> FE: 심각도 선택 (7-10점)
FE -> User: "24시간 이상 지속되고 있나요?" 추가 질문 표시
User -> FE: "예" 또는 "아니오" 선택
User -> FE: 컨텍스트 태그 선택 (선택적)
User -> FE: 메모 입력 (선택적)
User -> FE: 저장 버튼 클릭
FE -> BE: getLatestDoseEscalationDate(userId)
BE -> Database: SELECT FROM dosage_plans, dose_schedules
Database -> BE: 가장 최근 증량일
BE -> FE: 증량일 반환
FE -> FE: 경과일 계산
FE -> BE: saveSymptomLog(userId, date, symptomName, severity, daysSinceEscalation, isPersistent24h, tags, note)
BE -> Database: INSERT INTO symptom_logs
Database -> BE: symptom_log_id
BE -> Database: INSERT INTO symptom_context_tags (for each tag)
Database -> BE: 저장 완료
BE -> FE: 성공 응답
FE -> FE: 해당 증상 대처 가이드 조회
FE -> User: 대처 가이드 카드 표시
alt 24시간 이상 지속 선택
  FE -> User: "증상 체크 화면으로 이동하시겠어요?" 안내
  User -> FE: 확인 클릭
  FE -> User: 증상 체크 화면으로 이동 (F005)
else 증상 체크 생략
  FE -> User: 홈 대시보드로 이동
end

== Edge Case: 중복 기록 ==
User -> FE: 같은 날짜 체중 기록 시도
FE -> BE: saveWeightLog(userId, date, weightKg)
BE -> Database: SELECT FROM weight_logs WHERE user_id AND log_date
Database -> BE: 기존 기록 존재
BE -> FE: 중복 기록 확인 필요
FE -> User: "이미 기록이 있습니다. 덮어쓰시겠어요?" 메시지
User -> FE: 확인 클릭
FE -> BE: updateWeightLog(userId, date, weightKg)
BE -> Database: UPDATE weight_logs
Database -> BE: 업데이트 완료
BE -> FE: 성공 응답
FE -> User: 저장 완료 메시지 표시

@enduml
```
</file>

<file path="005/plan.md">
# Data Sharing Mode Implementation Plan

## 1. 개요

데이터 공유 모드는 사용자가 의료진에게 치료 기록을 보여주기 위한 읽기 전용 화면입니다. 투여 기록, 체중 변화, 부작용 패턴 등을 가독성 높은 전용 UI로 제공합니다.

**구현 모듈:**
- **DataSharingNotifier** (Application): 공유 모드 상태 관리
- **DataSharingAggregator** (Domain): 기간별 데이터 집계 로직
- **SharedDataReport** (Domain): 공유용 리포트 엔티티
- **DataSharingScreen** (Presentation): 공유 모드 전용 화면
- **SharedDataRepository** (Domain/Infrastructure): 기간별 데이터 조회 인터페이스 및 구현

**TDD 적용 범위:**
- Unit: Domain Layer (집계 로직, 엔티티 변환)
- Integration: Application Layer (Notifier, Repository 연동)
- Widget: Presentation Layer (UI 상태 전환, 읽기 전용 모드)

---

## 2. Architecture Diagram

```mermaid
graph TD
    subgraph Presentation
        DSScreen[DataSharingScreen]
        PeriodSelector[PeriodSelector Widget]
        ReportView[SharedReportView Widget]
    end

    subgraph Application
        DSNotifier[DataSharingNotifier]
        DSProvider[dataSharingNotifierProvider]
    end

    subgraph Domain
        DSAggregator[DataSharingAggregator UseCase]
        SharedReport[SharedDataReport Entity]
        SDRepo[SharedDataRepository Interface]
    end

    subgraph Infrastructure
        IsarSDRepo[IsarSharedDataRepository]
        MedicationRepo[MedicationRepository]
        TrackingRepo[TrackingRepository]
    end

    DSScreen --> DSProvider
    DSProvider --> DSNotifier
    DSNotifier --> DSAggregator
    DSNotifier --> SDRepo
    DSAggregator --> SharedReport
    SDRepo --> IsarSDRepo
    IsarSDRepo --> MedicationRepo
    IsarSDRepo --> TrackingRepo
```

---

## 3. Implementation Plan

### 3.1. SharedDataReport Entity (Domain)

**Location**: `lib/features/data_sharing/domain/entities/shared_data_report.dart`

**Responsibility**: 공유용 리포트 데이터 구조 정의

**Test Strategy**: Unit

**Test Scenarios**:
- Red Phase:
  - `test('should create SharedDataReport with all required fields')`
  - `test('should calculate compliance rate correctly')`
  - `test('should filter data by date range')`
  - `test('should return empty lists when no data exists')`

**Implementation Order**:
1. 엔티티 클래스 정의 (필드: 기간, 투여 기록 목록, 체중 기록 목록, 부작용 기록 목록, 증상 체크 목록, 투여 스케줄 목록)
2. 순응도 계산 메서드
3. 데이터 필터링 메서드
4. Immutability 보장 (copyWith)

**Dependencies**:
- `DoseRecord`, `WeightLog`, `SymptomLog`, `SymptomCheck`, `MedicationSchedule` (기존 엔티티)

---

### 3.2. SharedDataRepository Interface (Domain)

**Location**: `lib/features/data_sharing/domain/repositories/shared_data_repository.dart`

**Responsibility**: 기간별 데이터 조회 인터페이스 정의

**Test Strategy**: Unit (Mock 사용)

**Test Scenarios**:
- Red Phase:
  - `test('should define getReportData method signature')`
  - `test('should define period range enum')`

**Implementation Order**:
1. Repository 인터페이스 선언
2. `Future<SharedDataReport> getReportData(DateRange range)` 메서드 정의
3. DateRange enum 정의 (최근 1개월/3개월/전체)

**Dependencies**: `SharedDataReport`

---

### 3.3. IsarSharedDataRepository (Infrastructure)

**Location**: `lib/features/data_sharing/infrastructure/repositories/isar_shared_data_repository.dart`

**Responsibility**: Isar DB에서 기간별 데이터 조회 및 집계

**Test Strategy**: Integration

**Test Scenarios**:
- Red Phase:
  - `test('should fetch dose records within date range')`
  - `test('should fetch weight logs within date range')`
  - `test('should fetch symptom logs within date range')`
  - `test('should fetch symptom checks within date range')`
  - `test('should fetch medication schedules within date range')`
  - `test('should return empty report when no data exists')`
  - `test('should aggregate injection site history correctly')`
  - `test('should calculate adherence rate using schedules and dose records')`
  - `test('should handle missed doses correctly')`
  - Edge Cases:
    - `test('should handle partial data (only doses, no weights)')`
    - `test('should handle date range with future dates')`
    - `test('should handle all-time period correctly')`

**Implementation Order**:
1. Repository 구현 클래스 생성
2. 기간별 투여 기록 조회 로직
3. 기간별 체중/부작용 기록 조회 로직
4. 기간별 증상 체크 기록 조회 로직
5. 투여 스케줄 조회 로직 (계획된 투여 횟수 산출용)
6. 주사 부위 이력 집계 로직
7. 순응도 계산 로직 (실제 투여 횟수 / 계획된 투여 횟수 * 100)
8. SharedDataReport 생성 및 반환

**Dependencies**:
- `Isar`
- `MedicationRepository`
- `TrackingRepository`
- `SharedDataRepository` (구현 대상)

---

### 3.4. DataSharingAggregator UseCase (Domain)

**Location**: `lib/features/data_sharing/domain/usecases/data_sharing_aggregator.dart`

**Responsibility**: 리포트 데이터를 UI용 통계로 변환

**Test Strategy**: Unit

**Test Scenarios**:
- Red Phase:
  - `test('should calculate weight change trend')`
  - `test('should analyze symptom severity trend')`
  - `test('should group symptoms by context tags')`
  - `test('should identify dose escalation points')`
  - `test('should calculate average symptom severity')`
  - `test('should calculate adherence rate from schedules and dose records')`
  - `test('should handle missed doses correctly')`
  - Edge Cases:
    - `test('should return zero trend when only one weight record exists')`
    - `test('should handle empty symptom logs gracefully')`

**Implementation Order**:
1. UseCase 클래스 생성
2. 체중 변화 추이 계산 (시작 체중, 현재 체중, 변화율)
3. 부작용 강도 추이 계산 (평균, 최대, 최소)
4. 컨텍스트 태그별 빈도 집계
5. 용량 증량 시점 식별 로직

**Dependencies**: `SharedDataReport`

---

### 3.5. DataSharingNotifier (Application)

**Location**: `lib/features/data_sharing/application/notifiers/data_sharing_notifier.dart`

**Responsibility**: 공유 모드 상태 관리 및 UseCase 호출

**Test Strategy**: Integration

**Test Scenarios**:
- Red Phase:
  - `test('initial state should be inactive')`
  - `test('should enter sharing mode with selected period')`
  - `test('should load report data when entering sharing mode')`
  - `test('should exit sharing mode and reset state')`
  - `test('should update report when period changes')`
  - `test('should handle repository errors gracefully')`
  - Edge Cases:
    - `test('should prevent entering sharing mode when already active')`
    - `test('should handle loading timeout')`

**Implementation Order**:
1. Notifier 클래스 생성 (AsyncNotifier 상속)
2. 초기 상태 정의 (isActive: false)
3. `enterSharingMode(DateRange period)` 메서드
4. `exitSharingMode()` 메서드
5. `changePeriod(DateRange period)` 메서드
6. Repository 호출 및 상태 업데이트

**Dependencies**:
- `SharedDataRepository`
- `DataSharingAggregator`

---

### 3.6. DataSharingScreen (Presentation)

**Location**: `lib/features/data_sharing/presentation/screens/data_sharing_screen.dart`

**Responsibility**: 읽기 전용 리포트 화면 렌더링

**Test Strategy**: Widget Test

**Test Scenarios**:
- Red Phase:
  - `testWidgets('should display period selector')`
  - `testWidgets('should hide edit buttons in sharing mode')`
  - `testWidgets('should display adherence rate')`
  - `testWidgets('should display weight trend chart')`
  - `testWidgets('should display symptom severity chart')`
  - `testWidgets('should display injection site history table')`
  - `testWidgets('should display symptom check summary')`
  - `testWidgets('should display exit sharing mode button')`
  - `testWidgets('should navigate to home when exiting sharing mode')`
  - `testWidgets('should show confirmation dialog on back button press')`
  - `testWidgets('should exit sharing mode when confirmed in dialog')`
  - `testWidgets('should stay in sharing mode when cancelled in dialog')`
  - `testWidgets('should show detail popup when chart is tapped')`
  - `testWidgets('should display correct data for tapped chart point')`
  - `testWidgets('should dismiss detail popup when tapping outside')`
  - Edge Cases:
    - `testWidgets('should show empty state when no data exists')`
    - `testWidgets('should show loading indicator during data fetch')`

**Implementation Order**:
1. Screen Scaffold 생성
2. Period Selector 위젯 통합
3. PopScope 위젯 통합 (백 버튼 인터셉트)
4. 확인 다이얼로그 구현 ("공유를 종료하시겠습니까?")
5. 리포트 섹션 레이아웃 (우선순위 순서):
   1) 투여 기록 타임라인 + 순응도
   2) 주사 부위 순환 이력
   3) 체중 변화 그래프
   4) 부작용 강도 추이 + 발생 패턴
   5) 증상 체크 이력
6. 읽기 전용 모드 UI 적용 (편집 버튼 숨김)
7. 공유 종료 버튼
8. 차트 터치 이벤트 핸들러 구현
9. 상세 데이터 팝업 위젯 (해당 시점의 투여/체중/부작용 정보)
10. 데이터 없음 상태 처리

**Dependencies**:
- `DataSharingNotifier`
- Chart 위젯 (`fl_chart` 또는 자체 구현)

**QA Sheet (수동 테스트)**:
- [ ] 공유 모드 진입 시 개인화 요소(뱃지, 인사) 숨김 확인
- [ ] 기간 변경 시 데이터 재조회 확인
- [ ] 차트 터치 시 상세 데이터 팝업 확인
- [ ] 편집 버튼 클릭 시 "읽기 전용" 토스트 확인
- [ ] 백 버튼 시 확인 다이얼로그 확인
- [ ] 공유 종료 후 홈 화면 복귀 확인
- [ ] 로딩 인디케이터 표시 확인 (>1초 시)

---

### 3.7. Provider Setup (Application)

**Location**: `lib/features/data_sharing/application/providers.dart`

**Responsibility**: Riverpod Provider 정의

**Test Strategy**: Integration

**Test Scenarios**:
- Red Phase:
  - `test('should provide SharedDataRepository instance')`
  - `test('should provide DataSharingNotifier instance')`
  - `test('should watch notifier state changes')`

**Implementation Order**:
1. Repository Provider 정의
2. Notifier Provider 정의
3. Derived Provider (필요 시)

**Dependencies**:
- `IsarSharedDataRepository`
- `DataSharingNotifier`

---

## 4. TDD Workflow

### 시작: Domain Layer (Inside-Out)

1. **SharedDataReport Entity**
   - Red: 엔티티 필드 테스트 작성
   - Green: 엔티티 클래스 구현
   - Refactor: Immutability 보장, copyWith 추가
   - Commit: `feat(data-sharing): add SharedDataReport entity`

2. **SharedDataRepository Interface**
   - Red: 인터페이스 메서드 시그니처 테스트
   - Green: 인터페이스 정의
   - Commit: `feat(data-sharing): add SharedDataRepository interface`

3. **DataSharingAggregator UseCase**
   - Red: 집계 로직 테스트 (체중 추이, 부작용 패턴)
   - Green: 집계 메서드 구현
   - Refactor: 계산 로직 분리
   - Commit: `feat(data-sharing): add data aggregation use case`

---

### 진행: Infrastructure Layer

4. **IsarSharedDataRepository**
   - Red: 기간별 데이터 조회 테스트 (Integration)
   - Green: Isar 쿼리 구현
   - Refactor: 쿼리 최적화
   - Commit: `feat(data-sharing): implement Isar repository`

---

### 진행: Application Layer

5. **DataSharingNotifier**
   - Red: 상태 전환 테스트 (진입/종료/기간 변경)
   - Green: Notifier 로직 구현
   - Refactor: 에러 핸들링 개선
   - Commit: `feat(data-sharing): add notifier for sharing mode`

6. **Provider Setup**
   - Red: Provider 의존성 테스트
   - Green: Provider 정의
   - Commit: `feat(data-sharing): setup providers`

---

### 완료: Presentation Layer

7. **DataSharingScreen Widget**
   - Red: UI 렌더링 테스트 (Widget Test)
   - Green: Screen 레이아웃 구현
   - Refactor: 위젯 분리 (PeriodSelector, ChartSection)
   - Commit: `feat(data-sharing): add data sharing screen`

8. **Integration Test**
   - Red: End-to-End 시나리오 테스트
   - Green: 전체 흐름 통합
   - Commit: `test(data-sharing): add e2e integration tests`

---

### Commit 포인트 제안

- 각 모듈 완성 시점마다 커밋
- 테스트 통과 확인 후 커밋
- Refactor 완료 후 별도 커밋

---

## 5. Test Pyramid 구성

- **Unit Tests (70%)**:
  - SharedDataReport 엔티티 로직
  - DataSharingAggregator 집계 로직
  - DateRange 계산 로직

- **Integration Tests (20%)**:
  - IsarSharedDataRepository 데이터 조회
  - DataSharingNotifier 상태 관리
  - Provider 의존성 주입

- **Widget Tests (10%)**:
  - DataSharingScreen UI 렌더링
  - 읽기 전용 모드 검증
  - 기간 선택 UI 동작

---

## 6. 핵심 원칙

### Test First
- 모든 로직은 테스트 작성 후 구현
- AAA 패턴 준수 (Arrange, Act, Assert)
- Small Steps: 한 번에 하나의 시나리오만 구현

### FIRST
- Fast: 단위 테스트는 밀리초 단위
- Independent: 테스트 간 의존성 없음
- Repeatable: 동일한 결과 보장
- Self-validating: Pass/Fail 명확
- Timely: 코드 작성 직전에 테스트 작성

### Inside-Out 전략
- Core Logic (Domain) → Infrastructure → Application → Presentation
- 비즈니스 로직 먼저 검증 후 UI 통합

---

## 7. Edge Cases 처리

### 데이터 부재
- 선택 기간에 데이터 없음: 빈 리포트 반환
- 일부 데이터만 존재: 존재하는 항목만 표시

### 오작동 방지
- 공유 모드에서 편집 시도: UI 차단 + 토스트 메시지
- 백 버튼 시도: 확인 다이얼로그

### 대용량 데이터
- 렌더링 지연: 로딩 인디케이터 (>1초)
- 전체 기간 데이터: 가상 스크롤 적용

### 에러 핸들링
- Repository 조회 실패: 에러 상태 반환 + 재시도 버튼
- 네트워크 오류: 로컬 캐시 우선 조회 (Phase 1 대비)

---

## 8. 성능 요구사항

- 데이터 조회 시간: < 1초
- 차트 렌더링: < 500ms
- 기간 변경 응답: < 300ms

---

## 9. Phase 0 → Phase 1 전환 대비

**변경 사항**: Infrastructure Layer ONLY

```dart
// Phase 0
@riverpod
SharedDataRepository sharedDataRepository(ref) =>
  IsarSharedDataRepository(ref.watch(isarProvider));

// Phase 1
@riverpod
SharedDataRepository sharedDataRepository(ref) =>
  SupabaseSharedDataRepository(ref.watch(supabaseProvider));
```

**Zero changes**: Domain, Application, Presentation
</file>

<file path="005/spec.md">
# UC-F003: 데이터 공유 모드

## Primary Actor
GLP-1 사용자

## Precondition
- 사용자가 앱에 로그인되어 있음
- 투여 기록, 체중 기록, 부작용 기록 중 최소 하나 이상 존재함
- 사용자가 의료진 또는 타인에게 기록을 보여줄 상황에 놓여 있음

## Trigger
사용자가 앱 내 "기록 보여주기" 또는 "데이터 공유 모드" 버튼을 클릭함

## Main Scenario

### 1. 공유 모드 진입
- 사용자가 홈 대시보드 또는 기록 관련 화면에서 "기록 보여주기" 버튼 선택
- 시스템이 데이터 공유 모드로 전환
- 개인화 인사, 뱃지, 설정 등 무관한 UI 요소를 숨김
- 모든 편집 기능을 비활성화하여 읽기 전용 모드로 전환
- 기간 선택 UI 표시 (기본값: 최근 1개월)

### 2. 기간 선택
- 사용자가 표시 기간 선택 (최근 1개월/3개월/전체)
- 시스템이 선택된 기간의 데이터 조회 및 집계

### 3. 데이터 렌더링
- 시스템이 가독성 높은 전용 UI로 다음 데이터를 순차 표시:
  - **투여 기록 타임라인**: 날짜별 투여 이력, 용량 변화 시각화
  - **투여 순응도**: 계획 대비 실제 투여 완료율 백분율로 표시
  - **주사 부위 순환 이력**: 복부/허벅지/상완 부위별 사용 이력 표
  - **체중 변화 그래프**: 날짜별 체중 추이, 목표 체중 라인 함께 표시
  - **부작용 강도 추이**: 증상별 심각도 변화, 용량 증량 시점 마커 표시
  - **부작용 발생 패턴**: 컨텍스트 태그별 빈도 차트
  - **증상 체크 이력**: 심각 증상 체크 기록 요약

### 4. 데이터 탐색
- 사용자가 화면 스크롤로 상세 데이터 확인
- 사용자가 차트 터치 시 해당 시점의 상세 데이터 표시
- 사용자가 기간 변경 시 데이터 재조회 및 렌더링

### 5. 공유 종료
- 사용자가 "공유 종료" 버튼 클릭
- 시스템이 일반 모드로 복귀
- 홈 대시보드로 자동 이동

## Edge Cases

### 데이터 부재
- 선택 기간에 데이터가 전혀 없는 경우: "해당 기간에 기록이 없습니다" 안내 메시지 표시
- 일부 데이터만 존재하는 경우: 존재하는 항목만 표시하고 누락된 항목은 "기록 없음" 상태로 표시

### 오작동 방지
- 공유 모드에서 편집 시도 시: "읽기 전용 모드입니다" 토스트 메시지 표시
- 백 버튼 또는 제스처로 나가기 시도 시: "공유를 종료하시겠습니까?" 확인 대화상자 표시

### 대용량 데이터
- 데이터 렌더링 시간이 1초 초과 시: 로딩 인디케이터 표시
- 전체 기간 데이터가 6개월 이상인 경우: 페이지네이션 또는 가상 스크롤 적용

### 화면 캡처
- 화면 캡처 시도 시: 제한 없이 허용 (사용자 의도에 따름)

### 데이터 로딩 실패
- 네트워크 오류 또는 데이터베이스 오류 시: 에러 메시지 및 "다시 시도" 버튼 표시
- 재시도 후에도 실패 시: 공유 모드 자동 종료 후 홈으로 복귀

## Business Rules

### BR-1: 읽기 전용 원칙
- 데이터 공유 모드에서는 모든 편집, 추가, 삭제 기능이 완전히 비활성화됨
- 사용자는 데이터 열람 및 탐색만 가능함

### BR-2: UI 단순화
- 공유 모드는 데이터 확인 목적에만 집중
- 개인화 요소(인사, 뱃지, 인사이트 등) 및 설정 메뉴는 숨김 처리
- 차트와 텍스트의 가독성을 최대화한 전용 UI 적용

### BR-3: 데이터 표시 우선순위
1. 투여 기록 및 순응도 (치료 핵심 지표)
2. 체중 변화 (치료 목표 지표)
3. 부작용 기록 (안전성 지표)
4. 증상 체크 이력 (응급 대응 지표)

### BR-4: 기간 필터
- 기본 기간: 최근 1개월
- 선택 가능 기간: 1개월/3개월/전체
- 전체 기간 선택 시 치료 시작일부터 현재까지 모든 데이터 표시

### BR-5: 화면 이동 제한
- 공유 모드 활성화 상태에서는 다른 화면으로 이동 불가
- "공유 종료" 버튼을 통해서만 모드 해제 가능
- 백 버튼 사용 시 확인 대화상자 표시 후 종료 결정

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE
participant BE
database Database

User -> FE: "기록 보여주기" 버튼 클릭
activate FE
FE -> FE: 데이터 공유 모드로 UI 전환
FE -> FE: 편집 기능 비활성화
FE -> FE: 무관한 UI 요소 숨김
FE -> User: 기간 선택 UI 표시 (기본: 최근 1개월)
deactivate FE

User -> FE: 표시 기간 선택 (1개월/3개월/전체)
activate FE
FE -> Database: 선택 기간 내 투여 기록 조회
Database --> FE: 투여 기록 반환
FE -> Database: 선택 기간 내 체중 기록 조회
Database --> FE: 체중 기록 반환
FE -> Database: 선택 기간 내 부작용 기록 조회
Database --> FE: 부작용 기록 반환
FE -> Database: 선택 기간 내 증상 체크 기록 조회
Database --> FE: 증상 체크 기록 반환
FE -> Database: 투여 계획 및 스케줄 조회
Database --> FE: 투여 계획 및 스케줄 반환

FE -> FE: 투여 순응도 계산
FE -> FE: 부작용 패턴 분석
FE -> FE: 데이터 시각화 준비

FE -> User: 투여 기록 타임라인 표시
FE -> User: 투여 순응도 표시
FE -> User: 주사 부위 순환 이력 표시
FE -> User: 체중 변화 그래프 표시
FE -> User: 부작용 강도 추이 표시
FE -> User: 부작용 발생 패턴 표시
FE -> User: 증상 체크 이력 표시
deactivate FE

User -> FE: 차트 터치
activate FE
FE -> User: 해당 시점 상세 데이터 팝업 표시
deactivate FE

User -> FE: 화면 스크롤로 데이터 탐색
activate FE
FE -> User: 스크롤된 영역의 데이터 표시
deactivate FE

User -> FE: 기간 재선택
activate FE
FE -> Database: 새 기간 내 데이터 조회
Database --> FE: 데이터 반환
FE -> FE: 데이터 재집계 및 시각화
FE -> User: 업데이트된 데이터 표시
deactivate FE

User -> FE: "공유 종료" 버튼 클릭
activate FE
FE -> FE: 일반 모드로 UI 복원
FE -> FE: 편집 기능 재활성화
FE -> FE: 숨긴 UI 요소 복원
FE -> User: 홈 대시보드로 이동
deactivate FE

@enduml
```
</file>

<file path="006/plan.md">
# F004: 부작용 대처 가이드 Implementation Plan

## 1. 개요

F004는 부작용 기록 완료 시 자동으로 대처 가이드를 표시하고, 가이드 탭에서 증상별 가이드를 직접 조회할 수 있는 기능입니다.

### 모듈 구조
- **CopingGuideRepository** (Domain/Infrastructure): 가이드 조회 인터페이스 및 구현 (정적 데이터)
- **FeedbackRepository** (Domain/Infrastructure): 피드백 저장 인터페이스 및 구현
- **CopingGuideNotifier** (Application): 가이드 조회, 심각도 체크 및 피드백 상태 관리
- **CopingGuideScreen** (Presentation): 가이드 탭 화면
- **CopingGuideCard** (Presentation): 가이드 카드 위젯 (심각도 경고 배너 포함)
- **FeedbackWidget** (Presentation): 피드백 UI

### TDD 적용 범위
- Unit Tests: CopingGuideService, CopingGuideRepository (70%)
- Integration Tests: CopingGuideNotifier와 Repository 연동 (20%)
- Widget Tests: CopingGuideCard, FeedbackWidget (10%)

---

## 2. Architecture Diagram

```mermaid
graph TD
    %% Presentation Layer
    SymptomRecordScreen[SymptomRecordScreen<br/>F002]
    CopingGuideScreen[CopingGuideScreen<br/>가이드 탭]
    CopingGuideCard[CopingGuideCard<br/>가이드 카드]
    DetailedGuideScreen[DetailedGuideScreen<br/>상세 가이드]
    FeedbackWidget[FeedbackWidget<br/>피드백 UI]

    %% Application Layer
    CopingGuideNotifier[CopingGuideNotifier<br/>상태 관리]

    %% Domain Layer
    CopingGuideRepoInterface[CopingGuideRepository<br/>Interface]
    FeedbackRepoInterface[FeedbackRepository<br/>Interface]
    CopingGuide[CopingGuide<br/>Entity]
    GuideSection[GuideSection<br/>Entity]
    GuideFeedback[GuideFeedback<br/>Entity]
    CopingGuideState[CopingGuideState<br/>State Object]

    %% Infrastructure Layer
    StaticCopingGuideRepo[StaticCopingGuideRepository<br/>구현체]
    IsarFeedbackRepo[IsarFeedbackRepository<br/>구현체]
    GuideFeedbackDto[GuideFeedbackDto<br/>Isar Model]

    %% 관계
    SymptomRecordScreen --> CopingGuideCard
    CopingGuideScreen --> CopingGuideCard
    CopingGuideCard --> DetailedGuideScreen
    CopingGuideCard --> FeedbackWidget

    SymptomRecordScreen --> CopingGuideNotifier
    CopingGuideScreen --> CopingGuideNotifier
    CopingGuideCard --> CopingGuideNotifier
    DetailedGuideScreen --> CopingGuideNotifier
    FeedbackWidget --> CopingGuideNotifier

    CopingGuideNotifier --> CopingGuideRepoInterface
    CopingGuideNotifier --> FeedbackRepoInterface
    CopingGuideRepoInterface --> CopingGuide
    CopingGuideRepoInterface --> GuideSection
    FeedbackRepoInterface --> GuideFeedback
    CopingGuideNotifier --> CopingGuideState

    StaticCopingGuideRepo .->|implements| CopingGuideRepoInterface
    IsarFeedbackRepo .->|implements| FeedbackRepoInterface
    IsarFeedbackRepo --> GuideFeedbackDto
    GuideFeedbackDto --> GuideFeedback
```

---

## 3. Implementation Plan

### 3.1. Domain Layer - CopingGuide Entity

**Location**: `lib/features/coping_guide/domain/entities/coping_guide.dart`

**Responsibility**: 가이드 데이터 구조 정의

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```dart
// AAA 패턴
group('CopingGuide', () {
  test('증상명과 간단 가이드로 생성 가능', () {
    // Arrange & Act
    final guide = CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '소량씩 자주 식사하세요',
    );

    // Assert
    expect(guide.symptomName, '메스꺼움');
    expect(guide.shortGuide, '소량씩 자주 식사하세요');
  });

  test('상세 가이드 섹션 리스트를 포함할 수 있음', () {
    // Arrange
    final sections = [
      GuideSection(title: '즉시 조치', content: '물 마시기'),
      GuideSection(title: '식이 조절', content: '기름진 음식 피하기'),
    ];

    // Act
    final guide = CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '소량씩 자주 식사하세요',
      detailedSections: sections,
    );

    // Assert
    expect(guide.detailedSections, sections);
    expect(guide.detailedSections.length, 2);
  });
});

group('GuideSection', () {
  test('제목과 내용으로 생성 가능', () {
    // Arrange & Act
    final section = GuideSection(
      title: '즉시 조치',
      content: '물을 천천히 마시세요',
    );

    // Assert
    expect(section.title, '즉시 조치');
    expect(section.content, '물을 천천히 마시세요');
  });
});

group('GuideFeedback', () {
  test('증상명, 도움 여부, 타임스탬프로 생성 가능', () {
    // Arrange & Act
    final feedback = GuideFeedback(
      symptomName: '메스꺼움',
      helpful: true,
      timestamp: DateTime(2025, 1, 1),
    );

    // Assert
    expect(feedback.symptomName, '메스꺼움');
    expect(feedback.helpful, isTrue);
    expect(feedback.timestamp, DateTime(2025, 1, 1));
  });
});

group('CopingGuideState', () {
  test('가이드와 심각도 경고 플래그로 생성 가능', () {
    // Arrange
    final guide = CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '소량씩 자주 식사하세요',
    );

    // Act
    final state = CopingGuideState(
      guide: guide,
      showSeverityWarning: true,
    );

    // Assert
    expect(state.guide, guide);
    expect(state.showSeverityWarning, isTrue);
  });
});
```

**Edge Cases**:
- 빈 증상명 처리
- 빈 가이드 내용 처리
- null 상세 섹션 처리

**Implementation Order**:
1. CopingGuide 클래스 정의 (Red)
2. GuideSection 클래스 정의 (Red)
3. GuideFeedback 클래스 정의 (Red)
4. CopingGuideState 클래스 정의 (Red)
5. 최소 구현으로 테스트 통과 (Green)
6. Immutable 구조로 리팩토링 (Refactor)

**Dependencies**: 없음

---

### 3.2. Domain Layer - CopingGuideRepository Interface

**Location**: `lib/features/coping_guide/domain/repositories/coping_guide_repository.dart`

**Responsibility**: 가이드 조회 계약 정의

**Test Strategy**: Unit Test (Mock 사용)

**Test Scenarios (Red Phase)**:
```dart
group('CopingGuideRepository', () {
  test('증상명으로 가이드 조회 가능', () async {
    // Arrange
    final mockRepo = MockCopingGuideRepository();
    final expectedGuide = CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '소량씩 자주 식사하세요',
    );
    when(() => mockRepo.getGuideBySymptom('메스꺼움'))
        .thenAnswer((_) async => expectedGuide);

    // Act
    final result = await mockRepo.getGuideBySymptom('메스꺼움');

    // Assert
    expect(result, expectedGuide);
    verify(() => mockRepo.getGuideBySymptom('메스꺼움')).called(1);
  });

  test('등록되지 않은 증상은 null 반환', () async {
    // Arrange
    final mockRepo = MockCopingGuideRepository();
    when(() => mockRepo.getGuideBySymptom('알 수 없는 증상'))
        .thenAnswer((_) async => null);

    // Act
    final result = await mockRepo.getGuideBySymptom('알 수 없는 증상');

    // Assert
    expect(result, isNull);
  });

  test('모든 증상의 가이드 목록 조회 가능', () async {
    // Arrange
    final mockRepo = MockCopingGuideRepository();
    final expectedGuides = [
      CopingGuide(symptomName: '메스꺼움', shortGuide: '...'),
      CopingGuide(symptomName: '구토', shortGuide: '...'),
    ];
    when(() => mockRepo.getAllGuides())
        .thenAnswer((_) async => expectedGuides);

    // Act
    final result = await mockRepo.getAllGuides();

    // Assert
    expect(result, expectedGuides);
    expect(result.length, 2);
  });
});
```

**Edge Cases**:
- 빈 증상명 입력
- null 입력 처리
- Repository 조회 실패 시 예외 처리

**Implementation Order**:
1. Interface 메서드 시그니처 정의 (Red)
2. Mock 구현 테스트 (Green)
3. 메서드 문서화 (Refactor)

**Dependencies**: CopingGuide Entity

---

### 3.3. Domain Layer - FeedbackRepository Interface

**Location**: `lib/features/coping_guide/domain/repositories/feedback_repository.dart`

**Responsibility**: 피드백 저장 계약 정의

**Test Strategy**: Unit Test (Mock 사용)

**Test Scenarios (Red Phase)**:
```dart
group('FeedbackRepository', () {
  test('피드백 저장 가능', () async {
    // Arrange
    final mockRepo = MockFeedbackRepository();
    final feedback = GuideFeedback(
      symptomName: '메스꺼움',
      helpful: true,
      timestamp: DateTime.now(),
    );
    when(() => mockRepo.saveFeedback(feedback))
        .thenAnswer((_) async => {});

    // Act
    await mockRepo.saveFeedback(feedback);

    // Assert
    verify(() => mockRepo.saveFeedback(feedback)).called(1);
  });

  test('증상별 피드백 조회 가능', () async {
    // Arrange
    final mockRepo = MockFeedbackRepository();
    final expectedFeedbacks = [
      GuideFeedback(
        symptomName: '메스꺼움',
        helpful: true,
        timestamp: DateTime(2025, 1, 1),
      ),
    ];
    when(() => mockRepo.getFeedbacksBySymptom('메스꺼움'))
        .thenAnswer((_) async => expectedFeedbacks);

    // Act
    final result = await mockRepo.getFeedbacksBySymptom('메스꺼움');

    // Assert
    expect(result, expectedFeedbacks);
    expect(result.length, 1);
  });
});
```

**Edge Cases**:
- 저장 실패 시 예외 처리
- null 입력 처리

**Implementation Order**:
1. Interface 메서드 시그니처 정의 (Red)
2. Mock 구현 테스트 (Green)
3. 메서드 문서화 (Refactor)

**Dependencies**: GuideFeedback Entity

---

### 3.4. Infrastructure Layer - StaticCopingGuideRepository

**Location**: `lib/features/coping_guide/infrastructure/repositories/static_coping_guide_repository.dart`

**Responsibility**: 정적 가이드 데이터 조회 (하드코딩된 데이터 반환)

**Test Strategy**: Integration Test

**Test Scenarios (Red Phase)**:
```dart
group('StaticCopingGuideRepository', () {
  late StaticCopingGuideRepository repository;

  setUp(() {
    repository = StaticCopingGuideRepository();
  });

  test('메스꺼움 증상의 가이드를 반환', () async {
    // Act
    final result = await repository.getGuideBySymptom('메스꺼움');

    // Assert
    expect(result, isNotNull);
    expect(result!.symptomName, '메스꺼움');
    expect(result.shortGuide, isNotEmpty);
    expect(result.detailedSections, isNotEmpty);
  });

  test('모든 7가지 증상의 가이드를 반환', () async {
    // Arrange
    final expectedSymptoms = ['메스꺼움', '구토', '변비', '설사', '복통', '두통', '피로'];

    // Act
    final result = await repository.getAllGuides();

    // Assert
    expect(result.length, 7);
    for (var symptom in expectedSymptoms) {
      expect(result.any((g) => g.symptomName == symptom), isTrue);
    }
  });

  test('등록되지 않은 증상은 null 반환', () async {
    // Act
    final result = await repository.getGuideBySymptom('알 수 없는 증상');

    // Assert
    expect(result, isNull);
  });

  test('가이드 데이터는 긍정적인 톤으로 작성됨', () async {
    // Act
    final guides = await repository.getAllGuides();

    // Assert
    for (var guide in guides) {
      expect(guide.shortGuide, isNot(contains('위험')));
      expect(guide.shortGuide, isNot(contains('심각')));
    }
  });
});
```

**Edge Cases**:
- 빈 가이드 데이터 처리
- 데이터 상수 초기화 실패

**Implementation Order**:
1. 하드코딩된 7가지 증상 가이드 데이터 작성 (Red)
2. Repository 인터페이스 구현 (Green)
3. 가이드 데이터 상수로 분리 (Refactor)
4. GuideSection 구조 적용 (Refactor)

**Dependencies**: CopingGuideRepository Interface

---

### 3.5. Infrastructure Layer - IsarFeedbackRepository

**Location**: `lib/features/coping_guide/infrastructure/repositories/isar_feedback_repository.dart`

**Responsibility**: Isar를 통한 피드백 저장 및 조회

**Test Strategy**: Integration Test

**Test Scenarios (Red Phase)**:
```dart
group('IsarFeedbackRepository', () {
  late Isar isar;
  late IsarFeedbackRepository repository;

  setUp(() async {
    isar = await Isar.open(
      [GuideFeedbackDtoSchema],
      directory: await getTemporaryDirectory(),
    );
    repository = IsarFeedbackRepository(isar);
  });

  tearDown(() async {
    await isar.close(deleteFromDisk: true);
  });

  test('피드백 저장 성공', () async {
    // Arrange
    final feedback = GuideFeedback(
      symptomName: '메스꺼움',
      helpful: true,
      timestamp: DateTime.now(),
    );

    // Act
    await repository.saveFeedback(feedback);

    // Assert
    final saved = await repository.getFeedbacksBySymptom('메스꺼움');
    expect(saved.length, 1);
    expect(saved.first.symptomName, '메스꺼움');
    expect(saved.first.helpful, isTrue);
  });

  test('증상별 피드백 조회', () async {
    // Arrange
    final feedback1 = GuideFeedback(
      symptomName: '메스꺼움',
      helpful: true,
      timestamp: DateTime.now(),
    );
    final feedback2 = GuideFeedback(
      symptomName: '구토',
      helpful: false,
      timestamp: DateTime.now(),
    );
    await repository.saveFeedback(feedback1);
    await repository.saveFeedback(feedback2);

    // Act
    final result = await repository.getFeedbacksBySymptom('메스꺼움');

    // Assert
    expect(result.length, 1);
    expect(result.first.symptomName, '메스꺼움');
  });
});
```

**Edge Cases**:
- Isar 초기화 실패
- 중복 피드백 저장
- 빈 증상명 처리

**Implementation Order**:
1. GuideFeedbackDto 정의 (Red)
2. saveFeedback 구현 (Green)
3. getFeedbacksBySymptom 구현 (Green)
4. 에러 핸들링 추가 (Refactor)

**Dependencies**: FeedbackRepository Interface, GuideFeedback Entity, Isar

---

### 3.6. Infrastructure Layer - GuideFeedbackDto

**Location**: `lib/features/coping_guide/infrastructure/dtos/guide_feedback_dto.dart`

**Responsibility**: Isar 피드백 데이터 모델 및 Entity 변환

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```dart
group('GuideFeedbackDto', () {
  test('Entity에서 DTO로 변환', () {
    // Arrange
    final entity = GuideFeedback(
      symptomName: '메스꺼움',
      helpful: true,
      timestamp: DateTime(2025, 1, 1),
    );

    // Act
    final dto = GuideFeedbackDto.fromEntity(entity);

    // Assert
    expect(dto.symptomName, entity.symptomName);
    expect(dto.helpful, entity.helpful);
    expect(dto.timestamp, entity.timestamp);
  });

  test('DTO에서 Entity로 변환', () {
    // Arrange
    final dto = GuideFeedbackDto()
      ..symptomName = '메스꺼움'
      ..helpful = true
      ..timestamp = DateTime(2025, 1, 1);

    // Act
    final entity = dto.toEntity();

    // Assert
    expect(entity.symptomName, dto.symptomName);
    expect(entity.helpful, dto.helpful);
    expect(entity.timestamp, dto.timestamp);
  });
});
```

**Edge Cases**:
- null 타임스탬프 처리

**Implementation Order**:
1. Isar 스키마 정의 (Red)
2. toEntity/fromEntity 메서드 구현 (Green)

**Dependencies**: GuideFeedback Entity, Isar

---

### 3.7. Application Layer - CopingGuideNotifier

**Location**: `lib/features/coping_guide/application/notifiers/coping_guide_notifier.dart`

**Responsibility**: 가이드 조회, 심각도 체크 및 피드백 상태 관리

**Test Strategy**: Unit Test (Mock Repository)

**Test Scenarios (Red Phase)**:
```dart
group('CopingGuideNotifier', () {
  late MockCopingGuideRepository mockRepo;
  late ProviderContainer container;

  setUp(() {
    mockRepo = MockCopingGuideRepository();
    container = ProviderContainer(
      overrides: [
        copingGuideRepositoryProvider.overrideWithValue(mockRepo),
      ],
    );
  });

  tearDown(() {
    container.dispose();
  });

  test('초기 상태는 loading', () {
    // Act
    final notifier = container.read(copingGuideNotifierProvider.notifier);
    final state = container.read(copingGuideNotifierProvider);

    // Assert
    expect(state, isA<AsyncLoading>());
  });

  test('증상명으로 가이드 조회 성공', () async {
    // Arrange
    final expectedGuide = CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '소량씩 자주 식사하세요',
    );
    when(() => mockRepo.getGuideBySymptom('메스꺼움'))
        .thenAnswer((_) async => expectedGuide);

    // Act
    final notifier = container.read(copingGuideNotifierProvider.notifier);
    await notifier.getGuideBySymptom('메스꺼움');

    // Assert
    final state = container.read(copingGuideNotifierProvider);
    expect(state.value, expectedGuide);
    verify(() => mockRepo.getGuideBySymptom('메스꺼움')).called(1);
  });

  test('등록되지 않은 증상은 기본 가이드 반환', () async {
    // Arrange
    when(() => mockRepo.getGuideBySymptom('알 수 없는 증상'))
        .thenAnswer((_) async => null);

    // Act
    final notifier = container.read(copingGuideNotifierProvider.notifier);
    await notifier.getGuideBySymptom('알 수 없는 증상');

    // Assert
    final state = container.read(copingGuideNotifierProvider);
    expect(state.value, isNotNull);
    expect(state.value!.symptomName, '일반');
    expect(state.value!.shortGuide, contains('전문가와 상담'));
  });

  test('모든 가이드 목록 조회', () async {
    // Arrange
    final expectedGuides = [
      CopingGuide(symptomName: '메스꺼움', shortGuide: '...'),
      CopingGuide(symptomName: '구토', shortGuide: '...'),
    ];
    when(() => mockRepo.getAllGuides())
        .thenAnswer((_) async => expectedGuides);

    // Act
    final notifier = container.read(copingGuideListNotifierProvider.notifier);
    await notifier.loadAllGuides();

    // Assert
    final state = container.read(copingGuideListNotifierProvider);
    expect(state.value, expectedGuides);
    expect(state.value!.length, 2);
  });

  test('심각도 7-10점, 24시간 이상 지속 시 경고 플래그 활성화', () async {
    // Arrange
    final expectedGuide = CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '소량씩 자주 식사하세요',
    );
    when(() => mockRepo.getGuideBySymptom('메스꺼움'))
        .thenAnswer((_) async => expectedGuide);

    // Act
    final notifier = container.read(copingGuideNotifierProvider.notifier);
    await notifier.checkSeverityAndGuide('메스꺼움', 8, '24시간 이상');

    // Assert
    final state = container.read(copingGuideNotifierProvider);
    expect(state.value!.guide, expectedGuide);
    expect(state.value!.showSeverityWarning, isTrue);
  });

  test('심각도 6점 이하는 경고 플래그 비활성화', () async {
    // Arrange
    final expectedGuide = CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '소량씩 자주 식사하세요',
    );
    when(() => mockRepo.getGuideBySymptom('메스꺼움'))
        .thenAnswer((_) async => expectedGuide);

    // Act
    final notifier = container.read(copingGuideNotifierProvider.notifier);
    await notifier.checkSeverityAndGuide('메스꺼움', 5, '24시간 이상');

    // Assert
    final state = container.read(copingGuideNotifierProvider);
    expect(state.value!.showSeverityWarning, isFalse);
  });

  test('피드백 제출 및 저장', () async {
    // Arrange
    final mockFeedbackRepo = MockFeedbackRepository();
    container = ProviderContainer(
      overrides: [
        copingGuideRepositoryProvider.overrideWithValue(mockRepo),
        feedbackRepositoryProvider.overrideWithValue(mockFeedbackRepo),
      ],
    );
    when(() => mockFeedbackRepo.saveFeedback(any()))
        .thenAnswer((_) async => {});

    // Act
    final notifier = container.read(copingGuideNotifierProvider.notifier);
    await notifier.submitFeedback('메스꺼움', helpful: true);

    // Assert
    verify(() => mockFeedbackRepo.saveFeedback(any())).called(1);
  });
});
```

**Edge Cases**:
- Repository 조회 실패 시 에러 상태
- 피드백 저장 실패 시 에러 처리
- 동시 다발적인 조회 요청

**Implementation Order**:
1. AsyncNotifier 기본 구조 작성 (Red)
2. getGuideBySymptom 구현 (Green)
3. 기본 가이드 fallback 로직 추가 (Green)
4. checkSeverityAndGuide 구현 (심각도 체크 로직) (Green)
5. submitFeedback 구현 (피드백 저장) (Green)
6. getAllGuides Provider 추가 (Refactor)

**Dependencies**: CopingGuideRepository, FeedbackRepository

---

### 3.8. Presentation Layer - CopingGuideCard Widget

**Location**: `lib/features/coping_guide/presentation/widgets/coping_guide_card.dart`

**Responsibility**: 간단 버전 가이드 카드 UI (심각도 경고 배너 포함)

**Test Strategy**: Widget Test

**Test Scenarios (Red Phase)**:
```dart
group('CopingGuideCard', () {
  testWidgets('증상명과 간단 가이드 표시', (tester) async {
    // Arrange
    final guide = CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '소량씩 자주 식사하세요',
    );

    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: CopingGuideCard(guide: guide),
        ),
      ),
    );

    // Assert
    expect(find.text('메스꺼움 대처 가이드'), findsOneWidget);
    expect(find.text('소량씩 자주 식사하세요'), findsOneWidget);
  });

  testWidgets('"더 자세한 가이드 보기" 버튼 표시', (tester) async {
    // Arrange
    final guide = CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '...',
    );

    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: CopingGuideCard(guide: guide),
        ),
      ),
    );

    // Assert
    expect(find.text('더 자세한 가이드 보기'), findsOneWidget);
  });

  testWidgets('피드백 위젯 표시', (tester) async {
    // Arrange
    final guide = CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '...',
    );

    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: CopingGuideCard(guide: guide),
        ),
      ),
    );

    // Assert
    expect(find.text('도움이 되었나요?'), findsOneWidget);
    expect(find.text('예'), findsOneWidget);
    expect(find.text('아니오'), findsOneWidget);
  });

  testWidgets('"더 자세한 가이드 보기" 탭 시 상세 화면 이동', (tester) async {
    // Arrange
    final guide = CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '...',
    );
    bool navigated = false;

    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: CopingGuideCard(
            guide: guide,
            onDetailTap: () => navigated = true,
          ),
        ),
      ),
    );
    await tester.tap(find.text('더 자세한 가이드 보기'));
    await tester.pumpAndSettle();

    // Assert
    expect(navigated, isTrue);
  });

  testWidgets('심각도 경고 플래그 활성화 시 경고 배너 표시', (tester) async {
    // Arrange
    final state = CopingGuideState(
      guide: CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '...',
      ),
      showSeverityWarning: true,
    );

    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: CopingGuideCard(state: state),
        ),
      ),
    );

    // Assert
    expect(find.text('증상이 심각하거나 지속됩니다'), findsOneWidget);
    expect(find.text('증상 체크하기'), findsOneWidget);
  });

  testWidgets('경고 배너의 "증상 체크하기" 버튼 탭 시 F005 화면 이동', (tester) async {
    // Arrange
    final state = CopingGuideState(
      guide: CopingGuide(
        symptomName: '메스꺼움',
        shortGuide: '...',
      ),
      showSeverityWarning: true,
    );
    bool navigatedToF005 = false;

    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: CopingGuideCard(
            state: state,
            onCheckSymptom: () => navigatedToF005 = true,
          ),
        ),
      ),
    );
    await tester.tap(find.text('증상 체크하기'));
    await tester.pumpAndSettle();

    // Assert
    expect(navigatedToF005, isTrue);
  });
});
```

**Edge Cases**:
- 긴 텍스트 줄바꿈 처리
- 다크모드 대응
- 심각도 경고와 일반 모드 전환

**Implementation Order**:
1. 기본 카드 레이아웃 (Red)
2. 텍스트 표시 (Green)
3. 버튼 추가 (Green)
4. FeedbackWidget 통합 (Refactor)
5. SeverityWarningBanner 추가 (심각도 경고 배너) (Green)
6. 스타일링 적용 (Refactor)

**Dependencies**: CopingGuide Entity, CopingGuideState, FeedbackWidget

**QA Sheet**:
- [ ] 카드가 화면에 정상 표시됨
- [ ] 증상명이 카드 상단에 표시됨
- [ ] 간단 가이드 텍스트가 읽기 쉬움
- [ ] "더 자세한 가이드 보기" 버튼 탭 시 상세 화면 이동
- [ ] 피드백 버튼이 하단에 표시됨
- [ ] 심각도 경고 배너가 조건부로 표시됨
- [ ] 경고 배너 탭 시 F005 화면 이동

---

### 3.9. Presentation Layer - DetailedGuideScreen

**Location**: `lib/features/coping_guide/presentation/screens/detailed_guide_screen.dart`

**Responsibility**: 단계별 상세 가이드 화면

**Test Strategy**: Widget Test

**Test Scenarios (Red Phase)**:
```dart
group('DetailedGuideScreen', () {
  testWidgets('증상명을 제목으로 표시', (tester) async {
    // Arrange
    final guide = CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '...',
      detailedSections: [],
    );

    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: DetailedGuideScreen(guide: guide),
      ),
    );

    // Assert
    expect(find.text('메스꺼움 대처 가이드'), findsOneWidget);
  });

  testWidgets('4가지 섹션을 순서대로 표시', (tester) async {
    // Arrange
    final guide = CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '...',
      detailedSections: [
        GuideSection(title: '즉시 조치', content: '물 마시기'),
        GuideSection(title: '식이 조절', content: '기름진 음식 피하기'),
        GuideSection(title: '생활 습관', content: '충분한 휴식'),
        GuideSection(title: '경과 관찰', content: '3일 후에도 지속 시 상담'),
      ],
    );

    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: DetailedGuideScreen(guide: guide),
      ),
    );

    // Assert
    expect(find.text('즉시 조치'), findsOneWidget);
    expect(find.text('식이 조절'), findsOneWidget);
    expect(find.text('생활 습관'), findsOneWidget);
    expect(find.text('경과 관찰'), findsOneWidget);
  });

  testWidgets('스크롤 가능', (tester) async {
    // Arrange
    final guide = CopingGuide(
      symptomName: '메스꺼움',
      shortGuide: '...',
      detailedSections: List.generate(
        10,
        (i) => GuideSection(title: '섹션 $i', content: '내용 ' * 50),
      ),
    );

    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: DetailedGuideScreen(guide: guide),
      ),
    );

    // Assert
    expect(find.byType(ListView), findsOneWidget);
  });
});
```

**Edge Cases**:
- detailedSections가 비어있는 경우
- 매우 긴 텍스트 처리

**Implementation Order**:
1. Scaffold 기본 구조 (Red)
2. AppBar 추가 (Green)
3. ListView로 섹션 표시 (Green)
4. 섹션 구분선 추가 (Refactor)
5. 스타일링 적용 (Refactor)

**Dependencies**: CopingGuide Entity

**QA Sheet**:
- [ ] 상세 가이드 화면이 정상 표시됨
- [ ] 4가지 섹션이 명확히 구분됨
- [ ] 스크롤이 부드러움
- [ ] 뒤로가기 버튼 동작
- [ ] 텍스트 가독성이 높음

---

### 3.10. Presentation Layer - FeedbackWidget

**Location**: `lib/features/coping_guide/presentation/widgets/feedback_widget.dart`

**Responsibility**: 피드백 UI 및 상호작용

**Test Strategy**: Widget Test

**Test Scenarios (Red Phase)**:
```dart
group('FeedbackWidget', () {
  testWidgets('"도움이 되었나요?" 텍스트 표시', (tester) async {
    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: FeedbackWidget(
            onFeedback: (helpful) {},
          ),
        ),
      ),
    );

    // Assert
    expect(find.text('도움이 되었나요?'), findsOneWidget);
  });

  testWidgets('"예", "아니오" 버튼 표시', (tester) async {
    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: FeedbackWidget(
            onFeedback: (helpful) {},
          ),
        ),
      ),
    );

    // Assert
    expect(find.text('예'), findsOneWidget);
    expect(find.text('아니오'), findsOneWidget);
  });

  testWidgets('"예" 탭 시 콜백 호출 및 감사 메시지 표시', (tester) async {
    // Arrange
    bool? callbackResult;

    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: FeedbackWidget(
            onFeedback: (helpful) => callbackResult = helpful,
          ),
        ),
      ),
    );
    await tester.tap(find.text('예'));
    await tester.pumpAndSettle();

    // Assert
    expect(callbackResult, isTrue);
    expect(find.text('도움이 되어 기쁩니다!'), findsOneWidget);
  });

  testWidgets('"아니오" 탭 시 추가 옵션 표시', (tester) async {
    // Arrange
    bool? callbackResult;

    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: FeedbackWidget(
            onFeedback: (helpful) => callbackResult = helpful,
          ),
        ),
      ),
    );
    await tester.tap(find.text('아니오'));
    await tester.pumpAndSettle();

    // Assert
    expect(callbackResult, isFalse);
    expect(find.text('더 자세한 가이드 보기'), findsOneWidget);
  });
});
```

**Edge Cases**:
- 빠른 연속 탭 방지
- 피드백 제출 실패 시 재시도

**Implementation Order**:
1. 기본 레이아웃 (Red)
2. 버튼 추가 (Green)
3. 상태 관리 추가 (Green)
4. 감사 메시지 표시 로직 (Green)
5. "아니오" 선택 시 상세 가이드로 이동 (Refactor)

**Dependencies**: 없음

**QA Sheet**:
- [ ] 피드백 질문이 명확히 표시됨
- [ ] 버튼 탭 시 즉시 반응
- [ ] 감사 메시지가 자연스럽게 표시됨
- [ ] "아니오" 선택 시 상세 가이드로 자연스럽게 이동

---

### 3.11. Presentation Layer - CopingGuideScreen

**Location**: `lib/features/coping_guide/presentation/screens/coping_guide_screen.dart`

**Responsibility**: 가이드 탭 화면 (증상 목록 및 직접 조회)

**Test Strategy**: Widget Test

**Test Scenarios (Red Phase)**:
```dart
group('CopingGuideScreen', () {
  testWidgets('7가지 증상 목록 표시', (tester) async {
    // Arrange
    final container = ProviderContainer(
      overrides: [
        copingGuideListNotifierProvider.overrideWith((ref) {
          return MockCopingGuideListNotifier([
            CopingGuide(symptomName: '메스꺼움', shortGuide: '...'),
            CopingGuide(symptomName: '구토', shortGuide: '...'),
            CopingGuide(symptomName: '변비', shortGuide: '...'),
            CopingGuide(symptomName: '설사', shortGuide: '...'),
            CopingGuide(symptomName: '복통', shortGuide: '...'),
            CopingGuide(symptomName: '두통', shortGuide: '...'),
            CopingGuide(symptomName: '피로', shortGuide: '...'),
          ]);
        }),
      ],
    );

    // Act
    await tester.pumpWidget(
      UncontrolledProviderScope(
        container: container,
        child: MaterialApp(
          home: CopingGuideScreen(),
        ),
      ),
    );
    await tester.pumpAndSettle();

    // Assert
    expect(find.text('메스꺼움'), findsOneWidget);
    expect(find.text('구토'), findsOneWidget);
    expect(find.text('변비'), findsOneWidget);
    expect(find.text('설사'), findsOneWidget);
    expect(find.text('복통'), findsOneWidget);
    expect(find.text('두통'), findsOneWidget);
    expect(find.text('피로'), findsOneWidget);
  });

  testWidgets('증상 탭 시 가이드 카드 표시', (tester) async {
    // Arrange
    final container = ProviderContainer(
      overrides: [
        copingGuideListNotifierProvider.overrideWith((ref) {
          return MockCopingGuideListNotifier([
            CopingGuide(symptomName: '메스꺼움', shortGuide: '소량씩 자주 식사하세요'),
          ]);
        }),
      ],
    );

    // Act
    await tester.pumpWidget(
      UncontrolledProviderScope(
        container: container,
        child: MaterialApp(
          home: CopingGuideScreen(),
        ),
      ),
    );
    await tester.pumpAndSettle();
    await tester.tap(find.text('메스꺼움'));
    await tester.pumpAndSettle();

    // Assert
    expect(find.text('소량씩 자주 식사하세요'), findsOneWidget);
  });

  testWidgets('로딩 중 인디케이터 표시', (tester) async {
    // Arrange
    final container = ProviderContainer(
      overrides: [
        copingGuideListNotifierProvider.overrideWith((ref) {
          return MockCopingGuideListNotifier(null, isLoading: true);
        }),
      ],
    );

    // Act
    await tester.pumpWidget(
      UncontrolledProviderScope(
        container: container,
        child: MaterialApp(
          home: CopingGuideScreen(),
        ),
      ),
    );

    // Assert
    expect(find.byType(CircularProgressIndicator), findsOneWidget);
  });
});
```

**Edge Cases**:
- 데이터 로딩 실패 시 에러 메시지
- 빈 목록 처리

**Implementation Order**:
1. Scaffold 기본 구조 (Red)
2. ListView 추가 (Green)
3. Provider 연동 (Green)
4. 로딩/에러 상태 처리 (Refactor)
5. 탭 인터랙션 추가 (Refactor)

**Dependencies**: CopingGuideNotifier, CopingGuideCard

**QA Sheet**:
- [ ] 가이드 탭 화면이 정상 표시됨
- [ ] 7가지 증상이 모두 나열됨
- [ ] 증상 탭 시 가이드가 표시됨
- [ ] 로딩 인디케이터가 자연스러움
- [ ] 에러 발생 시 안내 메시지 표시

---

## 4. TDD Workflow

### 단계별 진행 순서

1. **Domain Entities 구현** (Inside-Out)
   - Red: CopingGuide, GuideSection, GuideFeedback, CopingGuideState 테스트 작성
   - Green: 최소 구현
   - Refactor: Immutable 구조로 개선
   - Commit: "feat: add CopingGuide entities"

2. **Repository Interfaces 정의**
   - Red: CopingGuideRepository, FeedbackRepository 인터페이스 테스트 (Mock)
   - Green: Interfaces 정의
   - Refactor: 문서화 추가
   - Commit: "feat: add repository interfaces"

3. **Infrastructure - StaticCopingGuideRepository 구현**
   - Red: StaticCopingGuideRepository 테스트
   - Green: 하드코딩된 7가지 증상 가이드 반환
   - Refactor: 가이드 데이터 상수화
   - Commit: "feat: implement StaticCopingGuideRepository"

4. **Infrastructure - FeedbackRepository 구현**
   - Red: GuideFeedbackDto 변환 테스트
   - Green: fromEntity/toEntity 구현
   - Red: IsarFeedbackRepository 테스트
   - Green: 피드백 저장 및 조회 구현
   - Commit: "feat: implement IsarFeedbackRepository"

5. **Application - Notifier 구현**
   - Red: CopingGuideNotifier 테스트 (조회, 심각도 체크, 피드백)
   - Green: getGuideBySymptom 구현
   - Green: checkSeverityAndGuide 구현 (심각도 로직)
   - Green: submitFeedback 구현 (피드백 저장)
   - Refactor: 기본 가이드 fallback 추가
   - Commit: "feat: add CopingGuideNotifier with severity check"

6. **Presentation - FeedbackWidget**
   - Red: Widget 테스트
   - Green: 기본 UI 구현
   - Refactor: "아니오" 선택 시 상세 가이드 이동
   - Commit: "feat: add FeedbackWidget"

7. **Presentation - SeverityWarningBanner**
   - Red: Widget 테스트
   - Green: 경고 배너 UI 구현
   - Refactor: F005 화면 연동
   - Commit: "feat: add SeverityWarningBanner"

8. **Presentation - CopingGuideCard**
   - Red: Widget 테스트
   - Green: 카드 레이아웃 구현
   - Refactor: FeedbackWidget 및 SeverityWarningBanner 통합
   - Commit: "feat: add CopingGuideCard with severity warning"

9. **Presentation - DetailedGuideScreen**
   - Red: Widget 테스트
   - Green: 상세 화면 구현
   - Refactor: 스타일링 개선
   - Commit: "feat: add DetailedGuideScreen"

10. **Presentation - CopingGuideScreen**
    - Red: Widget 테스트
    - Green: 목록 화면 구현
    - Refactor: Provider 연동 및 에러 처리
    - Commit: "feat: add CopingGuideScreen"

11. **F002 연동 테스트**
    - Integration Test: 증상 기록 후 가이드 자동 표시 (심각도 체크 포함)
    - Commit: "feat: integrate coping guide with symptom tracking"

12. **F005 연동 테스트**
    - Integration Test: 심각 증상 시 F005 화면 이동
    - Commit: "feat: integrate severity check with F005"

### Commit 포인트
- 각 모듈의 Red → Green → Refactor 사이클 완료 시
- 테스트가 모두 통과한 상태에서만 커밋
- 커밋 메시지는 conventional commits 형식 준수

### 완료 기준
- [ ] 모든 Unit Tests 통과
- [ ] 모든 Widget Tests 통과
- [ ] Integration Tests 통과 (F002 연동)
- [ ] Code Coverage 80% 이상
- [ ] QA Sheet 모든 항목 확인
- [ ] 문서화 완료

---

## 5. 핵심 원칙 준수

### Layer Dependency
```
Presentation → Application → Domain ← Infrastructure
```

### Repository Pattern
- Application/Presentation은 Repository Interface만 의존
- Infrastructure에서 StaticCopingGuideRepository (가이드 조회), IsarFeedbackRepository (피드백 저장) 구현
- Phase 1 전환 시 SupabaseCopingGuideRepository, SupabaseFeedbackRepository로 1줄 변경

### Test-First Approach
- 모든 코드 작성 전 테스트 작성
- Red → Green → Refactor 사이클 엄격히 준수
- 테스트는 행동(behavior) 검증, 구현 세부사항은 테스트하지 않음

### FIRST Principles
- Fast: 모든 테스트는 밀리초 단위로 실행
- Independent: 테스트 간 공유 상태 없음
- Repeatable: 동일한 결과 보장
- Self-validating: Pass/Fail 명확
- Timely: 코드 작성 직전에 테스트 작성

### Code Quality
- 모든 코드는 분석 도구 경고 없음 (flutter analyze)
- 테스트 코드도 프로덕션 코드 수준 품질 유지
- 작은 단위로 커밋하여 이력 추적 용이

---

## 6. plancheck.md 반영 사항

### Critical Priority 수정 (필수)

**1. 피드백 저장 기능 추가 (plancheck 1.1)**
- GuideFeedback Entity 추가 (Domain Layer)
- FeedbackRepository Interface 추가 (Domain Layer)
- IsarFeedbackRepository 구현 추가 (Infrastructure Layer)
- GuideFeedbackDto 추가 (Infrastructure Layer)
- CopingGuideNotifier.submitFeedback() 실제 저장 로직 구현
- 피드백 저장 테스트 시나리오 추가

**2. 심각 증상 연계 로직 추가 (plancheck 1.2)**
- CopingGuideState Entity 추가 (showSeverityWarning 플래그 포함)
- CopingGuideNotifier.checkSeverityAndGuide() 메서드 추가
  - 심각도 7-10점 AND 24시간 이상 지속 시 경고 플래그 활성화
- SeverityWarningBanner Widget 추가 (Presentation Layer)
- CopingGuideCard에 심각도 경고 배너 통합
- F005 화면 연동 로직 추가
- 심각도 체크 테스트 시나리오 추가

### Medium Priority 수정 (강력 권장)

**3. 가이드 데이터 관리 단순화 (plancheck 1.4)**
- IsarCopingGuideRepository → StaticCopingGuideRepository로 변경
  - Phase 0에서 정적 데이터만 사용하므로 Isar DB 구조 제거
  - 하드코딩된 Map 또는 상수로 7가지 증상 가이드 관리
  - DTO 변환 오버헤드 제거
- CopingGuideDto 제거 (가이드 데이터는 정적이므로 불필요)
- 테스트 단순화 (Isar 의존성 제거)

**4. "다른 팁 보기" 기능 명확화 (plancheck 1.3)**
- "아니오" 선택 시 즉시 DetailedGuideScreen(상세 가이드)로 이동
- alternativeTips 필드는 추가하지 않음 (Phase 1로 연기)
- FeedbackWidget 로직 단순화

### 미반영 사항 (Low Priority)

**5. 여러 증상 동시 기록 처리 (plancheck 1.5)**
- Phase 0에서는 단일 증상 가이드 표시만 구현
- Phase 1에서 MultipleSymptomsGuideSelector Widget 추가 검토

### 수정 후 검증 항목
- [ ] spec.md의 BR-005 (피드백 저장) 반영
- [ ] spec.md의 BR-007 (심각 증상 연계) 반영
- [ ] spec.md의 Edge Case 5, 6 (정적 데이터 관리) 반영
- [ ] Layer Dependency 위배 없음
- [ ] Repository Pattern 올바르게 적용
- [ ] 모든 시나리오 테스트 포함
</file>

<file path="006/spec.md">
# UF-F004: 부작용 대처 가이드 상세 명세

## Primary Actor
GLP-1 사용자

## Precondition
- 사용자가 로그인 완료
- 사용자가 부작용 증상을 기록 완료 (F002)
- 또는 사용자가 가이드 탭에서 직접 증상별 가이드 조회

## Trigger
- 사용자가 부작용 기록(F002)을 완료하면 자동으로 해당 증상의 대처 가이드 표시
- 사용자가 앱 내 가이드 탭에서 특정 증상의 가이드를 직접 조회

## Main Scenario

### 1. 부작용 기록 후 자동 가이드 표시
1. 사용자가 부작용 기록 화면(F002)에서 증상 선택 및 심각도 입력 완료
2. 시스템이 기록된 증상에 매칭되는 간단 버전 대처 가이드를 조회
3. 시스템이 증상별 맞춤형 가이드 카드를 기록 완료 화면 하단에 표시
   - 메스꺼움: 식사 방법, 피해야 할 음식, 도움이 되는 음료, 주사 타이밍 조정 팁
   - 구토: 수분 보충 방법, 식사 재개 순서, 회복 단계별 접근법
   - 설사: 권장 식이요법, 수분 및 전해질 관리, 피해야 할 음식
   - 변비: 식이섬유 섭취, 수분 권장량, 신체 활동, 배변 습관 개선
   - 복통: 완화 방법, 식이 조절, 스트레스 관리 기법
   - 두통: 수분 섭취, 휴식 방법, 일상 관리 팁
   - 피로: 휴식 및 회복, 영양 관리, 활동량 조절
4. 사용자가 가이드 내용 확인
5. 시스템이 "도움이 되었나요?" 피드백 UI 표시
6. 사용자가 "예" 또는 "아니오" 선택

### 2. 피드백 처리
- **"예" 선택 시:**
  - 시스템이 간단한 감사 메시지 표시
  - 사용자가 홈 화면으로 자유롭게 이동 가능

- **"아니오" 선택 시:**
  - 시스템이 "다른 팁 보기" 또는 "의료진 상담 권장" 옵션 제공
  - 사용자가 "다른 팁 보기" 선택 시 동일 증상의 추가 팁 표시
  - 사용자가 "의료진 상담 권장" 선택 시 전문가 상담 안내 화면으로 이동

### 3. 상세 가이드 조회
1. 사용자가 "더 자세한 가이드 보기" 버튼 클릭
2. 시스템이 단계별로 구성된 상세 가이드 화면 표시
   - 즉시 조치: 증상 완화를 위한 즉각적 대응 방법
   - 식이 조절: 권장 식단 및 피해야 할 음식
   - 생활 습관: 일상 관리 팁 및 활동량 조절
   - 경과 관찰: 증상 모니터링 및 전문가 상담 시기 안내
3. 사용자가 단계별 내용 확인
4. 사용자가 가이드 화면 종료 후 홈 화면으로 복귀

### 4. 가이드 탭에서 직접 조회
1. 사용자가 앱 내 가이드 탭 선택
2. 시스템이 전체 증상 목록 표시
3. 사용자가 특정 증상 선택
4. 시스템이 해당 증상의 간단 버전 또는 상세 버전 가이드 표시
5. 사용자가 내용 확인 후 화면 종료

## Edge Cases

### 1. 등록되지 않은 증상 기록 시
- 시스템이 일반적인 대처 가이드 표시
- "전문가와 상담하여 구체적인 조언을 받으시기 바랍니다" 안내 제공

### 2. 여러 증상 동시 기록 시
- 시스템이 각 증상별 가이드를 순차적으로 표시
- 또는 증상 목록 형태로 제공하고 사용자가 선택하여 확인

### 3. 피드백 미선택 시
- 시스템이 강제하지 않고 사용자가 자유롭게 화면 이동 허용
- 피드백은 선택적 데이터 수집

### 4. 상세 가이드 로딩 실패 시
- 시스템이 간단 버전 가이드 유지
- 재시도 옵션 제공
- 오류 메시지 표시

### 5. 가이드 내용 업데이트 필요 시
- 가이드 데이터는 앱 내 정적 데이터로 관리
- 내용 업데이트는 앱 버전 업데이트를 통해 배포

### 6. 네트워크 오류 시
- Phase 0에서는 로컬 DB에 저장된 가이드 데이터 사용
- 네트워크 상태와 무관하게 동작

## Business Rules

### BR-001: 가이드 자동 표시 규칙
- 부작용 기록(F002) 완료 즉시 해당 증상의 간단 버전 가이드 자동 표시
- 사용자가 명시적으로 거부하지 않는 한 가이드 카드 노출

### BR-002: 증상별 가이드 매칭
- 시스템은 7가지 주요 증상(메스꺼움, 구토, 변비, 설사, 복통, 두통, 피로)에 대한 가이드 보유
- 기록된 증상명과 가이드 데이터의 증상명이 정확히 일치해야 함

### BR-003: 가이드 톤 및 콘텐츠
- 모든 가이드는 긍정적이고 실용적인 톤 유지
- 불안감 유발 문구 배제, 안심 및 지원 메시지 중심
- 의학적 조언이 아닌 일상 관리 팁으로 명시

### BR-004: 전문가 상담 권장 조건
- 사용자가 가이드가 도움이 안 된다고 피드백한 경우
- 시스템은 전문가 상담 권장 안내를 제공하되 강제하지 않음

### BR-005: 피드백 데이터 활용
- 피드백 데이터는 선택적으로 저장
- Phase 1 이후 가이드 개선 및 콘텐츠 최적화에 활용 가능

### BR-006: 가이드 접근성
- 가이드는 기록 완료 화면 외에도 별도 탭에서 언제든 재확인 가능
- 사용자가 필요할 때 증상별 가이드를 독립적으로 조회 가능

### BR-007: 심각 증상 연계
- 기록된 증상의 심각도가 7-10점이고 24시간 이상 지속된다고 선택된 경우
- 대처 가이드 외에 증상 체크(F005) 화면으로 추가 안내 제공

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE as "Frontend\n(Presentation)"
participant BE as "Backend\n(Application/Domain)"
participant Database as "Database\n(Infrastructure)"

== 부작용 기록 후 자동 가이드 표시 ==
User -> FE: 부작용 기록 완료 (증상, 심각도)
FE -> BE: 부작용 기록 저장 요청
BE -> Database: symptom_logs 테이블에 저장
Database --> BE: 저장 완료
BE --> FE: 기록 성공 응답

FE -> BE: 기록된 증상에 대한 가이드 조회 요청
BE -> Database: 증상명으로 가이드 데이터 조회
Database --> BE: 간단 버전 가이드 데이터 반환
BE --> FE: 가이드 데이터 전달

FE -> User: 간단 버전 가이드 카드 표시
FE -> User: "도움이 되었나요?" 피드백 UI 표시

alt 사용자가 "예" 선택
    User -> FE: "예" 선택
    FE -> BE: 피드백 데이터 저장 (선택적)
    BE -> Database: 피드백 기록 저장
    Database --> BE: 저장 완료
    BE --> FE: 처리 완료
    FE -> User: 감사 메시지 표시
else 사용자가 "아니오" 선택
    User -> FE: "아니오" 선택
    FE -> BE: 피드백 데이터 저장 (선택적)
    BE -> Database: 피드백 기록 저장
    Database --> BE: 저장 완료
    BE --> FE: 처리 완료
    FE -> User: "다른 팁 보기" 또는 "의료진 상담 권장" 옵션 표시
end

== 상세 가이드 조회 ==
User -> FE: "더 자세한 가이드 보기" 버튼 클릭
FE -> BE: 상세 가이드 조회 요청
BE -> Database: 증상명으로 상세 가이드 데이터 조회
Database --> BE: 상세 가이드 데이터 반환
BE --> FE: 상세 가이드 데이터 전달
FE -> User: 단계별 상세 가이드 화면 표시
User -> FE: 내용 확인 후 화면 종료

== 가이드 탭에서 직접 조회 ==
User -> FE: 가이드 탭 선택
FE -> BE: 전체 증상 목록 조회 요청
BE -> Database: 가이드 데이터 전체 목록 조회
Database --> BE: 증상 목록 반환
BE --> FE: 증상 목록 전달
FE -> User: 증상 목록 표시

User -> FE: 특정 증상 선택
FE -> BE: 선택한 증상의 가이드 조회 요청
BE -> Database: 증상명으로 가이드 조회
Database --> BE: 가이드 데이터 반환
BE --> FE: 가이드 데이터 전달
FE -> User: 가이드 표시
User -> FE: 화면 종료
@enduml
```
</file>

<file path="007/plan.md">
# F005: 증상 체크 및 전문가 상담 권장 - Implementation Plan

## 1. 개요

**Feature**: 심각 증상 체크리스트 제공 및 전문가 상담 권장
**Location**: `lib/features/tracking/`
**TDD 범위**: Domain → Infrastructure → Application → Presentation 순서로 모든 레이어

### 주요 모듈 목록
1. **EmergencySymptomCheck Entity** (Domain) - 증상 체크 기록 모델
2. **EmergencyCheckRepository Interface** (Domain) - 데이터 접근 인터페이스
3. **EmergencySymptomCheckDto** (Infrastructure) - Isar DTO
4. **IsarEmergencyCheckRepository** (Infrastructure) - Repository 구현체
5. **EmergencyCheckNotifier** (Application) - 상태 관리 및 UseCase 호출
6. **EmergencyCheckScreen** (Presentation) - 증상 체크리스트 화면
7. **ConsultationRecommendationDialog** (Presentation) - 상담 권장 다이얼로그

---

## 2. Architecture Diagram

```mermaid
graph TD
    subgraph Presentation
        A[EmergencyCheckScreen]
        B[ConsultationRecommendationDialog]
    end

    subgraph Application
        C[EmergencyCheckNotifier]
        D[emergencyCheckNotifierProvider]
    end

    subgraph Domain
        E[EmergencySymptomCheck Entity]
        F[EmergencyCheckRepository Interface]
    end

    subgraph Infrastructure
        G[EmergencySymptomCheckDto]
        H[IsarEmergencyCheckRepository]
        I[emergencyCheckRepositoryProvider]
    end

    subgraph "F002 Dependencies"
        J[SymptomLog Entity]
        K[SymptomLogRepository]
    end

    subgraph "F001 Dependencies"
        L[MedicationPlanRepository]
    end

    A -->|watch/read| D
    B -->|read| D
    C -->|uses| F
    C -->|uses| K
    C -->|uses| L
    D -->|provides| C
    C -->|returns| E
    C -->|creates| J
    H -.implements.-> F
    I -->|provides| H
    G -->|toEntity| E
    E -->|fromEntity| G
    H -->|uses| G

    style E fill:#e1f5ff
    style F fill:#e1f5ff
    style G fill:#fff4e1
    style H fill:#fff4e1
    style C fill:#f0ffe1
    style A fill:#ffe1f5
    style B fill:#ffe1f5
    style J fill:#ffe1e1
    style K fill:#ffe1e1
    style L fill:#e1ffe1
```

---

## 3. Implementation Plan

### 3.1. EmergencySymptomCheck Entity (Domain)

**Location**: `lib/features/tracking/domain/entities/emergency_symptom_check.dart`

**Responsibility**: 증상 체크 기록의 비즈니스 모델 표현

**Test Strategy**: Unit Test

**Test Scenarios** (Red Phase):
```dart
// AAA Pattern
group('EmergencySymptomCheck Entity', () {
  test('주어진 필수 필드로 생성 시, 올바른 인스턴스 반환', () {
    // Arrange
    final id = 'test-id';
    final userId = 'user-123';
    final checkedAt = DateTime(2025, 1, 1, 10, 0);
    final symptoms = ['24시간 이상 계속 구토'];

    // Act
    final entity = EmergencySymptomCheck(
      id: id,
      userId: userId,
      checkedAt: checkedAt,
      checkedSymptoms: symptoms,
    );

    // Assert
    expect(entity.id, id);
    expect(entity.userId, userId);
    expect(entity.checkedAt, checkedAt);
    expect(entity.checkedSymptoms, symptoms);
  });

  test('여러 증상 선택 시, 모든 증상 포함', () {
    // Arrange
    final symptoms = [
      '24시간 이상 계속 구토',
      '물이나 음식을 전혀 삼킬 수 없어요'
    ];

    // Act
    final entity = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: symptoms,
    );

    // Assert
    expect(entity.checkedSymptoms.length, 2);
    expect(entity.checkedSymptoms, containsAll(symptoms));
  });

  test('빈 증상 리스트로 생성 시, 예외 발생하지 않음', () {
    // Arrange & Act
    final entity = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: [],
    );

    // Assert
    expect(entity.checkedSymptoms, isEmpty);
  });

  test('동일한 필드로 생성된 두 인스턴스는 동등', () {
    // Arrange
    final id = 'test-id';
    final userId = 'user-123';
    final checkedAt = DateTime(2025, 1, 1);
    final symptoms = ['24시간 이상 계속 구토'];

    // Act
    final entity1 = EmergencySymptomCheck(
      id: id,
      userId: userId,
      checkedAt: checkedAt,
      checkedSymptoms: symptoms,
    );
    final entity2 = EmergencySymptomCheck(
      id: id,
      userId: userId,
      checkedAt: checkedAt,
      checkedSymptoms: symptoms,
    );

    // Assert
    expect(entity1, equals(entity2));
    expect(entity1.hashCode, equals(entity2.hashCode));
  });
});
```

**Edge Cases**:
- 빈 증상 리스트 허용 (해당 없음 케이스)
- 중복 증상 처리 (리스트에 중복 허용)
- 동등성 비교 (equatable 사용)

**Implementation Order** (TDD):
1. Red: 생성자 테스트 작성
2. Green: Entity 클래스 구현 (equatable mixin)
3. Red: 여러 증상 테스트 작성
4. Green: 리스트 처리 구현
5. Refactor: 불변성 보장 (`final` 키워드)

**Dependencies**: `equatable` package

---

### 3.2. EmergencyCheckRepository Interface (Domain)

**Location**: `lib/features/tracking/domain/repositories/emergency_check_repository.dart`

**Responsibility**: 증상 체크 데이터 접근 계약 정의

**Test Strategy**: Unit Test (Mock 구현체 사용)

**Test Scenarios** (Red Phase):
```dart
// Mock Repository를 통한 Interface 테스트
class MockEmergencyCheckRepository extends Mock
    implements EmergencyCheckRepository {}

group('EmergencyCheckRepository Interface', () {
  late MockEmergencyCheckRepository mockRepository;

  setUp(() {
    mockRepository = MockEmergencyCheckRepository();
  });

  test('saveEmergencyCheck 호출 시, Future<void> 반환', () async {
    // Arrange
    final check = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: ['증상1'],
    );
    when(() => mockRepository.saveEmergencyCheck(check))
        .thenAnswer((_) async => {});

    // Act
    await mockRepository.saveEmergencyCheck(check);

    // Assert
    verify(() => mockRepository.saveEmergencyCheck(check)).called(1);
  });

  test('getEmergencyChecks 호출 시, List<EmergencySymptomCheck> 반환', () async {
    // Arrange
    final checks = [
      EmergencySymptomCheck(
        id: '1',
        userId: 'user-123',
        checkedAt: DateTime.now(),
        checkedSymptoms: ['증상1'],
      ),
    ];
    when(() => mockRepository.getEmergencyChecks('user-123'))
        .thenAnswer((_) async => checks);

    // Act
    final result = await mockRepository.getEmergencyChecks('user-123');

    // Assert
    expect(result, checks);
    verify(() => mockRepository.getEmergencyChecks('user-123')).called(1);
  });

  test('deleteEmergencyCheck 호출 시, Future<void> 반환', () async {
    // Arrange
    when(() => mockRepository.deleteEmergencyCheck('test-id'))
        .thenAnswer((_) async => {});

    // Act
    await mockRepository.deleteEmergencyCheck('test-id');

    // Assert
    verify(() => mockRepository.deleteEmergencyCheck('test-id')).called(1);
  });

  test('updateEmergencyCheck 호출 시, Future<void> 반환', () async {
    // Arrange
    final check = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: ['증상1'],
    );
    when(() => mockRepository.updateEmergencyCheck(check))
        .thenAnswer((_) async => {});

    // Act
    await mockRepository.updateEmergencyCheck(check);

    // Assert
    verify(() => mockRepository.updateEmergencyCheck(check)).called(1);
  });
});
```

**Implementation Order**:
1. Red: Interface 메서드 시그니처 테스트
2. Green: abstract class 정의 (saveEmergencyCheck, getEmergencyChecks, deleteEmergencyCheck, updateEmergencyCheck)
3. Refactor: 문서화 주석 추가

**Dependencies**: None (Pure Dart)

---

### 3.3. EmergencySymptomCheckDto (Infrastructure)

**Location**: `lib/features/tracking/infrastructure/dtos/emergency_symptom_check_dto.dart`

**Responsibility**: Isar 컬렉션 정의 및 Entity ↔ DTO 변환

**Test Strategy**: Unit Test

**Isar Schema**:
```dart
@collection
class EmergencySymptomCheckDto {
  Id id = Isar.autoIncrement;

  @Index()
  late String userId;

  @Index()
  late DateTime checkedAt;

  late List<String> checkedSymptoms; // PostgreSQL jsonb → Isar List<String> 매핑

  // Entity ↔ DTO 변환 메서드
  factory EmergencySymptomCheckDto.fromEntity(EmergencySymptomCheck entity) {
    return EmergencySymptomCheckDto()
      ..userId = entity.userId
      ..checkedAt = entity.checkedAt
      ..checkedSymptoms = entity.checkedSymptoms;
  }

  EmergencySymptomCheck toEntity() {
    return EmergencySymptomCheck(
      id: id.toString(),
      userId: userId,
      checkedAt: checkedAt,
      checkedSymptoms: checkedSymptoms,
    );
  }
}
```

**Phase 1 전환 시 주의사항**:
- Isar는 PostgreSQL jsonb를 `List<String>`으로 매핑
- Phase 1 전환 시 Supabase에서 jsonb로 변환 필요

**Test Scenarios** (Red Phase):
```dart
group('EmergencySymptomCheckDto', () {
  test('Entity를 DTO로 변환 시, 모든 필드 매핑', () {
    // Arrange
    final entity = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime(2025, 1, 1, 10, 0),
      checkedSymptoms: ['증상1', '증상2'],
    );

    // Act
    final dto = EmergencySymptomCheckDto.fromEntity(entity);

    // Assert
    expect(dto.userId, entity.userId);
    expect(dto.checkedAt, entity.checkedAt);
    expect(dto.checkedSymptoms, entity.checkedSymptoms);
  });

  test('DTO를 Entity로 변환 시, 모든 필드 매핑', () {
    // Arrange
    final dto = EmergencySymptomCheckDto()
      ..id = 1
      ..userId = 'user-123'
      ..checkedAt = DateTime(2025, 1, 1, 10, 0)
      ..checkedSymptoms = ['증상1'];

    // Act
    final entity = dto.toEntity();

    // Assert
    expect(entity.id, dto.id.toString());
    expect(entity.userId, dto.userId);
    expect(entity.checkedAt, dto.checkedAt);
    expect(entity.checkedSymptoms, dto.checkedSymptoms);
  });

  test('빈 증상 리스트 변환 시, 빈 리스트 유지', () {
    // Arrange
    final entity = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: [],
    );

    // Act
    final dto = EmergencySymptomCheckDto.fromEntity(entity);
    final convertedEntity = dto.toEntity();

    // Assert
    expect(convertedEntity.checkedSymptoms, isEmpty);
  });

  test('여러 증상 변환 시, 순서 유지', () {
    // Arrange
    final symptoms = ['증상1', '증상2', '증상3'];
    final entity = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: symptoms,
    );

    // Act
    final dto = EmergencySymptomCheckDto.fromEntity(entity);
    final convertedEntity = dto.toEntity();

    // Assert
    expect(convertedEntity.checkedSymptoms, orderedEquals(symptoms));
  });
});
```

**Edge Cases**:
- Isar Id (int) ↔ Entity id (String) 변환
- 빈 리스트 처리
- 증상 순서 보존

**Implementation Order**:
1. Red: DTO → Entity 변환 테스트
2. Green: `toEntity()` 메서드 구현
3. Red: Entity → DTO 변환 테스트
4. Green: `fromEntity()` 팩토리 구현
5. Refactor: Isar 어노테이션 추가 (@collection, @Index)

**Dependencies**: `isar`, `isar_flutter_libs`

---

### 3.4. IsarEmergencyCheckRepository (Infrastructure)

**Location**: `lib/features/tracking/infrastructure/repositories/isar_emergency_check_repository.dart`

**Responsibility**: Isar를 통한 증상 체크 데이터 CRUD

**Test Strategy**: Integration Test (Isar In-Memory)

**Test Scenarios** (Red Phase):
```dart
group('IsarEmergencyCheckRepository Integration', () {
  late Isar isar;
  late IsarEmergencyCheckRepository repository;

  setUp(() async {
    isar = await Isar.open(
      [EmergencySymptomCheckDtoSchema],
      directory: '',
      name: 'test_emergency_check',
    );
    repository = IsarEmergencyCheckRepository(isar);
  });

  tearDown(() async {
    await isar.close(deleteFromDisk: true);
  });

  test('증상 체크 저장 시, DB에 정상 저장', () async {
    // Arrange
    final check = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime(2025, 1, 1),
      checkedSymptoms: ['증상1'],
    );

    // Act
    await repository.saveEmergencyCheck(check);

    // Assert
    final saved = await isar.emergencySymptomCheckDtos.where().findAll();
    expect(saved.length, 1);
    expect(saved.first.userId, 'user-123');
  });

  test('사용자별 증상 체크 조회 시, 해당 사용자 데이터만 반환', () async {
    // Arrange
    final check1 = EmergencySymptomCheck(
      id: '1',
      userId: 'user-123',
      checkedAt: DateTime(2025, 1, 1),
      checkedSymptoms: ['증상1'],
    );
    final check2 = EmergencySymptomCheck(
      id: '2',
      userId: 'user-456',
      checkedAt: DateTime(2025, 1, 2),
      checkedSymptoms: ['증상2'],
    );
    await repository.saveEmergencyCheck(check1);
    await repository.saveEmergencyCheck(check2);

    // Act
    final result = await repository.getEmergencyChecks('user-123');

    // Assert
    expect(result.length, 1);
    expect(result.first.userId, 'user-123');
  });

  test('증상 체크 삭제 시, DB에서 제거', () async {
    // Arrange
    final check = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: ['증상1'],
    );
    await repository.saveEmergencyCheck(check);

    // Act
    await repository.deleteEmergencyCheck('test-id');

    // Assert
    final remaining = await isar.emergencySymptomCheckDtos.where().findAll();
    expect(remaining, isEmpty);
  });

  test('최근 체크 순서로 정렬 조회', () async {
    // Arrange
    final check1 = EmergencySymptomCheck(
      id: '1',
      userId: 'user-123',
      checkedAt: DateTime(2025, 1, 1),
      checkedSymptoms: ['증상1'],
    );
    final check2 = EmergencySymptomCheck(
      id: '2',
      userId: 'user-123',
      checkedAt: DateTime(2025, 1, 3),
      checkedSymptoms: ['증상2'],
    );
    final check3 = EmergencySymptomCheck(
      id: '3',
      userId: 'user-123',
      checkedAt: DateTime(2025, 1, 2),
      checkedSymptoms: ['증상3'],
    );
    await repository.saveEmergencyCheck(check1);
    await repository.saveEmergencyCheck(check2);
    await repository.saveEmergencyCheck(check3);

    // Act
    final result = await repository.getEmergencyChecks('user-123');

    // Assert
    expect(result.length, 3);
    expect(result[0].checkedAt, DateTime(2025, 1, 3)); // 최신순
    expect(result[1].checkedAt, DateTime(2025, 1, 2));
    expect(result[2].checkedAt, DateTime(2025, 1, 1));
  });

  test('존재하지 않는 ID 삭제 시, 예외 발생하지 않음', () async {
    // Act & Assert
    expect(
      () => repository.deleteEmergencyCheck('non-existent'),
      returnsNormally,
    );
  });

  test('증상 체크 수정 시, DB에 업데이트', () async {
    // Arrange
    final check = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: ['증상1'],
    );
    await repository.saveEmergencyCheck(check);

    // Act
    final updated = EmergencySymptomCheck(
      id: check.id,
      userId: check.userId,
      checkedAt: check.checkedAt,
      checkedSymptoms: ['새로운 증상'],
    );
    await repository.updateEmergencyCheck(updated);

    // Assert
    final result = await repository.getEmergencyChecks(check.userId);
    expect(result.first.checkedSymptoms, ['새로운 증상']);
  });

  test('같은 증상 반복 체크 시, 별도 기록으로 저장', () async {
    // Arrange
    final check1 = EmergencySymptomCheck(
      id: '1',
      userId: 'user-123',
      checkedAt: DateTime(2025, 1, 1, 10, 0),
      checkedSymptoms: ['24시간 이상 계속 구토'],
    );
    final check2 = EmergencySymptomCheck(
      id: '2',
      userId: 'user-123',
      checkedAt: DateTime(2025, 1, 1, 14, 0), // 4시간 후
      checkedSymptoms: ['24시간 이상 계속 구토'], // 같은 증상
    );

    // Act
    await repository.saveEmergencyCheck(check1);
    await repository.saveEmergencyCheck(check2);

    // Assert
    final result = await repository.getEmergencyChecks('user-123');
    expect(result.length, 2); // 별도 기록
    expect(result[0].checkedAt, DateTime(2025, 1, 1, 14, 0)); // 최신순
    expect(result[1].checkedAt, DateTime(2025, 1, 1, 10, 0));
  });
});
```

**Edge Cases**:
- 사용자별 필터링
- 최신순 정렬
- 삭제 대상 미존재
- 동시 저장 요청
- 같은 증상 다른 시간 체크 (별도 기록)

**Implementation Order**:
1. Red: saveEmergencyCheck 테스트
2. Green: 저장 로직 구현
3. Red: getEmergencyChecks 테스트
4. Green: 조회 로직 구현 (필터링, 정렬)
5. Red: deleteEmergencyCheck 테스트
6. Green: 삭제 로직 구현
7. Red: updateEmergencyCheck 테스트
8. Green: 수정 로직 구현
9. Refactor: 트랜잭션 처리, 에러 핸들링

**Provider Definition**:
```dart
@riverpod
EmergencyCheckRepository emergencyCheckRepository(
  EmergencyCheckRepositoryRef ref,
) {
  final isar = ref.watch(isarProvider);
  return IsarEmergencyCheckRepository(isar);
}
```

**Dependencies**: `EmergencySymptomCheckDto`, `Isar`

---

### 3.5. EmergencyCheckNotifier (Application)

**Location**: `lib/features/tracking/application/notifiers/emergency_check_notifier.dart`

**Responsibility**: 증상 체크 상태 관리 및 비즈니스 로직 호출, 부작용 기록 자동 생성 (BR2)

**Test Strategy**: Unit Test (Mock Repository)

**Test Scenarios** (Red Phase):
```dart
group('EmergencyCheckNotifier', () {
  late MockEmergencyCheckRepository mockEmergencyCheckRepository;
  late MockSymptomLogRepository mockSymptomLogRepository;
  late MockMedicationPlanRepository mockPlanRepository;
  late ProviderContainer container;

  setUp(() {
    mockEmergencyCheckRepository = MockEmergencyCheckRepository();
    mockSymptomLogRepository = MockSymptomLogRepository();
    mockPlanRepository = MockMedicationPlanRepository();
    container = ProviderContainer(
      overrides: [
        emergencyCheckRepositoryProvider.overrideWithValue(mockEmergencyCheckRepository),
        symptomLogRepositoryProvider.overrideWithValue(mockSymptomLogRepository),
        medicationPlanRepositoryProvider.overrideWithValue(mockPlanRepository),
      ],
    );
  });

  tearDown(() {
    container.dispose();
  });

  test('초기 상태는 loading', () {
    // Act
    final state = container.read(emergencyCheckNotifierProvider);

    // Assert
    expect(state, const AsyncValue<List<EmergencySymptomCheck>>.loading());
  });

  test('증상 체크 저장 시, Repository 호출 및 상태 갱신', () async {
    // Arrange
    final check = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: ['증상1'],
    );
    when(() => mockEmergencyCheckRepository.saveEmergencyCheck(check))
        .thenAnswer((_) async => {});
    when(() => mockSymptomLogRepository.saveSymptomLog(any()))
        .thenAnswer((_) async => {});
    when(() => mockPlanRepository.getCurrentPlan('user-123'))
        .thenAnswer((_) async => mockPlan);
    when(() => mockEmergencyCheckRepository.getEmergencyChecks('user-123'))
        .thenAnswer((_) async => [check]);

    // Act
    final notifier = container.read(emergencyCheckNotifierProvider.notifier);
    await notifier.saveEmergencyCheck(check);

    // Assert
    verify(() => mockEmergencyCheckRepository.saveEmergencyCheck(check)).called(1);
    verify(() => mockEmergencyCheckRepository.getEmergencyChecks('user-123')).called(1);
  });

  test('증상 체크 저장 시, 자동으로 부작용 기록 생성 (BR2)', () async {
    // Arrange
    final check = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: ['증상1', '증상2'],
    );
    when(() => mockEmergencyCheckRepository.saveEmergencyCheck(check))
        .thenAnswer((_) async => {});
    when(() => mockSymptomLogRepository.saveSymptomLog(any()))
        .thenAnswer((_) async => {});
    when(() => mockPlanRepository.getCurrentPlan('user-123'))
        .thenAnswer((_) async => mockPlan);
    when(() => mockEmergencyCheckRepository.getEmergencyChecks(any()))
        .thenAnswer((_) async => [check]);

    // Act
    final notifier = container.read(emergencyCheckNotifierProvider.notifier);
    await notifier.saveEmergencyCheck(check);

    // Assert
    // 각 증상마다 부작용 기록 생성 확인
    verify(() => mockSymptomLogRepository.saveSymptomLog(any())).called(2);

    // 심각도 10점 확인
    final capturedLogs = verify(
      () => mockSymptomLogRepository.saveSymptomLog(captureAny()),
    ).captured;
    expect(capturedLogs.every((log) => log.severity == 10), true);
  });

  test('부작용 기록 생성 실패 시, 증상 체크도 롤백', () async {
    // Arrange
    final check = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: ['증상1'],
    );
    when(() => mockEmergencyCheckRepository.saveEmergencyCheck(check))
        .thenAnswer((_) async => {});
    when(() => mockSymptomLogRepository.saveSymptomLog(any()))
        .thenThrow(Exception('DB 오류'));
    when(() => mockPlanRepository.getCurrentPlan('user-123'))
        .thenAnswer((_) async => mockPlan);

    // Act
    final notifier = container.read(emergencyCheckNotifierProvider.notifier);
    await expectLater(
      notifier.saveEmergencyCheck(check),
      throwsException,
    );

    // Assert
    final state = container.read(emergencyCheckNotifierProvider);
    expect(state.hasError, true);
  });

  test('증상 체크 저장 성공 시, data 상태로 전환', () async {
    // Arrange
    final check = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: ['증상1'],
    );
    when(() => mockEmergencyCheckRepository.saveEmergencyCheck(any()))
        .thenAnswer((_) async => {});
    when(() => mockSymptomLogRepository.saveSymptomLog(any()))
        .thenAnswer((_) async => {});
    when(() => mockPlanRepository.getCurrentPlan(any()))
        .thenAnswer((_) async => mockPlan);
    when(() => mockEmergencyCheckRepository.getEmergencyChecks(any()))
        .thenAnswer((_) async => [check]);

    // Act
    final notifier = container.read(emergencyCheckNotifierProvider.notifier);
    await notifier.saveEmergencyCheck(check);

    // Assert
    final state = container.read(emergencyCheckNotifierProvider);
    expect(state.value, [check]);
  });

  test('여러 증상 선택 저장 시, 모든 증상 포함하여 저장', () async {
    // Arrange
    final check = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: ['증상1', '증상2'],
    );
    when(() => mockEmergencyCheckRepository.saveEmergencyCheck(any()))
        .thenAnswer((_) async => {});
    when(() => mockSymptomLogRepository.saveSymptomLog(any()))
        .thenAnswer((_) async => {});
    when(() => mockPlanRepository.getCurrentPlan(any()))
        .thenAnswer((_) async => mockPlan);
    when(() => mockEmergencyCheckRepository.getEmergencyChecks(any()))
        .thenAnswer((_) async => [check]);

    // Act
    final notifier = container.read(emergencyCheckNotifierProvider.notifier);
    await notifier.saveEmergencyCheck(check);

    // Assert
    final capturedCheck = verify(
      () => mockEmergencyCheckRepository.saveEmergencyCheck(captureAny()),
    ).captured.first as EmergencySymptomCheck;
    expect(capturedCheck.checkedSymptoms.length, 2);
  });
});
```

**Edge Cases**:
- 동시 저장 요청 (debounce 처리)
- Repository 예외 처리
- 상태 전환 순서 보장
- 부작용 기록 생성 실패 시 트랜잭션 롤백

**Implementation Structure**:
```dart
@riverpod
class EmergencyCheckNotifier extends _$EmergencyCheckNotifier {
  @override
  Future<List<EmergencySymptomCheck>> build() async {
    final userId = ref.watch(currentUserIdProvider);
    final repository = ref.watch(emergencyCheckRepositoryProvider);
    return repository.getEmergencyChecks(userId);
  }

  Future<void> saveEmergencyCheck(EmergencySymptomCheck check) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      // 1. 증상 체크 저장
      await ref.read(emergencyCheckRepositoryProvider).saveEmergencyCheck(check);

      // 2. 자동으로 부작용 기록 생성 (BR2)
      final symptomLogRepo = ref.read(symptomLogRepositoryProvider);
      final planRepo = ref.read(medicationPlanRepositoryProvider);

      final currentPlan = await planRepo.getCurrentPlan(check.userId);
      final daysAfterIncrease = _calculateDaysAfterIncrease(currentPlan);

      for (final symptom in check.checkedSymptoms) {
        final symptomLog = SymptomLog(
          id: uuid.v4(),
          userId: check.userId,
          symptomName: symptom,
          severity: 10, // 고정값 (BR2)
          recordedAt: check.checkedAt,
          daysAfterDoseIncrease: daysAfterIncrease,
        );
        await symptomLogRepo.saveSymptomLog(symptomLog);
      }

      // 3. 상태 갱신
      return await ref.read(emergencyCheckRepositoryProvider).getEmergencyChecks(check.userId);
    });
  }

  int _calculateDaysAfterIncrease(MedicationPlan? plan) {
    if (plan == null) return 0;
    final lastIncrease = plan.phases
        .where((phase) => phase.startDate.isBefore(DateTime.now()))
        .map((phase) => phase.startDate)
        .reduce((a, b) => a.isAfter(b) ? a : b);
    return DateTime.now().difference(lastIncrease).inDays;
  }
}
```

**Implementation Order**:
1. Red: 초기 상태 테스트
2. Green: AsyncNotifier 기본 구조
3. Red: saveEmergencyCheck 테스트
4. Green: 증상 체크 저장 로직 구현
5. Red: 부작용 기록 자동 생성 테스트 (BR2)
6. Green: SymptomLog 자동 생성 로직 추가
7. Red: 트랜잭션 롤백 테스트
8. Green: 에러 처리 및 롤백 로직
9. Refactor: AsyncValue.guard 적용, 상태 재조회 로직 최적화

**Dependencies**:
- EmergencyCheckRepository (F005)
- SymptomLogRepository (F002)
- SymptomLog Entity (F002)
- MedicationPlanRepository (F001)
- riverpod_annotation

---

### 3.6. EmergencyCheckScreen (Presentation)

**Location**: `lib/features/tracking/presentation/screens/emergency_check_screen.dart`

**Responsibility**: 증상 체크리스트 UI 및 사용자 인터랙션 처리

**Test Strategy**: Widget Test

**Test Scenarios** (Red Phase):
```dart
group('EmergencyCheckScreen Widget', () {
  testWidgets('7개 증상 항목이 모두 표시됨', (tester) async {
    // Arrange & Act
    await tester.pumpWidget(
      ProviderScope(
        child: MaterialApp(
          home: EmergencyCheckScreen(),
        ),
      ),
    );

    // Assert
    expect(find.text('24시간 이상 계속 구토하고 있어요'), findsOneWidget);
    expect(find.text('물이나 음식을 전혀 삼킬 수 없어요'), findsOneWidget);
    expect(find.text('매우 심한 복통이 있어요 (견디기 어려운 정도)'), findsOneWidget);
    expect(find.text('설사가 48시간 이상 계속되고 있어요'), findsOneWidget);
    expect(find.text('소변이 진한 갈색이거나 8시간 이상 나오지 않았어요'), findsOneWidget);
    expect(find.text('대변에 피가 섞여 있거나 검은색이에요'), findsOneWidget);
    expect(find.text('피부나 눈 흰자위가 노랗게 변했어요'), findsOneWidget);
  });

  testWidgets('증상 선택 시, 체크 상태 변경', (tester) async {
    // Arrange
    await tester.pumpWidget(
      ProviderScope(
        child: MaterialApp(
          home: EmergencyCheckScreen(),
        ),
      ),
    );

    // Act
    await tester.tap(find.text('24시간 이상 계속 구토하고 있어요'));
    await tester.pump();

    // Assert
    final checkbox = tester.widget<CheckboxListTile>(
      find.byType(CheckboxListTile).first,
    );
    expect(checkbox.value, true);
  });

  testWidgets('증상 선택 후 확인 버튼 탭 시, 상담 권장 다이얼로그 표시', (tester) async {
    // Arrange
    await tester.pumpWidget(
      ProviderScope(
        child: MaterialApp(
          home: EmergencyCheckScreen(),
        ),
      ),
    );

    // Act
    await tester.tap(find.text('24시간 이상 계속 구토하고 있어요'));
    await tester.pump();
    await tester.tap(find.text('확인'));
    await tester.pumpAndSettle();

    // Assert
    expect(find.byType(ConsultationRecommendationDialog), findsOneWidget);
    expect(find.text('전문가와 상담이 필요합니다'), findsOneWidget);
  });

  testWidgets('여러 증상 선택 시, 모두 체크 상태 유지', (tester) async {
    // Arrange
    await tester.pumpWidget(
      ProviderScope(
        child: MaterialApp(
          home: EmergencyCheckScreen(),
        ),
      ),
    );

    // Act
    await tester.tap(find.text('24시간 이상 계속 구토하고 있어요'));
    await tester.pump();
    await tester.tap(find.text('물이나 음식을 전혀 삼킬 수 없어요'));
    await tester.pump();

    // Assert
    final checkboxes = tester.widgetList<CheckboxListTile>(
      find.byType(CheckboxListTile),
    );
    final checkedCount = checkboxes.where((cb) => cb.value == true).length;
    expect(checkedCount, 2);
  });

  testWidgets('해당 없음 버튼 탭 시, 화면 종료', (tester) async {
    // Arrange
    await tester.pumpWidget(
      ProviderScope(
        child: MaterialApp(
          home: Builder(
            builder: (context) => ElevatedButton(
              onPressed: () {
                Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (_) => EmergencyCheckScreen(),
                  ),
                );
              },
              child: Text('Open'),
            ),
          ),
        ),
      ),
    );
    await tester.tap(find.text('Open'));
    await tester.pumpAndSettle();

    // Act
    await tester.tap(find.text('해당 없음'));
    await tester.pumpAndSettle();

    // Assert
    expect(find.byType(EmergencyCheckScreen), findsNothing);
  });
});
```

**Edge Cases**:
- 증상 미선택 시 확인 버튼 비활성화
- 뒤로가기 동작 (기록 저장 여부)
- 로딩 중 UI 비활성화

**Implementation Order**:
1. Red: 체크리스트 렌더링 테스트
2. Green: StatefulWidget 기본 구조
3. Red: 증상 선택 상태 관리 테스트
4. Green: 체크박스 상태 로직 구현
5. Red: 확인 버튼 동작 테스트
6. Green: 다이얼로그 표시 및 Notifier 호출
7. Refactor: UI 컴포넌트 분리

**QA Sheet** (수동 테스트):
- [ ] 7개 증상 항목이 모두 표시되는가?
- [ ] 체크박스 선택/해제가 정상 동작하는가?
- [ ] 여러 증상 동시 선택이 가능한가?
- [ ] 증상 미선택 시 확인 버튼이 비활성화되는가?
- [ ] 확인 버튼 탭 시 다이얼로그가 표시되는가?
- [ ] 해당 없음 버튼 탭 시 화면이 종료되는가?
- [ ] 뒤로가기 동작이 자연스러운가?
- [ ] 로딩 중 중복 요청 방지가 되는가?

**Dependencies**: `EmergencyCheckNotifier`, `ConsultationRecommendationDialog`

---

### 3.7. ConsultationRecommendationDialog (Presentation)

**Location**: `lib/features/tracking/presentation/widgets/consultation_recommendation_dialog.dart`

**Responsibility**: 전문가 상담 권장 안내 다이얼로그

**Test Strategy**: Widget Test

**Test Scenarios** (Red Phase):
```dart
group('ConsultationRecommendationDialog Widget', () {
  testWidgets('선택된 증상 요약이 표시됨', (tester) async {
    // Arrange
    final selectedSymptoms = ['24시간 이상 계속 구토'];

    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: ConsultationRecommendationDialog(
            selectedSymptoms: selectedSymptoms,
          ),
        ),
      ),
    );

    // Assert
    expect(find.text('24시간 이상 계속 구토'), findsOneWidget);
  });

  testWidgets('전문가 상담 권장 문구가 표시됨', (tester) async {
    // Arrange
    final selectedSymptoms = ['증상1'];

    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: ConsultationRecommendationDialog(
            selectedSymptoms: selectedSymptoms,
          ),
        ),
      ),
    );

    // Assert
    expect(find.text('전문가와 상담이 필요합니다'), findsOneWidget);
  });

  testWidgets('여러 증상 선택 시, 모든 증상 표시', (tester) async {
    // Arrange
    final selectedSymptoms = ['증상1', '증상2', '증상3'];

    // Act
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: ConsultationRecommendationDialog(
            selectedSymptoms: selectedSymptoms,
          ),
        ),
      ),
    );

    // Assert
    expect(find.text('증상1'), findsOneWidget);
    expect(find.text('증상2'), findsOneWidget);
    expect(find.text('증상3'), findsOneWidget);
  });

  testWidgets('확인 버튼 탭 시, 다이얼로그 닫힘', (tester) async {
    // Arrange
    await tester.pumpWidget(
      MaterialApp(
        home: Builder(
          builder: (context) => ElevatedButton(
            onPressed: () {
              showDialog(
                context: context,
                builder: (_) => ConsultationRecommendationDialog(
                  selectedSymptoms: ['증상1'],
                ),
              );
            },
            child: Text('Show Dialog'),
          ),
        ),
      ),
    );
    await tester.tap(find.text('Show Dialog'));
    await tester.pumpAndSettle();

    // Act
    await tester.tap(find.text('확인'));
    await tester.pumpAndSettle();

    // Assert
    expect(find.byType(ConsultationRecommendationDialog), findsNothing);
  });
});
```

**Edge Cases**:
- 증상 없는 경우 처리 (방어 코드)
- 긴 증상명 텍스트 오버플로우
- 다이얼로그 바깥 영역 탭 동작

**Implementation Order**:
1. Red: 증상 요약 표시 테스트
2. Green: Dialog 기본 구조
3. Red: 권장 문구 표시 테스트
4. Green: 텍스트 레이아웃 구현
5. Red: 확인 버튼 동작 테스트
6. Green: Navigator.pop 호출
7. Refactor: 스타일링, 접근성 개선

**QA Sheet** (수동 테스트):
- [ ] 선택된 증상이 명확히 표시되는가?
- [ ] 권장 문구가 긍정적이면서 긴급성을 전달하는가?
- [ ] 여러 증상 표시가 가독성 있는가?
- [ ] 확인 버튼이 명확하고 터치하기 쉬운가?
- [ ] 다이얼로그 바깥 영역 탭 시 닫히는가?
- [ ] 다크 모드에서도 가독성이 좋은가?
- [ ] 긴 증상명이 정상적으로 표시되는가?

**Dependencies**: Flutter Material

---

### 3.8. Integration Test (전체 플로우)

**Location**: `test/features/tracking/integration/emergency_check_flow_test.dart`

**Responsibility**: 증상 체크부터 부작용 기록 자동 생성까지 전체 플로우 검증

**Test Strategy**: Integration Test (Isar In-Memory)

**Test Scenarios**:
```dart
group('증상 체크 전체 플로우 Integration', () {
  late Isar isar;
  late IsarEmergencyCheckRepository emergencyCheckRepo;
  late IsarSymptomLogRepository symptomLogRepo;
  late MockMedicationPlanRepository planRepo;

  setUp(() async {
    isar = await Isar.open(
      [EmergencySymptomCheckDtoSchema, SymptomLogDtoSchema],
      directory: '',
      name: 'test_emergency_flow',
    );
    emergencyCheckRepo = IsarEmergencyCheckRepository(isar);
    symptomLogRepo = IsarSymptomLogRepository(isar);
    planRepo = MockMedicationPlanRepository();
  });

  tearDown(() async {
    await isar.close(deleteFromDisk: true);
  });

  test('증상 체크 저장 시, emergency_symptom_checks + symptom_logs 모두 저장', () async {
    // Arrange
    final check = EmergencySymptomCheck(
      id: 'test-id',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: ['증상1', '증상2'],
    );
    when(() => planRepo.getCurrentPlan('user-123'))
        .thenAnswer((_) async => mockPlan);

    // Act
    await emergencyCheckRepo.saveEmergencyCheck(check);

    // 부작용 기록 자동 생성 (Notifier 로직 시뮬레이션)
    final currentPlan = await planRepo.getCurrentPlan(check.userId);
    final daysAfterIncrease = _calculateDaysAfterIncrease(currentPlan);

    for (final symptom in check.checkedSymptoms) {
      final log = SymptomLog(
        id: uuid.v4(),
        userId: check.userId,
        symptomName: symptom,
        severity: 10,
        recordedAt: check.checkedAt,
        daysAfterDoseIncrease: daysAfterIncrease,
      );
      await symptomLogRepo.saveSymptomLog(log);
    }

    // Assert
    final savedChecks = await emergencyCheckRepo.getEmergencyChecks('user-123');
    final savedLogs = await symptomLogRepo.getSymptomLogs('user-123');

    expect(savedChecks.length, 1);
    expect(savedLogs.length, 2); // 증상 2개 → 부작용 기록 2개
    expect(savedLogs.every((log) => log.severity == 10), true);
    expect(savedLogs[0].symptomName, '증상1');
    expect(savedLogs[1].symptomName, '증상2');
  });

  test('증상 체크 없이 부작용 기록만 있을 경우, 독립적으로 조회 가능', () async {
    // Arrange - 부작용 기록만 직접 저장
    final log = SymptomLog(
      id: uuid.v4(),
      userId: 'user-123',
      symptomName: '일반 부작용',
      severity: 5,
      recordedAt: DateTime.now(),
    );
    await symptomLogRepo.saveSymptomLog(log);

    // Act
    final savedChecks = await emergencyCheckRepo.getEmergencyChecks('user-123');
    final savedLogs = await symptomLogRepo.getSymptomLogs('user-123');

    // Assert
    expect(savedChecks, isEmpty); // 증상 체크 없음
    expect(savedLogs.length, 1); // 부작용 기록만 존재
  });

  test('여러 사용자의 증상 체크 및 부작용 기록이 분리되어 저장', () async {
    // Arrange
    final check1 = EmergencySymptomCheck(
      id: '1',
      userId: 'user-123',
      checkedAt: DateTime.now(),
      checkedSymptoms: ['증상1'],
    );
    final check2 = EmergencySymptomCheck(
      id: '2',
      userId: 'user-456',
      checkedAt: DateTime.now(),
      checkedSymptoms: ['증상2'],
    );

    // Act
    await emergencyCheckRepo.saveEmergencyCheck(check1);
    await emergencyCheckRepo.saveEmergencyCheck(check2);

    await symptomLogRepo.saveSymptomLog(
      SymptomLog(
        id: uuid.v4(),
        userId: 'user-123',
        symptomName: '증상1',
        severity: 10,
        recordedAt: check1.checkedAt,
      ),
    );
    await symptomLogRepo.saveSymptomLog(
      SymptomLog(
        id: uuid.v4(),
        userId: 'user-456',
        symptomName: '증상2',
        severity: 10,
        recordedAt: check2.checkedAt,
      ),
    );

    // Assert
    final user123Checks = await emergencyCheckRepo.getEmergencyChecks('user-123');
    final user123Logs = await symptomLogRepo.getSymptomLogs('user-123');
    final user456Checks = await emergencyCheckRepo.getEmergencyChecks('user-456');
    final user456Logs = await symptomLogRepo.getSymptomLogs('user-456');

    expect(user123Checks.length, 1);
    expect(user123Logs.length, 1);
    expect(user456Checks.length, 1);
    expect(user456Logs.length, 1);
  });
});
```

**Implementation Order**:
1. Red: 기본 플로우 테스트 (증상 체크 → 부작용 기록 자동 생성)
2. Green: 전체 플로우 구현 (Repository 간 연동)
3. Red: Edge Case 테스트 (사용자 분리, 독립적 조회)
4. Green: Edge Case 처리
5. Refactor: 테스트 코드 중복 제거

**Dependencies**:
- EmergencyCheckRepository (F005)
- SymptomLogRepository (F002)
- MedicationPlanRepository (F001)

---

## 4. TDD Workflow

### 시작점
0. **F002 의존성 확인** (SymptomLog Entity, SymptomLogRepository)
1. **EmergencySymptomCheck Entity** (가장 기본적인 모델)

### 진행 순서 (Inside-Out)
```
0. F002 Dependencies 확인
   ├─ SymptomLog Entity (F002에서 가져옴)
   └─ SymptomLogRepository (F002에서 가져옴)

1. Domain Layer
   ├─ EmergencySymptomCheck Entity (Red → Green → Refactor)
   └─ EmergencyCheckRepository Interface (Red → Green → Refactor)
      - updateEmergencyCheck 메서드 포함

2. Infrastructure Layer
   ├─ EmergencySymptomCheckDto (Red → Green → Refactor)
      - Isar 스키마 명시 (@collection, @Index)
   └─ IsarEmergencyCheckRepository (Red → Green → Refactor)
      - update 메서드 구현
      - Provider 정의 추가

3. Application Layer
   └─ EmergencyCheckNotifier (Red → Green → Refactor)
      - SymptomLog 자동 생성 로직 추가
      - F002, F001 의존성 통합

4. Presentation Layer
   ├─ ConsultationRecommendationDialog (Red → Green → Refactor)
   └─ EmergencyCheckScreen (Red → Green → Refactor)

5. Integration Test
   └─ 전체 플로우 (증상 체크 → 부작용 기록 자동 생성)
```

### Commit 포인트
1. ✅ Domain Layer 완료 (Entity + Repository Interface with updateEmergencyCheck)
2. ✅ Infrastructure Layer 완료 (DTO + Repository 구현체 + Provider 정의)
3. ✅ Application Layer 완료 (Notifier + SymptomLog 자동 생성 로직)
4. ✅ Presentation Layer 완료 (Screen + Dialog)
5. ✅ Integration Test 통과 (증상 체크 → 부작용 기록 자동 생성 플로우)

### 완료 조건
- [ ] 모든 Unit Test 통과 (100% 커버리지)
- [ ] Integration Test 통과 (Isar In-Memory)
- [ ] 전체 플로우 Integration Test 통과 (증상 체크 → 부작용 기록 자동 생성)
- [ ] Widget Test 통과 (모든 UI 컴포넌트)
- [ ] QA Sheet 수동 테스트 완료
- [ ] Code Review 완료 (Layer 의존성 확인, F002 연동 검증)
- [ ] Phase 0 → Phase 1 전환 가능성 검증

---

## 5. 핵심 원칙

### Test First
- 모든 구현 전 테스트 작성
- AAA 패턴 (Arrange, Act, Assert) 준수
- Given-When-Then 시나리오 명확화

### Small Steps
- 한 번에 하나의 테스트만 통과
- 최소한의 코드로 Green 상태 달성
- Refactor는 Green 이후에만 진행

### FIRST 원칙
- **Fast**: 단위 테스트는 밀리초 단위
- **Independent**: 테스트 간 의존성 없음
- **Repeatable**: 어떤 환경에서도 동일 결과
- **Self-validating**: 수동 확인 불필요
- **Timely**: 구현 전 테스트 작성

### Test Pyramid
- **Unit**: 70% (Domain, Infrastructure, Application)
- **Integration**: 20% (Repository + Isar)
- **Widget**: 10% (Presentation)

### Inside-Out 전략
- Core Logic (Domain) 먼저 구현
- 외부 의존성 (Infrastructure) 다음
- 상태 관리 (Application) 그 다음
- UI (Presentation) 마지막
</file>

<file path="007/spec.md">
# F005: 증상 체크 및 전문가 상담 권장

## Use Case Specification

### Primary Actor
GLP-1 치료 중 심각한 증상을 경험하는 사용자

### Precondition
- 사용자가 로그인된 상태
- 사용자가 투여 계획을 설정한 상태
- 심각한 증상이 발생하거나 24시간 이상 증상이 지속되는 상황

### Trigger
- 사용자가 홈 대시보드 또는 증상 관련 영역에서 "증상 체크" 메뉴 선택
- F002에서 부작용 심각도 7-10점 입력 후 "24시간 이상 지속" 선택 시 자동 진입

### Main Scenario

1. 사용자가 "증상 체크" 메뉴 진입
2. 시스템이 체크리스트 형태의 증상 화면 표시
   - 일상 언어로 작성된 7개 심각 증상 항목
3. 사용자가 해당 증상 선택
4. 시스템이 선택된 증상 확인 및 저장 (날짜시간, 선택 증상)
5. 시스템이 자동으로 부작용 기록 생성 (심각도 10점, F002 연동)
6. 시스템이 전문가 상담 권장 화면 표시
   - 선택한 증상 요약
   - "전문가와 상담이 필요합니다" 안내 문구
7. 사용자가 안내 확인 후 화면 종료

### Alternative Flow 1: 해당 증상 없음
3a. 사용자가 해당 없음 선택 또는 뒤로가기
3b. 시스템이 체크 기록 없이 화면 종료

### Alternative Flow 2: 여러 증상 동시 선택
3a. 사용자가 여러 증상 항목 선택
4a. 시스템이 모든 선택 증상 저장
6a. 시스템이 선택된 모든 증상 요약 표시
6b. 가장 심각한 증상 우선 강조

### Edge Cases

**입력 관련**
- 증상 체크 후 안내만 확인하고 나가기: 저장된 기록 유지
- 같은 증상 반복 체크: 각 기록 별도 저장 (날짜시간으로 구분)
- 증상 체크 중 증상 완화: 기록 삭제 또는 수정 허용 (설정 메뉴 통해)

**데이터 저장 실패**
- 로컬 DB 저장 실패: 에러 메시지 표시, 재시도 옵션 제공
- 앱 종료 전 자동 저장 완료 보장

**UI/UX**
- 긴급 상황 고려하여 간결하고 명확한 문구 사용
- 선택 후 즉시 안내 화면 표시 (지연 최소화)
- 뒤로가기 동작 명확히 안내 (기록 저장 여부)

### Business Rules

**BR1: 체크리스트 항목 (7개 고정)**
- "24시간 이상 계속 구토하고 있어요"
- "물이나 음식을 전혀 삼킬 수 없어요"
- "매우 심한 복통이 있어요 (견디기 어려운 정도)"
- "설사가 48시간 이상 계속되고 있어요"
- "소변이 진한 갈색이거나 8시간 이상 나오지 않았어요"
- "대변에 피가 섞여 있거나 검은색이에요"
- "피부나 눈 흰자위가 노랗게 변했어요"

**BR2: 자동 부작용 기록 생성**
- 증상 체크 시 자동으로 symptom_logs 테이블에 기록 생성
- 심각도는 10점으로 고정
- 증상명은 체크리스트 항목 텍스트 그대로 저장

**BR3: 전문가 상담 권장 조건**
- 체크리스트에서 하나라도 선택 시 무조건 상담 권장 화면 표시
- 안내 문구는 긍정적이면서 긴급성을 전달하는 톤 사용

**BR4: 데이터 저장 규칙**
- 체크 기록은 emergency_symptom_checks 테이블에 저장
- 체크 시간은 timestamptz로 정확히 기록
- 선택한 증상 목록은 jsonb 형태로 저장

---

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE
participant BE
database Database

== 증상 체크 진입 ==
User -> FE: "증상 체크" 메뉴 선택
FE -> FE: 체크리스트 화면 렌더링

== 증상 선택 및 저장 ==
User -> FE: 심각 증상 항목 선택
FE -> FE: 선택 항목 유효성 확인
FE -> BE: 체크 기록 저장 요청\n(checked_at, checked_symptoms)
BE -> Database: INSERT emergency_symptom_checks
Database --> BE: 저장 완료
BE --> FE: 저장 성공 응답

== 자동 부작용 기록 생성 ==
FE -> BE: 부작용 기록 생성 요청\n(심각도 10, 선택 증상)
BE -> BE: 투여 계획 조회하여\n용량 증량 후 경과일 계산
BE -> Database: INSERT symptom_logs
Database --> BE: 저장 완료
BE --> FE: 저장 성공 응답

== 전문가 상담 권장 표시 ==
FE -> FE: 선택 증상 요약 화면 생성
FE -> User: "전문가와 상담이 필요합니다"\n안내 표시
User -> FE: 안내 확인 후 화면 종료

== Alternative: 해당 없음 ==
User -> FE: 해당 없음 선택 또는 뒤로가기
FE -> User: 화면 종료

== Alternative: 여러 증상 선택 ==
User -> FE: 여러 증상 항목 선택
FE -> BE: 모든 선택 증상 저장 요청
BE -> Database: INSERT emergency_symptom_checks\n(checked_symptoms: jsonb 배열)
Database --> BE: 저장 완료
BE --> FE: 저장 성공 응답
FE -> User: 모든 선택 증상 요약 표시\n(가장 심각한 증상 강조)

@enduml
```
</file>

<file path="008/plan.md">
# 홈 대시보드 (F006) Implementation Plan

## 1. 개요

홈 대시보드는 사용자 치료 진행 상황을 한눈에 파악하고 지속적인 동기 부여를 제공하는 핵심 화면. 4-Layer Architecture + Repository Pattern + TDD 적용.

**모듈 구조:**
- **Domain Layer**: 대시보드 집계 로직, 뱃지 검증 로직, 통계 계산 UseCase
- **Application Layer**: DashboardNotifier (AsyncNotifier), 파생 Provider들
- **Infrastructure Layer**: BadgeRepository, 기존 Repository 재사용
- **Presentation Layer**: DashboardScreen, 위젯 컴포넌트

**TDD 적용 범위:**
- Domain UseCase: Unit Test 100%
- Application Notifier: Integration Test 주요 시나리오
- Presentation: Acceptance Test (Golden Test 포함)

---

## 2. Architecture Diagram

```mermaid
graph TD
    %% Presentation Layer
    DashboardScreen[DashboardScreen]
    GreetingWidget[GreetingWidget]
    WeeklyProgressWidget[WeeklyProgressWidget]
    QuickActionWidget[QuickActionWidget]
    NextScheduleWidget[NextScheduleWidget]
    WeeklyReportWidget[WeeklyReportWidget]
    TimelineWidget[TimelineWidget]
    BadgeWidget[BadgeWidget]

    %% Application Layer
    DashboardNotifier[DashboardNotifier<br/>AsyncNotifierProvider]
    ContinuousRecordDaysProvider[continuousRecordDaysProvider<br/>Provider]
    CurrentWeekProvider[currentWeekProvider<br/>Provider]
    WeeklyProgressProvider[weeklyProgressProvider<br/>Provider]
    InsightMessageProvider[insightMessageProvider<br/>Provider]

    %% Domain Layer
    CalculateContinuousRecordDaysUseCase[CalculateContinuousRecordDaysUseCase]
    CalculateCurrentWeekUseCase[CalculateCurrentWeekUseCase]
    CalculateWeeklyProgressUseCase[CalculateWeeklyProgressUseCase]
    CalculateAdherenceUseCase[CalculateAdherenceUseCase]
    CalculateWeightGoalEstimateUseCase[CalculateWeightGoalEstimateUseCase]
    VerifyBadgeConditionsUseCase[VerifyBadgeConditionsUseCase]
    GenerateInsightMessageUseCase[GenerateInsightMessageUseCase]
    DashboardData[DashboardData Entity]
    WeeklyProgress[WeeklyProgress Entity]
    NextSchedule[NextSchedule Entity]
    WeeklySummary[WeeklySummary Entity]
    TimelineEvent[TimelineEvent Entity]
    BadgeDefinition[BadgeDefinition Entity]
    UserBadge[UserBadge Entity]

    %% Infrastructure Layer
    BadgeRepository[BadgeRepository<br/>Interface]
    IsarBadgeRepository[IsarBadgeRepository<br/>Implementation]
    ProfileRepository[ProfileRepository<br/>재사용]
    TrackingRepository[TrackingRepository<br/>재사용]
    MedicationRepository[MedicationRepository<br/>재사용]

    %% Dependencies
    DashboardScreen --> DashboardNotifier
    DashboardScreen --> GreetingWidget
    DashboardScreen --> WeeklyProgressWidget
    DashboardScreen --> QuickActionWidget
    DashboardScreen --> NextScheduleWidget
    DashboardScreen --> WeeklyReportWidget
    DashboardScreen --> TimelineWidget
    DashboardScreen --> BadgeWidget

    GreetingWidget --> ContinuousRecordDaysProvider
    GreetingWidget --> CurrentWeekProvider
    WeeklyProgressWidget --> WeeklyProgressProvider
    BadgeWidget --> DashboardNotifier

    DashboardNotifier --> ProfileRepository
    DashboardNotifier --> TrackingRepository
    DashboardNotifier --> MedicationRepository
    DashboardNotifier --> BadgeRepository
    DashboardNotifier --> CalculateContinuousRecordDaysUseCase
    DashboardNotifier --> CalculateCurrentWeekUseCase
    DashboardNotifier --> CalculateWeeklyProgressUseCase
    DashboardNotifier --> CalculateAdherenceUseCase
    DashboardNotifier --> CalculateWeightGoalEstimateUseCase
    DashboardNotifier --> VerifyBadgeConditionsUseCase
    DashboardNotifier --> GenerateInsightMessageUseCase

    ContinuousRecordDaysProvider --> CalculateContinuousRecordDaysUseCase
    ContinuousRecordDaysProvider --> TrackingRepository
    CurrentWeekProvider --> CalculateCurrentWeekUseCase
    CurrentWeekProvider --> MedicationRepository
    WeeklyProgressProvider --> CalculateWeeklyProgressUseCase
    WeeklyProgressProvider --> TrackingRepository
    WeeklyProgressProvider --> MedicationRepository
    InsightMessageProvider --> GenerateInsightMessageUseCase
    InsightMessageProvider --> DashboardNotifier

    CalculateContinuousRecordDaysUseCase --> DashboardData
    CalculateWeeklyProgressUseCase --> WeeklyProgress
    VerifyBadgeConditionsUseCase --> BadgeRepository
    VerifyBadgeConditionsUseCase --> BadgeDefinition
    VerifyBadgeConditionsUseCase --> UserBadge

    IsarBadgeRepository --> BadgeRepository
    IsarBadgeRepository --> BadgeDefinition
    IsarBadgeRepository --> UserBadge
```

---

## 3. Implementation Plan

### 3.1 Domain Layer - Entities

**Location**: `lib/features/dashboard/domain/entities/`

**Responsibility**: 대시보드 데이터 구조 정의

**Test Strategy**: Unit Test (Serialization/Deserialization, Equality)

**Test Scenarios (Red Phase):**
```dart
// dashboard_data_test.dart
group('DashboardData', () {
  test('should create valid DashboardData instance', () {});
  test('should support equality comparison', () {});
  test('should copyWith correctly', () {});
});

// weekly_progress_test.dart
group('WeeklyProgress', () {
  test('should calculate rate correctly', () {});
  test('should handle zero target count', () {});
  test('should clamp rate between 0.0 and 1.0', () {});
});

// next_schedule_test.dart
group('NextSchedule', () {
  test('should format date correctly', () {});
  test('should handle null escalation date', () {});
});

// weekly_summary_test.dart
group('WeeklySummary', () {
  test('should format text summary', () {});
  test('should handle empty records', () {});
});

// timeline_event_test.dart
group('TimelineEvent', () {
  test('should create milestone event', () {});
  test('should sort events by date', () {});
});

// badge_definition_test.dart
group('BadgeDefinition', () {
  test('should create valid BadgeDefinition instance', () {});
  test('should define badge type correctly', () {});
  test('should support equality comparison', () {});
});

// user_badge_test.dart
group('UserBadge', () {
  test('should create valid UserBadge instance', () {});
  test('should track progress percentage', () {});
  test('should mark as achieved', () {});
  test('should support equality comparison', () {});
});
```

**Implementation Order (TDD):**
1. DashboardData Entity
2. WeeklyProgress Entity
3. NextSchedule Entity
4. WeeklySummary Entity
5. TimelineEvent Entity
6. BadgeDefinition Entity (뱃지 정의)
7. UserBadge Entity (사용자 뱃지 획득 상태)

**Dependencies**: None (Pure Dart)

---

### 3.2 Domain Layer - UseCases

**Location**: `lib/features/dashboard/domain/usecases/`

**Responsibility**: 비즈니스 로직 캡슐화 (계산, 검증)

**Test Strategy**: Unit Test (AAA Pattern)

**Test Scenarios (Red Phase):**

#### CalculateContinuousRecordDaysUseCase
```dart
group('CalculateContinuousRecordDaysUseCase', () {
  // Arrange
  late CalculateContinuousRecordDaysUseCase useCase;

  setUp(() {
    useCase = CalculateContinuousRecordDaysUseCase();
  });

  test('should return 0 when no records exist', () {});
  test('should return 1 when only today has record', () {});
  test('should return 7 when continuous 7 days record exist', () {});
  test('should reset to 0 when gap exists in records', () {});
  test('should handle mixed weight and symptom logs', () {});
  test('should handle duplicate logs on same date', () {});
});
```

#### CalculateCurrentWeekUseCase
```dart
group('CalculateCurrentWeekUseCase', () {
  test('should return 1 for treatment start date', () {});
  test('should return 2 after 7 days', () {});
  test('should return correct week for arbitrary date', () {});
  test('should handle timezone correctly', () {});
});
```

#### CalculateWeeklyProgressUseCase
```dart
group('CalculateWeeklyProgressUseCase', () {
  test('should calculate dose progress correctly', () {});
  test('should calculate weight record progress correctly', () {});
  test('should calculate symptom record progress correctly', () {});
  test('should handle zero target count', () {});
  test('should handle over 100% achievement', () {});
  test('should filter records within last 7 days', () {});
});
```

#### CalculateAdherenceUseCase
```dart
group('CalculateAdherenceUseCase', () {
  test('should return 100% when all doses completed', () {});
  test('should return 50% when half doses completed', () {});
  test('should return 0% when no doses completed', () {});
  test('should exclude future schedules', () {});
  test('should handle empty schedules', () {});
});
```

#### CalculateWeightGoalEstimateUseCase
```dart
group('CalculateWeightGoalEstimateUseCase', () {
  test('should estimate goal date with linear regression', () {});
  test('should return null when insufficient data (< 2 weeks)', () {});
  test('should return null when no weight loss trend', () {});
  test('should handle already achieved goal', () {});
  test('should handle weight gain trend', () {});
});
```

#### VerifyBadgeConditionsUseCase
```dart
group('VerifyBadgeConditionsUseCase', () {
  test('should verify "연속 7일 기록" badge', () {});
  test('should verify "연속 30일 기록" badge', () {});
  test('should verify "체중 5% 감량" badge', () {});
  test('should verify "체중 10% 감량" badge', () {});
  test('should verify "첫 투여 완료" badge', () {});
  test('should calculate progress percentage correctly', () {});
  test('should mark badge as achieved when condition met', () {});
  test('should handle multiple badge conditions by priority', () {}); // 우선순위 처리
});
```

#### GenerateInsightMessageUseCase
```dart
group('GenerateInsightMessageUseCase', () {
  test('should generate weight loss message when > 1%', () {});
  test('should generate continuous record message when >= 7 days', () {});
  test('should generate symptom improvement message', () {});
  test('should generate context pattern message', () {});
  test('should generate goal progress message', () {});
  test('should generate adherence correlation message', () {});
  test('should return default message when no condition met', () {});
  test('should prioritize messages by importance', () {});
});
```

**Implementation Order (TDD):**
1. CalculateContinuousRecordDaysUseCase
2. CalculateCurrentWeekUseCase
3. CalculateWeeklyProgressUseCase
4. CalculateAdherenceUseCase
5. CalculateWeightGoalEstimateUseCase
6. VerifyBadgeConditionsUseCase
7. GenerateInsightMessageUseCase (P1)

**Dependencies**: Domain Entities

---

### 3.3 Domain Layer - Repository Interface

**Location**: `lib/features/dashboard/domain/repositories/badge_repository.dart`

**Responsibility**: 뱃지 데이터 접근 인터페이스 정의

**Test Strategy**: Mock으로 검증 (실제 구현은 Infrastructure 테스트)

**Test Scenarios (Red Phase):**
```dart
group('BadgeRepository Interface', () {
  test('should define getBadgeDefinitions method', () {});
  test('should define getUserBadges method', () {});
  test('should define updateBadgeProgress method', () {});
  test('should define achieveBadge method', () {});
});
```

**Implementation Order:**
1. BadgeRepository Interface 정의

**Dependencies**: Badge Entity (Domain)

---

### 3.4 Infrastructure Layer - Repository Implementation

**Location**: `lib/features/dashboard/infrastructure/repositories/isar_badge_repository.dart`

**Responsibility**: Isar DB를 통한 뱃지 CRUD 구현

**Test Strategy**: Integration Test (Isar In-Memory DB)

**Test Scenarios (Red Phase):**
```dart
group('IsarBadgeRepository', () {
  late Isar isar;
  late IsarBadgeRepository repository;

  setUp(() async {
    isar = await Isar.open([BadgeDefinitionDtoSchema, UserBadgeDtoSchema],
                            directory: '');
    repository = IsarBadgeRepository(isar);
  });

  tearDown(() async {
    await isar.close(deleteFromDisk: true);
  });

  test('should get all badge definitions', () {});
  test('should get user badges by userId', () {});
  test('should update badge progress', () {});
  test('should achieve badge (status to achieved)', () {});
  test('should create new badge if not exists', () {});
  test('should handle concurrent updates safely', () {});
});
```

**Implementation Order:**
1. BadgeDefinitionDto (Isar Collection)
2. UserBadgeDto (Isar Collection)
3. IsarBadgeRepository Implementation

**Dependencies**:
- Isar
- BadgeRepository Interface
- Badge Entities

---

### 3.5 Application Layer - DashboardNotifier

**Location**: `lib/features/dashboard/application/notifiers/dashboard_notifier.dart`

**Responsibility**: 대시보드 상태 관리 및 UseCase 오케스트레이션

**Test Strategy**: Integration Test (Mock Repository)

**Test Scenarios (Red Phase):**
```dart
group('DashboardNotifier', () {
  late MockProfileRepository mockProfileRepository;
  late MockTrackingRepository mockTrackingRepository;
  late MockMedicationRepository mockMedicationRepository;
  late MockBadgeRepository mockBadgeRepository;
  late ProviderContainer container;

  setUp(() {
    mockProfileRepository = MockProfileRepository();
    mockTrackingRepository = MockTrackingRepository();
    mockMedicationRepository = MockMedicationRepository();
    mockBadgeRepository = MockBadgeRepository();

    container = ProviderContainer(
      overrides: [
        profileRepositoryProvider.overrideWithValue(mockProfileRepository),
        trackingRepositoryProvider.overrideWithValue(mockTrackingRepository),
        medicationRepositoryProvider.overrideWithValue(mockMedicationRepository),
        badgeRepositoryProvider.overrideWithValue(mockBadgeRepository),
      ],
    );
  });

  tearDown(() {
    container.dispose();
  });

  test('should load dashboard data on build', () async {});
  test('should emit loading state initially', () {});
  test('should emit data state after successful load', () {});
  test('should emit error state on repository failure', () {});
  test('should refresh data on refresh() call', () {});
  test('should calculate all statistics correctly', () {});
  test('should verify badge conditions and update progress', () {});
  test('should detect new badge achievement', () {});
  test('should handle empty data gracefully', () {});
  test('should aggregate data from multiple repositories', () {});
});
```

**Implementation Order:**
1. DashboardNotifier build() method
2. refresh() method
3. _loadDashboardData() private method
4. Badge verification logic integration
5. 실시간 갱신 메커니즘 (TrackingRepository Stream 구독 또는 명시적 refresh() 트리거)

**실시간 갱신 전략:**
- Phase 0: 퀵 액션 완료 후 DashboardNotifier.refresh() 명시적 호출
- Phase 1: Supabase Realtime을 통한 자동 갱신으로 전환

**Dependencies**:
- All Repositories
- All Domain UseCases
- DashboardData Entity

---

### 3.6 Application Layer - Derived Providers

**Location**: `lib/features/dashboard/application/providers.dart`

**Responsibility**: 특정 데이터 파생 계산

**Test Strategy**: Unit Test (Provider Test)

**Test Scenarios (Red Phase):**
```dart
group('continuousRecordDaysProvider', () {
  test('should derive continuous days from tracking repository', () {});
  test('should return 0 when no records', () {});
  test('should invalidate when tracking data changes', () {});
});

group('currentWeekProvider', () {
  test('should calculate week from medication start date', () {});
  test('should update when time changes', () {});
});

group('weeklyProgressProvider', () {
  test('should aggregate progress from multiple sources', () {});
  test('should handle missing data', () {});
});

group('insightMessageProvider', () {
  test('should generate message based on dashboard data', () {});
  test('should return null when no insight', () {});
});
```

**Implementation Order:**
1. continuousRecordDaysProvider
2. currentWeekProvider
3. weeklyProgressProvider
4. insightMessageProvider (P1)

**Dependencies**:
- Repositories
- UseCases

---

### 3.7 Presentation Layer - Widgets

**Location**: `lib/features/dashboard/presentation/widgets/`

**Responsibility**: UI 컴포넌트 렌더링

**Test Strategy**: Widget Test + Golden Test

**Test Scenarios (Red Phase):**

#### GreetingWidget
```dart
group('GreetingWidget', () {
  testWidgets('should display user name correctly', (tester) async {});
  testWidgets('should display continuous record days', (tester) async {});
  testWidgets('should display current week', (tester) async {});
  testWidgets('should show loading state', (tester) async {});
  testWidgets('should match golden file', (tester) async {});
});
```

#### WeeklyProgressWidget
```dart
group('WeeklyProgressWidget', () {
  testWidgets('should display dose progress bar', (tester) async {});
  testWidgets('should display weight record progress bar', (tester) async {});
  testWidgets('should display symptom record progress bar', (tester) async {});
  testWidgets('should highlight 100% achievement', (tester) async {});
  testWidgets('should show 0% for no progress', (tester) async {});
  testWidgets('should match golden file', (tester) async {});
});
```

#### QuickActionWidget
```dart
group('QuickActionWidget', () {
  testWidgets('should render three action buttons', (tester) async {});
  testWidgets('should navigate on button tap', (tester) async {});
  testWidgets('should prevent duplicate taps (debounce)', (tester) async {});
  testWidgets('should match golden file', (tester) async {});
});
```

#### NextScheduleWidget
```dart
group('NextScheduleWidget', () {
  testWidgets('should display next dose date and amount', (tester) async {});
  testWidgets('should display next escalation date', (tester) async {});
  testWidgets('should display goal estimate date', (tester) async {});
  testWidgets('should handle null escalation date', (tester) async {});
  testWidgets('should match golden file', (tester) async {});
});
```

#### WeeklyReportWidget
```dart
group('WeeklyReportWidget', () {
  testWidgets('should display text summary', (tester) async {});
  testWidgets('should render mini chart', (tester) async {});
  testWidgets('should display adherence percentage', (tester) async {});
  testWidgets('should navigate on tap', (tester) async {});
  testWidgets('should match golden file', (tester) async {});
});
```

#### TimelineWidget
```dart
group('TimelineWidget', () {
  testWidgets('should render timeline events', (tester) async {});
  testWidgets('should display milestones correctly', (tester) async {});
  testWidgets('should show progress to next goal', (tester) async {});
  testWidgets('should handle empty timeline', (tester) async {});
  testWidgets('should match golden file', (tester) async {});
});
```

#### BadgeWidget
```dart
group('BadgeWidget', () {
  testWidgets('should display achieved badges', (tester) async {});
  testWidgets('should display in-progress badges', (tester) async {});
  testWidgets('should show progress percentage', (tester) async {});
  testWidgets('should show achievement animation', (tester) async {});
  testWidgets('should match golden file', (tester) async {});
});
```

#### CelebrationAnimationWidget
```dart
group('CelebrationAnimationWidget', () {
  testWidgets('should show celebration animation on trigger', (tester) async {});
  testWidgets('should auto-dismiss after animation completes', (tester) async {});
  testWidgets('should not show when no achievement', (tester) async {});
  testWidgets('should match golden file', (tester) async {});
});
```

**Implementation Order:**
1. GreetingWidget
2. WeeklyProgressWidget
3. QuickActionWidget
4. NextScheduleWidget
5. WeeklyReportWidget
6. TimelineWidget
7. BadgeWidget
8. CelebrationAnimationWidget

**Dependencies**:
- Application Notifiers/Providers
- Riverpod ConsumerWidget
- Lottie or Confetti Package (CelebrationAnimationWidget용)

---

### 3.8 Presentation Layer - DashboardScreen

**Location**: `lib/features/dashboard/presentation/screens/dashboard_screen.dart`

**Responsibility**: 대시보드 전체 화면 구성

**Test Strategy**: Acceptance Test (Widget Test)

**Test Scenarios (Red Phase):**
```dart
group('DashboardScreen Acceptance Tests', () {
  testWidgets('should render all sections on successful load', (tester) async {});
  testWidgets('should show loading indicator initially', (tester) async {});
  testWidgets('should show error message on failure', (tester) async {});
  testWidgets('should refresh on pull-to-refresh', (tester) async {});
  testWidgets('should navigate on quick action tap', (tester) async {});
  testWidgets('should show celebration animation on dose completion', (tester) async {});
  testWidgets('should show 100% achievement highlight', (tester) async {});
  testWidgets('should display empty state for new user', (tester) async {});
  testWidgets('should update statistics in real-time after quick action', (tester) async {});
  testWidgets('should match golden file (full screen)', (tester) async {});
});
```

**QA Sheet (Manual Testing):**
1. 홈 화면 진입 시 모든 섹션 정상 렌더링 확인
2. 개인화 인사 영역 데이터 정확도 확인
3. 주간 목표 진행도 시각화 정확도 확인
4. 퀵 액션 버튼 네비게이션 동작 확인
5. 다음 일정 표시 정확도 확인
6. 주간 리포트 차트 렌더링 확인
7. 타임라인 이벤트 정렬 확인
8. 뱃지 획득 조건 충족 시 알림 확인
9. 투여 완료 시 축하 효과 확인
10. Pull-to-Refresh 동작 확인
11. 네트워크 오류 시 캐시 데이터 표시 확인
12. 로딩 상태 UI 확인

**Implementation Order:**
1. DashboardScreen Layout
2. AsyncValue State Handling (Loading/Data/Error)
3. Pull-to-Refresh
4. Navigation Integration
5. CelebrationAnimationWidget (투여 완료 시 축하 효과)
6. Achievement Highlight (주간 목표 100% 달성 시 시각적 강조)

**축하 효과 구현 방안:**
- CelebrationAnimationWidget: Lottie 애니메이션 또는 Confetti 효과
- 트리거 조건: 퀵 액션 완료 후 DashboardNotifier에서 achievement 플래그 설정
- 표시 위치: DashboardScreen 중앙 오버레이

**Dependencies**:
- DashboardNotifier
- All Widgets
- Router (core/routing)
- Lottie or Confetti Package (축하 효과용)

---

## 4. TDD Workflow

### Phase 1: Domain Layer (Inside-Out)
1. **Start**: Entity 테스트 작성 → 실패 확인 → Entity 구현 → 통과 확인
2. **UseCase**: 각 UseCase별로 Red → Green → Refactor
   - CalculateContinuousRecordDaysUseCase
   - CalculateCurrentWeekUseCase
   - CalculateWeeklyProgressUseCase
   - CalculateAdherenceUseCase
   - CalculateWeightGoalEstimateUseCase
   - VerifyBadgeConditionsUseCase
   - GenerateInsightMessageUseCase (P1)
3. **Commit Point**: 모든 Domain Layer 테스트 통과 후 Commit

### Phase 2: Infrastructure Layer
1. **Repository**: BadgeRepository 인터페이스 정의 → Isar 구현
2. **DTO**: BadgeDefinitionDto, UserBadgeDto 정의
3. **Integration Test**: In-Memory Isar로 CRUD 검증
4. **Commit Point**: Infrastructure Layer 테스트 통과 후 Commit

### Phase 3: Application Layer
1. **DashboardNotifier**: Mock Repository로 통합 테스트
   - build() → refresh() → private methods
2. **Derived Providers**: 각 Provider별 테스트
3. **Commit Point**: Application Layer 테스트 통과 후 Commit

### Phase 4: Presentation Layer (Outside-In)
1. **Widgets**: 각 Widget별 Red → Green → Refactor + Golden Test
   - GreetingWidget → WeeklyProgressWidget → QuickActionWidget → ...
2. **Screen**: DashboardScreen Acceptance Test
3. **QA Sheet**: Manual Testing
4. **Commit Point**: 모든 Presentation 테스트 통과 후 Commit

### Phase 5: Integration & Refactoring
1. **End-to-End Test**: 실제 앱에서 홈 화면 동작 검증
2. **Performance Profiling**: 대시보드 로딩 시간 측정 (< 1초 목표)
3. **Code Review**: Layer 의존성 검증, Repository Pattern 준수 확인
4. **Refactoring**: 중복 코드 제거, 공통 모듈 추출
5. **Final Commit**: "feat(dashboard): implement F006 home dashboard"

---

## 5. 핵심 원칙

### Test First
- 모든 테스트 케이스를 먼저 작성하고 실패를 확인한 후 구현
- 테스트 없는 코드 금지

### Small Steps
- 한 번에 하나의 테스트만 통과시키기
- 큰 변경은 작은 단위로 분해

### FIRST Principles
- **Fast**: 전체 테스트 스위트 < 10초
- **Independent**: 테스트 간 의존성 없음
- **Repeatable**: 환경 무관 재현 가능
- **Self-validating**: 자동 Pass/Fail 판정
- **Timely**: 구현 직전 테스트 작성

### Test Pyramid
- **Unit**: 70% (Domain UseCases, Entities)
- **Integration**: 20% (Application Notifiers, Infrastructure)
- **Acceptance**: 10% (Presentation Screen, E2E)

### Outside-In Strategy (Feature)
- 사용자 시나리오부터 시작
- Presentation → Application → Domain → Infrastructure 순서 검증

### Repository Pattern 엄수
- Application은 Repository Interface만 의존
- Infrastructure 구현 변경이 상위 Layer에 영향 없음
- Phase 0 → Phase 1 전환 대비
</file>

<file path="008/spec.md">
# Use Case Specification: UF-F006 홈 대시보드

## Primary Actor
GLP-1 치료 중인 사용자

## Precondition
- 사용자가 로그인 완료됨
- 온보딩(F000)을 통해 목표 체중 및 투여 계획이 설정됨

## Trigger
- 앱 실행
- 하단 탭에서 홈 탭 선택

## Main Scenario

### 1. 홈 대시보드 진입
1. 사용자가 앱을 실행하거나 홈 탭을 선택한다
2. FE는 BE에 대시보드 데이터 요청을 전송한다
3. BE는 Database에서 사용자 프로필, 투여 기록, 체중/부작용 기록, 뱃지 데이터를 조회한다
4. BE는 조회된 데이터를 기반으로 대시보드 통계를 계산한다
5. FE는 계산된 데이터를 화면에 렌더링한다

### 2. 개인화 인사 확인
1. 사용자가 홈 화면 상단의 개인화 인사 영역을 본다
2. FE는 사용자 이름, 연속 기록일, 현재 치료 주차를 표시한다

### 3. 주간 목표 진행도 확인
1. 사용자가 주간 목표 진행도 영역을 본다
2. FE는 투여 완료 목표, 체중 기록 목표, 부작용 기록 목표 각각의 달성률을 진행 바로 표시한다

### 4. 퀵 액션 버튼 사용
1. 사용자가 체중 기록, 부작용 기록, 또는 투여 완료 버튼을 클릭한다
2. FE는 해당 기록 화면(F002 또는 F001)으로 이동한다
3. 사용자가 기록을 완료하면 홈 화면으로 돌아온다
4. FE는 갱신된 데이터를 다시 요청하여 화면을 업데이트한다

### 5. 다음 예정 일정 확인
1. 사용자가 다음 예정 일정 영역을 본다
2. FE는 다음 투여 예정일 및 용량, 다음 증량 예정일(해당 시), 목표 달성 예상 시기를 표시한다

### 6. 주간 리포트 확인
1. 사용자가 주간 리포트 요약 영역을 본다
2. FE는 지난주 텍스트 요약, 최근 4주 체중 추이 미니 차트, 최근 1주 부작용 빈도, 투여 순응도를 표시한다
3. 사용자가 리포트 영역을 터치한다
4. FE는 데이터 공유 모드(F003) 상세 화면으로 이동한다

### 7. 치료 여정 타임라인 확인
1. 사용자가 타임라인 영역을 본다
2. FE는 치료 시작일부터 현재까지의 진행 상황을 시각화하여 표시한다
3. FE는 주요 마일스톤(용량 증량 시점, 체중 감량 목표 달성)을 표시한다

### 8. 성취 뱃지 확인
1. 사용자가 뱃지 영역을 본다
2. FE는 획득한 뱃지와 진행 중인 뱃지의 진행도를 표시한다
3. 새 뱃지 획득 시 FE는 축하 알림을 표시한다

### 9. 투여 완료 시 축하 효과
1. 사용자가 투여를 완료한다
2. FE는 축하 효과(애니메이션)를 표시한다

### 10. 주간 목표 100% 달성 시
1. 사용자가 주간 목표 항목 중 하나를 100% 달성한다
2. FE는 해당 항목을 시각적으로 강조 표시한다

## Edge Cases

### 신규 사용자 (데이터 없음)
- FE는 환영 메시지를 표시한다
- FE는 첫 기록 입력을 유도하는 안내를 표시한다
- 모든 통계는 초기값(0 또는 기본값)으로 표시한다

### 연속 기록일 중단
- BE는 연속 기록일을 0으로 리셋한다
- FE는 새로 시작하도록 격려하는 메시지를 표시한다

### 목표 달성 완료
- FE는 새 목표 설정을 유도하거나 유지 모드 안내를 표시한다

### 인사이트 생성 조건 미충족
- FE는 일반 격려 메시지를 표시한다

### 뱃지 획득 조건 동시 충족
- BE는 우선순위에 따라 뱃지 획득을 순차 처리한다
- FE는 뱃지를 순차적으로 알림한다

### 데이터 로딩 지연
- FE는 스켈레톤 UI 또는 로딩 인디케이터를 표시한다

### 과거 데이터 수정으로 통계 변동
- BE는 변경 감지 시 실시간으로 통계를 재계산한다
- FE는 갱신된 데이터를 화면에 반영한다

### 퀵 액션 연속 클릭
- FE는 중복 방지 처리(debounce)를 적용한다

### 네트워크 오류
- FE는 로컬 캐시된 데이터를 표시한다
- FE는 재시도 버튼을 제공한다

## Business Rules

### BR-001: 연속 기록일 계산
- 마지막 기록 날짜(F002 체중 또는 부작용 기록)부터 현재까지 일수를 계산한다
- 기록 없는 날이 발생하면 0으로 리셋한다

### BR-002: 치료 주차 계산
- 투여 시작일(F000)을 기준으로 현재 날짜까지의 주차를 계산한다
- 1주 = 7일 기준으로 계산한다

### BR-003: 주간 목표 달성률 계산
- 투여 완료 목표: (주간 실제 완료 횟수 / 주간 예정 투여 횟수) × 100
- 체중 기록 목표: (주간 실제 기록 횟수 / 주간 목표 기록 횟수) × 100
- 부작용 기록 목표: (주간 실제 기록 횟수 / 주간 목표 기록 횟수) × 100

### BR-004: 목표 달성 예상 시기 계산
- 최근 4주 체중 감량 추세를 선형 회귀 분석한다
- 현재 체중에서 목표 체중까지 도달하는 예상 일수를 계산한다

### BR-005: 투여 순응도 계산
- (실제 완료한 투여 횟수 / 예정된 투여 횟수) × 100
- 기준 기간: 치료 시작일부터 현재까지

### BR-006: 뱃지 획득 조건
- 연속 7일 기록: 마지막 7일간 연속으로 체중 또는 부작용 기록이 있는 경우
- 연속 30일 기록: 마지막 30일간 연속으로 체중 또는 부작용 기록이 있는 경우
- 체중 5% 감량: 시작 체중 대비 5% 이상 감량한 경우
- 체중 10% 감량: 시작 체중 대비 10% 이상 감량한 경우
- 첫 투여 완료: 첫 투여 기록이 완료된 경우

### BR-007: 뱃지 진행도 계산
- 각 뱃지별 현재 진행 상황을 백분율로 계산한다
- 예: 연속 7일 기록의 경우, 현재 연속 기록일 / 7 × 100

### BR-008: 타임라인 마일스톤
- 용량 증량 시점: dose_schedules 테이블에서 scheduled_dose_mg가 변경되는 시점
- 체중 감량 목표 달성: 시작 체중 대비 목표 체중의 특정 구간 달성(25%, 50%, 75%, 100%)

### BR-009: 주간 리포트 기준
- 주간: 최근 7일
- 지난주 텍스트 요약: 투여 완료 횟수, 체중 변화량(kg), 부작용 기록 횟수
- 최근 4주 체중 추이: 4주(28일) 기간의 체중 기록

### BR-010: 데이터 갱신 주기
- 퀵 액션으로 기록 완료 후: 즉시 갱신
- 홈 화면 재진입 시: 즉시 갱신
- 백그라운드에서 포그라운드 전환 시: 즉시 갱신

---

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE
participant BE
database Database

User -> FE: 앱 실행 또는 홈 탭 선택
activate FE
FE -> BE: GET /dashboard
activate BE
BE -> Database: SELECT user_profiles WHERE user_id = ?
activate Database
Database --> BE: user_profile
deactivate Database
BE -> Database: SELECT dose_records WHERE dosage_plan_id = ?
activate Database
Database --> BE: dose_records
deactivate Database
BE -> Database: SELECT weight_logs WHERE user_id = ? AND log_date >= ?
activate Database
Database --> BE: weight_logs
deactivate Database
BE -> Database: SELECT symptom_logs WHERE user_id = ? AND log_date >= ?
activate Database
Database --> BE: symptom_logs
deactivate Database
BE -> Database: SELECT user_badges WHERE user_id = ?
activate Database
Database --> BE: user_badges
deactivate Database
BE -> BE: 연속 기록일 계산
BE -> BE: 치료 주차 계산
BE -> BE: 주간 목표 달성률 계산
BE -> BE: 투여 순응도 계산
BE -> BE: 목표 달성 예상 시기 계산
BE -> BE: 뱃지 획득 조건 검증
BE --> FE: dashboard_data
deactivate BE
FE -> FE: 화면 렌더링
FE --> User: 대시보드 표시
deactivate FE

User -> FE: 체중 기록 버튼 클릭
activate FE
FE --> User: 체중 기록 화면으로 이동
deactivate FE

User -> FE: 체중 기록 완료
activate FE
FE -> BE: POST /weight-logs
activate BE
BE -> Database: INSERT INTO weight_logs
activate Database
Database --> BE: success
deactivate Database
BE --> FE: 201 Created
deactivate BE
FE --> User: 홈 화면으로 복귀
deactivate FE

User -> FE: 홈 화면 표시
activate FE
FE -> BE: GET /dashboard
activate BE
BE -> Database: SELECT weight_logs WHERE user_id = ?
activate Database
Database --> BE: weight_logs
deactivate Database
BE -> BE: 연속 기록일 재계산
BE -> BE: 주간 목표 달성률 재계산
BE -> BE: 뱃지 획득 조건 재검증
BE --> FE: dashboard_data
deactivate BE
FE -> FE: 갱신된 데이터 렌더링
FE --> User: 갱신된 대시보드 표시
deactivate FE

User -> FE: 뱃지 영역 확인
activate FE
FE --> User: 획득한 뱃지 및 진행도 표시
deactivate FE

User -> FE: 주간 리포트 터치
activate FE
FE --> User: 데이터 공유 모드(F003)로 이동
deactivate FE
@enduml
```
</file>

<file path="009/plan.md">
# UF-SETTINGS Implementation Plan

## 1. 개요

설정 화면 UI 및 네비게이션 구현 (프로필 데이터는 별도 Feature로 분리)

### Feature 분리
- **settings**: 설정 화면 UI, 메뉴 네비게이션
- **profile**: 사용자 프로필 데이터 관리 (재사용 가능)

### 모듈 목록
**Settings Feature**:
- `SettingsScreen` (Presentation): 설정 메뉴 UI, 네비게이션
- `SettingsMenuItem` (Presentation): 메뉴 항목 위젯

**Profile Feature** (별도 plan.md에서 구현):
- `UserProfile` (Domain): 프로필 엔티티
- `ProfileRepository` (Domain): 프로필 저장소 인터페이스
- `UserProfileNotifier` (Application): 프로필 상태 관리
- `IsarProfileRepository` (Infrastructure): Isar 구현
- `UserProfileDto` (Infrastructure): DTO

### TDD 적용 범위
- Widget: SettingsScreen UI, 네비게이션, 인증 검증
- Integration: 설정 화면 → 타 화면 전환 플로우

---

## 2. Architecture Diagram

```mermaid
graph TD
    %% Presentation Layer (Settings Feature)
    SettingsScreen[SettingsScreen<br/>설정 메뉴 UI]
    SettingsMenuItem[SettingsMenuItem<br/>메뉴 항목 위젯]

    %% External Dependencies
    AuthNotifier[AuthNotifier<br/>인증 상태 확인만]
    UserProfileNotifier[UserProfileNotifier<br/>프로필 표시용<br/>profile feature]
    AppRouter[GoRouter<br/>네비게이션]

    %% Navigation Targets
    ProfileEditScreen[UF-008<br/>프로필 수정]
    DosePlanScreen[UF-009<br/>투여 계획]
    WeeklyGoalScreen[UF-013<br/>주간 목표]
    NotificationScreen[UF-012<br/>알림 설정]

    %% Dependencies
    SettingsScreen --> SettingsMenuItem
    SettingsScreen --> AuthNotifier
    SettingsScreen --> UserProfileNotifier
    SettingsScreen --> AppRouter

    AppRouter -.navigate.-> ProfileEditScreen
    AppRouter -.navigate.-> DosePlanScreen
    AppRouter -.navigate.-> WeeklyGoalScreen
    AppRouter -.navigate.-> NotificationScreen
```

**설계 원칙**:
1. Settings Feature는 UI와 네비게이션만 담당
2. AuthNotifier는 로그인 상태 확인만 (로그아웃 처리 포함)
3. UserProfileNotifier는 프로필 표시용으로만 사용
4. 모든 화면 전환은 GoRouter를 통해 처리

---

## 3. Implementation Plan

**참고**: Profile Feature (UserProfile, ProfileRepository 등)는 별도 plan.md에서 구현

### 3.1. SettingsScreen (Presentation)

**Location**: `lib/features/settings/presentation/screens/settings_screen.dart`

**Responsibility**: 설정 메뉴 UI, 로그인 검증, 네비게이션

**Test Strategy**: Widget Test + QA Sheet

**Test Scenarios (Red Phase)**:
```dart
// 1. 로그인 검증 테스트 (Business Rule 1)
testWidgets('should redirect to login when not authenticated', (tester) async {
  // Arrange
  final mockAuthNotifier = MockAuthNotifier();
  when(() => mockAuthNotifier.isAuthenticated).thenReturn(false);

  // Act
  await tester.pumpWidget(
    ProviderScope(
      overrides: [
        authNotifierProvider.overrideWith(() => mockAuthNotifier),
      ],
      child: MaterialApp.router(
        routerConfig: router,
      ),
    ),
  );
  await tester.pumpAndSettle();

  // Assert
  expect(find.byType(LoginScreen), findsOneWidget);
});

// 2. 설정 화면 렌더링 테스트
testWidgets('should display settings menu items', (tester) async {
  // Arrange
  final mockAuthNotifier = MockAuthNotifier();
  when(() => mockAuthNotifier.isAuthenticated).thenReturn(true);

  final mockProfileNotifier = MockUserProfileNotifier();
  when(() => mockProfileNotifier.build()).thenReturn(AsyncValue.data(profile));

  // Act
  await tester.pumpWidget(
    ProviderScope(
      overrides: [
        authNotifierProvider.overrideWith(() => mockAuthNotifier),
        userProfileNotifierProvider.overrideWith(() => mockProfileNotifier),
      ],
      child: MaterialApp(home: SettingsScreen()),
    ),
  );

  // Assert
  expect(find.text('프로필 및 목표 수정'), findsOneWidget);
  expect(find.text('투여 계획 수정'), findsOneWidget);
  expect(find.text('주간 기록 목표 조정'), findsOneWidget);
  expect(find.text('푸시 알림 설정'), findsOneWidget);
  expect(find.text('로그아웃'), findsOneWidget);
});

// 3. 사용자 정보 표시 테스트
testWidgets('should display user information', (tester) async {
  // Arrange
  final profile = UserProfile(name: '홍길동', ...);
  when(() => mockProfileNotifier.build()).thenReturn(AsyncValue.data(profile));

  // Act
  await tester.pumpWidget(...);

  // Assert
  expect(find.text('홍길동'), findsOneWidget);
});

// 4. 로딩 상태 테스트 (Edge Case 3)
testWidgets('should show loading indicator when profile is loading', (tester) async {
  // Arrange
  when(() => mockProfileNotifier.build()).thenReturn(const AsyncValue.loading());

  // Act
  await tester.pumpWidget(...);

  // Assert
  expect(find.byType(CircularProgressIndicator), findsOneWidget);
});

// 5. 에러 상태 및 재시도 테스트
testWidgets('should show error message with retry button', (tester) async {
  // Arrange
  when(() => mockProfileNotifier.build())
    .thenReturn(AsyncValue.error(NetworkException(), StackTrace.empty));

  // Act
  await tester.pumpWidget(...);

  // Assert
  expect(find.text('프로필 정보를 불러올 수 없습니다'), findsOneWidget);
  expect(find.text('다시 시도'), findsOneWidget);

  // Act: 재시도
  await tester.tap(find.text('다시 시도'));
  await tester.pumpAndSettle();

  // Assert
  verify(() => mockProfileNotifier.loadProfile(any())).called(1);
});

// 6. 세션 만료 처리 테스트 (Edge Case 1)
testWidgets('should redirect to login on session expired', (tester) async {
  // Arrange
  when(() => mockProfileNotifier.build())
    .thenReturn(AsyncValue.error(UnauthorizedException(), StackTrace.empty));

  // Act
  await tester.pumpWidget(...);
  await tester.pumpAndSettle();

  // Assert
  expect(find.byType(LoginScreen), findsOneWidget);
});

// 7. 네비게이션 테스트 - 프로필 수정
testWidgets('should navigate to profile edit screen', (tester) async {
  // Arrange & Act
  await tester.pumpWidget(...);
  await tester.tap(find.text('프로필 및 목표 수정'));
  await tester.pumpAndSettle();

  // Assert
  expect(find.byType(ProfileEditScreen), findsOneWidget);
});

// 8. 네비게이션 테스트 - 투여 계획
testWidgets('should navigate to dose plan screen', (tester) async {
  await tester.tap(find.text('투여 계획 수정'));
  await tester.pumpAndSettle();
  expect(find.byType(DosePlanScreen), findsOneWidget);
});

// 9. 네비게이션 테스트 - 주간 목표
testWidgets('should navigate to weekly goal screen', (tester) async {
  await tester.tap(find.text('주간 기록 목표 조정'));
  await tester.pumpAndSettle();
  expect(find.byType(WeeklyGoalScreen), findsOneWidget);
});

// 10. 네비게이션 테스트 - 알림 설정
testWidgets('should navigate to notification settings', (tester) async {
  await tester.tap(find.text('푸시 알림 설정'));
  await tester.pumpAndSettle();
  expect(find.byType(NotificationSettingsScreen), findsOneWidget);
});

// 11. 로그아웃 확인 다이얼로그 테스트 (Business Rule 5)
testWidgets('should show confirmation dialog before logout', (tester) async {
  // Act
  await tester.tap(find.text('로그아웃'));
  await tester.pumpAndSettle();

  // Assert
  expect(find.text('로그아웃 하시겠습니까?'), findsOneWidget);
  expect(find.text('취소'), findsOneWidget);
  expect(find.text('확인'), findsOneWidget);
});

// 12. 로그아웃 실행 테스트
testWidgets('should logout when confirmed', (tester) async {
  // Arrange
  await tester.tap(find.text('로그아웃'));
  await tester.pumpAndSettle();

  // Act
  await tester.tap(find.text('확인'));
  await tester.pumpAndSettle();

  // Assert
  verify(() => mockAuthNotifier.logout()).called(1);
  expect(find.byType(LoginScreen), findsOneWidget);
});

// 13. 로그아웃 취소 테스트
testWidgets('should cancel logout when dismissed', (tester) async {
  // Arrange
  await tester.tap(find.text('로그아웃'));
  await tester.pumpAndSettle();

  // Act
  await tester.tap(find.text('취소'));
  await tester.pumpAndSettle();

  // Assert
  verifyNever(() => mockAuthNotifier.logout());
  expect(find.byType(SettingsScreen), findsOneWidget);
});
```

**Implementation Order**:
1. Red: 로그인 검증 테스트
2. Green: AuthNotifier 통합, 미인증 시 리다이렉트
3. Red: 메뉴 렌더링 테스트
4. Green: 기본 UI 구조
5. Red: 사용자 정보 표시 테스트
6. Green: UserProfileNotifier 통합
7. Red: 로딩/에러 상태 테스트
8. Green: AsyncValue 처리
9. Red: 네비게이션 테스트 5개
10. Green: GoRouter 통합, 라우팅 구현
11. Red: 로그아웃 다이얼로그 테스트
12. Green: 확인 다이얼로그 구현
13. Refactor: 위젯 분리 (SettingsMenuItem), 스타일 개선

**Implementation Details**:
```dart
// 로그인 검증 (Business Rule 1)
class SettingsScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authNotifierProvider);

    if (!authState.isAuthenticated) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        context.go('/login');
      });
      return const SizedBox.shrink();
    }

    final profileState = ref.watch(userProfileNotifierProvider);

    return profileState.when(
      data: (profile) => _buildSettings(context, profile, ref),
      loading: () => const CircularProgressIndicator(),
      error: (error, stack) => _buildError(error, ref),
    );
  }

  Widget _buildError(Object error, WidgetRef ref) {
    // Edge Case 1: 세션 만료
    if (error is UnauthorizedException) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        context.go('/login');
      });
      return const SizedBox.shrink();
    }

    // Edge Case 2: 네트워크 오류 - 재시도 옵션
    return Column(
      children: [
        Text('프로필 정보를 불러올 수 없습니다'),
        ElevatedButton(
          onPressed: () {
            final userId = ref.read(authNotifierProvider).currentUserId;
            ref.read(userProfileNotifierProvider.notifier).loadProfile(userId);
          },
          child: Text('다시 시도'),
        ),
      ],
    );
  }

  Widget _buildSettings(BuildContext context, UserProfile profile, WidgetRef ref) {
    return ListView(
      children: [
        // 사용자 정보
        ListTile(
          title: Text(profile.name),
          subtitle: Text('목표 체중: ${profile.targetWeightKg}kg'),
        ),
        Divider(),

        // 메뉴 항목들 (Business Rule 3: 설명 포함)
        SettingsMenuItem(
          title: '프로필 및 목표 수정',
          subtitle: '이름과 목표 체중을 변경할 수 있습니다',
          onTap: () => context.push('/profile/edit'),
        ),
        SettingsMenuItem(
          title: '투여 계획 수정',
          subtitle: '약물 투여 계획을 변경할 수 있습니다',
          onTap: () => context.push('/dose-plan/edit'),
        ),
        SettingsMenuItem(
          title: '주간 기록 목표 조정',
          subtitle: '주간 체중 및 증상 기록 목표를 설정합니다',
          onTap: () => context.push('/weekly-goal/edit'),
        ),
        SettingsMenuItem(
          title: '푸시 알림 설정',
          subtitle: '알림 시간과 방식을 설정합니다',
          onTap: () => context.push('/notification/settings'),
        ),
        Divider(),

        // Business Rule 4: 로그아웃은 하단 배치
        SettingsMenuItem(
          title: '로그아웃',
          subtitle: '앱에서 로그아웃합니다',
          onTap: () => _handleLogout(context, ref),
        ),
      ],
    );
  }

  // Business Rule 5: 확인 단계 필요
  Future<void> _handleLogout(BuildContext context, WidgetRef ref) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('로그아웃 하시겠습니까?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text('취소'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: Text('확인'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await ref.read(authNotifierProvider.notifier).logout();
      if (context.mounted) {
        context.go('/login');
      }
    }
  }
}
```

**Dependencies**: `UserProfileNotifier`, `AuthNotifier`, `go_router`

**QA Sheet (수동 테스트)**:
- [ ] 비로그인 상태에서 설정 화면 접근 시 로그인 화면으로 이동
- [ ] 설정 화면 진입 시 사용자 이름 및 목표 체중 표시
- [ ] 5개 메뉴 항목 모두 표시 (레이블 + 설명)
- [ ] 각 메뉴 항목 탭 시 올바른 화면 이동
- [ ] 로그아웃 버튼은 목록 하단에 배치
- [ ] 로그아웃 버튼 탭 시 확인 다이얼로그 표시
- [ ] 확인 선택 시 로그아웃 후 로그인 화면 이동
- [ ] 취소 선택 시 설정 화면 유지
- [ ] 네트워크 오류 시 재시도 옵션 표시
- [ ] 로딩 중 스켈레톤 UI 또는 인디케이터 표시

---

## 4. TDD Workflow

### Phase 1: Presentation Layer (Settings Feature만 구현)
1. **Start**: SettingsScreen 위젯 테스트 작성 (로그인 검증)
2. Red → Green → Refactor
3. Commit: "feat(settings): add authentication check"
4. **Next**: 메뉴 렌더링 테스트
5. Red → Green → Refactor
6. Commit: "feat(settings): implement menu UI"
7. **Next**: 네비게이션 테스트 (5개 화면)
8. Red → Green → Refactor
9. Commit: "feat(settings): implement navigation"
10. **Next**: 로그아웃 다이얼로그 테스트
11. Red → Green → Refactor
12. Commit: "feat(settings): implement logout flow"

### Phase 2: Integration
1. **Start**: 설정 화면 → 타 화면 전환 통합 테스트
2. Red → Green → Refactor
3. Commit: "test(settings): add integration tests"

### 완료 조건
- [ ] 모든 Widget 테스트 통과 (13개)
- [ ] Integration 테스트 통과
- [ ] QA Sheet 항목 모두 검증 (10개)
- [ ] 5개 화면으로 네비게이션 동작 확인
- [ ] 로그인 검증 및 세션 만료 처리 확인
- [ ] flutter analyze 경고 없음

---

## 5. Edge Cases 처리

### 5.1. 로그인 세션 만료
**구현**:
```dart
Widget _buildError(Object error, WidgetRef ref) {
  if (error is UnauthorizedException) {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.go('/login');
    });
    return const SizedBox.shrink();
  }
  // ...
}
```

**Test**: 섹션 3.1의 "Test 6" 참조

### 5.2. 네트워크 오류
**구현**:
```dart
Widget _buildError(Object error, WidgetRef ref) {
  // 네트워크 오류 시 재시도 옵션 제공
  return Column(
    children: [
      Text('프로필 정보를 불러올 수 없습니다'),
      ElevatedButton(
        onPressed: () {
          final userId = ref.read(authNotifierProvider).currentUserId;
          ref.read(userProfileNotifierProvider.notifier).loadProfile(userId);
        },
        child: Text('다시 시도'),
      ),
    ],
  );
}
```

**Test**: 섹션 3.1의 "Test 5" 참조

**참고**: 캐시 전략은 Profile Feature의 IsarProfileRepository에서 구현

### 5.3. 데이터 로딩 지연
**구현**:
```dart
return profileState.when(
  data: (profile) => _buildSettings(context, profile, ref),
  loading: () => const CircularProgressIndicator(),  // 로딩 UI
  error: (error, stack) => _buildError(error, ref),
);
```

**Test**: 섹션 3.1의 "Test 4" 참조

**참고**: Timeout 처리는 Profile Feature의 UserProfileNotifier에서 구현

---

## 6. 핵심 원칙 준수

### Feature 분리 원칙
- **Settings Feature**: UI와 네비게이션만 담당 (이 plan에서 구현)
- **Profile Feature**: 데이터 관리 담당 (별도 plan에서 구현)
- Settings는 Profile의 Notifier를 통해서만 데이터 접근

### Layer Dependency
```
SettingsScreen (Presentation)
  ↓
UserProfileNotifier (Application, Profile Feature)
  ↓
AuthNotifier (Application, Auth Feature)
  ↓
GoRouter (Infrastructure, Core)
```

### Business Rules 준수
1. **로그인 검증**: AuthNotifier.isAuthenticated 확인
2. **실시간 조회**: UserProfileNotifier가 매번 새로 조회 (Profile Feature 책임)
3. **메뉴 설명**: 모든 메뉴 항목에 subtitle 제공
4. **로그아웃 하단 배치**: Divider로 분리
5. **확인 다이얼로그**: 로그아웃 시 AlertDialog 표시

### Test Pyramid
- Widget: 85% (SettingsScreen 13개 테스트)
- Integration: 15% (네비게이션 플로우)

### FIRST Principles
- Fast: 모든 테스트 100ms 이내
- Independent: 각 테스트 독립 실행
- Repeatable: 동일 결과 보장
- Self-validating: 자동 검증
- Timely: 코드 작성 전 테스트 작성

---

## 7. 다른 Feature와의 상호작용

### 필수 의존성
1. **Profile Feature** (UserProfileNotifier)
   - `userProfileNotifierProvider`: 프로필 데이터 조회
   - `loadProfile(userId)`: 재시도 시 사용

2. **Auth Feature** (AuthNotifier)
   - `isAuthenticated`: 로그인 상태 확인
   - `currentUserId`: 프로필 조회용 ID
   - `logout()`: 로그아웃 실행

3. **Core Router** (GoRouter)
   - `/login`: 미인증 시 이동
   - `/profile/edit`: UF-008
   - `/dose-plan/edit`: UF-009
   - `/weekly-goal/edit`: UF-013
   - `/notification/settings`: UF-012

### 네비게이션 타겟 화면
- `ProfileEditScreen` (UF-008)
- `DosePlanScreen` (UF-009)
- `WeeklyGoalScreen` (UF-013)
- `NotificationSettingsScreen` (UF-012)
- `LoginScreen` (UF-007 로그아웃 후)

**참고**: 타겟 화면들은 각자의 plan.md에서 구현
</file>

<file path="009/spec.md">
# UF-SETTINGS: 설정 화면 상세 유스케이스

## Primary Actor
GLP-1 치료 관리 앱 사용자

## Precondition
- 사용자가 로그인 상태
- 홈 대시보드 또는 다른 화면에 설정 아이콘/메뉴가 표시됨

## Trigger
사용자가 홈 대시보드 또는 다른 화면에서 설정 아이콘/메뉴 선택

## Main Scenario

1. 사용자가 설정 아이콘/메뉴 선택
2. 시스템이 설정 화면으로 이동
3. 시스템이 사용자 프로필 정보 조회
4. 시스템이 현재 사용자 정보 표시 (이름, 가입일)
5. 시스템이 설정 메뉴 목록 렌더링:
   - 프로필 및 목표 수정 (UF-008로 이동)
   - 투여 계획 수정 (UF-009로 이동)
   - 주간 기록 목표 조정 (UF-013으로 이동)
   - 푸시 알림 설정 (UF-012로 이동)
   - 로그아웃 (UF-007 실행)
6. 사용자가 원하는 설정 메뉴 선택
7. 시스템이 선택된 기능의 화면으로 이동

## Edge Cases

### 로그인 세션 만료
- 발생 조건: 설정 화면 접근 시 저장된 토큰이 만료됨
- 처리: 자동으로 로그인 화면으로 이동
- 사용자 안내: "세션이 만료되었습니다. 다시 로그인해주세요."

### 네트워크 오류로 프로필 로딩 실패
- 발생 조건: 사용자 프로필 정보 조회 시 네트워크 오류
- 처리: 캐시된 정보 표시 또는 재시도 옵션 제공
- 사용자 안내: "프로필 정보를 불러올 수 없습니다. 다시 시도하시겠습니까?"

### 데이터 로딩 지연
- 발생 조건: 사용자 프로필 정보 조회에 시간이 소요됨
- 처리: 로딩 인디케이터 표시
- 사용자 안내: 스피너 또는 스켈레톤 UI

## Business Rules

1. 설정 화면은 로그인된 사용자만 접근 가능
2. 사용자 정보는 실시간으로 조회하여 최신 상태 유지
3. 각 설정 메뉴는 명확한 레이블과 설명 제공
4. 로그아웃 메뉴는 목록 하단에 배치
5. 설정 변경 시 사용자 확인 단계 필요 (UF-007, UF-008, UF-009, UF-012, UF-013)

---

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE
participant BE
database Database

User -> FE: 설정 아이콘/메뉴 선택
FE -> FE: 설정 화면으로 이동
FE -> BE: 사용자 프로필 정보 조회 요청
BE -> Database: SELECT FROM users WHERE id = user_id
Database --> BE: 사용자 정보 반환
BE --> FE: 사용자 프로필 정보 반환
FE -> FE: 사용자 정보 표시 (이름, 가입일)
FE -> FE: 설정 메뉴 목록 렌더링
FE --> User: 설정 화면 표시

alt 로그인 세션 만료
    FE -> BE: 사용자 프로필 정보 조회 요청
    BE --> FE: 401 Unauthorized
    FE -> FE: 로그인 화면으로 이동
    FE --> User: "세션이 만료되었습니다" 안내
end

alt 네트워크 오류
    FE -> BE: 사용자 프로필 정보 조회 요청
    BE --> FE: Network Error
    FE -> FE: 캐시된 정보 표시
    FE --> User: "프로필 정보를 불러올 수 없습니다" 안내
    User -> FE: 재시도 선택
    FE -> BE: 사용자 프로필 정보 재조회 요청
end

User -> FE: 설정 메뉴 선택
FE -> FE: 선택된 기능의 화면으로 이동
FE --> User: 기능 화면 표시
@enduml
```
</file>

<file path="010/plan.md">
# Logout Implementation Plan

## 1. 개요

### 1.1 모듈 목록 및 위치

**Feature**: Authentication
**Location**: `lib/features/authentication/`

**구현 모듈**:
- **LogoutUseCase** (Domain): `domain/usecases/logout_usecase.dart`
- **AuthRepository** (Domain Interface): `domain/repositories/auth_repository.dart`
- **SecureStorageRepository** (Domain Interface): `domain/repositories/secure_storage_repository.dart`
- **FlutterSecureStorageRepository** (Infrastructure): `infrastructure/repositories/flutter_secure_storage_repository.dart`
- **AuthNotifier** (Application): `application/notifiers/auth_notifier.dart`
- **SettingsScreen** (Presentation): `presentation/screens/settings_screen.dart`
- **LogoutConfirmDialog** (Presentation): `presentation/widgets/logout_confirm_dialog.dart`
- **AppRouter** (Core): `core/routing/app_router.dart` (수정)

**Providers**:
- `secureStorageRepositoryProvider`: `infrastructure/providers/storage_provider.dart`
- `authRepositoryProvider`: `infrastructure/providers/auth_provider.dart`
- `logoutUseCaseProvider`: `domain/providers/usecase_provider.dart`
- `authNotifierProvider`: `application/providers/notifier_provider.dart`

### 1.2 TDD 적용 범위
- **Unit Tests**: Domain Layer (LogoutUseCase, Entity)
- **Integration Tests**: Application Layer (AuthNotifier + Repository)
- **Widget Tests**: Presentation Layer (Dialog, Screen)

---

## 2. Architecture Diagram

```mermaid
graph TD
    A[SettingsScreen] -->|"사용자 클릭"| B[LogoutConfirmDialog]
    B -->|"확인"| C[AuthNotifier]
    C -->|"logout()"| D[LogoutUseCase]
    D -->|"clearTokens()<br/>(최대 3회 재시도)"| E[SecureStorageRepository]
    D -->|"clearSession()"| F[AuthRepository]
    E -->|"구현"| G[FlutterSecureStorageRepository]
    F -->|"구현"| H[LocalAuthRepository]

    C -->|"상태 변경"| I[AsyncValue.data null]
    I -->|"감지"| J[AppRouter]
    J -->|"redirect"| K[LoginScreen]

    style D fill:#e1f5ff
    style E fill:#fff3e0
    style F fill:#fff3e0
    style G fill:#f3e5f5
    style H fill:#f3e5f5
    style J fill:#c8e6c9
```

---

## 3. Implementation Plan

### 3.1 AuthRepository Interface (Domain)

**Location**: `lib/features/authentication/domain/repositories/auth_repository.dart`

**Responsibility**: 인증 상태 및 세션 관리 추상화

**Test Strategy**: Unit Test

**Interface Definition**:
```dart
abstract class AuthRepository {
  /// 현재 인증된 사용자 정보 반환
  Future<AuthUser?> getCurrentUser();

  /// 세션 정보 초기화 (메모리 내 사용자 데이터 제거)
  /// 로그아웃 시 호출되며, Isar 데이터는 건드리지 않음
  Future<void> clearSession();

  /// 로그인 처리
  Future<AuthUser> login(String email, String password);
}
```

**Test Scenarios (Red Phase)**:
```dart
group('AuthRepository Interface', () {
  test('should define clearSession method', () {
    // Arrange: Mock 구현체 생성
    // Act: clearSession 호출
    // Assert: Future<void> 반환
  });

  test('should define getCurrentUser method', () {
    // Arrange: Mock 구현체 생성
    // Act: getCurrentUser 호출
    // Assert: Future<AuthUser?> 반환
  });
});
```

**Implementation Order**:
1. Interface 정의 (Red)
2. Mock 구현 (Green)
3. Interface 정리 (Refactor)

**Dependencies**: None

---

### 3.2 SecureStorageRepository (Domain Interface)

**Location**: `lib/features/authentication/domain/repositories/secure_storage_repository.dart`

**Responsibility**: 토큰 저장소 추상화

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```dart
// AAA Pattern
group('SecureStorageRepository Interface', () {
  test('should define clearTokens method', () {
    // Arrange: Mock 구현체 생성
    // Act: clearTokens 호출
    // Assert: Future<void> 반환
  });

  test('should define getAccessToken method', () {
    // Arrange: Mock 구현체 생성
    // Act: getAccessToken 호출
    // Assert: Future<String?> 반환
  });
});
```

**Implementation Order**:
1. Interface 정의 (Red)
2. Mock 구현 (Green)
3. Interface 정리 (Refactor)

**Dependencies**: None

---

### 3.3 FlutterSecureStorageRepository (Infrastructure)

**Location**: `lib/features/authentication/infrastructure/repositories/flutter_secure_storage_repository.dart`

**Responsibility**: FlutterSecureStorage를 통한 토큰 관리

**Test Strategy**: Unit Test (Mocked FlutterSecureStorage)

**Test Scenarios (Red Phase)**:
```dart
group('FlutterSecureStorageRepository', () {
  late FlutterSecureStorage mockStorage;
  late FlutterSecureStorageRepository repository;

  setUp(() {
    mockStorage = MockFlutterSecureStorage();
    repository = FlutterSecureStorageRepository(mockStorage);
  });

  test('should delete accessToken when clearTokens is called', () {
    // Arrange: mockStorage.delete 설정
    // Act: repository.clearTokens()
    // Assert: verify delete('accessToken')
  });

  test('should delete refreshToken when clearTokens is called', () {
    // Arrange: mockStorage.delete 설정
    // Act: repository.clearTokens()
    // Assert: verify delete('refreshToken')
  });

  test('should delete tokenExpiresAt when clearTokens is called', () {
    // Arrange: mockStorage.delete 설정
    // Act: repository.clearTokens()
    // Assert: verify delete('tokenExpiresAt')
  });

  test('should throw exception when delete fails', () {
    // Arrange: mockStorage.delete always throws
    // Act: repository.clearTokens()
    // Assert: expect throwsA(isA<StorageException>())
  });
});
```

**Edge Cases**:
- 저장소 접근 권한 오류
- 삭제 중 예외 발생

**Implementation Order**:
1. clearTokens 기본 구현 (Red → Green)
2. 에러 핸들링 (Red → Green)
3. 코드 정리 (Refactor)

**Note**: 재시도 로직은 Infrastructure Layer가 아닌 LogoutUseCase(Domain Layer)에서 처리

**Dependencies**: `flutter_secure_storage`, SecureStorageRepository

---

### 3.4 LogoutUseCase (Domain)

**Location**: `lib/features/authentication/domain/usecases/logout_usecase.dart`

**Responsibility**: 로그아웃 비즈니스 로직 (토큰 삭제 + 세션 초기화 + 재시도 로직)

**Test Strategy**: Unit Test

**Architecture Note - Why Two Repositories?**:
```
LogoutUseCase는 두 개의 Repository에 직접 의존:
1. SecureStorageRepository: 토큰 삭제
2. AuthRepository: 세션 초기화

이유:
- 토큰 삭제 실패 시에도 세션 초기화 진행 (EC3 대응)
- 각 Repository의 책임이 명확히 분리됨
- UseCase에서 비즈니스 로직(재시도, 실패 시 처리) 제어
```

**Test Scenarios (Red Phase)**:
```dart
group('LogoutUseCase', () {
  late SecureStorageRepository mockStorageRepo;
  late AuthRepository mockAuthRepo;
  late LogoutUseCase useCase;

  setUp(() {
    mockStorageRepo = MockSecureStorageRepository();
    mockAuthRepo = MockAuthRepository();
    useCase = LogoutUseCase(
      storageRepository: mockStorageRepo,
      authRepository: mockAuthRepo,
    );
  });

  test('should clear tokens from secure storage', () async {
    // Arrange: mockStorageRepo.clearTokens returns success
    // Act: await useCase.execute()
    // Assert: verify mockStorageRepo.clearTokens called once
  });

  test('should clear session from auth repository', () async {
    // Arrange: mockAuthRepo.clearSession returns success
    // Act: await useCase.execute()
    // Assert: verify mockAuthRepo.clearSession called once
  });

  test('should retry token deletion up to 3 times on failure', () async {
    // Arrange: mockStorageRepo.clearTokens fails twice, succeeds on 3rd
    // Act: await useCase.execute()
    // Assert: verify clearTokens called 3 times
  });

  test('should clear session even if token deletion fails after 3 retries', () async {
    // Arrange: mockStorageRepo.clearTokens always throws
    // Act: await useCase.execute()
    // Assert: verify mockAuthRepo.clearSession still called
  });

  test('should execute in correct order: tokens then session', () async {
    // Arrange: track call order
    // Act: await useCase.execute()
    // Assert: verify clearTokens called before clearSession
  });

  test('should NOT clear Isar database when logging out', () async {
    // Arrange: mockIsarRepo (Medication, Weight 등)
    // Act: await useCase.execute()
    // Assert: verifyNever(() => mockIsarRepo.clearAll())
  });
});
```

**Edge Cases**:
- EC3: 토큰 삭제 실패 → 최대 3회 재시도 → 세션 초기화 진행
- BR2: Isar 데이터베이스는 건드리지 않음
- Repository 호출 순서 보장

**Implementation Order**:
1. 기본 execute 구현 (Red → Green)
2. 재시도 로직 추가 (Red → Green)
3. 에러 핸들링 (Red → Green)
4. Isar 데이터 보존 검증 (Red → Green)
5. 리팩토링 (Refactor)

**Dependencies**: SecureStorageRepository, AuthRepository

---

### 3.5 AuthNotifier (Application)

**Location**: `lib/features/authentication/application/notifiers/auth_notifier.dart`

**Responsibility**: 인증 상태 관리 및 로그아웃 처리

**Test Strategy**: Integration Test (Notifier + Repository)

**Test Scenarios (Red Phase)**:
```dart
group('AuthNotifier - Logout', () {
  late ProviderContainer container;
  late MockLogoutUseCase mockUseCase;

  setUp(() {
    mockUseCase = MockLogoutUseCase();
    container = ProviderContainer(
      overrides: [
        logoutUseCaseProvider.overrideWithValue(mockUseCase),
      ],
    );
  });

  test('should change state to loading during logout', () async {
    // Arrange: initial state = AsyncValue.data(user)
    // Act: notifier.logout()
    // Assert: expect state == AsyncValue.loading()
  });

  test('should change state to data(null) after successful logout', () async {
    // Arrange: mockUseCase.execute returns success
    // Act: await notifier.logout()
    // Assert: expect state == AsyncValue.data(null)
  });

  test('should change state to error if logout fails', () async {
    // Arrange: mockUseCase.execute throws exception
    // Act: await notifier.logout()
    // Assert: expect state == AsyncValue.error(...)
  });

  test('should call LogoutUseCase.execute once', () async {
    // Arrange: mockUseCase setup
    // Act: await notifier.logout()
    // Assert: verify useCase.execute called once
  });
});
```

**Edge Cases**:
- 로그아웃 중 앱 종료
- 중복 로그아웃 요청 방지

**Implementation Order**:
1. logout 메서드 기본 구현 (Red → Green)
2. 상태 전환 로직 (Red → Green)
3. 에러 핸들링 (Red → Green)
4. 리팩토링 (Refactor)

**Dependencies**: LogoutUseCase, AuthRepository

---

### 3.6 LogoutConfirmDialog (Presentation)

**Location**: `lib/features/authentication/presentation/widgets/logout_confirm_dialog.dart`

**Responsibility**: 로그아웃 확인 대화상자 UI

**Test Strategy**: Widget Test

**Test Scenarios (Red Phase)**:
```dart
group('LogoutConfirmDialog', () {
  testWidgets('should display confirmation message', (tester) async {
    // Arrange: build dialog
    // Act: pump widget
    // Assert: find.text('로그아웃하시겠습니까?')
  });

  testWidgets('should display confirm button', (tester) async {
    // Arrange: build dialog
    // Act: pump widget
    // Assert: find.text('확인')
  });

  testWidgets('should display cancel button', (tester) async {
    // Arrange: build dialog
    // Act: pump widget
    // Assert: find.text('취소')
  });

  testWidgets('should call onConfirm when confirm button tapped', (tester) async {
    // Arrange: mock onConfirm callback
    // Act: tap confirm button
    // Assert: verify onConfirm called
  });

  testWidgets('should pop dialog when cancel button tapped', (tester) async {
    // Arrange: build dialog
    // Act: tap cancel button
    // Assert: verify Navigator.pop called
  });
});
```

**QA Sheet (Manual)**:
- [ ] 대화상자가 화면 중앙에 표시됨
- [ ] 메시지가 명확하게 보임
- [ ] 버튼이 터치하기 쉬운 크기임
- [ ] 확인 버튼 색상이 강조됨 (Primary)
- [ ] 취소 버튼 색상이 중립적임 (Secondary)
- [ ] 다크 모드에서 가독성 확보

**Implementation Order**:
1. 기본 UI 구조 (Red → Green)
2. 버튼 콜백 연결 (Red → Green)
3. 스타일링 (Refactor)

**Dependencies**: None (Stateless Widget)

---

### 3.7 SettingsScreen (Presentation)

**Location**: `lib/features/authentication/presentation/screens/settings_screen.dart`

**Responsibility**: 설정 화면 및 로그아웃 버튼 표시

**Test Strategy**: Widget Test

**Test Scenarios (Red Phase)**:
```dart
group('SettingsScreen - Logout', () {
  testWidgets('should display logout button at bottom', (tester) async {
    // Arrange: build screen
    // Act: pump widget
    // Assert: find.text('로그아웃')
  });

  testWidgets('should show confirm dialog when logout tapped', (tester) async {
    // Arrange: build screen
    // Act: tap logout button
    // Assert: find dialog widget
  });

  testWidgets('should call AuthNotifier.logout when confirmed', (tester) async {
    // Arrange: mock AuthNotifier
    // Act: tap logout → tap confirm
    // Assert: verify notifier.logout called
  });

  testWidgets('should call AuthNotifier.logout when confirmed', (tester) async {
    // Arrange: mock AuthNotifier
    // Act: tap logout → tap confirm
    // Assert: verify notifier.logout called
  });

  testWidgets('should not logout when canceled', (tester) async {
    // Arrange: mock AuthNotifier
    // Act: tap logout → tap cancel
    // Assert: verify notifier.logout NOT called
  });
});
```

**QA Sheet (Manual)**:
- [ ] 로그아웃 버튼이 화면 하단에 표시됨
- [ ] 버튼이 다른 설정 항목과 명확히 구분됨
- [ ] 로딩 중 버튼 비활성화됨
- [ ] 에러 발생 시 스낵바로 안내 메시지 표시
- [ ] 다크 모드 지원 확인

**Note**: 로그아웃 후 로그인 화면 이동은 AppRouter에서 처리 (Section 3.8 참조)

**Implementation Order**:
1. 로그아웃 버튼 UI (Red → Green)
2. 대화상자 연동 (Red → Green)
3. AuthNotifier 연동 (Red → Green)
4. 에러 핸들링 (Red → Green)
5. 리팩토링 (Refactor)

**Dependencies**: AuthNotifier, LogoutConfirmDialog

---

### 3.8 AppRouter Navigation Logic (Core)

**Location**: `lib/core/routing/app_router.dart`

**Responsibility**: 인증 상태 변화 감지 및 자동 라우팅

**Test Strategy**: Integration Test

**Architecture Note**:
```
SettingsScreen은 로그아웃만 요청하고, 실제 네비게이션은 AppRouter가 처리
이유:
- Clean Architecture: Presentation Layer가 라우팅 로직 직접 관리 X
- AuthNotifier 상태 변화를 앱 전역에서 감지
- 로그아웃 외 다른 인증 상태 변화에도 일관된 처리 가능
```

**Implementation Options**:

**Option 1: GoRouter redirect (권장)**
```dart
GoRouter(
  redirect: (context, state) {
    final authState = ref.read(authNotifierProvider);
    final isLoginRoute = state.location == '/login';

    return authState.when(
      data: (user) {
        if (user == null && !isLoginRoute) {
          return '/login'; // 로그아웃 시 자동 이동
        }
        return null;
      },
      loading: () => null,
      error: (_, __) => null,
    );
  },
);
```

**Option 2: Root Widget ref.listen**
```dart
class MyApp extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref.listen(authNotifierProvider, (prev, next) {
      next.whenData((user) {
        if (user == null) {
          context.go('/login');
        }
      });
    });

    return MaterialApp.router(...);
  }
}
```

**Test Scenarios (Red Phase)**:
```dart
group('AppRouter - Logout Navigation', () {
  testWidgets('should redirect to login when auth state becomes null', (tester) async {
    // Arrange: initial state = authenticated
    // Act: change authNotifierProvider to AsyncValue.data(null)
    // Assert: verify current route == '/login'
  });

  testWidgets('should NOT redirect during loading state', (tester) async {
    // Arrange: initial state = authenticated
    // Act: change to AsyncValue.loading()
    // Assert: verify current route unchanged
  });

  testWidgets('should stay on login screen after logout', (tester) async {
    // Arrange: current route = '/login'
    // Act: logout (auth state -> null)
    // Assert: verify no navigation occurs
  });
});
```

**Implementation Order**:
1. GoRouter redirect 로직 추가 (Red → Green)
2. 엣지 케이스 처리 (Red → Green)
3. 리팩토링 (Refactor)

**Dependencies**: AuthNotifier, GoRouter

---

## 4. TDD Workflow

### 4.1 시작점
**AuthRepository Interface** (가장 의존성 낮은 모듈)

### 4.2 구현 순서 (Inside-Out)

```mermaid
graph LR
    A[AuthRepository<br/>Interface] --> B[SecureStorageRepository<br/>Interface]
    B --> C[FlutterSecureStorage<br/>Repository]
    C --> D[LogoutUseCase]
    D --> E[AuthNotifier]
    E --> F[LogoutConfirmDialog]
    F --> G[SettingsScreen]
    E --> H[AppRouter]

    style A fill:#e1f5ff
    style B fill:#e1f5ff
    style C fill:#e1f5ff
    style D fill:#e1f5ff
    style E fill:#ffe0b2
    style F fill:#c8e6c9
    style G fill:#c8e6c9
    style H fill:#c8e6c9
```

**단계별 TDD 사이클**:

1. **AuthRepository Interface**
   - Red: Interface 정의 테스트 작성
   - Green: Interface 정의
   - Refactor: 메서드 시그니처 정리
   - Commit: "feat(auth): add AuthRepository interface with clearSession"

2. **SecureStorageRepository Interface**
   - Red: Interface 정의 테스트 작성
   - Green: Interface 정의
   - Refactor: 메서드 시그니처 정리
   - Commit: "feat(auth): add SecureStorageRepository interface"

3. **FlutterSecureStorageRepository**
   - Red: clearTokens 테스트 작성
   - Green: clearTokens 구현
   - Red: 에러 핸들링 테스트 작성
   - Green: 에러 핸들링 구현
   - Refactor: 중복 제거, 상수화
   - Commit: "feat(auth): implement FlutterSecureStorageRepository"

4. **LogoutUseCase**
   - Red: execute 기본 테스트 작성
   - Green: execute 기본 구현
   - Red: 재시도 로직 테스트 작성
   - Green: 재시도 로직 구현
   - Red: Isar 데이터 보존 테스트 작성
   - Green: Isar 미접근 확인
   - Refactor: 비즈니스 로직 분리
   - Commit: "feat(auth): implement LogoutUseCase with retry logic"

5. **AuthNotifier**
   - Red: logout 상태 변경 테스트 작성
   - Green: logout 메서드 구현
   - Red: 에러 처리 테스트 작성
   - Green: 에러 처리 구현
   - Refactor: 상태 관리 로직 정리
   - Commit: "feat(auth): add logout to AuthNotifier"

6. **LogoutConfirmDialog**
   - Red: UI 렌더링 테스트 작성
   - Green: 기본 UI 구현
   - Red: 콜백 테스트 작성
   - Green: 콜백 연결
   - Refactor: 스타일 컴포넌트화
   - Commit: "feat(auth): add LogoutConfirmDialog"

7. **SettingsScreen**
   - Red: 로그아웃 버튼 테스트 작성
   - Green: 버튼 추가
   - Red: 대화상자 연동 테스트 작성
   - Green: 대화상자 연동
   - Red: AuthNotifier 연동 테스트 작성
   - Green: AuthNotifier 호출
   - Refactor: 위젯 분리, 스타일 정리
   - Commit: "feat(auth): add logout to SettingsScreen"

8. **AppRouter**
   - Red: 로그아웃 시 리다이렉트 테스트 작성
   - Green: redirect 로직 구현
   - Red: 엣지 케이스 테스트 작성
   - Green: 엣지 케이스 처리
   - Refactor: 라우팅 로직 정리
   - Commit: "feat(auth): add logout navigation to AppRouter"

### 4.3 완료 조건
- [ ] 모든 Unit Test 통과 (Domain, Infrastructure)
- [ ] 모든 Integration Test 통과 (Application)
- [ ] 모든 Widget Test 통과 (Presentation)
- [ ] 테스트 커버리지 80% 이상
- [ ] `flutter analyze` 경고 없음
- [ ] QA Sheet 체크리스트 완료
- [ ] Code Review 승인

---

## 5. Edge Cases Summary

### 5.1 Infrastructure Layer
- 저장소 접근 권한 오류 → 예외 throw
- 삭제 중 예외 발생 → 예외 throw

### 5.2 Domain Layer
- **EC3**: 토큰 삭제 실패 → 최대 3회 재시도 → 세션 초기화 진행
- Repository 호출 순서 보장 (토큰 → 세션)
- **BR2**: Isar 데이터베이스 미접근 (투여/체중 기록 보존)

### 5.3 Application Layer
- **EC4**: 로그아웃 중 앱 종료 → 다음 실행 시 토큰 체크
- 중복 로그아웃 요청 → 로딩 중 버튼 비활성화
- 네트워크 오류 → 로컬 처리만 진행

### 5.4 Presentation Layer
- **EC1**: 취소 버튼 선택 → 대화상자 닫기, 로그아웃 미실행
- 에러 발생 시 스낵바 표시

### 5.5 Navigation Layer
- 로그아웃 완료 시 자동 로그인 화면 이동
- 로딩 중 네비게이션 블로킹
- 이미 로그인 화면이면 리다이렉트 방지

---

## 6. Business Rules Compliance

### BR1: 토큰 보안
- FlutterSecureStorage 사용
- 삭제 실패 시 재시도
- 메모리에서 즉시 제거

### BR2: 로컬 데이터 보존
- Isar 데이터베이스 건드리지 않음
- 인증 정보만 삭제
- 투여/체중 기록 유지

### BR3: 확인 단계 필수
- LogoutConfirmDialog 구현
- 확인/취소 버튼 제공
- 의도하지 않은 로그아웃 방지

### BR4: 네트워크 독립성
- 서버 통신 없이 로컬 처리
- Phase 0 로컬 DB 기반
- 오프라인 동작 보장

### BR5: 재로그인 가능성
- 로컬 데이터 보존
- 동일 계정 재로그인 시 데이터 접근 가능

---

## 7. Performance Constraints

- 토큰 삭제: 50ms 이내
- 세션 초기화: 100ms 이내
- 전체 로그아웃 프로세스: 200ms 이내
- UI 응답성: 즉시 (로딩 인디케이터)

---

## 8. Test Coverage Goal

- **Unit Tests**: 90% (Domain, Infrastructure)
- **Integration Tests**: 80% (Application)
- **Widget Tests**: 70% (Presentation)

---

## 9. Dependencies

### 9.1 External Packages
- `flutter_secure_storage: ^9.0.0`
- `riverpod: ^2.5.1`
- `mocktail: ^1.0.0` (dev)

### 9.2 Internal Dependencies
- `core/routing/app_router.dart` (Navigation)
- `core/constants/storage_keys.dart` (Token key constants)

---

## 10. Acceptance Criteria

### 기능 완료 조건
- [x] 설정 화면에 로그아웃 버튼 표시
- [x] 버튼 클릭 시 확인 대화상자 표시
- [x] 확인 시 토큰 삭제 및 세션 초기화
- [x] 로그인 화면으로 자동 전환
- [x] 취소 시 로그아웃 미실행
- [x] 로컬 데이터 보존 확인
- [x] 에러 발생 시 적절한 안내

### 품질 완료 조건
- [x] 모든 테스트 통과
- [x] 코드 리뷰 승인
- [x] QA 검증 완료
- [x] 성능 기준 충족
</file>

<file path="010/spec.md">
# UF-007: 로그아웃 상세 유스케이스

## Primary Actor
GLP-1 치료 관리 앱 사용자

## Precondition
- 사용자가 앱에 로그인되어 있음
- 유효한 Access Token 및 Refresh Token이 안전한 저장소에 존재함
- 사용자가 설정 메뉴에 접근 가능함

## Trigger
사용자가 설정 메뉴에서 로그아웃 버튼을 클릭함

## Main Scenario

### 1. 설정 화면 진입
사용자가 홈 대시보드 또는 다른 화면에서 설정 아이콘을 선택하여 설정 화면으로 이동

### 2. 로그아웃 버튼 표시
설정 화면 하단에 로그아웃 버튼이 표시됨

### 3. 로그아웃 요청
사용자가 로그아웃 버튼을 클릭함

### 4. 확인 대화상자 표시
시스템이 "로그아웃하시겠습니까?" 확인 대화상자를 표시함
- 확인 버튼
- 취소 버튼

### 5. 로그아웃 확인
사용자가 확인 버튼을 선택함

### 6. 토큰 삭제
시스템이 안전한 저장소(FlutterSecureStorage)에서 저장된 인증 토큰을 삭제함
- Access Token 삭제
- Refresh Token 삭제
- 토큰 만료 시간 정보 삭제

### 7. 세션 정보 초기화
시스템이 로컬 세션 정보를 초기화함
- 메모리 내 사용자 세션 데이터 제거
- 인증 상태를 로그아웃 상태로 변경

### 8. 로그인 화면 이동
시스템이 로그인 화면으로 전환함

### 9. 완료
사용자가 로그인 화면을 확인하고 로그아웃이 완료됨

## Edge Cases

### EC1: 로그아웃 취소
- **상황**: 4단계에서 사용자가 취소 버튼을 선택
- **처리**: 확인 대화상자를 닫고 설정 화면 유지
- **결과**: 로그아웃 처리 없이 설정 화면에 그대로 머무름

### EC2: 네트워크 오류
- **상황**: 6-7단계에서 네트워크 오류 발생
- **처리**: 네트워크 상태와 무관하게 로컬 토큰 및 세션 정보 삭제 진행
- **결과**: 로컬 토큰 삭제 후 로그인 화면으로 이동

### EC3: 토큰 삭제 실패
- **상황**: 6단계에서 안전한 저장소 접근 오류로 토큰 삭제 실패
- **처리**: 에러를 로깅하고 재시도, 최대 3회 재시도 후에도 실패 시 세션 정보만 초기화
- **결과**: 다음 앱 실행 시 토큰 유효성 검증 단계에서 자동 처리됨

### EC4: 로그아웃 중 앱 종료
- **상황**: 6-8단계 사이에 사용자가 앱을 강제 종료함
- **처리**: 다음 앱 실행 시 저장된 토큰 존재 여부 확인
- **결과**: 토큰이 삭제된 경우 로그인 화면 표시, 삭제되지 않은 경우 자동 로그인 진행

### EC5: 로컬 데이터 보존
- **상황**: 로그아웃 후 로컬 Isar 데이터베이스 처리
- **처리**: Phase 0에서는 로컬 데이터 유지 (투여 기록, 체중 기록 등)
- **결과**: 재로그인 시 기존 데이터 계속 사용 가능

### EC6: 다중 기기 로그아웃
- **상황**: 사용자가 여러 기기에서 로그인되어 있고 한 기기에서 로그아웃
- **처리**: Phase 0에서는 각 기기의 세션이 독립적으로 관리됨
- **결과**: 다른 기기의 로그인 상태에는 영향 없음

## Business Rules

### BR1: 토큰 보안
로그아웃 시 모든 인증 토큰은 안전하게 삭제되어야 하며, 메모리에 남지 않아야 함

### BR2: 로컬 데이터 보존
Phase 0에서는 로그아웃 시 사용자의 로컬 데이터(투여 기록, 체중 기록 등)를 삭제하지 않음

### BR3: 확인 단계 필수
사용자의 의도하지 않은 로그아웃을 방지하기 위해 확인 대화상자를 반드시 표시해야 함

### BR4: 네트워크 독립성
로그아웃 처리는 네트워크 상태와 무관하게 동작해야 함 (Phase 0 로컬 DB 기반)

### BR5: 재로그인 가능성
로그아웃 후에도 동일한 소셜 계정으로 재로그인 시 기존 데이터에 접근 가능해야 함

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE
participant BE
database Database

User -> FE: 설정 화면 진입
FE -> FE: 설정 화면 표시
FE -> FE: 로그아웃 버튼 표시

User -> FE: 로그아웃 버튼 클릭
FE -> FE: 확인 대화상자 표시

User -> FE: 확인 선택
FE -> FE: 로그아웃 처리 시작
FE -> Database: Access Token 삭제
Database --> FE: 삭제 완료
FE -> Database: Refresh Token 삭제
Database --> FE: 삭제 완료
FE -> FE: 세션 정보 초기화
FE -> FE: 로그인 화면 이동
FE -> User: 로그인 화면 표시

@enduml
```
</file>

<file path="011/plan.md">
# 프로필 및 목표 수정 Implementation Plan

## 1. 개요

프로필 및 목표 수정 기능(UF-008)을 위한 모듈 목록:

- **Domain Layer**: UserProfile Entity, ProfileRepository Interface, UpdateProfileUseCase
- **Application Layer**: ProfileNotifier (상태 관리, 홈 대시보드 갱신)
- **Infrastructure Layer**: IsarProfileRepository (Repository 구현), UserProfileDto (DTO)
- **Presentation Layer**: ProfileEditScreen, ProfileEditForm Widget

**외부 의존성**: WeightLogRepository (현재 체중 불일치 감지용)

**TDD 적용 범위**: Domain, Application, Infrastructure Layer

---

## 2. Architecture Diagram

```mermaid
graph TD
    subgraph Presentation
        Screen[ProfileEditScreen]
        Form[ProfileEditForm Widget]
    end

    subgraph Application
        Notifier[ProfileNotifier]
        DashboardNotifier[DashboardNotifier]
    end

    subgraph Domain
        Entity[UserProfile Entity]
        RepoInterface[ProfileRepository Interface]
        UseCase[UpdateProfileUseCase]
        WeightRepo[WeightLogRepository Interface]
    end

    subgraph Infrastructure
        RepoImpl[IsarProfileRepository]
        DTO[UserProfileDto]
        WeightRepoImpl[IsarWeightLogRepository]
    end

    Screen --> Notifier
    Form --> Screen
    Notifier --> RepoInterface
    Notifier --> UseCase
    Notifier -.invalidate.-> DashboardNotifier
    UseCase --> RepoInterface
    UseCase --> WeightRepo
    RepoInterface <|.. RepoImpl
    WeightRepo <|.. WeightRepoImpl
    RepoImpl --> DTO
    DTO --> Entity
```

---

## 3. Implementation Plan

### 3.1. UserProfile Entity (Domain)

**Location**: `lib/features/profile/domain/entities/user_profile.dart`

**Responsibility**:
- 사용자 프로필 및 목표 데이터 표현
- 비즈니스 규칙 검증 (목표 체중 < 현재 체중, 체중 범위 20-300kg)
- 주간 감량 목표 계산

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```dart
// AAA 패턴: Arrange - Act - Assert

1. 생성 및 속성 검증
   - given: 유효한 프로필 데이터
   - when: UserProfile 생성
   - then: 모든 속성이 올바르게 저장됨

2. 주간 감량 목표 자동 계산
   - given: 현재 체중 80kg, 목표 체중 70kg, 목표 기간 10주
   - when: UserProfile 생성
   - then: weeklyLossGoalKg = 1.0

3. 목표 기간 없을 경우 주간 감량 목표 null
   - given: targetPeriodWeeks = null
   - when: UserProfile 생성
   - then: weeklyLossGoalKg = null

4. 목표 체중이 현재 체중보다 큰 경우 예외
   - given: 현재 체중 70kg, 목표 체중 80kg
   - when: UserProfile 생성
   - then: ArgumentError 발생

5. 체중이 20kg 미만인 경우 예외
   - given: targetWeightKg = 15kg
   - when: UserProfile 생성
   - then: ArgumentError 발생

6. 체중이 300kg 초과인 경우 예외
   - given: targetWeightKg = 350kg
   - when: UserProfile 생성
   - then: ArgumentError 발생

7. copyWith 메서드 동작 검증
   - given: 기존 UserProfile
   - when: copyWith로 일부 필드 변경
   - then: 변경된 필드만 업데이트됨

8. 주간 감량 목표가 1kg 초과 시 경고 필요 여부 확인
   - given: 주간 감량 목표 1.5kg
   - when: needsWeightLossWarning 호출
   - then: true 반환
```

**Implementation Order**:
1. Test: 기본 생성 및 속성 검증
2. Code: UserProfile 클래스, 기본 생성자
3. Test: 주간 감량 목표 계산
4. Code: 계산 로직 추가
5. Test: 검증 규칙 (목표 체중 < 현재 체중)
6. Code: 검증 로직 추가
7. Test: 체중 범위 검증
8. Code: 범위 검증 로직
9. Refactor: 검증 로직 분리, 상수 추출

**Dependencies**: 없음 (Pure Dart)

---

### 3.2. ProfileRepository Interface (Domain)

**Location**: `lib/features/profile/domain/repositories/profile_repository.dart`

**Responsibility**:
- 프로필 CRUD 인터페이스 정의
- Domain Layer가 Infrastructure에 의존하지 않도록 추상화
- 체중 기록 조회 (현재 체중 불일치 감지용)

**Test Strategy**: Unit Test (UseCase, Notifier 테스트 시 Mock 사용)

**Test Scenarios (Red Phase)**:
```dart
// Mock을 사용한 계약 테스트

1. getUserProfile 호출 가능
   - given: Mock Repository
   - when: getUserProfile 호출
   - then: 정상 호출됨

2. updateUserProfile 호출 가능
   - given: Mock Repository, UserProfile
   - when: updateUserProfile 호출
   - then: 정상 호출됨

3. watchUserProfile 스트림 반환
   - given: Mock Repository
   - when: watchUserProfile 호출
   - then: Stream<UserProfile> 반환

4. getLatestWeightLog 호출 가능
   - given: Mock Repository
   - when: getLatestWeightLog 호출
   - then: 최근 체중 기록 반환
```

**Implementation Order**:
1. Test: Interface 메서드 정의 확인
2. Code: ProfileRepository abstract class
3. Refactor: 문서화 주석 추가

**Dependencies**: UserProfile Entity

---

### 3.3. UpdateProfileUseCase (Domain)

**Location**: `lib/features/profile/domain/usecases/update_profile_usecase.dart`

**Responsibility**:
- 프로필 업데이트 비즈니스 로직 수행
- 검증 후 Repository 호출
- 현재 체중 변경 시 최근 체중 기록과 불일치 감지

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```dart
// Mock Repository 사용

1. 유효한 프로필 업데이트 성공
   - given: Mock Repository, 유효한 UserProfile
   - when: execute 호출
   - then: repository.updateUserProfile 호출됨

2. 목표 체중 > 현재 체중 시 실패
   - given: 잘못된 UserProfile
   - when: execute 호출
   - then: ValidationException 발생

3. 체중 범위 초과 시 실패
   - given: 체중 300kg 초과 UserProfile
   - when: execute 호출
   - then: ValidationException 발생

4. Repository 실패 시 예외 전파
   - given: Repository가 예외 발생
   - when: execute 호출
   - then: 동일한 예외 전파됨

5. 현재 체중 변경 시 최근 체중 기록과 불일치 감지
   - given: 현재 체중이 변경되고, 최근 체중 기록과 다름
   - when: execute 호출
   - then: WeightMismatchWarning 반환 (확인 필요 플래그)
```

**Implementation Order**:
1. Test: 기본 실행 및 Repository 호출
2. Code: UpdateProfileUseCase 클래스, execute 메서드
3. Test: 검증 실패 케이스
4. Code: 검증 로직 추가
5. Test: 현재 체중 불일치 감지
6. Code: getLatestWeightLog 조회 및 비교 로직 추가
7. Refactor: 검증 로직을 Entity로 이동

**Dependencies**: UserProfile, ProfileRepository

---

### 3.4. UserProfileDto (Infrastructure)

**Location**: `lib/features/profile/infrastructure/dtos/user_profile_dto.dart`

**Responsibility**:
- Isar 데이터베이스 스키마 정의
- DTO ↔ Entity 변환

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```dart
1. Entity → DTO 변환
   - given: UserProfile Entity
   - when: UserProfileDto.fromEntity 호출
   - then: 모든 필드가 올바르게 매핑됨

2. DTO → Entity 변환
   - given: UserProfileDto
   - when: toEntity 호출
   - then: 모든 필드가 올바르게 매핑됨

3. null 필드 처리
   - given: targetPeriodWeeks = null인 Entity
   - when: 변환 수행
   - then: null 값 유지됨

4. 왕복 변환 일관성
   - given: UserProfile Entity
   - when: Entity → DTO → Entity 변환
   - then: 원본과 동일한 데이터
```

**Implementation Order**:
1. Test: Entity → DTO 변환
2. Code: UserProfileDto 클래스, fromEntity 메서드
3. Test: DTO → Entity 변환
4. Code: toEntity 메서드
5. Test: 왕복 변환 일관성
6. Refactor: 중복 코드 제거

**Dependencies**: UserProfile Entity, Isar

---

### 3.5. IsarProfileRepository (Infrastructure)

**Location**: `lib/features/profile/infrastructure/repositories/isar_profile_repository.dart`

**Responsibility**:
- ProfileRepository 인터페이스 구현
- Isar를 통한 데이터 저장/조회
- DTO ↔ Entity 변환 관리
- 트랜잭션을 통한 원자성 보장

**Test Strategy**: Integration Test (실제 Isar 사용)

**Test Scenarios (Red Phase)**:
```dart
// 실제 Isar 인스턴스 사용

1. 프로필 저장 및 조회
   - given: IsarProfileRepository, UserProfile
   - when: updateUserProfile → getUserProfile
   - then: 저장한 데이터 반환됨

2. 프로필 업데이트
   - given: 기존 프로필 존재
   - when: 새로운 프로필로 updateUserProfile
   - then: 업데이트된 데이터 조회됨

3. 프로필 없을 때 null 반환
   - given: 빈 DB
   - when: getUserProfile 호출
   - then: null 반환

4. watchUserProfile 실시간 업데이트
   - given: IsarProfileRepository
   - when: watchUserProfile 구독 후 updateUserProfile
   - then: 스트림에서 업데이트된 데이터 수신

5. 동일 userId로 중복 저장 시 덮어쓰기
   - given: 동일 userId의 프로필 2개
   - when: 순차적으로 저장
   - then: 마지막 저장본만 존재

6. getLatestWeightLog 조회
   - given: 체중 기록이 존재하는 DB
   - when: getLatestWeightLog 호출
   - then: 가장 최근 체중 기록 반환

7. 트랜잭션 사용한 저장
   - given: updateUserProfile 호출
   - when: isar.writeTxn() 사용
   - then: 트랜잭션으로 안전하게 저장됨
```

**Implementation Order**:
1. Test: 기본 저장 및 조회
2. Code: IsarProfileRepository 클래스, getUserProfile, updateUserProfile (isar.writeTxn 사용)
3. Test: 업데이트 동작
4. Code: 업데이트 로직
5. Test: watchUserProfile 스트림
6. Code: watch 메서드 구현
7. Test: getLatestWeightLog 조회
8. Code: getLatestWeightLog 메서드 구현
9. Refactor: 에러 핸들링 추가

**Dependencies**: ProfileRepository, UserProfileDto, Isar

---

### 3.6. ProfileNotifier (Application)

**Location**: `lib/features/profile/application/notifiers/profile_notifier.dart`

**Responsibility**:
- 프로필 상태 관리
- UI 이벤트를 UseCase/Repository 호출로 변환
- AsyncValue를 통한 로딩/에러 상태 관리
- 프로필 업데이트 후 홈 대시보드 상태 갱신 (ref.invalidate)
- 변경사항 감지 및 최적화

**Test Strategy**: Unit Test (Mock Repository, UseCase)

**Test Scenarios (Red Phase)**:
```dart
// Mock 사용

1. 초기 로드 성공
   - given: Mock Repository with 프로필 데이터
   - when: build 호출
   - then: AsyncValue.data(profile) 반환

2. 초기 로드 실패
   - given: Mock Repository가 예외 발생
   - when: build 호출
   - then: AsyncValue.error 반환

3. 프로필 업데이트 성공
   - given: 초기 상태, Mock UseCase
   - when: updateProfile 호출
   - then: state = AsyncValue.loading → data

4. 프로필 업데이트 실패
   - given: Mock UseCase가 예외 발생
   - when: updateProfile 호출
   - then: state = AsyncValue.error

5. 주간 목표 업데이트
   - given: 초기 상태, Mock Repository
   - when: updateWeeklyGoals 호출
   - then: state 업데이트됨

6. 업데이트 중 중복 호출 방지
   - given: 업데이트 진행 중
   - when: updateProfile 재호출
   - then: 첫 번째 완료 후 두 번째 실행

7. 변경사항 없이 저장 시도
   - given: 수정되지 않은 프로필
   - when: updateProfile 호출
   - then: Repository 호출 없이 즉시 반환

8. 현재 체중 변경 시 불일치 감지
   - given: 최근 체중 기록과 다른 현재 체중
   - when: updateProfile 호출
   - then: 확인 메시지 필요 상태 반환 (WeightMismatchWarning)

9. 프로필 업데이트 후 홈 대시보드 갱신
   - given: 프로필 업데이트 성공
   - when: updateProfile 완료
   - then: ref.invalidate()로 대시보드 Provider 갱신
```

**Implementation Order**:
1. Test: 초기 로드
2. Code: ProfileNotifier 클래스, build 메서드
3. Test: 업데이트 성공 케이스
4. Code: updateProfile 메서드
5. Test: 에러 핸들링
6. Code: AsyncValue.guard 적용
7. Test: 변경사항 감지
8. Code: hasChanges() 메서드 추가
9. Test: 홈 대시보드 갱신
10. Code: ref.invalidate() 추가
11. Refactor: 로직 분리, 상수 추출

**Dependencies**: ProfileRepository, UpdateProfileUseCase, Riverpod

---

### 3.7. ProfileEditScreen (Presentation)

**Location**: `lib/features/profile/presentation/screens/profile_edit_screen.dart`

**Responsibility**:
- 프로필 수정 UI 렌더링
- ProfileNotifier 상태 구독
- 사용자 입력 수집 및 검증
- 저장 완료 확인 메시지 표시
- 현재 체중 변경 시 확인 다이얼로그 표시

**Test Strategy**: Widget Test

**Test Scenarios (Red Phase)**:
```dart
1. 화면 로드 시 로딩 표시
   - given: ProfileNotifier state = loading
   - when: 화면 빌드
   - then: CircularProgressIndicator 표시

2. 프로필 데이터 로드 시 폼에 표시
   - given: ProfileNotifier state = data(profile)
   - when: 화면 빌드
   - then: 이름, 목표 체중, 현재 체중, 목표 기간 표시

3. 저장 버튼 클릭 시 updateProfile 호출
   - given: 수정된 폼 데이터
   - when: 저장 버튼 탭
   - then: ProfileNotifier.updateProfile 호출됨

4. 입력 검증 에러 표시
   - given: 목표 체중 > 현재 체중
   - when: 저장 시도
   - then: 에러 메시지 표시

5. 저장 성공 시 네비게이션 및 확인 메시지
   - given: updateProfile 성공
   - when: 저장 완료
   - then: "저장되었습니다" 스낵바 표시 후 이전 화면으로 이동

6. 저장 실패 시 스낵바 표시
   - given: updateProfile 실패
   - when: 에러 발생
   - then: 에러 스낵바 표시

7. 현재 체중 변경 시 확인 다이얼로그
   - given: 최근 체중 기록과 다른 현재 체중
   - when: 저장 시도
   - then: 확인 다이얼로그 표시

8. 변경사항 없이 저장 시도
   - given: 수정되지 않은 폼
   - when: 저장 버튼 탭
   - then: 저장 없이 이전 화면으로 이동
```

**Implementation Order**:
1. Test: 기본 화면 렌더링
2. Code: ProfileEditScreen 클래스, Scaffold
3. Test: 폼 데이터 표시
4. Code: ProfileEditForm Widget
5. Test: 저장 동작
6. Code: 저장 버튼 핸들러
7. Test: 저장 완료 스낵바
8. Code: 저장 완료 시 스낵바 표시
9. Test: 현재 체중 확인 다이얼로그
10. Code: 확인 다이얼로그 표시 로직
11. Test: 변경사항 없을 때 처리
12. Code: 변경사항 감지 및 즉시 복귀
13. Refactor: UI 컴포넌트 분리

**Dependencies**: ProfileNotifier, Flutter Widgets

**QA Sheet** (수동 테스트):
- [ ] 화면 진입 시 현재 프로필 정보가 표시되는가?
- [ ] 이름 필드를 수정할 수 있는가?
- [ ] 목표 체중을 수정할 수 있는가?
- [ ] 현재 체중을 수정할 수 있는가?
- [ ] 목표 기간을 수정할 수 있는가?
- [ ] 목표 체중 > 현재 체중 입력 시 에러 메시지가 표시되는가?
- [ ] 체중 20kg 미만 입력 시 에러 메시지가 표시되는가?
- [ ] 체중 300kg 초과 입력 시 에러 메시지가 표시되는가?
- [ ] 주간 감량 목표가 실시간으로 재계산되는가?
- [ ] 주간 감량 목표 1kg 초과 시 경고가 표시되는가?
- [ ] 저장 버튼 클릭 시 로딩 표시가 나타나는가?
- [ ] 저장 완료 시 확인 메시지가 표시되는가?
- [ ] 저장 완료 시 설정 화면으로 돌아가는가?
- [ ] 저장 실패 시 에러 메시지가 표시되는가?
- [ ] 변경사항 없이 저장 시 즉시 복귀하는가?
- [ ] 현재 체중 변경 시 확인 다이얼로그가 표시되는가?
- [ ] 저장 완료 후 홈 대시보드가 업데이트되는가?

---

### 3.8. ProfileEditForm Widget (Presentation)

**Location**: `lib/features/profile/presentation/widgets/profile_edit_form.dart`

**Responsibility**:
- 입력 필드 렌더링 (이름, 목표 체중, 현재 체중, 목표 기간)
- 실시간 입력 검증
- 주간 감량 목표 표시

**Test Strategy**: Widget Test

**Test Scenarios (Red Phase)**:
```dart
1. 모든 입력 필드 렌더링
   - given: ProfileEditForm Widget
   - when: 빌드
   - then: 이름, 목표 체중, 현재 체중, 목표 기간 필드 표시

2. 초기 값 표시
   - given: 초기 UserProfile
   - when: 빌드
   - then: 각 필드에 초기 값 표시

3. 입력 값 변경 감지
   - given: 폼
   - when: 이름 필드 입력
   - then: onChanged 콜백 호출

4. 주간 감량 목표 계산 표시
   - given: 목표 체중 70kg, 현재 체중 80kg, 목표 기간 10주
   - when: 입력 완료
   - then: "주간 감량 목표: 1.0kg" 표시

5. 경고 메시지 표시
   - given: 주간 감량 목표 1.5kg
   - when: 계산 완료
   - then: 경고 아이콘 및 메시지 표시
```

**Implementation Order**:
1. Test: 기본 필드 렌더링
2. Code: TextField 위젯들
3. Test: 초기 값 표시
4. Code: Controller 연결
5. Test: 주간 감량 목표 표시
6. Code: 계산 로직 및 표시 위젯
7. Refactor: 재사용 가능한 입력 필드 컴포넌트 추출

**Dependencies**: Flutter Widgets, UserProfile

**QA Sheet** (수동 테스트):
- [ ] 각 필드에 라벨이 명확히 표시되는가?
- [ ] 숫자 입력 필드에 숫자 키패드가 나타나는가?
- [ ] 목표 기간 입력 시 주간 감량 목표가 즉시 계산되는가?
- [ ] 경고 메시지가 눈에 띄는 색상으로 표시되는가?
- [ ] 필드 간 탭 이동이 자연스러운가?

---

## 4. TDD Workflow

### 시작 단계
1. UserProfile Entity 테스트 작성
2. Red: 테스트 실패 확인
3. Green: 최소 코드로 테스트 통과
4. Refactor: 검증 로직 정리

### 중간 단계
5. ProfileRepository Interface 정의
6. UpdateProfileUseCase 테스트 작성 (Mock 사용)
7. Red → Green → Refactor
8. UserProfileDto 테스트 작성
9. Red → Green → Refactor

### 후반 단계
10. IsarProfileRepository Integration Test 작성
11. Red → Green → Refactor (실제 Isar 사용)
12. ProfileNotifier Unit Test 작성 (Mock 사용)
13. Red → Green → Refactor

### 완료 단계
14. ProfileEditScreen Widget Test 작성
15. Red → Green → Refactor
16. ProfileEditForm Widget Test 작성
17. Red → Green → Refactor
18. 통합 테스트 실행 및 수동 QA

### Commit 포인트
- Entity + Repository Interface 완료
- UseCase + DTO 완료
- Repository 구현 완료
- Notifier 완료
- Presentation Layer 완료

### 완료 조건
- 모든 Unit/Integration/Widget 테스트 통과
- Presentation Layer 수동 QA 체크리스트 완료
- 코드 커버리지 80% 이상
- flutter analyze 경고 0개

---

## 5. 핵심 원칙

### Test First
- 코드보다 테스트를 먼저 작성
- Red → Green → Refactor 사이클 엄격히 준수

### Small Steps
- 한 번에 하나의 시나리오만 구현
- 테스트 케이스 단위로 커밋

### FIRST 원칙
- Fast: 빠른 테스트 실행
- Independent: 독립적인 테스트
- Repeatable: 반복 가능한 결과
- Self-validating: 자동 검증
- Timely: 코드 작성 전 테스트 작성

### Test Pyramid
- Unit Test 70%: Entity, UseCase, DTO, Repository Mock
- Integration Test 20%: IsarProfileRepository
- Widget Test 10%: Screen, Form

### Outside-In 전략
- Presentation Layer에서 시작하여 필요한 하위 레이어를 순차적으로 구현
- 각 레이어는 Interface를 통해 하위 레이어와 통신
</file>

<file path="011/spec.md">
# UF-008: 프로필 및 목표 수정

## Use Case Specification

### Primary Actor
GLP-1 사용자 (치료 중 목표 또는 프로필 정보를 변경하려는 사용자)

### Precondition
- 사용자가 로그인되어 있음
- 온보딩 완료로 기본 프로필 및 목표가 설정되어 있음

### Trigger
- 사용자가 설정 메뉴에서 "프로필 및 목표 수정" 선택

### Main Scenario

1. 사용자가 홈 대시보드 또는 다른 화면에서 설정 아이콘 또는 메뉴를 선택한다.
2. 설정 메뉴에서 "프로필 및 목표 수정"을 선택한다.
3. 시스템은 현재 사용자의 프로필 및 목표 정보를 조회한다.
4. 시스템은 수정 화면에 기존 정보를 표시한다:
   - 사용자 이름
   - 목표 체중 (kg)
   - 현재 체중 (kg)
   - 목표 기간 (주 단위, 선택 사항)
   - 자동 계산된 주간 감량 목표 (목표 기간 입력 시)
5. 사용자가 수정할 필드의 값을 변경한다.
6. 시스템은 실시간으로 입력 값을 검증한다:
   - 이름: 비어있지 않은지 확인
   - 목표 체중 및 현재 체중: 양수 값, 현실적 범위 (20kg 이상 300kg 이하)
   - 목표 기간: 양수 값 또는 미입력 허용
7. 목표 체중 또는 목표 기간이 변경된 경우, 시스템은 주간 평균 감량 목표를 재계산하여 표시한다.
8. 재계산된 주간 감량 목표가 안전 범위 (주당 1kg)를 초과하는 경우, 시스템은 경고 메시지를 표시한다.
9. 사용자가 저장 버튼을 클릭한다.
10. 시스템은 변경사항을 Repository를 통해 저장한다.
11. 시스템은 홈 대시보드 관련 데이터 재계산을 트리거한다:
    - 목표 진행도
    - 목표 달성 예상 시기
    - 인사이트 메시지
12. 시스템은 저장 완료 확인 메시지를 표시한다.
13. 시스템은 자동으로 설정 화면으로 복귀한다.

### Edge Cases

- **목표 체중이 현재 체중보다 큰 경우**: 에러 메시지 표시, 저장 불가
- **변경사항 없이 저장 시도**: 그대로 유지, 설정 화면으로 복귀
- **저장 중 앱 종료**: 변경사항 폐기, 다음 실행 시 기존 정보 유지
- **현재 체중 변경 시 최근 체중 기록과 불일치**: 확인 메시지 표시 후 진행 허용
- **목표 변경으로 인한 목표 달성 예상일 변동**: 홈 대시보드에 자동 반영
- **목표 기간 미입력**: 주간 감량 목표 계산 건너뛰기
- **비현실적인 체중 값 입력 (20kg 미만, 300kg 초과)**: 에러 메시지 표시, 저장 불가
- **저장 실패 (DB 오류)**: 에러 메시지 표시, 재시도 안내

### Business Rules

- 목표 체중은 현재 체중보다 작아야 한다.
- 체중은 20kg 이상 300kg 이하의 현실적인 범위 내여야 한다.
- 주간 감량 목표는 (현재 체중 - 목표 체중) / 목표 기간 (주) 공식으로 자동 계산된다.
- 주간 감량 목표가 1kg을 초과하는 경우 경고를 표시하되 저장은 허용한다.
- 프로필 정보 변경 시 홈 대시보드의 모든 관련 데이터가 실시간으로 재계산된다.
- 현재 체중 값 변경은 프로필 정보만 업데이트하며, 체중 기록 (weight_logs)은 별도로 관리된다.

---

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE
participant BE
database Database

User -> FE: 설정 메뉴에서 "프로필 및 목표 수정" 선택
activate FE
FE -> BE: 현재 프로필 및 목표 정보 조회 요청
activate BE
BE -> Database: SELECT user_profiles WHERE user_id = ?
activate Database
Database --> BE: 프로필 및 목표 데이터 반환
deactivate Database
BE --> FE: 프로필 및 목표 정보 반환
deactivate BE
FE -> FE: 수정 화면에 기존 정보 표시
FE --> User: 프로필 및 목표 수정 화면 표시

User -> FE: 정보 수정 입력 (이름/목표 체중/현재 체중/목표 기간)
FE -> FE: 실시간 입력 검증
alt 목표 체중 또는 목표 기간 변경
    FE -> FE: 주간 감량 목표 재계산
    FE --> User: 재계산된 주간 감량 목표 표시
    alt 주간 감량 목표가 1kg 초과
        FE --> User: 경고 메시지 표시
    end
end

alt 목표 체중이 현재 체중보다 큰 경우
    FE --> User: 에러 메시지 표시, 저장 불가
else 비현실적인 체중 값 (20kg 미만 또는 300kg 초과)
    FE --> User: 에러 메시지 표시, 저장 불가
else 유효한 입력
    User -> FE: 저장 버튼 클릭
    FE -> BE: 변경사항 저장 요청
    activate BE
    BE -> Database: UPDATE user_profiles SET target_weight_kg = ?, target_period_weeks = ?, weekly_loss_goal_kg = ?, updated_at = now() WHERE user_id = ?
    activate Database
    Database --> BE: 저장 성공
    deactivate Database
    BE --> FE: 저장 완료 응답
    deactivate BE
    FE -> FE: 홈 대시보드 데이터 재계산 트리거
    FE --> User: 저장 완료 확인 메시지 표시
    FE --> User: 설정 화면으로 복귀
end

deactivate FE
@enduml
```
</file>

<file path="012/plan.md">
# 투여 계획 수정 구현 계획

## 1. 개요

투여 계획 수정 기능은 사용자가 온보딩 후 설정된 투여 계획을 변경할 수 있도록 지원합니다. 계획 변경 시 이력을 기록하고 투여 스케줄을 재계산합니다.

### 구현 모듈
- **Domain Layer**: Entity, Repository Interface, Business Logic
- **Application Layer**: Notifier, UseCase
- **Infrastructure Layer**: Repository Implementation, DTO
- **Presentation Layer**: Screen, Widget
- **TDD 적용 범위**: All Layers

## 2. Architecture Diagram

```mermaid
graph TD
    subgraph Presentation
        A[EditDosagePlanScreen]
        B[DosagePlanFormWidget]
        C[EscalationPlanEditorWidget]
        D[PlanChangeConfirmationDialog]
    end

    subgraph Application
        E[DosagePlanNotifier]
        F[UpdateDosagePlanUseCase]
    end

    subgraph Domain
        G[DosagePlan Entity]
        H[PlanChangeHistory Entity]
        I[DoseSchedule Entity]
        J[DosagePlanRepository Interface]
        K[DoseScheduleRepository Interface]
        L[ValidateDosagePlan UseCase]
        M[RecalculateDoseSchedule UseCase]
        N[AnalyzePlanChangeImpact UseCase]
    end

    subgraph Infrastructure
        O[IsarDosagePlanRepository]
        P[IsarDoseScheduleRepository]
        Q[DosagePlanDto]
        R[PlanChangeHistoryDto]
        S[DoseScheduleDto]
    end

    A --> E
    A --> B
    A --> C
    A --> D
    B --> E
    E --> F
    F --> L
    F --> N
    F --> M
    F --> J
    F --> K
    J --> O
    K --> P
    M --> K
    N --> I
    M --> I
    O --> Q
    O --> R
    P --> S
    G -.-> Q
    H -.-> R
    I -.-> S
```

## 3. Implementation Plan

### Module 1: DosagePlan Entity (Domain)

**Location**: `lib/features/tracking/domain/entities/dosage_plan.dart`

**Responsibility**: 투여 계획 데이터 모델 정의

**Test Strategy**: Unit Test

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: Entity 생성 테스트
test('should create DosagePlan with required fields', () {
  // Arrange & Act
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );

  // Assert
  expect(plan.id, 'plan-1');
  expect(plan.medicationName, 'Ozempic');
  expect(plan.isActive, true);
});

// TC-2: Escalation plan 포함 Entity 생성
test('should create DosagePlan with escalation plan', () {
  // Arrange
  final escalationPlan = [
    EscalationStep(weeks: 4, doseMg: 0.5),
    EscalationStep(weeks: 8, doseMg: 1.0),
  ];

  // Act
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
    escalationPlan: escalationPlan,
  );

  // Assert
  expect(plan.escalationPlan, escalationPlan);
  expect(plan.escalationPlan?.length, 2);
});

// TC-3: copyWith 메서드 테스트
test('should copy DosagePlan with updated fields', () {
  // Arrange
  final originalPlan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );

  // Act
  final updatedPlan = originalPlan.copyWith(
    medicationName: 'Wegovy',
    initialDoseMg: 0.5,
  );

  // Assert
  expect(updatedPlan.medicationName, 'Wegovy');
  expect(updatedPlan.initialDoseMg, 0.5);
  expect(updatedPlan.id, originalPlan.id);
  expect(updatedPlan.cycleDays, originalPlan.cycleDays);
});
```

**Implementation Order**:
1. DosagePlan 클래스 기본 구조 작성
2. EscalationStep 클래스 작성
3. copyWith 메서드 구현
4. Equality 구현 (Equatable 사용)

**Dependencies**: None

---

### Module 2: PlanChangeHistory Entity (Domain)

**Location**: `lib/features/tracking/domain/entities/plan_change_history.dart`

**Responsibility**: 투여 계획 변경 이력 데이터 모델

**Test Strategy**: Unit Test

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: 변경 이력 Entity 생성
test('should create PlanChangeHistory with old and new plan', () {
  // Arrange & Act
  final history = PlanChangeHistory(
    id: 'history-1',
    dosagePlanId: 'plan-1',
    changedAt: DateTime(2025, 2, 1),
    oldPlan: {'initialDoseMg': 0.25},
    newPlan: {'initialDoseMg': 0.5},
  );

  // Assert
  expect(history.dosagePlanId, 'plan-1');
  expect(history.oldPlan['initialDoseMg'], 0.25);
  expect(history.newPlan['initialDoseMg'], 0.5);
});
```

**Implementation Order**:
1. PlanChangeHistory 클래스 작성
2. JSON serialization 지원

**Dependencies**: None

---

### Module 3: DoseSchedule Entity (Domain)

**Location**: `lib/features/tracking/domain/entities/dose_schedule.dart`

**Responsibility**: 투여 스케줄 데이터 모델 정의

**Test Strategy**: Unit Test

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: DoseSchedule Entity 생성
test('should create DoseSchedule with required fields', () {
  // Arrange & Act
  final schedule = DoseSchedule(
    id: 'schedule-1',
    dosagePlanId: 'plan-1',
    scheduledDate: DateTime(2025, 1, 1),
    doseMg: 0.25,
    isCompleted: false,
  );

  // Assert
  expect(schedule.id, 'schedule-1');
  expect(schedule.dosagePlanId, 'plan-1');
  expect(schedule.isCompleted, false);
});
```

**Implementation Order**:
1. DoseSchedule 클래스 작성
2. Equality 구현 (Equatable 사용)

**Dependencies**: None

---

### Module 4: ValidateDosagePlan UseCase (Domain)

**Location**: `lib/features/tracking/domain/usecases/validate_dosage_plan_usecase.dart`

**Responsibility**: 투여 계획 입력값 검증 비즈니스 로직

**Test Strategy**: Unit Test

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: 유효한 투여 계획 검증
test('should return success for valid dosage plan', () {
  // Arrange
  final useCase = ValidateDosagePlanUseCase();
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );

  // Act
  final result = useCase.execute(plan);

  // Assert
  expect(result.isValid, true);
});

// TC-2: 빈 약물명 검증 실패
test('should return failure for empty medication name', () {
  // Arrange
  final useCase = ValidateDosagePlanUseCase();
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: '',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );

  // Act
  final result = useCase.execute(plan);

  // Assert
  expect(result.isValid, false);
  expect(result.errorMessage, contains('약물명'));
});

// TC-3: 음수 주기 검증 실패
test('should return failure for negative cycle days', () {
  // Arrange
  final useCase = ValidateDosagePlanUseCase();
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: -1,
    initialDoseMg: 0.25,
  );

  // Act
  final result = useCase.execute(plan);

  // Assert
  expect(result.isValid, false);
  expect(result.errorMessage, contains('주기'));
});

// TC-4: 증량 계획 역순 검증 실패
test('should return failure for decreasing escalation plan', () {
  // Arrange
  final useCase = ValidateDosagePlanUseCase();
  final escalationPlan = [
    EscalationStep(weeks: 4, doseMg: 1.0),
    EscalationStep(weeks: 8, doseMg: 0.5),
  ];
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
    escalationPlan: escalationPlan,
  );

  // Act
  final result = useCase.execute(plan);

  // Assert
  expect(result.isValid, false);
  expect(result.errorMessage, contains('증량'));
});
```

**Implementation Order**:
1. ValidationResult 클래스 작성
2. ValidateDosagePlanUseCase 클래스 기본 구조
3. 각 검증 규칙 구현 (약물명, 주기, 용량, 증량 계획)

**Dependencies**: DosagePlan Entity

---

### Module 5: RecalculateDoseScheduleUseCase (Domain)

**Location**: `lib/features/tracking/domain/usecases/recalculate_dose_schedule_usecase.dart`

**Responsibility**: 변경된 투여 계획 기반으로 미래 스케줄 재계산 (증량 계획 반영)

**Test Strategy**: Unit Test

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: 주기 변경 시 스케줄 재계산
test('should recalculate schedules when cycle days changed', () {
  // Arrange
  final useCase = RecalculateDoseScheduleUseCase();
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7, // 7일 주기로 변경
    initialDoseMg: 0.25,
  );
  final currentDate = DateTime(2025, 1, 15);

  // Act
  final schedules = useCase.execute(plan, currentDate);

  // Assert
  expect(schedules.isNotEmpty, true);
  expect(schedules[0].scheduledDate, DateTime(2025, 1, 15));
  expect(schedules[1].scheduledDate, DateTime(2025, 1, 22));
});

// TC-2: 증량 계획 반영 확인
test('should apply escalation plan to schedules', () {
  // Arrange
  final useCase = RecalculateDoseScheduleUseCase();
  final escalationPlan = [
    EscalationStep(weeks: 4, doseMg: 0.5),
    EscalationStep(weeks: 8, doseMg: 1.0),
  ];
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
    escalationPlan: escalationPlan,
  );
  final currentDate = DateTime(2025, 1, 1);

  // Act
  final schedules = useCase.execute(plan, currentDate);

  // Assert
  expect(schedules[0].doseMg, 0.25); // 초기 용량
  expect(schedules[4].doseMg, 0.5); // 4주차 증량
  expect(schedules[8].doseMg, 1.0); // 8주차 증량
});

// TC-3: 1초 이내 완료 (성능 요구사항)
test('should complete within 1 second', () {
  // Arrange
  final useCase = RecalculateDoseScheduleUseCase();
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );
  final currentDate = DateTime(2025, 1, 1);

  // Act
  final stopwatch = Stopwatch()..start();
  final schedules = useCase.execute(plan, currentDate);
  stopwatch.stop();

  // Assert
  expect(stopwatch.elapsedMilliseconds, lessThan(1000));
});

// TC-4: 과거 기록 보존 확인
test('should only calculate future schedules', () {
  // Arrange
  final useCase = RecalculateDoseScheduleUseCase();
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );
  final currentDate = DateTime(2025, 2, 1); // 과거 기록 존재

  // Act
  final schedules = useCase.execute(plan, currentDate);

  // Assert
  expect(schedules.every((s) => s.scheduledDate.isAfter(currentDate)), true);
});
```

**Implementation Order**:
1. RecalculateDoseScheduleUseCase 클래스 작성
2. execute 메서드 구현 (주기 기반 스케줄 생성)
3. 증량 계획 적용 로직
4. 성능 최적화 (1초 이내 완료)

**Dependencies**: DosagePlan Entity, DoseSchedule Entity

---

### Module 6: AnalyzePlanChangeImpactUseCase (Domain)

**Location**: `lib/features/tracking/domain/usecases/analyze_plan_change_impact_usecase.dart`

**Responsibility**: 투여 계획 변경사항이 기존 스케줄에 미치는 영향 분석

**Test Strategy**: Unit Test

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: 시작일 변경 시 영향 분석
test('should analyze impact when start date changed', () {
  // Arrange
  final useCase = AnalyzePlanChangeImpactUseCase();
  final oldPlan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );
  final newPlan = oldPlan.copyWith(startDate: DateTime(2025, 1, 15));
  final currentDate = DateTime(2025, 1, 10);

  // Act
  final impact = useCase.execute(oldPlan, newPlan, currentDate);

  // Assert
  expect(impact.affectedScheduleCount, greaterThan(0));
  expect(impact.changedFields, contains('startDate'));
});

// TC-2: 증량 계획 변경 시 영향 분석
test('should analyze impact when escalation plan changed', () {
  // Arrange
  final useCase = AnalyzePlanChangeImpactUseCase();
  final oldPlan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
    escalationPlan: [EscalationStep(weeks: 4, doseMg: 0.5)],
  );
  final newPlan = oldPlan.copyWith(
    escalationPlan: [EscalationStep(weeks: 4, doseMg: 1.0)],
  );
  final currentDate = DateTime(2025, 1, 10);

  // Act
  final impact = useCase.execute(oldPlan, newPlan, currentDate);

  // Assert
  expect(impact.hasEscalationChange, true);
  expect(impact.changedFields, contains('escalationPlan'));
});

// TC-3: 변경사항 없음 감지
test('should detect no changes', () {
  // Arrange
  final useCase = AnalyzePlanChangeImpactUseCase();
  final oldPlan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );
  final newPlan = oldPlan; // 동일
  final currentDate = DateTime(2025, 1, 10);

  // Act
  final impact = useCase.execute(oldPlan, newPlan, currentDate);

  // Assert
  expect(impact.affectedScheduleCount, 0);
  expect(impact.changedFields, isEmpty);
});
```

**Implementation Order**:
1. PlanChangeImpact 클래스 작성
2. AnalyzePlanChangeImpactUseCase 클래스 작성
3. 필드별 변경 감지 로직
4. 영향받는 스케줄 카운트 계산
5. 현재 증량 진행 주차 계산

**Dependencies**: DosagePlan Entity, DoseSchedule Entity

---

### Module 7: DosagePlanRepository Interface (Domain)

**Location**: `lib/features/tracking/domain/repositories/dosage_plan_repository.dart`

**Responsibility**: 투여 계획 저장소 인터페이스 정의

**Test Strategy**: Integration Test (구현체 테스트)

**Test Scenarios**: N/A (Interface는 구현체에서 테스트)

**Implementation Order**:
1. Repository 인터페이스 메서드 정의

**Dependencies**: DosagePlan Entity, PlanChangeHistory Entity

---

### Module 8: DoseScheduleRepository Interface (Domain)

**Location**: `lib/features/tracking/domain/repositories/dose_schedule_repository.dart`

**Responsibility**: 투여 스케줄 저장소 인터페이스 정의

**Test Strategy**: Integration Test (구현체 테스트)

**Test Scenarios**: N/A (Interface는 구현체에서 테스트)

**Implementation Order**:
1. Repository 인터페이스 메서드 정의
   - deleteFutureSchedules(String dosagePlanId, DateTime fromDate)
   - saveBatchSchedules(List<DoseSchedule> schedules)
   - getSchedulesByPlanId(String dosagePlanId)

**Dependencies**: DoseSchedule Entity

---

### Module 9: DosagePlanDto & PlanChangeHistoryDto (Infrastructure)

**Location**:
- `lib/features/tracking/infrastructure/dtos/dosage_plan_dto.dart`
- `lib/features/tracking/infrastructure/dtos/plan_change_history_dto.dart`

**Responsibility**: Isar 데이터베이스용 DTO 정의 및 Entity 변환

**Test Strategy**: Unit Test

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: DTO to Entity 변환
test('should convert DosagePlanDto to DosagePlan entity', () {
  // Arrange
  final dto = DosagePlanDto()
    ..id = 'plan-1'
    ..userId = 'user-1'
    ..medicationName = 'Ozempic'
    ..startDate = DateTime(2025, 1, 1)
    ..cycleDays = 7
    ..initialDoseMg = 0.25
    ..isActive = true;

  // Act
  final entity = dto.toEntity();

  // Assert
  expect(entity.id, 'plan-1');
  expect(entity.medicationName, 'Ozempic');
  expect(entity.isActive, true);
});

// TC-2: Entity to DTO 변환
test('should convert DosagePlan entity to DosagePlanDto', () {
  // Arrange
  final entity = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );

  // Act
  final dto = DosagePlanDto.fromEntity(entity);

  // Assert
  expect(dto.id, 'plan-1');
  expect(dto.medicationName, 'Ozempic');
  expect(dto.isActive, true);
});

// TC-3: EscalationPlan JSON 직렬화
test('should serialize escalation plan to JSON', () {
  // Arrange
  final escalationPlan = [
    EscalationStep(weeks: 4, doseMg: 0.5),
    EscalationStep(weeks: 8, doseMg: 1.0),
  ];
  final entity = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
    escalationPlan: escalationPlan,
  );

  // Act
  final dto = DosagePlanDto.fromEntity(entity);
  final jsonString = dto.escalationPlanJson;

  // Assert
  expect(jsonString, isNotNull);
  final decoded = jsonDecode(jsonString!);
  expect(decoded, isA<List>());
  expect(decoded.length, 2);
});
```

**Implementation Order**:
1. DosagePlanDto 클래스 작성 (Isar Collection)
2. toEntity/fromEntity 메서드 구현
3. EscalationPlan JSON 직렬화 로직
4. PlanChangeHistoryDto 동일 과정 반복

**Dependencies**: DosagePlan Entity, PlanChangeHistory Entity, Isar

---

### Module 10: DoseScheduleDto (Infrastructure)

**Location**: `lib/features/tracking/infrastructure/dtos/dose_schedule_dto.dart`

**Responsibility**: Isar 데이터베이스용 DoseSchedule DTO 정의 및 Entity 변환

**Test Strategy**: Unit Test

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: DTO to Entity 변환
test('should convert DoseScheduleDto to DoseSchedule entity', () {
  // Arrange
  final dto = DoseScheduleDto()
    ..id = 'schedule-1'
    ..dosagePlanId = 'plan-1'
    ..scheduledDate = DateTime(2025, 1, 1)
    ..doseMg = 0.25
    ..isCompleted = false;

  // Act
  final entity = dto.toEntity();

  // Assert
  expect(entity.id, 'schedule-1');
  expect(entity.dosagePlanId, 'plan-1');
  expect(entity.isCompleted, false);
});

// TC-2: Entity to DTO 변환
test('should convert DoseSchedule entity to DoseScheduleDto', () {
  // Arrange
  final entity = DoseSchedule(
    id: 'schedule-1',
    dosagePlanId: 'plan-1',
    scheduledDate: DateTime(2025, 1, 1),
    doseMg: 0.25,
    isCompleted: false,
  );

  // Act
  final dto = DoseScheduleDto.fromEntity(entity);

  // Assert
  expect(dto.id, 'schedule-1');
  expect(dto.dosagePlanId, 'plan-1');
  expect(dto.isCompleted, false);
});
```

**Implementation Order**:
1. DoseScheduleDto 클래스 작성 (Isar Collection)
2. toEntity/fromEntity 메서드 구현

**Dependencies**: DoseSchedule Entity, Isar

---

### Module 11: IsarDosagePlanRepository (Infrastructure)

**Location**: `lib/features/tracking/infrastructure/repositories/isar_dosage_plan_repository.dart`

**Responsibility**: Isar 기반 투여 계획 저장소 구현

**Test Strategy**: Integration Test

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: 활성 투여 계획 조회
test('should get active dosage plan for user', () async {
  // Arrange
  final isar = await openTestIsar();
  final repository = IsarDosagePlanRepository(isar);
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
    isActive: true,
  );
  await repository.saveDosagePlan(plan);

  // Act
  final result = await repository.getActiveDosagePlan('user-1');

  // Assert
  expect(result, isNotNull);
  expect(result!.id, 'plan-1');
  expect(result.isActive, true);
});

// TC-2: 투여 계획 업데이트
test('should update dosage plan', () async {
  // Arrange
  final isar = await openTestIsar();
  final repository = IsarDosagePlanRepository(isar);
  final originalPlan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );
  await repository.saveDosagePlan(originalPlan);

  final updatedPlan = originalPlan.copyWith(
    medicationName: 'Wegovy',
    initialDoseMg: 0.5,
  );

  // Act
  await repository.updateDosagePlan(updatedPlan);
  final result = await repository.getActiveDosagePlan('user-1');

  // Assert
  expect(result!.medicationName, 'Wegovy');
  expect(result.initialDoseMg, 0.5);
});

// TC-3: 변경 이력 저장
test('should save plan change history', () async {
  // Arrange
  final isar = await openTestIsar();
  final repository = IsarDosagePlanRepository(isar);
  final history = PlanChangeHistory(
    id: 'history-1',
    dosagePlanId: 'plan-1',
    changedAt: DateTime(2025, 2, 1),
    oldPlan: {'initialDoseMg': 0.25},
    newPlan: {'initialDoseMg': 0.5},
  );

  // Act
  await repository.savePlanChangeHistory(history);
  final result = await repository.getPlanChangeHistory('plan-1');

  // Assert
  expect(result.length, 1);
  expect(result.first.oldPlan['initialDoseMg'], 0.25);
  expect(result.first.newPlan['initialDoseMg'], 0.5);
});

// TC-4: 트랜잭션으로 계획 업데이트 및 이력 저장
test('should update plan and save history in transaction', () async {
  // Arrange
  final isar = await openTestIsar();
  final repository = IsarDosagePlanRepository(isar);
  final originalPlan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );
  await repository.saveDosagePlan(originalPlan);

  final updatedPlan = originalPlan.copyWith(initialDoseMg: 0.5);
  final history = PlanChangeHistory(
    id: 'history-1',
    dosagePlanId: 'plan-1',
    changedAt: DateTime.now(),
    oldPlan: {'initialDoseMg': 0.25},
    newPlan: {'initialDoseMg': 0.5},
  );

  // Act
  await repository.updatePlanWithHistory(updatedPlan, history);

  // Assert
  final plan = await repository.getActiveDosagePlan('user-1');
  final histories = await repository.getPlanChangeHistory('plan-1');
  expect(plan!.initialDoseMg, 0.5);
  expect(histories.length, 1);
});

// TC-5: 트랜잭션 실패 시 롤백
test('should rollback both history and plan on error', () async {
  // Arrange
  final isar = await openTestIsar();
  final repository = IsarDosagePlanRepository(isar);
  final originalPlan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );
  await repository.saveDosagePlan(originalPlan);

  // Act & Assert
  // 잘못된 데이터로 트랜잭션 실패 시뮬레이션
  expect(
    () => repository.updatePlanWithHistory(null, null),
    throwsA(isA<Exception>()),
  );

  // 원본 데이터 보존 확인
  final plan = await repository.getActiveDosagePlan('user-1');
  expect(plan!.initialDoseMg, 0.25);
});
```

**Implementation Order**:
1. IsarDosagePlanRepository 클래스 기본 구조
2. getActiveDosagePlan 구현
3. updateDosagePlan 구현
4. savePlanChangeHistory 구현
5. getPlanChangeHistory 구현
6. updatePlanWithHistory 구현 (트랜잭션)

**Dependencies**: DosagePlanRepository Interface, DosagePlanDto, PlanChangeHistoryDto, Isar

---

### Module 12: IsarDoseScheduleRepository (Infrastructure)

**Location**: `lib/features/tracking/infrastructure/repositories/isar_dose_schedule_repository.dart`

**Responsibility**: Isar 기반 투여 스케줄 저장소 구현

**Test Strategy**: Integration Test

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: 미래 스케줄 삭제
test('should delete future schedules from specific date', () async {
  // Arrange
  final isar = await openTestIsar();
  final repository = IsarDoseScheduleRepository(isar);

  final schedules = [
    DoseSchedule(
      id: 'schedule-1',
      dosagePlanId: 'plan-1',
      scheduledDate: DateTime(2025, 1, 1),
      doseMg: 0.25,
      isCompleted: true,
    ),
    DoseSchedule(
      id: 'schedule-2',
      dosagePlanId: 'plan-1',
      scheduledDate: DateTime(2025, 1, 15),
      doseMg: 0.25,
      isCompleted: false,
    ),
    DoseSchedule(
      id: 'schedule-3',
      dosagePlanId: 'plan-1',
      scheduledDate: DateTime(2025, 2, 1),
      doseMg: 0.25,
      isCompleted: false,
    ),
  ];

  await repository.saveBatchSchedules(schedules);

  // Act
  await repository.deleteFutureSchedules('plan-1', DateTime(2025, 1, 10));

  // Assert
  final remaining = await repository.getSchedulesByPlanId('plan-1');
  expect(remaining.length, 1); // 과거 기록만 남음
  expect(remaining[0].id, 'schedule-1');
});

// TC-2: 배치 스케줄 저장
test('should save batch schedules', () async {
  // Arrange
  final isar = await openTestIsar();
  final repository = IsarDoseScheduleRepository(isar);

  final schedules = List.generate(10, (i) => DoseSchedule(
    id: 'schedule-$i',
    dosagePlanId: 'plan-1',
    scheduledDate: DateTime(2025, 1, 1).add(Duration(days: i * 7)),
    doseMg: 0.25,
    isCompleted: false,
  ));

  // Act
  await repository.saveBatchSchedules(schedules);

  // Assert
  final saved = await repository.getSchedulesByPlanId('plan-1');
  expect(saved.length, 10);
});

// TC-3: 특정 계획의 스케줄 조회
test('should get schedules by plan id', () async {
  // Arrange
  final isar = await openTestIsar();
  final repository = IsarDoseScheduleRepository(isar);

  final plan1Schedules = [
    DoseSchedule(
      id: 'schedule-1',
      dosagePlanId: 'plan-1',
      scheduledDate: DateTime(2025, 1, 1),
      doseMg: 0.25,
      isCompleted: false,
    ),
  ];

  final plan2Schedules = [
    DoseSchedule(
      id: 'schedule-2',
      dosagePlanId: 'plan-2',
      scheduledDate: DateTime(2025, 1, 1),
      doseMg: 0.5,
      isCompleted: false,
    ),
  ];

  await repository.saveBatchSchedules([...plan1Schedules, ...plan2Schedules]);

  // Act
  final result = await repository.getSchedulesByPlanId('plan-1');

  // Assert
  expect(result.length, 1);
  expect(result[0].dosagePlanId, 'plan-1');
});
```

**Implementation Order**:
1. IsarDoseScheduleRepository 클래스 기본 구조
2. deleteFutureSchedules 구현
3. saveBatchSchedules 구현
4. getSchedulesByPlanId 구현

**Dependencies**: DoseScheduleRepository Interface, DoseScheduleDto, Isar

---

### Module 13: UpdateDosagePlanUseCase (Application)

**Location**: `lib/features/tracking/application/usecases/update_dosage_plan_usecase.dart`

**Responsibility**: 투여 계획 수정 로직 조율 (검증, 영향 분석, 이력 저장, 업데이트, 스케줄 재계산)

**Test Strategy**: Unit Test (with Mock Repository)

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: 유효한 계획 업데이트 및 스케줄 재계산 성공
test('should update dosage plan and recalculate schedules successfully', () async {
  // Arrange
  final mockPlanRepository = MockDosagePlanRepository();
  final mockScheduleRepository = MockDoseScheduleRepository();
  final validateUseCase = ValidateDosagePlanUseCase();
  final analyzeImpactUseCase = AnalyzePlanChangeImpactUseCase();
  final recalculateScheduleUseCase = RecalculateDoseScheduleUseCase();
  final useCase = UpdateDosagePlanUseCase(
    mockPlanRepository,
    mockScheduleRepository,
    validateUseCase,
    analyzeImpactUseCase,
    recalculateScheduleUseCase,
  );

  final oldPlan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );

  final newPlan = oldPlan.copyWith(initialDoseMg: 0.5);

  when(mockPlanRepository.updatePlanWithHistory(any, any))
      .thenAnswer((_) async => {});
  when(mockScheduleRepository.deleteFutureSchedules(any, any))
      .thenAnswer((_) async => {});
  when(mockScheduleRepository.saveBatchSchedules(any))
      .thenAnswer((_) async => {});

  // Act
  final result = await useCase.execute(oldPlan, newPlan);

  // Assert
  expect(result.isSuccess, true);
  verify(mockPlanRepository.updatePlanWithHistory(any, any)).called(1);
  verify(mockScheduleRepository.deleteFutureSchedules('plan-1', any)).called(1);
  verify(mockScheduleRepository.saveBatchSchedules(any)).called(1);
});

// TC-2: 유효하지 않은 계획 업데이트 실패
test('should fail to update invalid dosage plan', () async {
  // Arrange
  final mockPlanRepository = MockDosagePlanRepository();
  final mockScheduleRepository = MockDoseScheduleRepository();
  final validateUseCase = ValidateDosagePlanUseCase();
  final analyzeImpactUseCase = AnalyzePlanChangeImpactUseCase();
  final recalculateScheduleUseCase = RecalculateDoseScheduleUseCase();
  final useCase = UpdateDosagePlanUseCase(
    mockPlanRepository,
    mockScheduleRepository,
    validateUseCase,
    analyzeImpactUseCase,
    recalculateScheduleUseCase,
  );

  final oldPlan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );

  final newPlan = oldPlan.copyWith(medicationName: '');

  // Act
  final result = await useCase.execute(oldPlan, newPlan);

  // Assert
  expect(result.isSuccess, false);
  expect(result.errorMessage, contains('약물명'));
  verifyNever(mockPlanRepository.updatePlanWithHistory(any, any));
  verifyNever(mockScheduleRepository.deleteFutureSchedules(any, any));
});

// TC-3: 변경사항 없을 때 조기 복귀
test('should return early when no changes detected', () async {
  // Arrange
  final mockPlanRepository = MockDosagePlanRepository();
  final mockScheduleRepository = MockDoseScheduleRepository();
  final validateUseCase = ValidateDosagePlanUseCase();
  final analyzeImpactUseCase = AnalyzePlanChangeImpactUseCase();
  final recalculateScheduleUseCase = RecalculateDoseScheduleUseCase();
  final useCase = UpdateDosagePlanUseCase(
    mockPlanRepository,
    mockScheduleRepository,
    validateUseCase,
    analyzeImpactUseCase,
    recalculateScheduleUseCase,
  );

  final oldPlan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );

  final newPlan = oldPlan; // 동일

  // Act
  final result = await useCase.execute(oldPlan, newPlan);

  // Assert
  expect(result.isSuccess, true);
  verifyNever(mockPlanRepository.updatePlanWithHistory(any, any));
  verifyNever(mockScheduleRepository.deleteFutureSchedules(any, any));
});

// TC-4: 스케줄 재계산 실패 시 롤백
test('should rollback on schedule recalculation failure', () async {
  // Arrange
  final mockPlanRepository = MockDosagePlanRepository();
  final mockScheduleRepository = MockDoseScheduleRepository();
  final validateUseCase = ValidateDosagePlanUseCase();
  final analyzeImpactUseCase = AnalyzePlanChangeImpactUseCase();
  final recalculateScheduleUseCase = RecalculateDoseScheduleUseCase();
  final useCase = UpdateDosagePlanUseCase(
    mockPlanRepository,
    mockScheduleRepository,
    validateUseCase,
    analyzeImpactUseCase,
    recalculateScheduleUseCase,
  );

  final oldPlan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );

  final newPlan = oldPlan.copyWith(initialDoseMg: 0.5);

  when(mockPlanRepository.updatePlanWithHistory(any, any))
      .thenAnswer((_) async => {});
  when(mockScheduleRepository.deleteFutureSchedules(any, any))
      .thenThrow(Exception('Schedule deletion failed'));

  // Act
  final result = await useCase.execute(oldPlan, newPlan);

  // Assert
  expect(result.isSuccess, false);
  expect(result.errorMessage, contains('Schedule deletion failed'));
});
```

**Implementation Order**:
1. UpdateDosagePlanUseCase 클래스 작성
2. execute 메서드 구현
   - 변경사항 감지 (AnalyzePlanChangeImpactUseCase)
   - 변경사항 없으면 조기 복귀
   - 검증 (ValidateDosagePlanUseCase)
   - 계획 업데이트 및 이력 저장 (트랜잭션)
   - 미래 스케줄 삭제
   - 스케줄 재계산 (RecalculateDoseScheduleUseCase)
   - 새 스케줄 저장
3. 에러 처리 및 롤백 로직

**Dependencies**:
- DosagePlanRepository Interface
- DoseScheduleRepository Interface
- ValidateDosagePlanUseCase
- AnalyzePlanChangeImpactUseCase
- RecalculateDoseScheduleUseCase

---

### Module 8: DosagePlanNotifier (Application)

**Location**: `lib/features/tracking/application/notifiers/dosage_plan_notifier.dart`

**Responsibility**: 투여 계획 상태 관리 (Riverpod)

**Test Strategy**: Unit Test (with Mock Repository & UseCase)

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: 초기 활성 계획 로드
test('should load active dosage plan on build', () async {
  // Arrange
  final mockRepository = MockDosagePlanRepository();
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );

  when(mockRepository.getActiveDosagePlan('user-1'))
      .thenAnswer((_) async => plan);

  // Act
  final container = ProviderContainer(
    overrides: [
      dosagePlanRepositoryProvider.overrideWithValue(mockRepository),
    ],
  );
  final state = await container.read(dosagePlanNotifierProvider.future);

  // Assert
  expect(state, isNotNull);
  expect(state!.id, 'plan-1');
});

// TC-2: 투여 계획 업데이트 호출
test('should update dosage plan and refresh state', () async {
  // Arrange
  final mockRepository = MockDosagePlanRepository();
  final mockUseCase = MockUpdateDosagePlanUseCase();

  final oldPlan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );

  final newPlan = oldPlan.copyWith(initialDoseMg: 0.5);

  when(mockRepository.getActiveDosagePlan('user-1'))
      .thenAnswer((_) async => oldPlan)
      .thenAnswer((_) async => newPlan);

  when(mockUseCase.execute(oldPlan, newPlan))
      .thenAnswer((_) async => UpdateResult.success());

  // Act
  final container = ProviderContainer(
    overrides: [
      dosagePlanRepositoryProvider.overrideWithValue(mockRepository),
      updateDosagePlanUseCaseProvider.overrideWithValue(mockUseCase),
    ],
  );

  final notifier = container.read(dosagePlanNotifierProvider.notifier);
  await notifier.updatePlan(oldPlan, newPlan);

  // Assert
  final state = await container.read(dosagePlanNotifierProvider.future);
  expect(state!.initialDoseMg, 0.5);
});
```

**Implementation Order**:
1. DosagePlanNotifier 클래스 작성 (AsyncNotifier 상속)
2. build 메서드 구현 (초기 로드)
3. updatePlan 메서드 구현
4. 에러 상태 처리

**Dependencies**: DosagePlanRepository, UpdateDosagePlanUseCase

---

### Module 9: DosagePlanFormWidget (Presentation)

**Location**: `lib/features/tracking/presentation/widgets/dosage_plan_form_widget.dart`

**Responsibility**: 투여 계획 입력 폼 UI

**Test Strategy**: Widget Test

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: 폼 렌더링 및 초기값 표시
testWidgets('should display form with initial values', (tester) async {
  // Arrange
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );

  // Act
  await tester.pumpWidget(
    MaterialApp(
      home: Scaffold(
        body: DosagePlanFormWidget(initialPlan: plan),
      ),
    ),
  );

  // Assert
  expect(find.text('Ozempic'), findsOneWidget);
  expect(find.text('7'), findsOneWidget);
  expect(find.text('0.25'), findsOneWidget);
});

// TC-2: 실시간 검증 피드백 표시
testWidgets('should show validation error for empty medication name', (tester) async {
  // Arrange & Act
  await tester.pumpWidget(
    MaterialApp(
      home: Scaffold(
        body: DosagePlanFormWidget(),
      ),
    ),
  );

  await tester.enterText(find.byKey(Key('medication_name_field')), '');
  await tester.pump();

  // Assert
  expect(find.text('약물명을 입력하세요'), findsOneWidget);
});
```

**Implementation Order**:
1. DosagePlanFormWidget 기본 구조
2. TextFormField 위젯 작성
3. 실시간 검증 로직 연결
4. FormKey 관리

**Dependencies**: None

---

### Module 15: PlanChangeConfirmationDialog (Presentation)

**Location**: `lib/features/tracking/presentation/widgets/plan_change_confirmation_dialog.dart`

**Responsibility**: 투여 계획 변경 영향 확인 다이얼로그

**Test Strategy**: Widget Test

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: 다이얼로그 렌더링 및 영향 정보 표시
testWidgets('should display impact information', (tester) async {
  // Arrange
  final impact = PlanChangeImpact(
    affectedScheduleCount: 5,
    firstAffectedDate: DateTime(2025, 1, 15),
    changedFields: ['initialDoseMg', 'cycleDays'],
    hasEscalationChange: false,
  );

  // Act
  await tester.pumpWidget(
    MaterialApp(
      home: Scaffold(
        body: PlanChangeConfirmationDialog(impact: impact),
      ),
    ),
  );

  // Assert
  expect(find.text('투여 계획 변경 시 이후 스케줄이 재계산됩니다'), findsOneWidget);
  expect(find.text('진행하시겠습니까?'), findsOneWidget);
  expect(find.text('영향받는 스케줄: 5개'), findsOneWidget);
});

// TC-2: 확인/취소 버튼 동작
testWidgets('should handle confirm and cancel actions', (tester) async {
  // Arrange
  bool confirmed = false;
  final impact = PlanChangeImpact(
    affectedScheduleCount: 5,
    firstAffectedDate: DateTime(2025, 1, 15),
    changedFields: ['initialDoseMg'],
    hasEscalationChange: false,
  );

  // Act
  await tester.pumpWidget(
    MaterialApp(
      home: Scaffold(
        body: Builder(
          builder: (context) => ElevatedButton(
            onPressed: () async {
              final result = await showDialog<bool>(
                context: context,
                builder: (_) => PlanChangeConfirmationDialog(impact: impact),
              );
              confirmed = result ?? false;
            },
            child: Text('Open'),
          ),
        ),
      ),
    ),
  );

  await tester.tap(find.text('Open'));
  await tester.pumpAndSettle();

  await tester.tap(find.text('확인'));
  await tester.pumpAndSettle();

  // Assert
  expect(confirmed, true);
});
```

**Implementation Order**:
1. PlanChangeConfirmationDialog 위젯 작성
2. 영향 정보 표시 UI
3. 확인/취소 버튼 처리

**Dependencies**: PlanChangeImpact (from AnalyzePlanChangeImpactUseCase)

---

### Module 16: EditDosagePlanScreen (Presentation)

**Location**: `lib/features/tracking/presentation/screens/edit_dosage_plan_screen.dart`

**Responsibility**: 투여 계획 수정 화면

**Test Strategy**: Widget Test + QA Sheet

**Test Scenarios**:

**Red Phase**:
```dart
// TC-1: 화면 렌더링 및 로딩 상태
testWidgets('should show loading indicator while fetching plan', (tester) async {
  // Arrange
  final container = ProviderContainer(
    overrides: [
      dosagePlanNotifierProvider.overrideWith(
        (ref) => AsyncValue.loading(),
      ),
    ],
  );

  // Act
  await tester.pumpWidget(
    UncontrolledProviderScope(
      container: container,
      child: MaterialApp(home: EditDosagePlanScreen()),
    ),
  );

  // Assert
  expect(find.byType(CircularProgressIndicator), findsOneWidget);
});

// TC-2: 저장 버튼 클릭 및 성공 메시지
testWidgets('should save plan and show success message', (tester) async {
  // Arrange
  final mockNotifier = MockDosagePlanNotifier();
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );

  when(mockNotifier.build()).thenAnswer((_) async => plan);
  when(mockNotifier.updatePlan(any, any)).thenAnswer((_) async => {});

  final container = ProviderContainer(
    overrides: [
      dosagePlanNotifierProvider.overrideWith((ref) => mockNotifier),
    ],
  );

  // Act
  await tester.pumpWidget(
    UncontrolledProviderScope(
      container: container,
      child: MaterialApp(home: EditDosagePlanScreen()),
    ),
  );
  await tester.pumpAndSettle();

  await tester.enterText(find.byKey(Key('medication_name_field')), 'Wegovy');
  await tester.tap(find.byKey(Key('save_button')));
  await tester.pumpAndSettle();

  // Assert
  expect(find.text('투여 계획이 수정되었습니다'), findsOneWidget);
});

// TC-3: 영향 분석 다이얼로그 표시
testWidgets('should show impact analysis dialog before save', (tester) async {
  // Arrange
  final mockNotifier = MockDosagePlanNotifier();
  final plan = DosagePlan(
    id: 'plan-1',
    userId: 'user-1',
    medicationName: 'Ozempic',
    startDate: DateTime(2025, 1, 1),
    cycleDays: 7,
    initialDoseMg: 0.25,
  );

  when(mockNotifier.build()).thenAnswer((_) async => plan);

  final container = ProviderContainer(
    overrides: [
      dosagePlanNotifierProvider.overrideWith((ref) => mockNotifier),
    ],
  );

  // Act
  await tester.pumpWidget(
    UncontrolledProviderScope(
      container: container,
      child: MaterialApp(home: EditDosagePlanScreen()),
    ),
  );
  await tester.pumpAndSettle();

  await tester.enterText(find.byKey(Key('medication_name_field')), 'Wegovy');
  await tester.tap(find.byKey(Key('save_button')));
  await tester.pumpAndSettle();

  // Assert
  expect(find.text('투여 계획 변경 시 이후 스케줄이 재계산됩니다'), findsOneWidget);
  expect(find.text('진행하시겠습니까?'), findsOneWidget);
});
```

**Implementation Order**:
1. EditDosagePlanScreen Scaffold 구조
2. Consumer/ConsumerWidget 연결
3. DosagePlanFormWidget 통합
4. 저장 전 영향 분석 (AnalyzePlanChangeImpactUseCase 호출)
5. PlanChangeConfirmationDialog 표시
6. 저장 버튼 및 확인 다이얼로그
7. 성공/실패 스낵바

**Dependencies**:
- DosagePlanNotifier
- DosagePlanFormWidget
- PlanChangeConfirmationDialog
- AnalyzePlanChangeImpactUseCase

**QA Sheet**:
- [ ] 설정 메뉴에서 "투여 계획 수정" 선택 시 화면 이동
- [ ] 기존 투여 계획 정보가 폼에 자동 입력됨
- [ ] 약물명 필드 빈 값 입력 시 에러 메시지 표시
- [ ] 주기 필드 음수 입력 시 에러 메시지 표시
- [ ] 증량 계획 역순 입력 시 에러 메시지 표시
- [ ] 변경사항 없이 저장 시 즉시 복귀 (불필요한 DB 업데이트 방지)
- [ ] 저장 버튼 클릭 시 영향 분석 다이얼로그 표시
- [ ] 영향 분석 다이얼로그에 영향받는 스케줄 개수 표시
- [ ] 확인 선택 시 저장 완료 메시지 표시
- [ ] 저장 완료 후 스케줄 재계산 1초 이내 완료
- [ ] 미래 스케줄 삭제 및 새 스케줄 생성 확인
- [ ] 저장 후 설정 화면으로 복귀
- [ ] 네트워크 오류 시 에러 메시지 표시
- [ ] 트랜잭션 실패 시 롤백 확인

## 4. TDD Workflow

### 시작점
1. **DosagePlan Entity** 테스트 작성 (Red)
2. Entity 구현 (Green)
3. Refactor (필요 시)

### 진행 순서
1. **Domain Layer 완성**
   - Entity: DosagePlan, PlanChangeHistory, DoseSchedule
   - UseCase: ValidateDosagePlan, RecalculateDoseSchedule, AnalyzePlanChangeImpact
   - Repository Interface: DosagePlanRepository, DoseScheduleRepository

2. **Infrastructure Layer 완성**
   - DTO: DosagePlanDto, PlanChangeHistoryDto, DoseScheduleDto
   - Repository Implementation: IsarDosagePlanRepository, IsarDoseScheduleRepository

3. **Application Layer 완성**
   - UseCase: UpdateDosagePlanUseCase (통합)
   - Notifier: DosagePlanNotifier

4. **Presentation Layer 완성**
   - Widget: DosagePlanFormWidget, PlanChangeConfirmationDialog
   - Screen: EditDosagePlanScreen

### Commit 포인트
- [ ] Domain Layer 테스트 통과 (Entity + UseCase + Repository Interface)
- [ ] Infrastructure Layer 테스트 통과 (DTO + Repository Implementation)
- [ ] Application Layer 테스트 통과 (UpdateDosagePlanUseCase + Notifier)
- [ ] Presentation Layer 테스트 통과 (Widget + Screen)
- [ ] Integration Test 통과 (스케줄 재계산 포함)
- [ ] QA Sheet 완료

### 완료 조건
- 모든 Unit Test 통과 (Coverage > 80%)
- 모든 Widget Test 통과
- 모든 Integration Test 통과
- QA Sheet 항목 통과
- flutter analyze 경고 없음
- 성능 요구사항 충족:
  - 스케줄 재계산 1초 이내 완료
  - 트랜잭션 처리 확인 (계획 업데이트 + 이력 저장)
  - 미래 스케줄 삭제 및 재생성 확인
</file>

<file path="012/spec.md">
# UF-009: 투여 계획 수정 상세 유스케이스

## Primary Actor
GLP-1 사용자

## Precondition
- 사용자가 로그인된 상태
- 초기 투여 계획이 온보딩 단계에서 설정되어 있음
- 현재 활성화된 투여 계획이 존재함

## Trigger
사용자가 설정 메뉴에서 "투여 계획 수정" 메뉴를 선택

## Main Scenario

### 1. 투여 계획 수정 화면 진입
- 사용자가 설정 메뉴에서 "투여 계획 수정"을 선택
- FE는 현재 활성화된 투여 계획 정보 요청
- BE는 dosage_plans 테이블에서 (user_id, is_active=true) 조건으로 현재 계획 조회
- FE는 기존 정보가 채워진 수정 폼 표시 (약물명, 시작일, 주기, 초기 용량, 증량 계획)

### 2. 사용자 입력 및 검증
- 사용자가 하나 이상의 필드를 수정
- FE는 각 필드에 대해 실시간 검증 수행:
  - 약물명: 비어있지 않은지 확인
  - 시작일: 날짜 형식 유효성 확인 (과거 날짜 시 경고 표시하되 허용)
  - 주기: 양수 값 확인
  - 초기 용량: 양수 값 확인
  - 증량 계획: 용량이 논리적 순서로 증가하는지 확인

### 3. 영향 분석 및 확인
- 사용자가 저장 버튼 클릭
- FE는 변경사항이 기존 투여 기록에 미치는 영향 분석
- FE는 영향 확인 메시지 표시: "투여 계획 변경 시 이후 스케줄이 재계산됩니다. 진행하시겠습니까?"
- 사용자가 확인 선택

### 4. 계획 변경 저장
- FE는 변경 전 계획과 변경 후 계획을 BE에 전송
- BE는 트랜잭션 시작
- BE는 plan_change_history 테이블에 변경 이력 삽입 (dosage_plan_id, changed_at, old_plan, new_plan)
- BE는 dosage_plans 테이블에서 해당 계획 업데이트 (medication_name, start_date, cycle_days, initial_dose_mg, escalation_plan, updated_at)
- BE는 트랜잭션 커밋

### 5. 투여 스케줄 재계산
- FE는 스케줄 재계산 로직 실행
- FE는 변경된 계획 기준으로 dose_schedules 재생성:
  - 기존 dose_schedules 중 미래 일정 삭제
  - 새 계획 기반으로 전체 스케줄 재생성
  - 증량 계획 반영
  - 1초 이내 완료
- FE는 재계산된 스케줄을 BE에 저장

### 6. 완료 및 복귀
- FE는 "투여 계획이 수정되었습니다" 확인 메시지 표시
- FE는 설정 화면으로 복귀
- 홈 대시보드의 다음 예정 일정 자동 갱신

## Edge Cases

### EC-1: 과거 시작일로 변경
- 시작일이 과거 날짜로 변경되는 경우
- FE는 경고 메시지 표시: "시작일이 과거 날짜입니다. 계속하시겠습니까?"
- 사용자 확인 후 진행 허용

### EC-2: 진행 중인 증량 계획 변경
- 이미 일부 증량이 진행된 상태에서 증량 계획 변경
- FE는 영향 범위 명확히 안내: "현재 N주차 진행 중입니다. 변경 시 이후 증량 일정이 조정됩니다."
- 사용자 확인 후 진행

### EC-3: 주기 변경으로 인한 기록 불일치
- 투여 주기 변경으로 기존 투여 기록과 새 스케줄이 불일치
- 기존 dose_records는 유지 (과거 기록 보존)
- 스케줄만 재계산하여 미래 일정 조정
- FE는 안내 메시지: "기존 투여 기록은 유지되며, 이후 스케줄만 조정됩니다."

### EC-4: 저장 중 앱 종료
- 저장 프로세스 진행 중 앱 비정상 종료
- BE 트랜잭션 롤백으로 데이터 일관성 유지
- 다음 실행 시 변경사항 폐기, 기존 계획 유지

### EC-5: 증량 계획 대폭 변경
- 증량 속도나 최종 용량이 크게 변경되는 경우
- FE는 안전성 경고 표시: "용량 변경이 큽니다. 의료진과 상담 후 진행하세요."
- 사용자 확인 후 진행 허용

### EC-6: 변경사항 없이 저장
- 사용자가 아무 값도 변경하지 않고 저장 버튼 클릭
- FE는 변경사항 없음을 감지하고 즉시 설정 화면으로 복귀
- 불필요한 DB 업데이트 방지

### EC-7: 네트워크 오류
- 저장 요청 중 네트워크 오류 발생
- FE는 로컬에 변경사항 임시 저장
- 재시도 옵션 제공
- 연결 복구 시 자동 재시도 (최대 3회)

## Business Rules

### BR-1: 증량 계획 논리적 검증
- 증량 계획의 용량은 항상 이전 용량보다 크거나 같아야 함
- 감량 또는 역순은 에러로 처리

### BR-2: 활성 계획 단일성
- 사용자는 항상 하나의 활성 투여 계획만 가질 수 있음
- is_active=true인 계획은 사용자당 1개만 존재

### BR-3: 변경 이력 필수 기록
- 모든 투여 계획 변경은 plan_change_history에 기록되어야 함
- 추적성 보장을 위해 변경 전후 상태 모두 저장

### BR-4: 과거 기록 불가역성
- 이미 완료된 dose_records는 투여 계획 변경과 무관하게 유지
- 스케줄 재계산은 현재 시점 이후만 적용

### BR-5: 스케줄 재계산 성능
- 스케줄 재계산은 1초 이내 완료되어야 함
- 대용량 데이터 처리 시에도 사용자 대기 시간 최소화

### BR-6: 트랜잭션 원자성
- 투여 계획 업데이트와 변경 이력 저장은 하나의 트랜잭션으로 처리
- 일부만 성공하는 경우 전체 롤백

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE
participant BE
database Database

User -> FE: 설정 메뉴에서 "투여 계획 수정" 선택
FE -> BE: GET /dosage-plans/active
BE -> Database: SELECT * FROM dosage_plans WHERE user_id = ? AND is_active = true
Database --> BE: 현재 투여 계획 데이터
BE --> FE: 투여 계획 JSON
FE --> User: 기존 정보가 채워진 수정 폼 표시

User -> FE: 필드 수정 (약물명, 시작일, 주기, 용량, 증량 계획)
FE -> FE: 실시간 입력 검증
FE --> User: 검증 피드백 표시

User -> FE: 저장 버튼 클릭
FE -> FE: 변경사항 영향 분석
FE --> User: 영향 확인 메시지 표시
User -> FE: 확인 선택

FE -> BE: PUT /dosage-plans/{id} (old_plan, new_plan)
BE -> Database: BEGIN TRANSACTION
BE -> Database: INSERT INTO plan_change_history (dosage_plan_id, changed_at, old_plan, new_plan)
Database --> BE: 변경 이력 저장 완료
BE -> Database: UPDATE dosage_plans SET ... WHERE id = ?
Database --> BE: 투여 계획 업데이트 완료
BE -> Database: COMMIT
BE --> FE: 200 OK

FE -> FE: 투여 스케줄 재계산 시작
FE -> BE: DELETE /dose-schedules/future?plan_id={id}
BE -> Database: DELETE FROM dose_schedules WHERE dosage_plan_id = ? AND scheduled_date > NOW()
Database --> BE: 미래 스케줄 삭제 완료
BE --> FE: 200 OK

FE -> FE: 새 계획 기반 스케줄 생성 (1초 이내)
FE -> BE: POST /dose-schedules/batch (스케줄 배열)
BE -> Database: INSERT INTO dose_schedules (multiple rows)
Database --> BE: 스케줄 저장 완료
BE --> FE: 200 OK

FE --> User: "투여 계획이 수정되었습니다" 메시지
FE -> FE: 설정 화면으로 복귀
FE -> FE: 홈 대시보드 데이터 갱신

@enduml
```
</file>

<file path="013/plan.md">
# 과거 기록 수정/삭제 (UF-011) Implementation Plan

## 1. 개요

과거 기록 수정/삭제 기능은 사용자가 잘못 입력하거나 변경이 필요한 체중, 증상, 투여 기록을 수정하거나 삭제할 수 있는 기능. 기록 변경 시 관련 통계와 인사이트를 자동으로 재계산하여 데이터 일관성 유지. 4-Layer Architecture + Repository Pattern + TDD 적용.

**모듈 구조:**
- **Domain Layer**: 기록 수정 검증 로직, 통계 재계산 트리거 UseCase, 감사 추적 UseCase, Repository Interface
- **Application Layer**: RecordEditNotifier (AsyncNotifier), 통계 재계산 오케스트레이션
- **Infrastructure Layer**: Repository 구현체 (IsarTrackingRepository, IsarMedicationRepository, IsarAuditRepository)
- **Presentation Layer**: RecordEditDialog (날짜 수정 포함), RecordDeleteDialog, 기록 목록 화면 수정

**TDD 적용 범위:**
- Domain UseCase: Unit Test 100%
- Application Notifier: Integration Test 주요 시나리오
- Presentation: Widget Test + Acceptance Test

---

## 2. Architecture Diagram

```mermaid
graph TD
    %% Presentation Layer
    RecordListScreen[RecordListScreen<br/>체중/증상/투여 기록 목록]
    RecordDetailSheet[RecordDetailSheet<br/>기록 상세 바텀시트]
    WeightEditDialog[WeightEditDialog]
    SymptomEditDialog[SymptomEditDialog]
    DoseEditDialog[DoseEditDialog]
    RecordDeleteDialog[RecordDeleteDialog]

    %% Application Layer
    WeightRecordEditNotifier[WeightRecordEditNotifier<br/>AsyncNotifierProvider]
    SymptomRecordEditNotifier[SymptomRecordEditNotifier<br/>AsyncNotifierProvider]
    DoseRecordEditNotifier[DoseRecordEditNotifier<br/>AsyncNotifierProvider]
    RecalculateStatisticsNotifier[RecalculateStatisticsNotifier<br/>AsyncNotifierProvider]

    %% Domain Layer
    ValidateWeightEditUseCase[ValidateWeightEditUseCase]
    ValidateSymptomEditUseCase[ValidateSymptomEditUseCase]
    ValidateDateUniqueConstraintUseCase[ValidateDateUniqueConstraintUseCase]
    RecalculateDashboardStatisticsUseCase[RecalculateDashboardStatisticsUseCase]
    RecalculateContinuousRecordDaysUseCase[RecalculateContinuousRecordDaysUseCase]
    RecalculateBadgeProgressUseCase[RecalculateBadgeProgressUseCase]
    LogRecordChangeUseCase[LogRecordChangeUseCase]

    %% Domain Layer - Repository Interfaces
    TrackingRepository[TrackingRepository<br/>Interface]
    MedicationRepository[MedicationRepository<br/>Interface]
    DashboardRepository[DashboardRepository<br/>Interface]
    BadgeRepository[BadgeRepository<br/>Interface]
    AuditRepository[AuditRepository<br/>Interface]

    %% Dependencies
    RecordListScreen --> RecordDetailSheet
    RecordDetailSheet --> WeightEditDialog
    RecordDetailSheet --> SymptomEditDialog
    RecordDetailSheet --> DoseEditDialog
    RecordDetailSheet --> RecordDeleteDialog

    WeightEditDialog --> WeightRecordEditNotifier
    SymptomEditDialog --> SymptomRecordEditNotifier
    DoseEditDialog --> DoseRecordEditNotifier
    RecordDeleteDialog --> WeightRecordEditNotifier
    RecordDeleteDialog --> SymptomRecordEditNotifier
    RecordDeleteDialog --> DoseRecordEditNotifier

    WeightRecordEditNotifier --> TrackingRepository
    WeightRecordEditNotifier --> ValidateWeightEditUseCase
    WeightRecordEditNotifier --> ValidateDateUniqueConstraintUseCase
    WeightRecordEditNotifier --> RecalculateStatisticsNotifier

    SymptomRecordEditNotifier --> TrackingRepository
    SymptomRecordEditNotifier --> ValidateSymptomEditUseCase
    SymptomRecordEditNotifier --> RecalculateStatisticsNotifier

    DoseRecordEditNotifier --> MedicationRepository
    DoseRecordEditNotifier --> RecalculateStatisticsNotifier

    RecalculateStatisticsNotifier --> RecalculateDashboardStatisticsUseCase
    RecalculateStatisticsNotifier --> RecalculateContinuousRecordDaysUseCase
    RecalculateStatisticsNotifier --> RecalculateBadgeProgressUseCase
    RecalculateStatisticsNotifier --> DashboardRepository
    RecalculateStatisticsNotifier --> BadgeRepository

    ValidateDateUniqueConstraintUseCase --> TrackingRepository

    WeightRecordEditNotifier --> LogRecordChangeUseCase
    SymptomRecordEditNotifier --> LogRecordChangeUseCase
    DoseRecordEditNotifier --> LogRecordChangeUseCase

    LogRecordChangeUseCase --> AuditRepository
```

---

## 3. Domain Layer - Repository Interfaces

**Location**: `lib/features/{feature}/domain/repositories/`

**Purpose**: Repository 인터페이스 정의 (Domain Layer에 위치, Infrastructure Layer에서 구현)

### TrackingRepository Interface
```dart
abstract class TrackingRepository {
  // 체중 기록
  Future<WeightLog?> getWeightLog(String id);
  Future<WeightLog?> getWeightLogByDate(String userId, DateTime date);
  Future<List<WeightLog>> getWeightLogs(String userId);
  Future<void> updateWeightLog(String id, double weightKg);
  Future<void> deleteWeightLog(String id);

  // 증상 기록 (연쇄 삭제 명시)
  Future<SymptomLog?> getSymptomLog(String id);
  Future<List<SymptomLog>> getSymptomLogs(String userId);
  Future<void> updateSymptomLog(String id, SymptomLog updatedLog);
  /// 증상 기록 삭제 시 연관된 컨텍스트 태그, 피드백도 함께 삭제
  Future<void> deleteSymptomLog(String id, {bool cascade = true});
}
```

### MedicationRepository Interface
```dart
abstract class MedicationRepository {
  Future<DoseRecord?> getDoseRecord(String id);
  Future<List<DoseRecord>> getDoseRecords(DosagePlanQuery query);
  Future<void> updateDoseRecord(String id, double doseMg, String injectionSite, String? note);
  Future<void> deleteDoseRecord(String id);
}
```

### DashboardRepository Interface
```dart
abstract class DashboardRepository {
  Future<DashboardData> getDashboardData(String userId);
  Future<void> updateWeeklyProgress(String userId, WeeklyProgress progress);
  Future<void> updateContinuousRecordDays(String userId, int days);
  Future<void> updateWeeklySummary(String userId, WeeklySummary summary);
}
```

### BadgeRepository Interface
```dart
abstract class BadgeRepository {
  Future<List<UserBadge>> getUserBadges(String userId);
  Future<UserBadge?> getUserBadge(String userId, String badgeId);
  Future<void> updateBadgeProgress(String userId, String badgeId, int percentage);
  Future<void> achieveBadge(String userId, String badgeId);
}
```

### AuditRepository Interface
```dart
abstract class AuditRepository {
  Future<void> logChange(AuditLog log);
  Future<List<AuditLog>> getChangeLogs(String userId, String recordId);
}
```

---

## 4. Implementation Plan

### 4.1 Domain Layer - Validation UseCases

**Location**: `lib/features/tracking/domain/usecases/`

**Responsibility**: 기록 수정/삭제 시 비즈니스 규칙 검증

**Test Strategy**: Unit Test (AAA Pattern)

**Test Scenarios (Red Phase):**

#### ValidateWeightEditUseCase
```dart
group('ValidateWeightEditUseCase', () {
  late ValidateWeightEditUseCase useCase;

  setUp(() {
    useCase = ValidateWeightEditUseCase();
  });

  // Arrange & Act & Assert
  test('should return success for valid weight in range 20-300kg', () {
    // Arrange
    final weight = 70.5;

    // Act
    final result = useCase.execute(weight);

    // Assert
    expect(result.isSuccess, true);
  });

  test('should return error for weight below 20kg', () {
    final result = useCase.execute(19.9);
    expect(result.isFailure, true);
    expect(result.error, contains('20kg'));
  });

  test('should return error for weight above 300kg', () {
    final result = useCase.execute(300.1);
    expect(result.isFailure, true);
    expect(result.error, contains('300kg'));
  });

  test('should return error for negative weight', () {
    final result = useCase.execute(-5.0);
    expect(result.isFailure, true);
  });

  test('should return error for zero weight', () {
    final result = useCase.execute(0.0);
    expect(result.isFailure, true);
  });

  test('should return warning for weight < 30kg but >= 20kg', () {
    final result = useCase.execute(25.0);
    expect(result.isSuccess, true);
    expect(result.warning, isNotNull);
  });

  test('should return warning for weight > 200kg but <= 300kg', () {
    final result = useCase.execute(250.0);
    expect(result.isSuccess, true);
    expect(result.warning, isNotNull);
  });
});
```

#### ValidateSymptomEditUseCase
```dart
group('ValidateSymptomEditUseCase', () {
  late ValidateSymptomEditUseCase useCase;

  setUp(() {
    useCase = ValidateSymptomEditUseCase();
  });

  test('should return success for severity in range 1-10', () {
    final result = useCase.execute(severity: 5, symptomName: '메스꺼움');
    expect(result.isSuccess, true);
  });

  test('should return error for severity below 1', () {
    final result = useCase.execute(severity: 0, symptomName: '메스꺼움');
    expect(result.isFailure, true);
  });

  test('should return error for severity above 10', () {
    final result = useCase.execute(severity: 11, symptomName: '메스꺼움');
    expect(result.isFailure, true);
  });

  test('should return error for empty symptom name', () {
    final result = useCase.execute(severity: 5, symptomName: '');
    expect(result.isFailure, true);
  });

  test('should validate symptom name from predefined list', () {
    final validSymptoms = ['메스꺼움', '구토', '변비', '설사', '복통', '두통', '피로'];
    for (var symptom in validSymptoms) {
      final result = useCase.execute(severity: 5, symptomName: symptom);
      expect(result.isSuccess, true);
    }
  });

  test('should allow custom symptom names (not in predefined list)', () {
    final result = useCase.execute(severity: 5, symptomName: '커스텀증상');
    expect(result.isSuccess, true);
  });
});
```

#### ValidateDateUniqueConstraintUseCase
```dart
group('ValidateDateUniqueConstraintUseCase', () {
  late ValidateDateUniqueConstraintUseCase useCase;
  late MockTrackingRepository mockRepository;

  setUp(() {
    mockRepository = MockTrackingRepository();
    useCase = ValidateDateUniqueConstraintUseCase(mockRepository);
  });

  test('should return success when date is available for new weight log', () async {
    // Arrange
    final date = DateTime(2025, 1, 1);
    final userId = 'user123';
    when(() => mockRepository.getWeightLogByDate(userId, date))
        .thenAnswer((_) async => null);

    // Act
    final result = await useCase.execute(userId: userId, date: date);

    // Assert
    expect(result.isSuccess, true);
  });

  test('should return conflict when date already has weight log', () async {
    final date = DateTime(2025, 1, 1);
    final userId = 'user123';
    final existingLog = WeightLog(
      id: 'log1',
      userId: userId,
      logDate: date,
      weightKg: 70.0,
      createdAt: DateTime.now(),
    );
    when(() => mockRepository.getWeightLogByDate(userId, date))
        .thenAnswer((_) async => existingLog);

    final result = await useCase.execute(userId: userId, date: date);

    expect(result.isConflict, true);
    expect(result.existingRecordId, 'log1');
  });

  test('should allow same date when editing existing record', () async {
    final date = DateTime(2025, 1, 1);
    final userId = 'user123';
    final recordId = 'log1';
    final existingLog = WeightLog(
      id: recordId,
      userId: userId,
      logDate: date,
      weightKg: 70.0,
      createdAt: DateTime.now(),
    );
    when(() => mockRepository.getWeightLogByDate(userId, date))
        .thenAnswer((_) async => existingLog);

    final result = await useCase.execute(
      userId: userId,
      date: date,
      editingRecordId: recordId,
    );

    expect(result.isSuccess, true);
  });

  test('should return error for future date', () async {
    final futureDate = DateTime.now().add(Duration(days: 1));
    final result = await useCase.execute(
      userId: 'user123',
      date: futureDate,
    );

    expect(result.isFailure, true);
    expect(result.error, contains('미래 날짜'));
  });
});
```

#### LogRecordChangeUseCase (감사 추적)
```dart
group('LogRecordChangeUseCase', () {
  late LogRecordChangeUseCase useCase;
  late MockAuditRepository mockAuditRepo;

  setUp(() {
    mockAuditRepo = MockAuditRepository();
    useCase = LogRecordChangeUseCase(mockAuditRepo);
  });

  test('should log weight record update', () async {
    final auditLog = AuditLog(
      id: 'audit1',
      userId: 'user123',
      recordId: 'log1',
      recordType: 'weight',
      changeType: 'update',
      oldValue: {'weightKg': 70.0},
      newValue: {'weightKg': 68.5},
      timestamp: DateTime.now(),
    );

    when(() => mockAuditRepo.logChange(auditLog))
        .thenAnswer((_) async => {});

    await useCase.execute(auditLog);

    verify(() => mockAuditRepo.logChange(auditLog)).called(1);
  });

  test('should log record deletion', () async {
    final auditLog = AuditLog(
      id: 'audit2',
      userId: 'user123',
      recordId: 'log1',
      recordType: 'weight',
      changeType: 'delete',
      oldValue: {'weightKg': 70.0, 'logDate': '2025-01-01'},
      newValue: null,
      timestamp: DateTime.now(),
    );

    await useCase.execute(auditLog);

    verify(() => mockAuditRepo.logChange(auditLog)).called(1);
  });
});
```

**Implementation Order (TDD):**
1. ValidateWeightEditUseCase
2. ValidateSymptomEditUseCase
3. ValidateDateUniqueConstraintUseCase
4. LogRecordChangeUseCase

**Dependencies**: Repository Interface (Domain)

---

### 4.2 Domain Layer - Statistics Recalculation UseCases

**Location**: `lib/features/dashboard/domain/usecases/`

**Responsibility**: 기록 변경 시 영향받는 통계 재계산

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase):**

#### RecalculateDashboardStatisticsUseCase
```dart
group('RecalculateDashboardStatisticsUseCase', () {
  late RecalculateDashboardStatisticsUseCase useCase;
  late MockTrackingRepository mockTrackingRepo;
  late MockMedicationRepository mockMedicationRepo;
  late MockProfileRepository mockProfileRepo;

  setUp(() {
    mockTrackingRepo = MockTrackingRepository();
    mockMedicationRepo = MockMedicationRepository();
    mockProfileRepo = MockProfileRepository();
    useCase = RecalculateDashboardStatisticsUseCase(
      trackingRepository: mockTrackingRepo,
      medicationRepository: mockMedicationRepo,
      profileRepository: mockProfileRepo,
    );
  });

  test('should recalculate weekly progress after weight log change', () async {
    // Arrange
    final userId = 'user123';
    final weights = [
      WeightLog(id: '1', userId: userId, logDate: DateTime.now(), weightKg: 70.0, createdAt: DateTime.now()),
      WeightLog(id: '2', userId: userId, logDate: DateTime.now().subtract(Duration(days: 1)), weightKg: 71.0, createdAt: DateTime.now()),
    ];
    when(() => mockTrackingRepo.getWeightLogs(userId))
        .thenAnswer((_) async => weights);
    when(() => mockProfileRepo.getUserProfile(userId))
        .thenAnswer((_) async => UserProfile(
          userId: userId,
          targetWeightKg: 65.0,
          weeklyWeightRecordGoal: 7,
          weeklySymptomRecordGoal: 7,
        ));

    // Act
    final result = await useCase.execute(userId);

    // Assert
    expect(result.weeklyProgress.weightRecordCount, 2);
    expect(result.weeklyProgress.weightTargetCount, 7);
  });

  test('should recalculate continuous record days after deletion', () async {
    final userId = 'user123';
    final weights = [
      WeightLog(id: '1', userId: userId, logDate: DateTime.now(), weightKg: 70.0, createdAt: DateTime.now()),
      // Gap exists (yesterday missing)
      WeightLog(id: '2', userId: userId, logDate: DateTime.now().subtract(Duration(days: 2)), weightKg: 71.0, createdAt: DateTime.now()),
    ];
    when(() => mockTrackingRepo.getWeightLogs(userId))
        .thenAnswer((_) async => weights);
    when(() => mockTrackingRepo.getSymptomLogs(userId))
        .thenAnswer((_) async => []);

    final result = await useCase.execute(userId);

    expect(result.continuousRecordDays, 1); // Gap caused by deletion
  });

  test('should handle empty records after deletion', () async {
    final userId = 'user123';
    when(() => mockTrackingRepo.getWeightLogs(userId))
        .thenAnswer((_) async => []);
    when(() => mockTrackingRepo.getSymptomLogs(userId))
        .thenAnswer((_) async => []);
    when(() => mockMedicationRepo.getDoseRecords(any()))
        .thenAnswer((_) async => []);

    final result = await useCase.execute(userId);

    expect(result.continuousRecordDays, 0);
    expect(result.weeklyProgress.weightRecordCount, 0);
  });
});
```

#### RecalculateBadgeProgressUseCase
```dart
group('RecalculateBadgeProgressUseCase', () {
  late RecalculateBadgeProgressUseCase useCase;
  late MockBadgeRepository mockBadgeRepo;
  late MockTrackingRepository mockTrackingRepo;

  setUp(() {
    mockBadgeRepo = MockBadgeRepository();
    mockTrackingRepo = MockTrackingRepository();
    useCase = RecalculateBadgeProgressUseCase(
      badgeRepository: mockBadgeRepo,
      trackingRepository: mockTrackingRepo,
    );
  });

  test('should update "연속 7일 기록" badge progress after edit', () async {
    final userId = 'user123';
    final continuousDays = 5;
    final badge = UserBadge(
      id: 'badge1',
      userId: userId,
      badgeId: 'streak_7',
      status: 'in_progress',
      progressPercentage: 50,
      achievedAt: null,
    );
    when(() => mockBadgeRepo.getUserBadge(userId, 'streak_7'))
        .thenAnswer((_) async => badge);

    final result = await useCase.execute(
      userId: userId,
      badgeId: 'streak_7',
      currentValue: continuousDays,
      targetValue: 7,
    );

    expect(result.progressPercentage, 71); // 5/7 = 71%
    expect(result.status, 'in_progress');
    verify(() => mockBadgeRepo.updateBadgeProgress(userId, 'streak_7', 71)).called(1);
  });

  test('should mark badge as achieved when condition met', () async {
    final userId = 'user123';
    final continuousDays = 7;

    final result = await useCase.execute(
      userId: userId,
      badgeId: 'streak_7',
      currentValue: continuousDays,
      targetValue: 7,
    );

    expect(result.progressPercentage, 100);
    expect(result.status, 'achieved');
    verify(() => mockBadgeRepo.achieveBadge(userId, 'streak_7')).called(1);
  });

  test('should downgrade achieved badge if condition no longer met after deletion', () async {
    final userId = 'user123';
    final badge = UserBadge(
      id: 'badge1',
      userId: userId,
      badgeId: 'streak_7',
      status: 'achieved',
      progressPercentage: 100,
      achievedAt: DateTime.now(),
    );
    when(() => mockBadgeRepo.getUserBadge(userId, 'streak_7'))
        .thenAnswer((_) async => badge);

    final result = await useCase.execute(
      userId: userId,
      badgeId: 'streak_7',
      currentValue: 5, // Dropped to 5 after deletion
      targetValue: 7,
    );

    expect(result.status, 'in_progress');
    expect(result.progressPercentage, 71);
    expect(result.achievedAt, null);
  });
});
```

**Implementation Order:**
1. RecalculateDashboardStatisticsUseCase
2. RecalculateBadgeProgressUseCase

**Dependencies**: Repository Interfaces, Dashboard Entities

---

### 4.3 Application Layer - Record Edit Notifiers

**Location**: `lib/features/tracking/application/notifiers/`

**Responsibility**: 기록 수정/삭제 상태 관리 및 검증 오케스트레이션

**Test Strategy**: Integration Test (Mock Repository)

**Test Scenarios (Red Phase):**

#### WeightRecordEditNotifier
```dart
group('WeightRecordEditNotifier', () {
  late MockTrackingRepository mockRepository;
  late MockValidateWeightEditUseCase mockValidateUseCase;
  late MockValidateDateUniqueConstraintUseCase mockDateValidateUseCase;
  late MockRecalculateStatisticsNotifier mockRecalculateNotifier;
  late ProviderContainer container;

  setUp(() {
    mockRepository = MockTrackingRepository();
    mockValidateUseCase = MockValidateWeightEditUseCase();
    mockDateValidateUseCase = MockValidateDateUniqueConstraintUseCase();
    mockRecalculateNotifier = MockRecalculateStatisticsNotifier();

    container = ProviderContainer(
      overrides: [
        trackingRepositoryProvider.overrideWithValue(mockRepository),
        validateWeightEditUseCaseProvider.overrideWithValue(mockValidateUseCase),
        validateDateUniqueConstraintUseCaseProvider.overrideWithValue(mockDateValidateUseCase),
        recalculateStatisticsNotifierProvider.overrideWithValue(mockRecalculateNotifier),
      ],
    );
  });

  tearDown(() {
    container.dispose();
  });

  test('should update weight log successfully with audit logging', () async {
    // Arrange
    final recordId = 'log1';
    final newWeight = 68.5;
    final userId = 'user123';
    final originalLog = WeightLog(
      id: recordId,
      userId: userId,
      logDate: DateTime.now(),
      weightKg: 70.0,
      createdAt: DateTime.now(),
    );
    when(() => mockRepository.getWeightLog(recordId))
        .thenAnswer((_) async => originalLog);
    when(() => mockValidateUseCase.execute(newWeight))
        .thenReturn(ValidationResult.success());
    when(() => mockRepository.updateWeightLog(recordId, newWeight))
        .thenAnswer((_) async => {});
    when(() => mockRecalculateNotifier.recalculate(userId))
        .thenAnswer((_) async => {});
    when(() => mockLogRecordChangeUseCase.execute(any()))
        .thenAnswer((_) async => {});

    // Act
    final notifier = container.read(weightRecordEditNotifierProvider.notifier);
    await notifier.updateWeight(recordId: recordId, newWeight: newWeight, userId: userId);

    // Assert
    final state = container.read(weightRecordEditNotifierProvider);
    expect(state.hasValue, true);
    verify(() => mockRepository.updateWeightLog(recordId, newWeight)).called(1);
    verify(() => mockRecalculateNotifier.recalculate(userId)).called(1);
    verify(() => mockLogRecordChangeUseCase.execute(any())).called(1);
  });

  test('should emit error when validation fails', () async {
    final recordId = 'log1';
    final invalidWeight = 500.0; // Above 300kg
    when(() => mockValidateUseCase.execute(invalidWeight))
        .thenReturn(ValidationResult.error('체중은 300kg 이하여야 합니다'));

    final notifier = container.read(weightRecordEditNotifierProvider.notifier);
    await notifier.updateWeight(recordId: recordId, newWeight: invalidWeight, userId: 'user123');

    final state = container.read(weightRecordEditNotifierProvider);
    expect(state.hasError, true);
    expect(state.error.toString(), contains('300kg'));
    verifyNever(() => mockRepository.updateWeightLog(any(), any()));
  });

  test('should emit warning but allow update for borderline weight', () async {
    final recordId = 'log1';
    final borderlineWeight = 25.0; // < 30kg but >= 20kg
    final userId = 'user123';
    when(() => mockValidateUseCase.execute(borderlineWeight))
        .thenReturn(ValidationResult.success(warning: '비정상적으로 낮은 체중입니다'));
    when(() => mockRepository.updateWeightLog(recordId, borderlineWeight))
        .thenAnswer((_) async => {});

    final notifier = container.read(weightRecordEditNotifierProvider.notifier);
    final result = await notifier.updateWeight(
      recordId: recordId,
      newWeight: borderlineWeight,
      userId: userId,
    );

    expect(result.warning, isNotNull);
    verify(() => mockRepository.updateWeightLog(recordId, borderlineWeight)).called(1);
  });

  test('should delete weight log and recalculate statistics', () async {
    final recordId = 'log1';
    final userId = 'user123';
    when(() => mockRepository.deleteWeightLog(recordId))
        .thenAnswer((_) async => {});
    when(() => mockRecalculateNotifier.recalculate(userId))
        .thenAnswer((_) async => {});

    final notifier = container.read(weightRecordEditNotifierProvider.notifier);
    await notifier.deleteWeight(recordId: recordId, userId: userId);

    verify(() => mockRepository.deleteWeightLog(recordId)).called(1);
    verify(() => mockRecalculateNotifier.recalculate(userId)).called(1);
  });

  test('should handle date conflict with overwrite option', () async {
    final existingRecordId = 'log1';
    final newDate = DateTime(2025, 1, 1);
    final newWeight = 70.0;
    final userId = 'user123';

    when(() => mockDateValidateUseCase.execute(
      userId: userId,
      date: newDate,
      editingRecordId: existingRecordId,
    )).thenAnswer((_) async => ValidationResult.conflict(
      existingRecordId: existingRecordId,
    ));
    when(() => mockRepository.updateWeightLog(existingRecordId, newWeight))
        .thenAnswer((_) async => {});

    final notifier = container.read(weightRecordEditNotifierProvider.notifier);
    final result = await notifier.updateWeight(
      recordId: existingRecordId,
      newWeight: newWeight,
      userId: userId,
      allowOverwrite: true,
    );

    expect(result.isSuccess, true);
    verify(() => mockRepository.updateWeightLog(existingRecordId, newWeight)).called(1);
  });

  test('should rollback on recalculation failure and restore original state', () async {
    final recordId = 'log1';
    final newWeight = 68.5;
    final userId = 'user123';
    final originalLog = WeightLog(
      id: recordId,
      userId: userId,
      logDate: DateTime.now(),
      weightKg: 70.0,
      createdAt: DateTime.now(),
    );

    when(() => mockRepository.getWeightLog(recordId))
        .thenAnswer((_) async => originalLog);
    when(() => mockValidateUseCase.execute(newWeight))
        .thenReturn(ValidationResult.success());
    when(() => mockRepository.updateWeightLog(recordId, any()))
        .thenAnswer((_) async => {});
    when(() => mockRecalculateNotifier.recalculate(userId))
        .thenThrow(Exception('Recalculation failed'));

    final notifier = container.read(weightRecordEditNotifierProvider.notifier);
    await notifier.updateWeight(recordId: recordId, newWeight: newWeight, userId: userId);

    final state = container.read(weightRecordEditNotifierProvider);
    expect(state.hasError, true);

    // Should update twice: once with new weight, once rollback to original
    verifyInOrder([
      () => mockRepository.updateWeightLog(recordId, newWeight),
      () => mockRepository.updateWeightLog(recordId, originalLog.weightKg),
    ]);
  });

  test('should handle repository update failure without rollback', () async {
    final recordId = 'log1';
    final newWeight = 68.5;
    final userId = 'user123';

    when(() => mockRepository.getWeightLog(recordId))
        .thenAnswer((_) async => WeightLog(
          id: recordId,
          userId: userId,
          logDate: DateTime.now(),
          weightKg: 70.0,
          createdAt: DateTime.now(),
        ));
    when(() => mockValidateUseCase.execute(newWeight))
        .thenReturn(ValidationResult.success());
    when(() => mockRepository.updateWeightLog(recordId, newWeight))
        .thenThrow(Exception('Database error'));

    final notifier = container.read(weightRecordEditNotifierProvider.notifier);
    await notifier.updateWeight(recordId: recordId, newWeight: newWeight, userId: userId);

    final state = container.read(weightRecordEditNotifierProvider);
    expect(state.hasError, true);

    // Repository update failed, so recalculation should not be called
    verifyNever(() => mockRecalculateNotifier.recalculate(any()));
  });
});
```

#### SymptomRecordEditNotifier
```dart
group('SymptomRecordEditNotifier', () {
  late MockTrackingRepository mockRepository;
  late MockValidateSymptomEditUseCase mockValidateUseCase;
  late MockRecalculateStatisticsNotifier mockRecalculateNotifier;
  late ProviderContainer container;

  setUp(() {
    mockRepository = MockTrackingRepository();
    mockValidateUseCase = MockValidateSymptomEditUseCase();
    mockRecalculateNotifier = MockRecalculateStatisticsNotifier();

    container = ProviderContainer(
      overrides: [
        trackingRepositoryProvider.overrideWithValue(mockRepository),
        validateSymptomEditUseCaseProvider.overrideWithValue(mockValidateUseCase),
        recalculateStatisticsNotifierProvider.overrideWithValue(mockRecalculateNotifier),
      ],
    );
  });

  tearDown(() {
    container.dispose();
  });

  test('should update symptom log successfully', () async {
    final recordId = 'symptom1';
    final updatedLog = SymptomLog(
      id: recordId,
      userId: 'user123',
      logDate: DateTime.now(),
      symptomName: '메스꺼움',
      severity: 7,
      tags: ['기름진음식'],
      note: '저녁 식사 후 발생',
    );
    when(() => mockValidateUseCase.execute(
      severity: updatedLog.severity,
      symptomName: updatedLog.symptomName,
    )).thenReturn(ValidationResult.success());
    when(() => mockRepository.updateSymptomLog(recordId, updatedLog))
        .thenAnswer((_) async => {});
    when(() => mockRecalculateNotifier.recalculate(updatedLog.userId))
        .thenAnswer((_) async => {});

    final notifier = container.read(symptomRecordEditNotifierProvider.notifier);
    await notifier.updateSymptom(recordId: recordId, updatedLog: updatedLog);

    verify(() => mockRepository.updateSymptomLog(recordId, updatedLog)).called(1);
    verify(() => mockRecalculateNotifier.recalculate(updatedLog.userId)).called(1);
  });

  test('should emit error for invalid severity', () async {
    final recordId = 'symptom1';
    final invalidLog = SymptomLog(
      id: recordId,
      userId: 'user123',
      logDate: DateTime.now(),
      symptomName: '메스꺼움',
      severity: 15, // Above 10
      tags: [],
    );
    when(() => mockValidateUseCase.execute(
      severity: invalidLog.severity,
      symptomName: invalidLog.symptomName,
    )).thenReturn(ValidationResult.error('심각도는 1-10 사이여야 합니다'));

    final notifier = container.read(symptomRecordEditNotifierProvider.notifier);
    await notifier.updateSymptom(recordId: recordId, updatedLog: invalidLog);

    final state = container.read(symptomRecordEditNotifierProvider);
    expect(state.hasError, true);
    verifyNever(() => mockRepository.updateSymptomLog(any(), any()));
  });

  test('should cascade delete symptom log including tags and feedback', () async {
    final recordId = 'symptom1';
    final userId = 'user123';
    when(() => mockRepository.deleteSymptomLog(recordId, cascade: true))
        .thenAnswer((_) async => {});
    when(() => mockRecalculateNotifier.recalculate(userId))
        .thenAnswer((_) async => {});

    final notifier = container.read(symptomRecordEditNotifierProvider.notifier);
    await notifier.deleteSymptom(recordId: recordId, userId: userId);

    // Verify cascade delete with tags and feedback
    verify(() => mockRepository.deleteSymptomLog(recordId, cascade: true)).called(1);
    verify(() => mockRecalculateNotifier.recalculate(userId)).called(1);
  });
});
```

#### DoseRecordEditNotifier
```dart
group('DoseRecordEditNotifier', () {
  late MockMedicationRepository mockRepository;
  late MockRecalculateStatisticsNotifier mockRecalculateNotifier;
  late MockLogRecordChangeUseCase mockLogRecordChangeUseCase;
  late ProviderContainer container;

  setUp(() {
    mockRepository = MockMedicationRepository();
    mockRecalculateNotifier = MockRecalculateStatisticsNotifier();
    mockLogRecordChangeUseCase = MockLogRecordChangeUseCase();

    container = ProviderContainer(
      overrides: [
        medicationRepositoryProvider.overrideWithValue(mockRepository),
        recalculateStatisticsNotifierProvider.overrideWithValue(mockRecalculateNotifier),
        logRecordChangeUseCaseProvider.overrideWithValue(mockLogRecordChangeUseCase),
      ],
    );
  });

  tearDown(() {
    container.dispose();
  });

  test('should update dose record successfully', () async {
    final recordId = 'dose1';
    final newDoseMg = 0.75;
    final newInjectionSite = '허벅지';
    final note = '투여 부위 변경';
    final userId = 'user123';

    when(() => mockRepository.updateDoseRecord(recordId, newDoseMg, newInjectionSite, note))
        .thenAnswer((_) async => {});
    when(() => mockRecalculateNotifier.recalculate(userId))
        .thenAnswer((_) async => {});
    when(() => mockLogRecordChangeUseCase.execute(any()))
        .thenAnswer((_) async => {});

    final notifier = container.read(doseRecordEditNotifierProvider.notifier);
    await notifier.updateDoseRecord(
      recordId: recordId,
      newDoseMg: newDoseMg,
      newInjectionSite: newInjectionSite,
      note: note,
      userId: userId,
    );

    verify(() => mockRepository.updateDoseRecord(recordId, newDoseMg, newInjectionSite, note)).called(1);
    verify(() => mockRecalculateNotifier.recalculate(userId)).called(1);
    verify(() => mockLogRecordChangeUseCase.execute(any())).called(1);
  });

  test('should validate dose amount is positive', () async {
    final recordId = 'dose1';
    final invalidDose = 0.0;
    final userId = 'user123';

    final notifier = container.read(doseRecordEditNotifierProvider.notifier);
    await notifier.updateDoseRecord(
      recordId: recordId,
      newDoseMg: invalidDose,
      newInjectionSite: '복부',
      userId: userId,
    );

    final state = container.read(doseRecordEditNotifierProvider);
    expect(state.hasError, true);
    expect(state.error.toString(), contains('투여량은 0보다 커야 합니다'));
    verifyNever(() => mockRepository.updateDoseRecord(any(), any(), any(), any()));
  });

  test('should delete dose record without affecting schedule', () async {
    final recordId = 'dose1';
    final userId = 'user123';
    when(() => mockRepository.deleteDoseRecord(recordId))
        .thenAnswer((_) async => {});
    when(() => mockRecalculateNotifier.recalculate(userId))
        .thenAnswer((_) async => {});
    when(() => mockLogRecordChangeUseCase.execute(any()))
        .thenAnswer((_) async => {});

    final notifier = container.read(doseRecordEditNotifierProvider.notifier);
    await notifier.deleteDoseRecord(recordId: recordId, userId: userId);

    verify(() => mockRepository.deleteDoseRecord(recordId)).called(1);
    // Schedule should NOT be affected
    verifyNever(() => mockRepository.updateDosagePlan(any()));
    verify(() => mockRecalculateNotifier.recalculate(userId)).called(1);
    verify(() => mockLogRecordChangeUseCase.execute(any())).called(1);
  });

  test('should handle repository failure gracefully', () async {
    final recordId = 'dose1';
    final userId = 'user123';
    when(() => mockRepository.deleteDoseRecord(recordId))
        .thenThrow(Exception('Database error'));

    final notifier = container.read(doseRecordEditNotifierProvider.notifier);
    await notifier.deleteDoseRecord(recordId: recordId, userId: userId);

    final state = container.read(doseRecordEditNotifierProvider);
    expect(state.hasError, true);
    verifyNever(() => mockRecalculateNotifier.recalculate(any()));
  });
});
```

**Implementation Order:**
1. WeightRecordEditNotifier (가장 복잡: 날짜 고유 제약 처리)
2. SymptomRecordEditNotifier
3. DoseRecordEditNotifier (가장 단순)

**Dependencies**: Repository Interfaces, Validation UseCases, RecalculateStatisticsNotifier

---

### 4.4 Application Layer - Statistics Recalculation Notifier

**Location**: `lib/features/dashboard/application/notifiers/recalculate_statistics_notifier.dart`

**Responsibility**: 기록 변경 시 모든 영향받는 통계 재계산 오케스트레이션

**Test Strategy**: Integration Test

**Test Scenarios (Red Phase):**

```dart
group('RecalculateStatisticsNotifier', () {
  late MockDashboardRepository mockDashboardRepo;
  late MockBadgeRepository mockBadgeRepo;
  late MockRecalculateDashboardStatisticsUseCase mockRecalcStatUseCase;
  late MockRecalculateBadgeProgressUseCase mockRecalcBadgeUseCase;
  late ProviderContainer container;

  setUp(() {
    mockDashboardRepo = MockDashboardRepository();
    mockBadgeRepo = MockBadgeRepository();
    mockRecalcStatUseCase = MockRecalculateDashboardStatisticsUseCase();
    mockRecalcBadgeUseCase = MockRecalculateBadgeProgressUseCase();

    container = ProviderContainer(
      overrides: [
        dashboardRepositoryProvider.overrideWithValue(mockDashboardRepo),
        badgeRepositoryProvider.overrideWithValue(mockBadgeRepo),
        recalculateDashboardStatisticsUseCaseProvider.overrideWithValue(mockRecalcStatUseCase),
        recalculateBadgeProgressUseCaseProvider.overrideWithValue(mockRecalcBadgeUseCase),
      ],
    );
  });

  tearDown(() {
    container.dispose();
  });

  test('should recalculate all statistics in correct order', () async {
    final userId = 'user123';
    final dashboardData = DashboardData(
      userName: 'Test User',
      continuousRecordDays: 5,
      currentWeek: 3,
      weeklyProgress: WeeklyProgress(/* ... */),
      nextSchedule: NextSchedule(/* ... */),
      weeklySummary: WeeklySummary(/* ... */),
      badges: [],
      timeline: [],
    );

    when(() => mockRecalcStatUseCase.execute(userId))
        .thenAnswer((_) async => dashboardData);
    when(() => mockBadgeRepo.getUserBadges(userId))
        .thenAnswer((_) async => []);
    when(() => mockRecalcBadgeUseCase.execute(
      userId: userId,
      badgeId: any(named: 'badgeId'),
      currentValue: any(named: 'currentValue'),
      targetValue: any(named: 'targetValue'),
    )).thenAnswer((_) async => UserBadge(/* ... */));

    final notifier = container.read(recalculateStatisticsNotifierProvider);
    await notifier.recalculate(userId);

    // Verify order: Dashboard stats first, then badges
    verifyInOrder([
      () => mockRecalcStatUseCase.execute(userId),
      () => mockBadgeRepo.getUserBadges(userId),
      // Badge recalculations...
    ]);
  });

  test('should invalidate DashboardNotifier after recalculation', () async {
    final userId = 'user123';
    when(() => mockRecalcStatUseCase.execute(userId))
        .thenAnswer((_) async => DashboardData(/* ... */));
    when(() => mockBadgeRepo.getUserBadges(userId))
        .thenAnswer((_) async => []);

    final notifier = container.read(recalculateStatisticsNotifierProvider);
    await notifier.recalculate(userId);

    // DashboardNotifier should be invalidated
    verify(() => container.invalidate(dashboardNotifierProvider)).called(1);
  });

  test('should detect new badge achievement and return notification', () async {
    final userId = 'user123';
    final badge = UserBadge(
      id: 'badge1',
      userId: userId,
      badgeId: 'streak_7',
      status: 'achieved',
      progressPercentage: 100,
      achievedAt: DateTime.now(),
    );
    when(() => mockRecalcStatUseCase.execute(userId))
        .thenAnswer((_) async => DashboardData(/* ... */));
    when(() => mockBadgeRepo.getUserBadges(userId))
        .thenAnswer((_) async => [badge]);

    final notifier = container.read(recalculateStatisticsNotifierProvider);
    final result = await notifier.recalculate(userId);

    expect(result.hasNewBadge, true);
    expect(result.newBadgeId, 'streak_7');
  });

  test('should handle partial failure gracefully', () async {
    final userId = 'user123';
    when(() => mockRecalcStatUseCase.execute(userId))
        .thenAnswer((_) async => DashboardData(/* ... */));
    when(() => mockBadgeRepo.getUserBadges(userId))
        .thenThrow(Exception('Badge fetch failed'));

    final notifier = container.read(recalculateStatisticsNotifierProvider);
    await notifier.recalculate(userId);

    // Should complete dashboard recalc despite badge failure
    verify(() => mockRecalcStatUseCase.execute(userId)).called(1);
  });
});
```

**Implementation Order:**
1. recalculate() method (main orchestration)
2. _invalidateDashboard() private method
3. _detectNewBadges() private method

**Dependencies**: Dashboard/Badge Repositories, Recalculation UseCases

---

### 4.5 Presentation Layer - Edit Dialogs

**Location**: `lib/features/tracking/presentation/widgets/`

**Responsibility**: 기록 수정 UI 제공

**Test Strategy**: Widget Test

**Test Scenarios (Red Phase):**

#### WeightEditDialog
```dart
group('WeightEditDialog', () {
  testWidgets('should display current weight value', (tester) async {
    final currentWeight = 70.5;
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: WeightEditDialog(currentWeight: currentWeight),
        ),
      ),
    );

    expect(find.text('70.5'), findsOneWidget);
  });

  testWidgets('should validate input in real-time', (tester) async {
    await tester.pumpWidget(MaterialApp(home: WeightEditDialog(currentWeight: 70.0)));

    final textField = find.byType(TextField);
    await tester.enterText(textField, '500');
    await tester.pump();

    expect(find.text('체중은 300kg 이하여야 합니다'), findsOneWidget);
  });

  testWidgets('should show warning for borderline weight', (tester) async {
    await tester.pumpWidget(MaterialApp(home: WeightEditDialog(currentWeight: 70.0)));

    final textField = find.byType(TextField);
    await tester.enterText(textField, '25');
    await tester.pump();

    expect(find.textContaining('비정상적으로 낮은'), findsOneWidget);
  });

  testWidgets('should disable save button for invalid input', (tester) async {
    await tester.pumpWidget(MaterialApp(home: WeightEditDialog(currentWeight: 70.0)));

    await tester.enterText(find.byType(TextField), '-5');
    await tester.pump();

    final saveButton = find.text('저장');
    expect(tester.widget<ElevatedButton>(saveButton).enabled, false);
  });

  testWidgets('should call onSave with new weight', (tester) async {
    double? savedWeight;
    await tester.pumpWidget(
      MaterialApp(
        home: WeightEditDialog(
          currentWeight: 70.0,
          onSave: (weight) => savedWeight = weight,
        ),
      ),
    );

    await tester.enterText(find.byType(TextField), '68.5');
    await tester.tap(find.text('저장'));
    await tester.pump();

    expect(savedWeight, 68.5);
  });

  testWidgets('should show loading indicator during save', (tester) async {
    await tester.pumpWidget(
      MaterialApp(
        home: WeightEditDialog(
          currentWeight: 70.0,
          onSave: (_) async => await Future.delayed(Duration(seconds: 1)),
        ),
      ),
    );

    await tester.enterText(find.byType(TextField), '68.5');
    await tester.tap(find.text('저장'));
    await tester.pump();

    expect(find.byType(CircularProgressIndicator), findsOneWidget);
  });

  testWidgets('should allow changing log date', (tester) async {
    await tester.pumpWidget(
      MaterialApp(
        home: WeightEditDialog(
          currentWeight: 70.0,
          currentDate: DateTime(2025, 1, 1),
        ),
      ),
    );

    // 날짜 선택 버튼 탭
    await tester.tap(find.byIcon(Icons.calendar_today));
    await tester.pumpAndSettle();

    // 새로운 날짜 선택
    await tester.tap(find.text('2'));
    await tester.tap(find.text('확인'));
    await tester.pumpAndSettle();

    expect(find.text('2025-01-02'), findsOneWidget);
  });

  testWidgets('should validate date uniqueness and show overwrite dialog', (tester) async {
    await tester.pumpWidget(
      MaterialApp(
        home: WeightEditDialog(
          currentWeight: 70.0,
          currentDate: DateTime(2025, 1, 1),
        ),
      ),
    );

    // 중복 날짜 선택
    await tester.tap(find.byIcon(Icons.calendar_today));
    await tester.pumpAndSettle();
    await tester.tap(find.text('3')); // 이미 기록이 있는 날짜
    await tester.tap(find.text('확인'));
    await tester.pumpAndSettle();

    // 덮어쓰기 확인 다이얼로그 표시
    expect(find.text('이미 기록이 존재합니다'), findsOneWidget);
    expect(find.text('덮어쓰기'), findsOneWidget);
    expect(find.text('취소'), findsOneWidget);
  });
});
```

#### SymptomEditDialog
```dart
group('SymptomEditDialog', () {
  testWidgets('should display current symptom data', (tester) async {
    final symptom = SymptomLog(
      id: '1',
      userId: 'user123',
      logDate: DateTime.now(),
      symptomName: '메스꺼움',
      severity: 7,
      tags: ['기름진음식', '과식'],
    );
    await tester.pumpWidget(MaterialApp(home: SymptomEditDialog(symptom: symptom)));

    expect(find.text('메스꺼움'), findsOneWidget);
    expect(find.text('7'), findsOneWidget);
    expect(find.text('기름진음식'), findsOneWidget);
    expect(find.text('과식'), findsOneWidget);
  });

  testWidgets('should allow changing symptom name', (tester) async {
    final symptom = SymptomLog(
      id: '1',
      userId: 'user123',
      logDate: DateTime.now(),
      symptomName: '메스꺼움',
      severity: 5,
    );
    await tester.pumpWidget(MaterialApp(home: SymptomEditDialog(symptom: symptom)));

    await tester.tap(find.text('메스꺼움'));
    await tester.pumpAndSettle();
    await tester.tap(find.text('구토'));
    await tester.pumpAndSettle();

    expect(find.text('구토'), findsOneWidget);
  });

  testWidgets('should allow adjusting severity with slider', (tester) async {
    final symptom = SymptomLog(
      id: '1',
      userId: 'user123',
      logDate: DateTime.now(),
      symptomName: '메스꺼움',
      severity: 5,
    );
    await tester.pumpWidget(MaterialApp(home: SymptomEditDialog(symptom: symptom)));

    final slider = find.byType(Slider);
    await tester.drag(slider, Offset(100, 0)); // Increase severity
    await tester.pump();

    // Severity should change
    expect(find.text('5'), findsNothing);
  });

  testWidgets('should allow adding/removing tags', (tester) async {
    final symptom = SymptomLog(
      id: '1',
      userId: 'user123',
      logDate: DateTime.now(),
      symptomName: '메스꺼움',
      severity: 5,
      tags: ['기름진음식'],
    );
    await tester.pumpWidget(MaterialApp(home: SymptomEditDialog(symptom: symptom)));

    // Remove existing tag
    await tester.tap(find.byIcon(Icons.close).first);
    await tester.pump();
    expect(find.text('기름진음식'), findsNothing);

    // Add new tag
    await tester.tap(find.text('과식'));
    await tester.pump();
    expect(find.text('과식'), findsOneWidget);
  });

  testWidgets('should validate severity range', (tester) async {
    final symptom = SymptomLog(
      id: '1',
      userId: 'user123',
      logDate: DateTime.now(),
      symptomName: '메스꺼움',
      severity: 5,
    );
    await tester.pumpWidget(MaterialApp(home: SymptomEditDialog(symptom: symptom)));

    // Slider should not allow values outside 1-10
    final slider = find.byType(Slider);
    final sliderWidget = tester.widget<Slider>(slider);
    expect(sliderWidget.min, 1);
    expect(sliderWidget.max, 10);
  });
});
```

#### RecordDeleteDialog
```dart
group('RecordDeleteDialog', () {
  testWidgets('should show confirmation message', (tester) async {
    await tester.pumpWidget(
      MaterialApp(
        home: RecordDeleteDialog(
          recordType: '체중 기록',
          recordInfo: '70.5kg (2025-01-01)',
        ),
      ),
    );

    expect(find.textContaining('체중 기록'), findsOneWidget);
    expect(find.textContaining('70.5kg'), findsOneWidget);
    expect(find.text('삭제'), findsOneWidget);
    expect(find.text('취소'), findsOneWidget);
  });

  testWidgets('should show permanent deletion warning', (tester) async {
    await tester.pumpWidget(
      MaterialApp(home: RecordDeleteDialog(recordType: '체중 기록', recordInfo: '70kg')),
    );

    expect(find.textContaining('영구적'), findsOneWidget);
    expect(find.textContaining('복구할 수 없습니다'), findsOneWidget);
  });

  testWidgets('should call onConfirm when delete tapped', (tester) async {
    bool confirmed = false;
    await tester.pumpWidget(
      MaterialApp(
        home: RecordDeleteDialog(
          recordType: '체중 기록',
          recordInfo: '70kg',
          onConfirm: () => confirmed = true,
        ),
      ),
    );

    await tester.tap(find.text('삭제'));
    await tester.pump();

    expect(confirmed, true);
  });

  testWidgets('should close dialog when cancel tapped', (tester) async {
    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: Builder(
            builder: (context) => ElevatedButton(
              onPressed: () {
                showDialog(
                  context: context,
                  builder: (_) => RecordDeleteDialog(
                    recordType: '체중 기록',
                    recordInfo: '70kg',
                  ),
                );
              },
              child: Text('Open'),
            ),
          ),
        ),
      ),
    );

    await tester.tap(find.text('Open'));
    await tester.pumpAndSettle();
    await tester.tap(find.text('취소'));
    await tester.pumpAndSettle();

    expect(find.byType(RecordDeleteDialog), findsNothing);
  });

  testWidgets('should emphasize delete button with destructive color', (tester) async {
    await tester.pumpWidget(
      MaterialApp(home: RecordDeleteDialog(recordType: '체중 기록', recordInfo: '70kg')),
    );

    final deleteButton = tester.widget<TextButton>(
      find.widgetWithText(TextButton, '삭제'),
    );
    expect(deleteButton.style?.foregroundColor?.resolve({}), Colors.red);
  });
});
```

#### DoseEditDialog
```dart
group('DoseEditDialog', () {
  testWidgets('should display current dose data', (tester) async {
    final record = DoseRecord(
      id: 'dose1',
      dosagePlanId: 'plan1',
      administeredAt: DateTime.now(),
      actualDoseMg: 0.5,
      injectionSite: '복부',
      isCompleted: true,
    );
    await tester.pumpWidget(MaterialApp(home: DoseEditDialog(record: record)));

    expect(find.text('0.5'), findsOneWidget);
    expect(find.text('복부'), findsOneWidget);
  });

  testWidgets('should allow changing dose amount', (tester) async {
    final record = DoseRecord(
      id: 'dose1',
      dosagePlanId: 'plan1',
      administeredAt: DateTime.now(),
      actualDoseMg: 0.5,
      injectionSite: '복부',
      isCompleted: true,
    );
    await tester.pumpWidget(MaterialApp(home: DoseEditDialog(record: record)));

    final textField = find.byType(TextField).first;
    await tester.enterText(textField, '0.75');
    await tester.pump();

    expect(find.text('0.75'), findsOneWidget);
  });

  testWidgets('should allow changing injection site', (tester) async {
    final record = DoseRecord(
      id: 'dose1',
      dosagePlanId: 'plan1',
      administeredAt: DateTime.now(),
      actualDoseMg: 0.5,
      injectionSite: '복부',
      isCompleted: true,
    );
    await tester.pumpWidget(MaterialApp(home: DoseEditDialog(record: record)));

    await tester.tap(find.text('복부'));
    await tester.pumpAndSettle();
    await tester.tap(find.text('허벅지'));
    await tester.pumpAndSettle();

    expect(find.text('허벅지'), findsOneWidget);
  });

  testWidgets('should validate dose is positive', (tester) async {
    final record = DoseRecord(
      id: 'dose1',
      dosagePlanId: 'plan1',
      administeredAt: DateTime.now(),
      actualDoseMg: 0.5,
      injectionSite: '복부',
      isCompleted: true,
    );
    await tester.pumpWidget(MaterialApp(home: DoseEditDialog(record: record)));

    await tester.enterText(find.byType(TextField).first, '0');
    await tester.pump();

    expect(find.text('투여량은 0보다 커야 합니다'), findsOneWidget);
  });

  testWidgets('should call onSave with updated data', (tester) async {
    double? savedDose;
    String? savedSite;
    final record = DoseRecord(
      id: 'dose1',
      dosagePlanId: 'plan1',
      administeredAt: DateTime.now(),
      actualDoseMg: 0.5,
      injectionSite: '복부',
      isCompleted: true,
    );

    await tester.pumpWidget(
      MaterialApp(
        home: DoseEditDialog(
          record: record,
          onSave: (dose, site, note) {
            savedDose = dose;
            savedSite = site;
          },
        ),
      ),
    );

    await tester.enterText(find.byType(TextField).first, '0.75');
    await tester.tap(find.text('복부'));
    await tester.pumpAndSettle();
    await tester.tap(find.text('허벅지'));
    await tester.pumpAndSettle();
    await tester.tap(find.text('저장'));
    await tester.pump();

    expect(savedDose, 0.75);
    expect(savedSite, '허벅지');
  });
});
```

**Implementation Order:**
1. WeightEditDialog (가장 복잡: 실시간 검증 + 경고 + 날짜 수정)
2. SymptomEditDialog (중간: 여러 필드 + 태그 관리)
3. DoseEditDialog (중간: 투여량 + 부위 수정)
4. RecordDeleteDialog (단순: 확인만)

**Dependencies**: Application Notifiers

---

### 4.6 Presentation Layer - Record Detail Sheet

**Location**: `lib/features/tracking/presentation/widgets/record_detail_sheet.dart`

**Responsibility**: 기록 상세 정보 표시 및 수정/삭제 진입점

**Test Strategy**: Widget Test

**Test Scenarios (Red Phase):**

```dart
group('RecordDetailSheet', () {
  testWidgets('should display weight record details', (tester) async {
    final weightLog = WeightLog(
      id: 'log1',
      userId: 'user123',
      logDate: DateTime(2025, 1, 1),
      weightKg: 70.5,
      createdAt: DateTime(2025, 1, 1, 9, 0),
    );
    await tester.pumpWidget(
      MaterialApp(home: RecordDetailSheet.weight(log: weightLog)),
    );

    expect(find.text('70.5 kg'), findsOneWidget);
    expect(find.text('2025-01-01'), findsOneWidget);
    expect(find.text('수정'), findsOneWidget);
    expect(find.text('삭제'), findsOneWidget);
  });

  testWidgets('should display symptom record details', (tester) async {
    final symptomLog = SymptomLog(
      id: 'symptom1',
      userId: 'user123',
      logDate: DateTime(2025, 1, 1),
      symptomName: '메스꺼움',
      severity: 7,
      tags: ['기름진음식', '과식'],
      note: '저녁 식사 후 발생',
    );
    await tester.pumpWidget(
      MaterialApp(home: RecordDetailSheet.symptom(log: symptomLog)),
    );

    expect(find.text('메스꺼움'), findsOneWidget);
    expect(find.text('심각도: 7/10'), findsOneWidget);
    expect(find.text('기름진음식'), findsOneWidget);
    expect(find.text('과식'), findsOneWidget);
    expect(find.text('저녁 식사 후 발생'), findsOneWidget);
  });

  testWidgets('should display dose record details', (tester) async {
    final doseRecord = DoseRecord(
      id: 'dose1',
      dosagePlanId: 'plan1',
      administeredAt: DateTime(2025, 1, 1, 10, 0),
      actualDoseMg: 0.5,
      injectionSite: '복부',
      isCompleted: true,
      note: '정상 투여',
    );
    await tester.pumpWidget(
      MaterialApp(home: RecordDetailSheet.dose(record: doseRecord)),
    );

    expect(find.text('0.5 mg'), findsOneWidget);
    expect(find.text('복부'), findsOneWidget);
    expect(find.text('정상 투여'), findsOneWidget);
  });

  testWidgets('should open edit dialog on edit tap', (tester) async {
    final weightLog = WeightLog(
      id: 'log1',
      userId: 'user123',
      logDate: DateTime.now(),
      weightKg: 70.0,
      createdAt: DateTime.now(),
    );
    await tester.pumpWidget(
      MaterialApp(home: RecordDetailSheet.weight(log: weightLog)),
    );

    await tester.tap(find.text('수정'));
    await tester.pumpAndSettle();

    expect(find.byType(WeightEditDialog), findsOneWidget);
  });

  testWidgets('should open delete dialog on delete tap', (tester) async {
    final weightLog = WeightLog(
      id: 'log1',
      userId: 'user123',
      logDate: DateTime.now(),
      weightKg: 70.0,
      createdAt: DateTime.now(),
    );
    await tester.pumpWidget(
      MaterialApp(home: RecordDetailSheet.weight(log: weightLog)),
    );

    await tester.tap(find.text('삭제'));
    await tester.pumpAndSettle();

    expect(find.byType(RecordDeleteDialog), findsOneWidget);
  });

  testWidgets('should close sheet after successful edit', (tester) async {
    final weightLog = WeightLog(
      id: 'log1',
      userId: 'user123',
      logDate: DateTime.now(),
      weightKg: 70.0,
      createdAt: DateTime.now(),
    );

    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: Builder(
            builder: (context) => ElevatedButton(
              onPressed: () {
                showModalBottomSheet(
                  context: context,
                  builder: (_) => RecordDetailSheet.weight(log: weightLog),
                );
              },
              child: Text('Open'),
            ),
          ),
        ),
      ),
    );

    await tester.tap(find.text('Open'));
    await tester.pumpAndSettle();

    // Simulate successful edit
    await tester.tap(find.text('수정'));
    await tester.pumpAndSettle();
    await tester.enterText(find.byType(TextField), '68.5');
    await tester.tap(find.text('저장'));
    await tester.pumpAndSettle();

    // Sheet should close
    expect(find.byType(RecordDetailSheet), findsNothing);
  });

  testWidgets('should show success snackbar after edit', (tester) async {
    final weightLog = WeightLog(
      id: 'log1',
      userId: 'user123',
      logDate: DateTime.now(),
      weightKg: 70.0,
      createdAt: DateTime.now(),
    );

    await tester.pumpWidget(
      MaterialApp(
        home: Scaffold(
          body: Builder(
            builder: (context) => ElevatedButton(
              onPressed: () {
                showModalBottomSheet(
                  context: context,
                  builder: (_) => RecordDetailSheet.weight(log: weightLog),
                );
              },
              child: Text('Open'),
            ),
          ),
        ),
      ),
    );

    await tester.tap(find.text('Open'));
    await tester.pumpAndSettle();
    await tester.tap(find.text('수정'));
    await tester.pumpAndSettle();
    await tester.enterText(find.byType(TextField), '68.5');
    await tester.tap(find.text('저장'));
    await tester.pumpAndSettle();

    expect(find.text('체중 기록이 수정되었습니다'), findsOneWidget);
  });

  testWidgets('should show new badge notification after recalculation', (tester) async {
    // Mock RecalculateStatisticsNotifier to return new badge
    final weightLog = WeightLog(
      id: 'log1',
      userId: 'user123',
      logDate: DateTime.now(),
      weightKg: 70.0,
      createdAt: DateTime.now(),
    );

    await tester.pumpWidget(
      MaterialApp(home: RecordDetailSheet.weight(log: weightLog)),
    );

    await tester.tap(find.text('수정'));
    await tester.pumpAndSettle();
    await tester.enterText(find.byType(TextField), '68.5');
    await tester.tap(find.text('저장'));
    await tester.pumpAndSettle();

    // Should show badge achievement notification
    expect(find.textContaining('뱃지'), findsOneWidget);
  });
});
```

**Implementation Order:**
1. RecordDetailSheet Layout
2. Edit/Delete Button Handlers
3. Success/Error Snackbar
4. Badge Achievement Notification

**Dependencies**: Edit Dialogs, Delete Dialog, Application Notifiers

---

### 4.7 Presentation Layer - Record List Screen Updates

**Location**: `lib/features/tracking/presentation/screens/record_list_screen.dart`

**Responsibility**: 기록 목록에서 상세 시트 열기

**Test Strategy**: Acceptance Test

**Test Scenarios (Red Phase):**

```dart
group('RecordListScreen Edit/Delete Flow', () {
  testWidgets('should open detail sheet on record tap', (tester) async {
    final weights = [
      WeightLog(id: '1', userId: 'user123', logDate: DateTime.now(), weightKg: 70.0, createdAt: DateTime.now()),
      WeightLog(id: '2', userId: 'user123', logDate: DateTime.now().subtract(Duration(days: 1)), weightKg: 71.0, createdAt: DateTime.now()),
    ];

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          trackingNotifierProvider.overrideWith(
            (ref) => FakeTrackingNotifier(weights: weights),
          ),
        ],
        child: MaterialApp(home: RecordListScreen()),
      ),
    );

    await tester.tap(find.text('70.0 kg'));
    await tester.pumpAndSettle();

    expect(find.byType(RecordDetailSheet), findsOneWidget);
  });

  testWidgets('should refresh list after successful edit', (tester) async {
    final weights = [
      WeightLog(id: '1', userId: 'user123', logDate: DateTime.now(), weightKg: 70.0, createdAt: DateTime.now()),
    ];

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          trackingNotifierProvider.overrideWith(
            (ref) => FakeTrackingNotifier(weights: weights),
          ),
        ],
        child: MaterialApp(home: RecordListScreen()),
      ),
    );

    await tester.tap(find.text('70.0 kg'));
    await tester.pumpAndSettle();
    await tester.tap(find.text('수정'));
    await tester.pumpAndSettle();
    await tester.enterText(find.byType(TextField), '68.5');
    await tester.tap(find.text('저장'));
    await tester.pumpAndSettle();

    // List should show updated value
    expect(find.text('68.5 kg'), findsOneWidget);
    expect(find.text('70.0 kg'), findsNothing);
  });

  testWidgets('should remove item from list after deletion', (tester) async {
    final weights = [
      WeightLog(id: '1', userId: 'user123', logDate: DateTime.now(), weightKg: 70.0, createdAt: DateTime.now()),
      WeightLog(id: '2', userId: 'user123', logDate: DateTime.now().subtract(Duration(days: 1)), weightKg: 71.0, createdAt: DateTime.now()),
    ];

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          trackingNotifierProvider.overrideWith(
            (ref) => FakeTrackingNotifier(weights: weights),
          ),
        ],
        child: MaterialApp(home: RecordListScreen()),
      ),
    );

    expect(find.text('70.0 kg'), findsOneWidget);

    await tester.tap(find.text('70.0 kg'));
    await tester.pumpAndSettle();
    await tester.tap(find.text('삭제'));
    await tester.pumpAndSettle();
    await tester.tap(find.text('삭제')); // Confirm
    await tester.pumpAndSettle();

    // Item should be removed
    expect(find.text('70.0 kg'), findsNothing);
    expect(find.text('71.0 kg'), findsOneWidget); // Other item remains
  });

  testWidgets('should show empty state after deleting all records', (tester) async {
    final weights = [
      WeightLog(id: '1', userId: 'user123', logDate: DateTime.now(), weightKg: 70.0, createdAt: DateTime.now()),
    ];

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          trackingNotifierProvider.overrideWith(
            (ref) => FakeTrackingNotifier(weights: weights),
          ),
        ],
        child: MaterialApp(home: RecordListScreen()),
      ),
    );

    await tester.tap(find.text('70.0 kg'));
    await tester.pumpAndSettle();
    await tester.tap(find.text('삭제'));
    await tester.pumpAndSettle();
    await tester.tap(find.text('삭제'));
    await tester.pumpAndSettle();

    expect(find.text('기록이 없습니다'), findsOneWidget);
  });

  testWidgets('should handle concurrent edit attempts gracefully', (tester) async {
    // Edge case: Multiple users editing same record
    final weights = [
      WeightLog(id: '1', userId: 'user123', logDate: DateTime.now(), weightKg: 70.0, createdAt: DateTime.now()),
    ];

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          trackingNotifierProvider.overrideWith(
            (ref) => FakeTrackingNotifier(weights: weights),
          ),
        ],
        child: MaterialApp(home: RecordListScreen()),
      ),
    );

    await tester.tap(find.text('70.0 kg'));
    await tester.pumpAndSettle();
    await tester.tap(find.text('수정'));
    await tester.pumpAndSettle();

    // Simulate concurrent update (record deleted by another client)
    // Should show error message
    await tester.enterText(find.byType(TextField), '68.5');
    await tester.tap(find.text('저장'));
    await tester.pumpAndSettle();

    expect(find.textContaining('이미 삭제되었거나'), findsOneWidget);
  });
});
```

**QA Sheet (Manual Testing):**
1. 기록 목록에서 항목 탭 시 상세 시트 열림 확인
2. 상세 시트에서 "수정" 버튼 탭 시 수정 다이얼로그 열림 확인
3. 수정 다이얼로그에서 값 변경 후 저장 시:
   - 성공 메시지 표시 확인
   - 시트 자동 닫힘 확인
   - 목록에 변경사항 즉시 반영 확인
4. 상세 시트에서 "삭제" 버튼 탭 시 확인 다이얼로그 열림 확인
5. 삭제 확인 시:
   - 기록 삭제 확인
   - 목록에서 항목 제거 확인
   - 성공 메시지 표시 확인
6. 홈 대시보드에서 통계 갱신 확인:
   - 연속 기록일 재계산 확인
   - 주간 목표 진행도 재계산 확인
   - 뱃지 진행도 업데이트 확인
7. 데이터 공유 모드에서 변경사항 반영 확인
8. 네트워크 오류 시 에러 처리 확인
9. 삭제 취소 버튼 동작 확인
10. 수정 중 뒤로가기 버튼 시 변경사항 폐기 확인

**Implementation Order:**
1. Detail Sheet Integration
2. List Refresh Logic
3. Success/Error Handling
4. Empty State Handling

**Dependencies**: RecordDetailSheet, Application Notifiers

---

## 5. TDD Workflow

### Phase 1: Domain Layer (Inside-Out)
1. **Start**: Validation UseCases 테스트 작성
   - ValidateWeightEditUseCase (Red → Green → Refactor)
   - ValidateSymptomEditUseCase (Red → Green → Refactor)
   - ValidateDateUniqueConstraintUseCase (Red → Green → Refactor)
   - LogRecordChangeUseCase (Red → Green → Refactor)
2. **Statistics Recalculation UseCases**:
   - RecalculateDashboardStatisticsUseCase (Red → Green → Refactor)
   - RecalculateBadgeProgressUseCase (Red → Green → Refactor)
3. **Commit Point**: 모든 Domain Layer 테스트 통과 후 Commit

### Phase 2: Application Layer
1. **Record Edit Notifiers**:
   - WeightRecordEditNotifier (Red → Green → Refactor)
   - SymptomRecordEditNotifier (Red → Green → Refactor)
   - DoseRecordEditNotifier (Red → Green → Refactor)
2. **Statistics Recalculation Notifier**:
   - RecalculateStatisticsNotifier (Red → Green → Refactor)
3. **Commit Point**: Application Layer 테스트 통과 후 Commit

### Phase 3: Presentation Layer (Outside-In)
1. **Edit Dialogs**:
   - WeightEditDialog (Red → Green → Refactor + Widget Test) - 날짜 수정 포함
   - SymptomEditDialog (Red → Green → Refactor + Widget Test)
   - DoseEditDialog (Red → Green → Refactor + Widget Test) - 투여 기록 수정
   - RecordDeleteDialog (Red → Green → Refactor + Widget Test)
2. **Detail Sheet**:
   - RecordDetailSheet (Red → Green → Refactor + Widget Test)
3. **List Screen Updates**:
   - RecordListScreen Integration (Red → Green → Refactor + Acceptance Test)
4. **Commit Point**: Presentation Layer 테스트 통과 후 Commit

### Phase 4: Integration & Refactoring
1. **End-to-End Test**: 실제 앱에서 수정/삭제 플로우 검증
2. **QA Sheet**: Manual Testing
3. **Performance Check**: 통계 재계산 시간 측정 (< 500ms 목표)
4. **Code Review**: Layer 의존성 검증, Repository Pattern 준수 확인
5. **Refactoring**: 중복 코드 제거, 공통 검증 로직 추출
6. **Final Commit**: "feat(tracking): implement UF-011 record edit/delete"

---

## 6. 핵심 원칙

### Test First
- 모든 테스트 케이스를 먼저 작성하고 실패를 확인한 후 구현
- 테스트 없는 코드 금지

### Small Steps
- 한 번에 하나의 테스트만 통과시키기
- UseCase 단위로 작은 커밋 유지

### FIRST Principles
- **Fast**: 전체 테스트 스위트 < 5초
- **Independent**: 테스트 간 의존성 없음
- **Repeatable**: 환경 무관 재현 가능
- **Self-validating**: 자동 Pass/Fail 판정
- **Timely**: 구현 직전 테스트 작성

### Test Pyramid
- **Unit**: 70% (Domain UseCases, Validation)
- **Integration**: 20% (Application Notifiers, Recalculation)
- **Acceptance**: 10% (Presentation Screens, E2E)

### Inside-Out Strategy
- Domain Layer부터 시작하여 Presentation Layer로 확장
- 비즈니스 로직(검증, 재계산)을 먼저 안정화

### Repository Pattern 엄수
- Application은 Repository Interface만 의존
- Infrastructure 구현 변경이 상위 Layer에 영향 없음
- 통계 재계산도 Repository를 통해서만 데이터 접근

### Data Consistency
- 모든 수정/삭제 작업은 통계 재계산을 트리거
- Rollback 메커니즘으로 데이터 무결성 보장 (재계산 실패 시 원본 복구, Repository 실패 시 중단)
- Badge 획득 조건 재검증으로 정확도 유지

### Audit Trail
- 모든 수정/삭제 작업은 감사 로그 생성 (BR-5 준수)
- LogRecordChangeUseCase를 통한 변경 이력 추적
- AuditRepository를 통한 감사 데이터 저장

---

## 7. Critical Fixes Applied

본 plan은 plancheck.md의 Critical 및 Medium 이슈를 반영하여 다음과 같이 수정되었습니다:

### Architecture Fixes
1. **Repository Interface 위치 수정**: Infrastructure Layer → Domain Layer로 이동
2. **RecalculateStatisticsNotifier Provider 타입 수정**: Provider → AsyncNotifierProvider

### Missing Features Added
3. **투여 기록 수정 기능 추가**: DoseRecordEditNotifier에 updateDoseRecord() 메서드 및 DoseEditDialog 추가
4. **날짜 수정 기능 추가**: WeightEditDialog에 날짜 선택 UI 및 중복 검증 로직 추가
5. **감사 추적 (Audit Trail) 구현**: LogRecordChangeUseCase, AuditRepository 추가

### Implementation Improvements
6. **증상 기록 연쇄 삭제 명시**: TrackingRepository.deleteSymptomLog(cascade: true) 파라미터 추가
7. **Rollback 메커니즘 구체화**:
   - 재계산 실패 시 원본 데이터 복구
   - Repository 실패 시 재계산 스킵
   - 원본 데이터 백업 및 복구 로직 명시
8. **Repository 인터페이스 명시**: DashboardRepository, BadgeRepository 메서드 시그니처 추가
</file>

<file path="013/spec.md">
# UF-011: 과거 기록 수정/삭제

## 유스케이스 명세

### Primary Actor
과거에 기록한 데이터(체중, 부작용, 투여 기록)를 수정하거나 삭제해야 하는 GLP-1 사용자

### Precondition (사용자 관점)
- 사용자가 로그인되어 있음
- 기존 기록(체중, 부작용, 투여 기록)이 존재함
- 기록 목록 화면에 접근 가능함

### Trigger
사용자가 기록 목록에서 특정 기록을 선택하고 수정 또는 삭제를 선택함

### Main Scenario

#### 1. 기록 목록 조회
사용자가 기록 이력 화면으로 이동하여 과거 기록 목록을 확인함

#### 2. 기록 선택
사용자가 특정 기록을 탭하여 상세 정보를 확인함

#### 3. 작업 선택
사용자가 기록 상세 화면에서 "수정" 또는 "삭제" 옵션을 선택함

#### 4. 수정 플로우
- 시스템이 기존 데이터가 채워진 수정 폼을 표시함
- 사용자가 값을 수정함 (날짜, 체중, 증상 심각도, 투여량, 주사 부위 등)
- 시스템이 입력 필드를 검증함
- 사용자가 변경사항을 확인함
- 시스템이 Repository를 통해 수정된 기록을 저장함
- 시스템이 영향받는 통계 재계산을 트리거함:
  * 홈 대시보드 지표 (UF-F006)
  * 데이터 공유 모드 리포트 (UF-F003)
  * 주간 목표 진행도
  * 뱃지 달성 진행도
  * 인사이트 및 트렌드
- 시스템이 성공 확인 메시지를 표시함
- 사용자가 기록 목록으로 돌아감

#### 5. 삭제 플로우
- 시스템이 삭제 확인 대화상자를 표시함
- 사용자가 삭제를 확인함
- 시스템이 Repository를 통해 기록을 삭제함
- 시스템이 영향받는 통계 재계산을 트리거함:
  * 홈 대시보드 지표 (UF-F006)
  * 데이터 공유 모드 리포트 (UF-F003)
  * 주간 목표 진행도
  * 뱃지 달성 진행도
  * 인사이트 및 트렌드
- 시스템이 성공 확인 메시지를 표시함
- 사용자가 기록 목록으로 돌아감

### Edge Cases

#### 잘못된 입력
- 미래 날짜 선택: 에러 메시지 표시
- 유효하지 않은 체중 값(음수, 비현실적): 검증 에러 표시
- 1-10 범위 외의 심각도: 검증 에러 표시

#### 투여 기록 삭제
- 투여 기록 삭제는 스케줄에 영향을 주지 않음 (스케줄은 별도 관리)
- 완료 기록만 삭제됨

#### 증상 기록 삭제
- 연관된 대처 가이드 피드백도 함께 삭제됨
- 컨텍스트 태그도 함께 삭제됨

#### 중복 방지
- 기존 날짜와 중복되도록 수정: 날짜별 고유 제약이 있는 기록(체중 기록)에 대해 충돌 경고 표시

#### 앱 중단
- 수정/삭제 중 앱 종료: 변경사항이 폐기됨
- 미완료 수정에 대한 자동 저장 없음

#### 데이터 일관성
- 관련 통계가 실시간으로 재계산됨
- Application Layer의 DashboardNotifier를 통해 트리거됨
- 모든 종속 뷰가 자동으로 업데이트됨

#### 삭제 영구성
- 삭제는 영구적임 (실행 취소 불가)
- 삭제 전 명확한 경고 표시됨

#### 다중 기록 작업
- 일괄 수정/삭제는 MVP에서 지원하지 않음
- 개별 기록 작업만 허용됨

### Business Rules

#### BR-1: 기록 소유권
인증된 사용자만 자신의 기록을 수정하거나 삭제할 수 있음

#### BR-2: 검증 규칙
- 체중: 양수여야 하며 현실적 범위(20-300kg) 내여야 함
- 날짜: 미래 날짜일 수 없음
- 증상 심각도: 1-10 범위여야 함
- 투여량: 양수여야 함

#### BR-3: 날짜 고유 제약
체중 기록은 날짜별 고유 제약이 있음 (하루 한 기록). 중복 날짜로 수정 시 덮어쓰기 확인 필요

#### BR-4: 통계 재계산
모든 수정 또는 삭제 작업은 다음의 자동 재계산을 트리거함:
- 주간 목표 진행도
- 연속 기록일
- 뱃지 달성 상태
- 대시보드 인사이트
- 데이터 공유 모드 리포트

#### BR-5: 감사 추적
데이터 무결성을 위해 기록 수정 내역이 로그됨 (투여 계획의 경우 plan_change_history에 저장)

#### BR-6: 연쇄 동작
- 투여 기록 삭제: 기록만 삭제, 스케줄은 유지
- 증상 기록 삭제: 연관된 태그와 피드백도 삭제
- 체중 기록 삭제: 연쇄 효과 없음

#### BR-7: 소프트 검증
일부 경고는 사용자가 진행할 수 있도록 허용함 (예: 비현실적 체중 값은 경고를 표시하지만 저장 허용)

---

## Sequence Diagram

```plantuml
@startuml

actor User
participant FE as "Frontend\n(Presentation Layer)"
participant BE as "Backend\n(Application Layer)"
database Database

User -> FE: 기록 이력 화면으로 이동
FE -> BE: 기록 목록 요청
BE -> Database: 기록 조회 (weight_logs, symptom_logs, dose_records)
Database --> BE: 기록 반환
BE --> FE: 기록 목록 전달
FE --> User: 기록 목록 표시

User -> FE: 특정 기록 선택
FE -> BE: 기록 상세 요청
BE -> Database: ID로 기록 조회
Database --> BE: 기록 상세 반환
BE --> FE: 기록 상세 전달
FE --> User: 상세 화면 표시 (수정/삭제 옵션 포함)

alt 수정 플로우
    User -> FE: "수정" 선택
    FE --> User: 기존 값이 채워진 폼 표시
    User -> FE: 값 수정 후 제출
    FE -> FE: 입력 검증
    alt 검증 실패
        FE --> User: 에러 메시지 표시
    else 검증 성공
        FE -> BE: 기록 수정 요청
        BE -> Database: 기록 업데이트
        Database --> BE: 업데이트 확인
        BE -> BE: 통계 재계산 트리거
        BE -> Database: 대시보드 지표 재계산
        Database --> BE: 지표 업데이트됨
        BE --> FE: 수정 성공
        FE --> User: 성공 메시지 표시
        FE -> FE: 기록 목록 새로고침
    end
else 삭제 플로우
    User -> FE: "삭제" 선택
    FE --> User: 확인 대화상자 표시
    User -> FE: 삭제 확인
    FE -> BE: 기록 삭제 요청
    BE -> Database: 기록 삭제
    Database --> BE: 삭제 확인
    BE -> BE: 통계 재계산 트리거
    BE -> Database: 대시보드 지표 재계산
    Database --> BE: 지표 업데이트됨
    BE --> FE: 삭제 성공
    FE --> User: 성공 메시지 표시
    FE -> FE: 기록 목록 새로고침
end

@enduml
```
</file>

<file path="014/plan.md">
# 푸시 알림 설정 Implementation Plan

## 1. 개요

**Feature**: UF-012 푸시 알림 설정
**TDD 전략**: Outside-In (UI → Application → Domain → Infrastructure)
**핵심 목표**: 투여 알림 시간 설정, 알림 활성화/비활성화, 디바이스 권한 관리, 알림 스케줄 자동 업데이트

### 모듈 목록

| 모듈 | 위치 | 책임 | TDD 적용 |
|------|------|------|----------|
| NotificationSettings Entity | `features/notification/domain/entities/notification_settings.dart` | 알림 설정 도메인 모델 | Unit |
| NotificationRepository Interface | `features/notification/domain/repositories/notification_repository.dart` | 알림 데이터 접근 계약 | Unit |
| NotificationScheduler Interface | `features/notification/domain/services/notification_scheduler.dart` | 알림 스케줄링 계약 | Unit |
| NotificationNotifier | `features/notification/application/notifiers/notification_notifier.dart` | 알림 설정 상태 관리 | Unit + Integration |
| NotificationSettingsScreen | `features/notification/presentation/screens/notification_settings_screen.dart` | 알림 설정 UI | Widget + Acceptance |
| NotificationSettingsDto | `features/notification/infrastructure/dtos/notification_settings_dto.dart` | 알림 설정 DTO (Isar) | Unit |
| IsarNotificationRepository | `features/notification/infrastructure/repositories/isar_notification_repository.dart` | Isar 기반 알림 저장소 | Integration |
| LocalNotificationScheduler | `features/notification/infrastructure/services/local_notification_scheduler.dart` | Flutter Local Notifications 구현 | Integration |
| PermissionService | `features/notification/infrastructure/services/permission_service.dart` | 알림 권한 관리 | Integration |

---

## 2. Architecture Diagram

```mermaid
graph TB
    subgraph Presentation
        SettingsScreen[NotificationSettingsScreen<br/>알림 설정 UI]
        TimePickerWidget[TimePickerWidget<br/>시간 선택 UI]
    end

    subgraph Application
        NotificationNotifier[NotificationNotifier<br/>알림 설정 상태 관리]
        NotificationProvider[notificationNotifierProvider]
    end

    subgraph Domain
        NotificationSettings[NotificationSettings Entity<br/>알림 설정 모델]
        NotificationRepo[NotificationRepository Interface<br/>알림 데이터 계약]
        NotificationScheduler[NotificationScheduler Interface<br/>스케줄링 계약]
        MedicationRepo[MedicationRepository Interface<br/>투여 계획 조회]
    end

    subgraph Infrastructure
        IsarNotificationRepo[IsarNotificationRepository<br/>Isar 저장소 구현]
        LocalNotificationScheduler[LocalNotificationScheduler<br/>flutter_local_notifications 구현]
        PermissionService[PermissionService<br/>권한 관리]
        NotificationSettingsDto[NotificationSettingsDto<br/>Isar DTO]
    end

    SettingsScreen -->|ref.read| NotificationProvider
    NotificationProvider -->|provides| NotificationNotifier
    NotificationNotifier -->|depends on| NotificationRepo
    NotificationNotifier -->|depends on| NotificationScheduler
    NotificationNotifier -->|depends on| MedicationRepo
    NotificationRepo -.implements.- IsarNotificationRepo
    NotificationScheduler -.implements.- LocalNotificationScheduler
    LocalNotificationScheduler -->|uses| PermissionService
    IsarNotificationRepo -->|converts| NotificationSettingsDto
    NotificationSettingsDto -->|toEntity| NotificationSettings

    style NotificationSettings fill:#e1f5ff
    style NotificationRepo fill:#fff4e1
    style NotificationScheduler fill:#fff4e1
    style NotificationNotifier fill:#ffe1f5
    style SettingsScreen fill:#e1ffe1
    style IsarNotificationRepo fill:#f5e1ff
```

---

## 3. Implementation Plan

### 3.1. Domain Layer

#### NotificationSettings Entity
- **Location**: `features/notification/domain/entities/notification_settings.dart`
- **Responsibility**: 알림 설정 정보를 표현하는 불변 모델
- **Test Strategy**: Unit Test
- **Test Scenarios**:
  ```dart
  // Red Phase
  test('should create NotificationSettings with default values', () {
    // Arrange & Act
    final settings = NotificationSettings(
      userId: 'user123',
      notificationTime: TimeOfDay(hour: 9, minute: 0),
      notificationEnabled: true,
    );

    // Assert
    expect(settings.userId, 'user123');
    expect(settings.notificationTime.hour, 9);
    expect(settings.notificationEnabled, true);
  });

  test('should create NotificationSettings with disabled state', () {
    // Arrange & Act
    final settings = NotificationSettings(
      userId: 'user123',
      notificationTime: TimeOfDay(hour: 21, minute: 30),
      notificationEnabled: false,
    );

    // Assert
    expect(settings.notificationEnabled, false);
  });

  test('should support copyWith for immutability', () {
    // Arrange
    final original = NotificationSettings(
      userId: 'user123',
      notificationTime: TimeOfDay(hour: 9, minute: 0),
      notificationEnabled: true,
    );

    // Act
    final updated = original.copyWith(
      notificationTime: TimeOfDay(hour: 21, minute: 0),
    );

    // Assert
    expect(updated.notificationTime.hour, 21);
    expect(updated.notificationEnabled, true);
  });

  test('should support equality comparison', () {
    // Arrange
    final settings1 = NotificationSettings(
      userId: 'user123',
      notificationTime: TimeOfDay(hour: 9, minute: 0),
      notificationEnabled: true,
    );
    final settings2 = NotificationSettings(
      userId: 'user123',
      notificationTime: TimeOfDay(hour: 9, minute: 0),
      notificationEnabled: true,
    );

    // Assert
    expect(settings1, equals(settings2));
  });
  ```
- **Implementation Order**:
  1. 기본 생성자 및 필드 정의 (userId, notificationTime, notificationEnabled)
  2. copyWith 메서드
  3. Equatable 구현
- **Dependencies**: None

---

#### NotificationRepository Interface
- **Location**: `features/notification/domain/repositories/notification_repository.dart`
- **Responsibility**: 알림 설정 데이터 접근 계약 정의
- **Test Strategy**: Unit Test (Mock 사용)
- **Test Scenarios**:
  ```dart
  // Red Phase
  test('should define getNotificationSettings method signature', () async {
    // Arrange
    final mockRepo = MockNotificationRepository();
    when(mockRepo.getNotificationSettings('user123'))
        .thenAnswer((_) async => mockSettings);

    // Act
    final settings = await mockRepo.getNotificationSettings('user123');

    // Assert
    expect(settings, isA<NotificationSettings>());
  });

  test('should define saveNotificationSettings method signature', () async {
    // Arrange
    final mockRepo = MockNotificationRepository();
    when(mockRepo.saveNotificationSettings(any))
        .thenAnswer((_) async => {});

    // Act
    await mockRepo.saveNotificationSettings(mockSettings);

    // Assert
    verify(mockRepo.saveNotificationSettings(mockSettings)).called(1);
  });

  test('should return null when settings not found', () async {
    // Arrange
    final mockRepo = MockNotificationRepository();
    when(mockRepo.getNotificationSettings('user123'))
        .thenAnswer((_) async => null);

    // Act
    final settings = await mockRepo.getNotificationSettings('user123');

    // Assert
    expect(settings, isNull);
  });
  ```
- **Method Signatures**:
  ```dart
  abstract class NotificationRepository {
    Future<NotificationSettings?> getNotificationSettings(String userId);
    Future<void> saveNotificationSettings(NotificationSettings settings);
  }
  ```
- **Dependencies**: NotificationSettings

---

#### NotificationScheduler Interface
- **Location**: `features/notification/domain/services/notification_scheduler.dart`
- **Responsibility**: 알림 스케줄링 계약 정의 (권한 확인, 알림 등록/취소)
- **Test Strategy**: Unit Test (Mock 사용)
- **Test Scenarios**:
  ```dart
  // Red Phase
  test('should define checkPermission method signature', () async {
    // Arrange
    final mockScheduler = MockNotificationScheduler();
    when(mockScheduler.checkPermission())
        .thenAnswer((_) async => true);

    // Act
    final hasPermission = await mockScheduler.checkPermission();

    // Assert
    expect(hasPermission, isA<bool>());
  });

  test('should define requestPermission method signature', () async {
    // Arrange
    final mockScheduler = MockNotificationScheduler();
    when(mockScheduler.requestPermission())
        .thenAnswer((_) async => true);

    // Act
    final granted = await mockScheduler.requestPermission();

    // Assert
    expect(granted, isTrue);
  });

  test('should define scheduleNotifications method signature', () async {
    // Arrange
    final mockScheduler = MockNotificationScheduler();
    final doseSchedules = [mockDoseSchedule1, mockDoseSchedule2];
    when(mockScheduler.scheduleNotifications(
      doseSchedules: doseSchedules,
      notificationTime: any,
    )).thenAnswer((_) async => {});

    // Act
    await mockScheduler.scheduleNotifications(
      doseSchedules: doseSchedules,
      notificationTime: TimeOfDay(hour: 9, minute: 0),
    );

    // Assert
    verify(mockScheduler.scheduleNotifications(
      doseSchedules: doseSchedules,
      notificationTime: any,
    )).called(1);
  });

  test('should define cancelAllNotifications method signature', () async {
    // Arrange
    final mockScheduler = MockNotificationScheduler();
    when(mockScheduler.cancelAllNotifications())
        .thenAnswer((_) async => {});

    // Act
    await mockScheduler.cancelAllNotifications();

    // Assert
    verify(mockScheduler.cancelAllNotifications()).called(1);
  });
  ```
- **Method Signatures**:
  ```dart
  abstract class NotificationScheduler {
    Future<bool> checkPermission();
    Future<bool> requestPermission();
    Future<void> scheduleNotifications({
      required List<DoseSchedule> doseSchedules,
      required TimeOfDay notificationTime,
    });
    Future<void> cancelAllNotifications();
  }
  ```
- **Dependencies**: DoseSchedule (from medication domain)

---

### 3.2. Infrastructure Layer

#### PermissionService
- **Location**: `features/notification/infrastructure/services/permission_service.dart`
- **Responsibility**: 디바이스 알림 권한 확인 및 요청 (permission_handler 사용)
- **Test Strategy**: Integration Test (실제 디바이스 또는 Mock)
- **Test Scenarios**:
  ```dart
  // Red Phase
  test('should check notification permission status', () async {
    // Arrange
    final service = PermissionService();

    // Act
    final hasPermission = await service.checkPermission();

    // Assert
    expect(hasPermission, isA<bool>());
  });

  test('should request notification permission', () async {
    // Arrange
    final service = PermissionService();

    // Act
    final granted = await service.requestPermission();

    // Assert
    expect(granted, isA<bool>());
  });

  test('should return false when permission denied', () async {
    // Arrange
    final service = PermissionService();
    // Mock permission denied

    // Act
    final granted = await service.requestPermission();

    // Assert
    expect(granted, false);
  });

  test('should open app settings', () async {
    // Arrange
    final service = PermissionService();

    // Act & Assert
    await expectLater(
      service.openAppSettings(),
      completes,
    );
  });
  ```
- **Implementation Order**:
  1. checkPermission 구현
  2. requestPermission 구현
  3. openAppSettings 구현
- **Dependencies**: permission_handler

---

#### LocalNotificationScheduler
- **Location**: `features/notification/infrastructure/services/local_notification_scheduler.dart`
- **Responsibility**: flutter_local_notifications를 사용한 알림 스케줄링 구현
- **Test Strategy**: Integration Test (실제 플러그인 또는 Mock)
- **Test Scenarios**:
  ```dart
  // Red Phase
  test('should initialize notification plugin', () async {
    // Arrange & Act
    final scheduler = LocalNotificationScheduler();
    await scheduler.initialize();

    // Assert
    expect(scheduler.isInitialized, true);
  });

  test('should check notification permission via PermissionService', () async {
    // Arrange
    final mockPermissionService = MockPermissionService();
    when(mockPermissionService.checkPermission())
        .thenAnswer((_) async => true);
    final scheduler = LocalNotificationScheduler(mockPermissionService);

    // Act
    final hasPermission = await scheduler.checkPermission();

    // Assert
    expect(hasPermission, true);
    verify(mockPermissionService.checkPermission()).called(1);
  });

  test('should request notification permission via PermissionService', () async {
    // Arrange
    final mockPermissionService = MockPermissionService();
    when(mockPermissionService.requestPermission())
        .thenAnswer((_) async => true);
    final scheduler = LocalNotificationScheduler(mockPermissionService);

    // Act
    final granted = await scheduler.requestPermission();

    // Assert
    expect(granted, true);
    verify(mockPermissionService.requestPermission()).called(1);
  });

  test('should schedule notifications for dose schedules', () async {
    // Arrange
    final scheduler = LocalNotificationScheduler();
    final doseSchedules = [
      DoseSchedule(
        id: 'schedule1',
        dosagePlanId: 'plan1',
        scheduledDate: DateTime.now().add(Duration(days: 1)),
        scheduledDoseMg: 0.5,
      ),
      DoseSchedule(
        id: 'schedule2',
        dosagePlanId: 'plan1',
        scheduledDate: DateTime.now().add(Duration(days: 8)),
        scheduledDoseMg: 1.0,
      ),
    ];

    // Act
    await scheduler.scheduleNotifications(
      doseSchedules: doseSchedules,
      notificationTime: TimeOfDay(hour: 9, minute: 0),
    );

    // Assert
    final pendingNotifications = await scheduler.getPendingNotifications();
    expect(pendingNotifications.length, 2);
  });

  test('should cancel all notifications', () async {
    // Arrange
    final scheduler = LocalNotificationScheduler();
    await scheduler.scheduleNotifications(
      doseSchedules: [mockDoseSchedule],
      notificationTime: TimeOfDay(hour: 9, minute: 0),
    );

    // Act
    await scheduler.cancelAllNotifications();

    // Assert
    final pendingNotifications = await scheduler.getPendingNotifications();
    expect(pendingNotifications, isEmpty);
  });

  test('should not schedule notification for past dates', () async {
    // Arrange
    final scheduler = LocalNotificationScheduler();
    final pastSchedule = DoseSchedule(
      id: 'schedule1',
      dosagePlanId: 'plan1',
      scheduledDate: DateTime.now().subtract(Duration(days: 1)),
      scheduledDoseMg: 0.5,
    );

    // Act
    await scheduler.scheduleNotifications(
      doseSchedules: [pastSchedule],
      notificationTime: TimeOfDay(hour: 9, minute: 0),
    );

    // Assert
    final pendingNotifications = await scheduler.getPendingNotifications();
    expect(pendingNotifications, isEmpty);
  });

  test('should schedule only one notification per date', () async {
    // Arrange
    final scheduler = LocalNotificationScheduler();
    final sameDate = DateTime.now().add(Duration(days: 1));
    final doseSchedules = [
      DoseSchedule(
        id: 'schedule1',
        dosagePlanId: 'plan1',
        scheduledDate: sameDate,
        scheduledDoseMg: 0.5,
      ),
      DoseSchedule(
        id: 'schedule2',
        dosagePlanId: 'plan1',
        scheduledDate: sameDate,
        scheduledDoseMg: 0.5,
      ),
    ];

    // Act
    await scheduler.scheduleNotifications(
      doseSchedules: doseSchedules,
      notificationTime: TimeOfDay(hour: 9, minute: 0),
    );

    // Assert
    final pendingNotifications = await scheduler.getPendingNotifications();
    expect(pendingNotifications.length, 1);
  });
  ```
- **Edge Cases**:
  - 권한 거부: requestPermission이 false 반환
  - 과거 날짜: 알림 등록하지 않음
  - 같은 날짜 여러 투여: 알림 한 번만 등록
  - 알림 시간이 투여 예정일 이후: 다음날 동일 시간 예약
- **Implementation Order**:
  1. initialize 구현 (flutter_local_notifications 초기화)
  2. checkPermission 구현 (PermissionService 위임)
  3. requestPermission 구현 (PermissionService 위임)
  4. scheduleNotifications 구현 (중복 날짜 필터링, 과거 날짜 제외)
  5. cancelAllNotifications 구현
- **Dependencies**: flutter_local_notifications, PermissionService, DoseSchedule

---

#### NotificationSettingsDto
- **Location**: `features/notification/infrastructure/dtos/notification_settings_dto.dart`
- **Responsibility**: Isar 저장을 위한 DTO 변환
- **Test Strategy**: Unit Test
- **Test Scenarios**:
  ```dart
  // Red Phase
  test('should convert NotificationSettingsDto to NotificationSettings entity', () {
    // Arrange
    final dto = NotificationSettingsDto()
      ..userId = 'user123'
      ..notificationHour = 9
      ..notificationMinute = 0
      ..notificationEnabled = true;

    // Act
    final entity = dto.toEntity();

    // Assert
    expect(entity.userId, 'user123');
    expect(entity.notificationTime.hour, 9);
    expect(entity.notificationTime.minute, 0);
    expect(entity.notificationEnabled, true);
  });

  test('should convert NotificationSettings entity to NotificationSettingsDto', () {
    // Arrange
    final entity = NotificationSettings(
      userId: 'user123',
      notificationTime: TimeOfDay(hour: 21, minute: 30),
      notificationEnabled: false,
    );

    // Act
    final dto = NotificationSettingsDto.fromEntity(entity);

    // Assert
    expect(dto.userId, 'user123');
    expect(dto.notificationHour, 21);
    expect(dto.notificationMinute, 30);
    expect(dto.notificationEnabled, false);
  });

  test('should handle midnight time (00:00)', () {
    // Arrange
    final entity = NotificationSettings(
      userId: 'user123',
      notificationTime: TimeOfDay(hour: 0, minute: 0),
      notificationEnabled: true,
    );

    // Act
    final dto = NotificationSettingsDto.fromEntity(entity);
    final convertedEntity = dto.toEntity();

    // Assert
    expect(convertedEntity.notificationTime.hour, 0);
    expect(convertedEntity.notificationTime.minute, 0);
  });
  ```
- **Implementation Order**:
  1. DTO 클래스 정의 (Isar @collection 어노테이션)
  2. toEntity 메서드 (TimeOfDay 재구성)
  3. fromEntity 메서드 (TimeOfDay 분해)
- **Dependencies**: Isar, NotificationSettings

---

#### IsarNotificationRepository
- **Location**: `features/notification/infrastructure/repositories/isar_notification_repository.dart`
- **Responsibility**: NotificationRepository 인터페이스 구현 (Isar)
- **Test Strategy**: Integration Test (실제 Isar 인스턴스)
- **Test Scenarios**:
  ```dart
  // Red Phase
  testWidgets('should save notification settings to Isar', () async {
    // Arrange
    final isar = await openTestIsar();
    final repo = IsarNotificationRepository(isar);
    final settings = NotificationSettings(
      userId: 'user123',
      notificationTime: TimeOfDay(hour: 9, minute: 0),
      notificationEnabled: true,
    );

    // Act
    await repo.saveNotificationSettings(settings);

    // Assert
    final savedSettings = await repo.getNotificationSettings('user123');
    expect(savedSettings, isNotNull);
    expect(savedSettings!.notificationTime.hour, 9);
    expect(savedSettings.notificationEnabled, true);
  });

  testWidgets('should return null when settings not found', () async {
    // Arrange
    final isar = await openTestIsar();
    final repo = IsarNotificationRepository(isar);

    // Act
    final settings = await repo.getNotificationSettings('nonexistent');

    // Assert
    expect(settings, isNull);
  });

  testWidgets('should update existing settings', () async {
    // Arrange
    final isar = await openTestIsar();
    final repo = IsarNotificationRepository(isar);
    final initial = NotificationSettings(
      userId: 'user123',
      notificationTime: TimeOfDay(hour: 9, minute: 0),
      notificationEnabled: true,
    );
    await repo.saveNotificationSettings(initial);

    // Act
    final updated = initial.copyWith(
      notificationTime: TimeOfDay(hour: 21, minute: 0),
      notificationEnabled: false,
    );
    await repo.saveNotificationSettings(updated);

    // Assert
    final savedSettings = await repo.getNotificationSettings('user123');
    expect(savedSettings!.notificationTime.hour, 21);
    expect(savedSettings.notificationEnabled, false);
  });
  ```
- **Implementation Order**:
  1. getNotificationSettings 구현 (userId로 조회)
  2. saveNotificationSettings 구현 (upsert 방식)
- **Dependencies**: Isar, NotificationSettingsDto

---

### 3.3. Application Layer

#### NotificationNotifier
- **Location**: `features/notification/application/notifiers/notification_notifier.dart`
- **Responsibility**: 알림 설정 상태 관리 및 UseCase 오케스트레이션
- **Test Strategy**: Unit Test (MockRepository, MockScheduler)
- **Test Scenarios**:
  ```dart
  // Red Phase
  test('should initialize with loading state', () {
    // Arrange
    final container = ProviderContainer(
      overrides: [
        notificationRepositoryProvider.overrideWithValue(mockRepo),
        notificationSchedulerProvider.overrideWithValue(mockScheduler),
      ],
    );

    // Act
    final state = container.read(notificationNotifierProvider);

    // Assert
    expect(state, isA<AsyncLoading>());
  });

  test('should load notification settings on build', () async {
    // Arrange
    when(mockRepo.getNotificationSettings(any))
        .thenAnswer((_) async => mockSettings);
    final container = ProviderContainer(
      overrides: [
        notificationRepositoryProvider.overrideWithValue(mockRepo),
        notificationSchedulerProvider.overrideWithValue(mockScheduler),
      ],
    );

    // Act
    await container.read(notificationNotifierProvider.future);

    // Assert
    final state = container.read(notificationNotifierProvider);
    expect(state.value, mockSettings);
  });

  test('should return default settings when none exist', () async {
    // Arrange
    when(mockRepo.getNotificationSettings(any))
        .thenAnswer((_) async => null);
    final container = ProviderContainer(
      overrides: [
        notificationRepositoryProvider.overrideWithValue(mockRepo),
        notificationSchedulerProvider.overrideWithValue(mockScheduler),
      ],
    );

    // Act
    await container.read(notificationNotifierProvider.future);

    // Assert
    final state = container.read(notificationNotifierProvider);
    expect(state.value!.notificationTime.hour, 9); // 기본값
    expect(state.value!.notificationEnabled, true);
  });

  test('should update notification time and reschedule', () async {
    // Arrange
    when(mockRepo.saveNotificationSettings(any))
        .thenAnswer((_) async => {});
    when(mockScheduler.cancelAllNotifications())
        .thenAnswer((_) async => {});
    when(mockScheduler.scheduleNotifications(
      doseSchedules: any,
      notificationTime: any,
    )).thenAnswer((_) async => {});
    when(mockMedicationRepo.getDoseSchedules(any))
        .thenAnswer((_) async => [mockDoseSchedule]);

    final container = ProviderContainer(
      overrides: [
        notificationRepositoryProvider.overrideWithValue(mockRepo),
        notificationSchedulerProvider.overrideWithValue(mockScheduler),
        medicationRepositoryProvider.overrideWithValue(mockMedicationRepo),
      ],
    );
    final notifier = container.read(notificationNotifierProvider.notifier);

    // Act
    await notifier.updateNotificationTime(TimeOfDay(hour: 21, minute: 0));

    // Assert
    verify(mockRepo.saveNotificationSettings(any)).called(1);
    verify(mockScheduler.cancelAllNotifications()).called(1);
    verify(mockScheduler.scheduleNotifications(
      doseSchedules: any,
      notificationTime: any,
    )).called(1);
  });

  test('should toggle notification enabled and reschedule', () async {
    // Arrange
    when(mockScheduler.checkPermission())
        .thenAnswer((_) async => true);
    when(mockRepo.saveNotificationSettings(any))
        .thenAnswer((_) async => {});
    when(mockScheduler.cancelAllNotifications())
        .thenAnswer((_) async => {});
    when(mockScheduler.scheduleNotifications(
      doseSchedules: any,
      notificationTime: any,
    )).thenAnswer((_) async => {});
    when(mockMedicationRepo.getDoseSchedules(any))
        .thenAnswer((_) async => [mockDoseSchedule]);

    final container = ProviderContainer(
      overrides: [
        notificationRepositoryProvider.overrideWithValue(mockRepo),
        notificationSchedulerProvider.overrideWithValue(mockScheduler),
        medicationRepositoryProvider.overrideWithValue(mockMedicationRepo),
      ],
    );
    final notifier = container.read(notificationNotifierProvider.notifier);

    // Act
    await notifier.toggleNotificationEnabled();

    // Assert
    verify(mockScheduler.checkPermission()).called(1);
    verify(mockRepo.saveNotificationSettings(any)).called(1);
  });

  test('should request permission when toggling enabled without permission', () async {
    // Arrange
    when(mockScheduler.checkPermission())
        .thenAnswer((_) async => false);
    when(mockScheduler.requestPermission())
        .thenAnswer((_) async => true);
    when(mockRepo.saveNotificationSettings(any))
        .thenAnswer((_) async => {});
    when(mockScheduler.scheduleNotifications(
      doseSchedules: any,
      notificationTime: any,
    )).thenAnswer((_) async => {});
    when(mockMedicationRepo.getDoseSchedules(any))
        .thenAnswer((_) async => [mockDoseSchedule]);

    final container = ProviderContainer(
      overrides: [
        notificationRepositoryProvider.overrideWithValue(mockRepo),
        notificationSchedulerProvider.overrideWithValue(mockScheduler),
        medicationRepositoryProvider.overrideWithValue(mockMedicationRepo),
      ],
    );
    final notifier = container.read(notificationNotifierProvider.notifier);

    // Act
    await notifier.toggleNotificationEnabled();

    // Assert
    verify(mockScheduler.requestPermission()).called(1);
    verify(mockRepo.saveNotificationSettings(any)).called(1);
  });

  test('should not enable when permission denied', () async {
    // Arrange
    when(mockScheduler.checkPermission())
        .thenAnswer((_) async => false);
    when(mockScheduler.requestPermission())
        .thenAnswer((_) async => false);

    final container = ProviderContainer(
      overrides: [
        notificationRepositoryProvider.overrideWithValue(mockRepo),
        notificationSchedulerProvider.overrideWithValue(mockScheduler),
      ],
    );
    final notifier = container.read(notificationNotifierProvider.notifier);

    // Act
    await notifier.toggleNotificationEnabled();

    // Assert
    verifyNever(mockRepo.saveNotificationSettings(any));
    verifyNever(mockScheduler.scheduleNotifications(
      doseSchedules: any,
      notificationTime: any,
    ));
  });

  test('should cancel all notifications when disabling', () async {
    // Arrange
    when(mockRepo.saveNotificationSettings(any))
        .thenAnswer((_) async => {});
    when(mockScheduler.cancelAllNotifications())
        .thenAnswer((_) async => {});

    final container = ProviderContainer(
      overrides: [
        notificationRepositoryProvider.overrideWithValue(mockRepo),
        notificationSchedulerProvider.overrideWithValue(mockScheduler),
      ],
    );
    final notifier = container.read(notificationNotifierProvider.notifier);

    // Act (enabled: true → false)
    await notifier.toggleNotificationEnabled();

    // Assert
    verify(mockScheduler.cancelAllNotifications()).called(1);
    verifyNever(mockScheduler.scheduleNotifications(
      doseSchedules: any,
      notificationTime: any,
    ));
  });
  ```
- **Implementation Order**:
  1. build() 메서드 (getNotificationSettings 호출, 기본값 반환)
  2. updateNotificationTime() 메서드
  3. toggleNotificationEnabled() 메서드 (권한 확인 및 요청)
  4. _rescheduleNotifications() 프라이빗 메서드 (스케줄 재계산)
- **Dependencies**: NotificationRepository, NotificationScheduler, MedicationRepository (for dose schedules)

---

### 3.4. Presentation Layer

#### NotificationSettingsScreen
- **Location**: `features/notification/presentation/screens/notification_settings_screen.dart`
- **Responsibility**: 알림 설정 UI 렌더링 및 사용자 입력 처리
- **Test Strategy**: Widget Test + Acceptance Test
- **Test Scenarios**:
  ```dart
  // Widget Test - Red Phase
  testWidgets('should display notification time and enabled toggle', (tester) async {
    // Arrange
    final mockNotifier = MockNotificationNotifier();
    when(mockNotifier.build()).thenAnswer((_) async => mockSettings);

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          notificationNotifierProvider.overrideWith(() => mockNotifier),
        ],
        child: MaterialApp(home: NotificationSettingsScreen()),
      ),
    );
    await tester.pumpAndSettle();

    // Assert
    expect(find.text('푸시 알림 설정'), findsOneWidget);
    expect(find.byType(Switch), findsOneWidget);
    expect(find.text('알림 시간'), findsOneWidget);
  });

  testWidgets('should display current notification time', (tester) async {
    // Arrange
    final settings = NotificationSettings(
      userId: 'user123',
      notificationTime: TimeOfDay(hour: 9, minute: 0),
      notificationEnabled: true,
    );

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          notificationNotifierProvider.overrideWith((ref) {
            return AsyncValue.data(settings);
          }),
        ],
        child: MaterialApp(home: NotificationSettingsScreen()),
      ),
    );
    await tester.pumpAndSettle();

    // Assert
    expect(find.text('오전 9:00'), findsOneWidget);
  });

  testWidgets('should open time picker when time is tapped', (tester) async {
    // Arrange
    await tester.pumpWidget(
      ProviderScope(
        child: MaterialApp(home: NotificationSettingsScreen()),
      ),
    );
    await tester.pumpAndSettle();

    // Act
    await tester.tap(find.byKey(Key('notification_time_button')));
    await tester.pumpAndSettle();

    // Assert
    expect(find.byType(TimePickerDialog), findsOneWidget);
  });

  testWidgets('should call updateNotificationTime when time selected', (tester) async {
    // Arrange
    final mockNotifier = MockNotificationNotifier();
    when(mockNotifier.updateNotificationTime(any))
        .thenAnswer((_) async => {});

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          notificationNotifierProvider.overrideWith(() => mockNotifier),
        ],
        child: MaterialApp(home: NotificationSettingsScreen()),
      ),
    );
    await tester.pumpAndSettle();

    // Act
    await tester.tap(find.byKey(Key('notification_time_button')));
    await tester.pumpAndSettle();
    // Select time (mocked)
    await tester.tap(find.text('OK'));
    await tester.pumpAndSettle();

    // Assert
    verify(mockNotifier.updateNotificationTime(any)).called(1);
  });

  testWidgets('should call toggleNotificationEnabled when switch toggled', (tester) async {
    // Arrange
    final mockNotifier = MockNotificationNotifier();
    when(mockNotifier.toggleNotificationEnabled())
        .thenAnswer((_) async => {});

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          notificationNotifierProvider.overrideWith(() => mockNotifier),
        ],
        child: MaterialApp(home: NotificationSettingsScreen()),
      ),
    );
    await tester.pumpAndSettle();

    // Act
    await tester.tap(find.byType(Switch));
    await tester.pumpAndSettle();

    // Assert
    verify(mockNotifier.toggleNotificationEnabled()).called(1);
  });

  testWidgets('should show permission denied dialog when permission refused', (tester) async {
    // Arrange
    final mockNotifier = MockNotificationNotifier();
    when(mockNotifier.toggleNotificationEnabled())
        .thenThrow(PermissionDeniedException());

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          notificationNotifierProvider.overrideWith(() => mockNotifier),
        ],
        child: MaterialApp(home: NotificationSettingsScreen()),
      ),
    );
    await tester.pumpAndSettle();

    // Act
    await tester.tap(find.byType(Switch));
    await tester.pumpAndSettle();

    // Assert
    expect(find.text('알림 권한이 필요합니다'), findsOneWidget);
    expect(find.text('설정으로 이동'), findsOneWidget);
  });

  testWidgets('should show confirmation message on save', (tester) async {
    // Arrange
    final mockNotifier = MockNotificationNotifier();
    when(mockNotifier.updateNotificationTime(any))
        .thenAnswer((_) async => {});

    await tester.pumpWidget(
      ProviderScope(
        overrides: [
          notificationNotifierProvider.overrideWith(() => mockNotifier),
        ],
        child: MaterialApp(home: NotificationSettingsScreen()),
      ),
    );
    await tester.pumpAndSettle();

    // Act
    await tester.tap(find.byKey(Key('notification_time_button')));
    await tester.pumpAndSettle();
    await tester.tap(find.text('OK'));
    await tester.pumpAndSettle();

    // Assert
    expect(find.text('알림 설정이 저장되었습니다'), findsOneWidget);
  });
  ```
- **QA Sheet** (수동 테스트):
  | 항목 | 체크 |
  |------|------|
  | 알림 시간 선택 시 TimePicker 표시 | ☐ |
  | 선택한 시간이 UI에 반영됨 | ☐ |
  | 알림 토글 스위치 정상 동작 | ☐ |
  | 권한 없을 시 권한 요청 대화상자 표시 | ☐ |
  | 권한 거부 시 "설정으로 이동" 안내 표시 | ☐ |
  | "설정으로 이동" 버튼 클릭 시 시스템 설정 앱 열림 | ☐ |
  | 알림 시간 변경 시 "설정이 저장되었습니다" 메시지 표시 | ☐ |
  | 알림 비활성화 시 모든 알림 취소 확인 (시스템 알림 확인) | ☐ |
  | 알림 활성화 시 투여 예정일에 알림 등록 확인 | ☐ |
  | 네트워크 오류 시 로컬 저장 및 에러 메시지 표시 | ☐ |
- **Implementation Order**:
  1. UI 레이아웃 구성 (Switch, Time display, Time picker button)
  2. NotificationNotifier 연동 (ref.watch)
  3. Time picker 표시 로직
  4. updateNotificationTime 호출
  5. toggleNotificationEnabled 호출
  6. 권한 거부 처리 (Dialog 표시)
  7. 확인 메시지 표시 (SnackBar)
- **Dependencies**: NotificationNotifier

---

## 4. TDD Workflow

### Phase 1: Domain Layer (Inside-Out)
1. **시작**: NotificationSettings Entity 테스트 작성
2. **Red → Green → Refactor**:
   - NotificationSettings Entity 구현
   - NotificationRepository Interface 정의
   - NotificationScheduler Interface 정의
3. **Commit**: "feat(notification): add domain entities and repository interfaces"

### Phase 2: Infrastructure Layer
1. **시작**: PermissionService 테스트 작성
2. **Red → Green → Refactor**:
   - PermissionService 구현
   - LocalNotificationScheduler 구현 (initialize, permission 메서드)
   - NotificationSettingsDto 구현
   - IsarNotificationRepository 구현
   - LocalNotificationScheduler 스케줄링 로직 구현
3. **Commit**: "feat(notification): implement infrastructure layer with local notifications"

### Phase 3: Application Layer
1. **시작**: NotificationNotifier 테스트 작성
2. **Red → Green → Refactor**:
   - NotificationNotifier build() 구현
   - updateNotificationTime() 구현
   - toggleNotificationEnabled() 구현
   - _rescheduleNotifications() 구현
3. **Commit**: "feat(notification): add notification settings state management"

### Phase 4: Presentation Layer
1. **시작**: NotificationSettingsScreen 위젯 테스트 작성
2. **Red → Green → Refactor**:
   - NotificationSettingsScreen UI 구현
   - Time picker 연동
   - Switch 토글 로직
   - NotificationNotifier 연동
   - 권한 거부 Dialog 처리
   - 확인 메시지 표시
3. **Commit**: "feat(notification): implement notification settings screen UI"

### Phase 5: Acceptance Testing
1. **시작**: E2E 시나리오 작성
2. **Red → Green → Refactor**:
   - 알림 시간 변경 플로우
   - 알림 활성화/비활성화 플로우
   - 권한 요청 및 거부 플로우
   - 알림 스케줄 업데이트 확인
3. **Commit**: "test(notification): add acceptance tests for notification settings"

### Phase 6: Refactoring
1. 중복 코드 제거
2. 에러 메시지 상수화
3. 스케줄링 로직 최적화
4. **Commit**: "refactor(notification): optimize scheduling logic and extract constants"

---

## 5. 핵심 원칙

### Repository Pattern
- Application/Presentation은 **NotificationRepository Interface**만 의존
- Infrastructure는 **IsarNotificationRepository 구현체** 제공
- Phase 1 전환 시 **SupabaseNotificationRepository**로 1줄 변경 (알림 설정은 로컬이지만 서버 동기화 가능)

### Test Pyramid
- **Unit Tests (70%)**: Entity, DTO, PermissionService, NotificationNotifier
- **Integration Tests (20%)**: IsarNotificationRepository, LocalNotificationScheduler
- **Acceptance Tests (10%)**: NotificationSettingsScreen E2E 플로우

### TDD 사이클
1. **Red**: 실패하는 테스트 작성
2. **Green**: 최소한의 코드로 통과
3. **Refactor**: 중복 제거 및 최적화

### Edge Case 처리
- 권한 거부: 설정 앱 이동 안내
- 과거 날짜: 알림 등록 제외
- 같은 날짜 여러 투여: 알림 한 번만 등록
- 알림 시간 이후: 다음날 동일 시간 예약
- 네트워크 오류: 로컬 저장 후 재시도 큐 등록
- 알림 설정 변경 후 즉시 반영 불가: 안내 메시지 표시

---

## 6. 성공 기준

### 기능 요구사항
- [x] 알림 시간 설정 및 저장 (24시간 형식)
- [x] 알림 활성화/비활성화 토글
- [x] 디바이스 알림 권한 확인 및 요청
- [x] 권한 거부 시 설정 앱 이동 안내
- [x] 투여 스케줄 기반 알림 자동 등록
- [x] 알림 시간 변경 시 스케줄 자동 재계산
- [x] 알림 비활성화 시 모든 알림 취소
- [x] 같은 날짜 여러 투여 시 알림 한 번만 발송
- [x] 과거 날짜 알림 등록 제외

### 비기능 요구사항
- [x] 모든 테스트 통과 (Unit + Integration + Acceptance)
- [x] Layer 간 의존성 규칙 준수
- [x] Repository Pattern 엄격히 적용
- [x] 알림 스케줄링 1초 이내 완료
- [x] 디바이스 재부팅 후에도 알림 유지

### 코드 품질
- [x] Test Coverage > 80%
- [x] No warnings (flutter analyze)
- [x] TDD 사이클 완료 (모든 모듈)
- [x] Commit 메시지 규칙 준수
</file>

<file path="014/spec.md">
# UF-012: 푸시 알림 설정

## Primary Actor
GLP-1 치료 중인 사용자

## Precondition
- 사용자가 로그인 상태
- 투여 계획이 등록되어 있음
- 설정 화면에 접근 가능

## Trigger
- 사용자가 설정 메뉴에서 "푸시 알림 설정" 선택
- 투여 알림 시간 조정 필요
- 알림 활성화 또는 비활성화 필요

## Main Scenario

### 1. 알림 설정 화면 진입
1. 사용자가 설정 메뉴에서 "푸시 알림 설정" 선택
2. 시스템이 현재 알림 설정 상태 조회
3. 시스템이 알림 설정 화면 표시

### 2. 알림 시간 설정
1. 사용자가 투여 알림 시간 선택 UI 클릭
2. 시스템이 시간 선택 피커 표시
3. 사용자가 원하는 알림 시간 선택
4. 시스템이 선택된 시간 저장

### 3. 알림 활성화/비활성화
1. 사용자가 알림 토글 스위치 조작
2. 시스템이 디바이스 알림 권한 상태 확인
3. 권한이 부여된 경우: 토글 상태 변경 및 저장
4. 권한이 부여되지 않은 경우: 권한 요청 플로우 실행

### 4. 알림 권한 요청
1. 시스템이 알림 권한 요청 대화상자 표시
2. 사용자가 권한 허용 선택: 알림 활성화
3. 사용자가 권한 거부 선택: 설정 앱으로 이동 안내 표시

### 5. 알림 스케줄 업데이트
1. 시스템이 투여 스케줄 조회
2. 시스템이 설정된 알림 시간 기반으로 알림 스케줄 생성
3. 시스템이 기존 알림 스케줄 취소
4. 시스템이 새로운 알림 스케줄 등록

### 6. 저장 완료
1. 시스템이 변경사항 저장 완료
2. 시스템이 확인 메시지 표시
3. 사용자가 설정 화면으로 복귀

## Edge Cases

### EC1. 디바이스 알림 권한 거부
- 사용자가 알림 권한을 거부한 경우
- 시스템이 설정 앱으로 이동 유도 메시지 표시
- "설정으로 이동" 버튼 제공

### EC2. 여러 투여 예정일이 같은 날
- 같은 날에 여러 투여 예정인 경우
- 시스템이 해당 날짜에 알림 한 번만 발송

### EC3. 알림 시간이 투여 예정일 이후
- 설정된 알림 시간이 이미 지난 경우
- 시스템이 다음날 동일 시간에 알림 예약

### EC4. 알림 설정 변경 후 즉시 반영 불가
- 알림 설정 변경 직후 투여 예정일인 경우
- 시스템이 "다음 알림부터 적용됩니다" 안내 메시지 표시

### EC5. 알림 권한 재요청
- 이전에 권한을 거부한 사용자가 알림 활성화 시도
- 시스템이 직접 설정 앱으로 이동하도록 안내

### EC6. 네트워크 오류로 저장 실패
- 설정 저장 중 네트워크 오류 발생
- 시스템이 로컬에 임시 저장 후 재시도 큐 등록
- 사용자에게 에러 메시지 및 재시도 안내

### EC7. 앱 백그라운드 제한
- 디바이스의 배터리 최적화로 백그라운드 제한된 경우
- 시스템이 배터리 최적화 예외 설정 안내

## Business Rules

### BR1. 알림 시간 설정
- 알림 시간은 24시간 형식으로 설정 가능
- 기본 알림 시간: 오전 9시
- 사용자는 투여 예정일마다 동일한 시간에 알림 수신

### BR2. 알림 권한 관리
- 알림 권한은 디바이스 설정에 의존
- 권한 거부 시 인앱 알림 대체 수단 제공 불가
- 사용자가 수동으로 설정 앱에서 권한 부여 필요

### BR3. 알림 스케줄 관리
- 알림은 투여 예정일 당일 지정 시간에 발송
- 투여 계획 변경 시 알림 스케줄 자동 재계산
- 투여 완료 기록 시 해당 알림 자동 취소

### BR4. 알림 내용
- 알림 제목: "투여 예정일 알림"
- 알림 본문: "오늘은 {약물명} {용량}mg 투여일입니다"
- 알림 터치 시 투여 스케줄러 화면으로 이동

### BR5. 알림 활성화 상태
- 알림 비활성화 시 모든 예정 알림 취소
- 알림 재활성화 시 현재 시점 이후 알림만 재등록
- 알림 상태는 사용자 프로필에 저장

### BR6. 복수 디바이스 지원
- Phase 1 (클라우드 동기화) 이후 지원
- 각 디바이스에서 독립적으로 알림 설정 관리
- 서버는 알림 설정 동기화하지 않음 (로컬 설정)

### BR7. 데이터 저장
- 알림 시간: user_profiles 테이블에 저장
- 알림 활성화 상태: user_profiles 테이블에 저장
- 알림 스케줄: dose_schedules 테이블의 notification_time 컬럼 사용

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE
participant BE
database Database

User -> FE: 설정 메뉴에서 "푸시 알림 설정" 선택
FE -> BE: 현재 알림 설정 조회 요청
BE -> Database: SELECT notification_time, notification_enabled FROM user_profiles WHERE user_id = ?
Database --> BE: 알림 설정 데이터 반환
BE --> FE: 알림 설정 데이터 반환
FE --> User: 알림 설정 화면 표시

User -> FE: 알림 시간 선택
FE -> FE: 시간 피커 표시
User -> FE: 원하는 시간 선택
FE -> FE: 선택된 시간 임시 저장

User -> FE: 알림 활성화 토글
FE -> FE: 디바이스 알림 권한 확인

alt 알림 권한 없음
    FE -> FE: 알림 권한 요청 대화상자 표시
    User -> FE: 권한 허용
    FE -> FE: 알림 권한 부여 완료
else 알림 권한 거부
    FE --> User: "설정 앱에서 알림 권한을 허용해주세요" 안내
    User -> FE: 설정으로 이동
end

FE -> BE: 알림 설정 저장 요청
BE -> Database: UPDATE user_profiles SET notification_time = ?, notification_enabled = ? WHERE user_id = ?
Database --> BE: 저장 완료
BE -> Database: SELECT * FROM dose_schedules WHERE dosage_plan_id = ? AND scheduled_date >= CURRENT_DATE
Database --> BE: 투여 스케줄 목록 반환
BE -> Database: UPDATE dose_schedules SET notification_time = ? WHERE id IN (?)
Database --> BE: 알림 시간 업데이트 완료
BE --> FE: 저장 완료 응답

FE -> FE: 기존 알림 스케줄 취소
FE -> FE: 새로운 알림 스케줄 등록
FE --> User: "알림 설정이 저장되었습니다" 메시지 표시
User -> FE: 설정 화면으로 복귀
@enduml
```
</file>

<file path="015/plan.md">
# UF-013: 주간 기록 목표 조정 Implementation Plan

## 1. 개요

주간 체중 기록 목표와 부작용 기록 목표를 사용자가 직접 조정할 수 있는 기능을 구현한다. 목표 변경 시 홈 대시보드의 주간 진행도가 즉시 재계산된다.

**모듈 목록:**
- **Domain**: UserProfile Entity, ProfileRepository Interface
- **Infrastructure**: IsarProfileRepository, UserProfileDto
- **Application**: ProfileNotifier (목표 업데이트 메서드 추가)
- **Presentation**: WeeklyGoalSettingsScreen, WeeklyGoalInputWidget

**TDD 적용 범위:**
- Domain Layer: 100% (Entity 비즈니스 로직)
- Application Layer: 100% (Notifier 상태 관리)
- Infrastructure Layer: 100% (Repository 구현)
- Presentation Layer: Manual QA (위젯 테스트)

---

## 2. Architecture Diagram

```mermaid
graph TD
    subgraph Presentation Layer
        A[WeeklyGoalSettingsScreen]
        B[WeeklyGoalInputWidget]
    end

    subgraph Application Layer
        C[ProfileNotifier]
        D[DashboardNotifier]
    end

    subgraph Domain Layer
        E[UserProfile Entity]
        F[ProfileRepository Interface]
    end

    subgraph Infrastructure Layer
        G[IsarProfileRepository]
        H[UserProfileDto]
        I[Isar DB]
    end

    A --> B
    A --> C
    B --> C
    C --> F
    F --> G
    G --> H
    H --> I
    C --> D
    E -.defines.- F
```

**데이터 흐름:**
1. User Input (Screen) → ProfileNotifier.updateWeeklyGoals()
2. ProfileNotifier → ProfileRepository.updateWeeklyGoals()
3. IsarProfileRepository → Isar DB (UPDATE user_profiles)
4. ProfileNotifier → invalidate DashboardNotifier
5. DashboardNotifier → recalculate weekly progress
6. UI → reflect updated progress

---

## 3. Implementation Plan

### 3.1. Domain Layer: UserProfile Entity

**Location**: `lib/features/profile/domain/entities/user_profile.dart`

**Responsibility**:
- 주간 목표 데이터 모델 정의
- 주간 목표 검증 로직 (0~7 범위)

**기존 Entity 구조**:
```dart
class UserProfile {
  final String id;
  final String userId;
  final DateTime createdAt;
  final DateTime updatedAt;

  // 기존 필드들...
}
```

**추가 필드**:
```dart
class UserProfile {
  // 기존 필드...

  final int weeklyWeightRecordGoal;   // 신규 추가 (기본값: 7)
  final int weeklySymptomRecordGoal;  // 신규 추가 (기본값: 7)

  UserProfile({
    required this.id,
    required this.userId,
    required this.weeklyWeightRecordGoal,
    required this.weeklySymptomRecordGoal,
    required this.createdAt,
    required this.updatedAt,
  }) {
    if (weeklyWeightRecordGoal < 0 || weeklyWeightRecordGoal > 7) {
      throw ArgumentError('주간 체중 기록 목표는 0~7 범위여야 합니다');
    }
    if (weeklySymptomRecordGoal < 0 || weeklySymptomRecordGoal > 7) {
      throw ArgumentError('주간 부작용 기록 목표는 0~7 범위여야 합니다');
    }
  }
}
```

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```dart
describe('UserProfile Entity')
  test('주간 체중 기록 목표가 0~7 범위 내인지 검증')
    // Arrange: weeklyWeightRecordGoal = -1
    // Act: UserProfile 생성
    // Assert: ArgumentError 발생

  test('주간 부작용 기록 목표가 0~7 범위 내인지 검증')
    // Arrange: weeklySymptomRecordGoal = 8
    // Act: UserProfile 생성
    // Assert: ArgumentError 발생

  test('유효한 주간 목표로 UserProfile 생성 성공')
    // Arrange: weeklyWeightRecordGoal = 5, weeklySymptomRecordGoal = 3
    // Act: UserProfile 생성
    // Assert: 생성 성공, 필드 값 일치

  test('copyWith로 주간 목표만 변경 가능')
    // Arrange: 기존 UserProfile
    // Act: copyWith(weeklyWeightRecordGoal: 4)
    // Assert: 목표만 변경, 나머지 필드 유지

  test('주간 목표 0 허용 (경고용)')
    // Arrange: weeklyWeightRecordGoal = 0
    // Act: UserProfile 생성
    // Assert: 생성 성공
```

**Implementation Order (TDD Cycle)**:
1. Red: 테스트 작성 (Entity 검증 로직)
2. Green: Entity에 검증 로직 추가
3. Refactor: Entity 불변성 확인

**Dependencies**: 없음 (Pure Dart)

---

### 3.2. Domain Layer: ProfileRepository Interface

**Location**: `lib/features/profile/domain/repositories/profile_repository.dart`

**Responsibility**:
- UserProfile CRUD 인터페이스 정의
- updateWeeklyGoals 메서드 시그니처 정의

**Test Strategy**: Unit Test (Mock 사용)

**Test Scenarios (Red Phase)**:
```dart
describe('ProfileRepository Interface')
  test('updateWeeklyGoals 메서드 시그니처 존재')
    // Arrange: Mock ProfileRepository
    // Act: updateWeeklyGoals(userId, 5, 3) 호출
    // Assert: 메서드 호출 성공

  test('updateWeeklyGoals 반환 타입 Future<void>')
    // Arrange: Mock ProfileRepository
    // Act: updateWeeklyGoals() 실행
    // Assert: Future<void> 반환
```

**Implementation Order (TDD Cycle)**:
1. Red: 테스트 작성 (Interface 메서드 시그니처)
2. Green: Interface에 updateWeeklyGoals 추가
3. Refactor: 메서드 문서화

**Dependencies**: UserProfile Entity

---

### 3.3. Infrastructure Layer: UserProfileDto

**Location**: `lib/features/profile/infrastructure/dtos/user_profile_dto.dart`

**Responsibility**:
- Isar DB 스키마 정의
- Entity ↔ DTO 변환

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```dart
describe('UserProfileDto')
  test('Entity → DTO 변환 (fromEntity)')
    // Arrange: UserProfile Entity
    // Act: UserProfileDto.fromEntity(profile)
    // Assert: DTO 필드 값 일치

  test('DTO → Entity 변환 (toEntity)')
    // Arrange: UserProfileDto
    // Act: dto.toEntity()
    // Assert: Entity 필드 값 일치

  test('주간 목표 필드 NOT NULL 제약 확인')
    // Arrange: weeklyWeightRecordGoal = null
    // Act: DTO 생성 시도
    // Assert: 컴파일 에러 또는 실행 시 에러

  test('주간 목표 기본값 7 설정')
    // Arrange: 기본값 사용
    // Act: DTO 생성
    // Assert: weeklyWeightRecordGoal = 7, weeklySymptomRecordGoal = 7
```

**Implementation Order (TDD Cycle)**:
1. Red: 테스트 작성 (DTO ↔ Entity 변환)
2. Green: DTO 구현 (fromEntity/toEntity)
3. Refactor: 변환 로직 최적화

**Dependencies**: UserProfile Entity, Isar

---

### 3.4. Infrastructure Layer: IsarProfileRepository

**Location**: `lib/features/profile/infrastructure/repositories/isar_profile_repository.dart`

**Responsibility**:
- ProfileRepository 구현
- Isar DB 접근 및 트랜잭션 관리

**Test Strategy**: Integration Test (Isar Test Instance)

**Test Scenarios (Red Phase)**:
```dart
describe('IsarProfileRepository.updateWeeklyGoals')
  test('주간 목표 업데이트 성공')
    // Arrange: Isar DB에 UserProfile 존재
    // Act: updateWeeklyGoals(userId, 5, 3)
    // Assert: DB에서 조회 시 목표 변경 확인

  test('updated_at 필드 갱신 확인')
    // Arrange: 기존 UserProfile (updated_at = t1)
    // Act: updateWeeklyGoals()
    // Assert: updated_at = t2 (t2 > t1)

  test('존재하지 않는 userId로 업데이트 시도')
    // Arrange: 존재하지 않는 userId
    // Act: updateWeeklyGoals(invalidUserId, 5, 3)
    // Assert: RepositoryException 발생

  test('트랜잭션 실패 시 롤백')
    // Arrange: DB 트랜잭션 중 에러 발생
    // Act: updateWeeklyGoals()
    // Assert: 변경사항 롤백, 기존 값 유지

  test('동시 업데이트 요청 처리 (Race Condition)')
    // Arrange: 동시에 2개 업데이트 요청
    // Act: 병렬 updateWeeklyGoals() 실행
    // Assert: 마지막 요청 값으로 저장
```

**Implementation Order (TDD Cycle)**:
1. Red: 테스트 작성 (Repository 메서드)
2. Green: Repository 구현 (Isar 트랜잭션)
3. Refactor: 에러 핸들링 강화

**Dependencies**: ProfileRepository Interface, UserProfileDto, Isar

---

### 3.5. Application Layer: ProfileNotifier

**Location**: `lib/features/profile/application/notifiers/profile_notifier.dart`

**Responsibility**:
- UserProfile 상태 관리
- updateWeeklyGoals 메서드 제공
- DashboardNotifier 재계산 트리거

**DashboardNotifier 연동 로직**:
```dart
Future<void> updateWeeklyGoals(int weightGoal, int symptomGoal) async {
  state = const AsyncValue.loading();

  try {
    await _repository.updateWeeklyGoals(_userId, weightGoal, symptomGoal);

    // DashboardNotifier 재계산 트리거
    ref.invalidate(dashboardNotifierProvider);

    // 업데이트된 프로필 조회
    final updatedProfile = await _repository.getProfile(_userId);
    state = AsyncValue.data(updatedProfile);
  } catch (e, st) {
    state = AsyncValue.error(e, st);
  }
}
```

**Test Strategy**: Unit Test (Mock Repository)

**Test Scenarios (Red Phase)**:
```dart
describe('ProfileNotifier.updateWeeklyGoals')
  test('목표 업데이트 성공 시 상태 갱신')
    // Arrange: Mock ProfileRepository
    // Act: notifier.updateWeeklyGoals(5, 3)
    // Assert: state = AsyncValue.data(updatedProfile)

  test('목표 업데이트 실패 시 에러 상태')
    // Arrange: Repository가 RepositoryException 발생
    // Act: notifier.updateWeeklyGoals(5, 3)
    // Assert: state = AsyncValue.error(exception)

  test('목표 업데이트 중 로딩 상태')
    // Arrange: 비동기 Repository
    // Act: notifier.updateWeeklyGoals(5, 3) (완료 전)
    // Assert: state = AsyncValue.loading()

  test('DashboardNotifier invalidate 트리거')
    // Arrange: Mock DashboardNotifier
    // Act: notifier.updateWeeklyGoals(5, 3)
    // Assert: ref.invalidate(dashboardNotifierProvider) 호출 확인

  test('유효하지 않은 목표 값 입력 시 에러')
    // Arrange: weeklyWeightRecordGoal = -1
    // Act: notifier.updateWeeklyGoals(-1, 3)
    // Assert: ArgumentError 발생
```

**Implementation Order (TDD Cycle)**:
1. Red: 테스트 작성 (Notifier 상태 전환)
2. Green: Notifier 메서드 구현
3. Refactor: 상태 관리 로직 정리

**Dependencies**: ProfileRepository, DashboardNotifier

---

### 3.6. Application Layer: 주간 집계 및 달성률 계산 로직

**Location**: `lib/features/dashboard/application/notifiers/dashboard_notifier.dart`

**Responsibility**:
- BR-3: 주간 기록 건수 계산
- BR-2: 달성률 계산 (100% 상한선 적용)

**BR-3 주간 집계 로직**:
```dart
int calculateWeeklyRecordCount(List<WeightLog> logs) {
  final now = DateTime.now();
  // 월요일 00:00 계산
  final weekStart = now.subtract(Duration(days: now.weekday - 1));
  final weekStartDate = DateTime(weekStart.year, weekStart.month, weekStart.day);

  // 일요일 23:59 계산
  final weekEnd = weekStartDate.add(Duration(days: 6, hours: 23, minutes: 59, seconds: 59));

  // log_date 기준으로 필터링 (created_at 아님)
  final uniqueDates = logs
    .where((log) =>
      log.logDate.isAfter(weekStartDate) &&
      log.logDate.isBefore(weekEnd))
    .map((log) => log.logDate.toIso8601String().substring(0, 10)) // YYYY-MM-DD만 추출
    .toSet(); // 중복 날짜 제거

  return uniqueDates.length;
}
```

**BR-2 달성률 계산 로직**:
```dart
double calculateAchievementRate(int actualCount, int goalCount) {
  if (goalCount == 0) return 0.0;

  final rate = (actualCount / goalCount) * 100;

  // 100% 상한선 적용 (목표 감소 시 초과 방지)
  return rate > 100 ? 100.0 : rate;
}
```

**Test Strategy**: Unit Test

**Test Scenarios (Red Phase)**:
```dart
describe('주간 집계 로직 (BR-3)')
  test('월요일 00:00 ~ 일요일 23:59 범위 기록만 집계')
    // Arrange: 지난주 기록 1건, 이번주 기록 3건, 다음주 기록 1건
    // Act: calculateWeeklyRecordCount(logs)
    // Assert: 3 반환

  test('같은 날짜 중복 기록은 1건으로 계산')
    // Arrange: 2025-01-06 기록 3건 (같은 날짜)
    // Act: calculateWeeklyRecordCount(logs)
    // Assert: 1 반환

  test('log_date 기준 집계 (created_at 무시)')
    // Arrange: log_date = 2025-01-06, created_at = 2025-01-07
    // Act: calculateWeeklyRecordCount(logs)
    // Assert: 2025-01-06이 속한 주로 집계

describe('달성률 계산 로직 (BR-2)')
  test('달성률 100% 초과 시 100.0 반환')
    // Arrange: actualCount = 5, goalCount = 3
    // Act: calculateAchievementRate(5, 3)
    // Assert: 100.0 반환 (166.67%가 아님)

  test('목표 0인 경우 0.0 반환')
    // Arrange: actualCount = 5, goalCount = 0
    // Act: calculateAchievementRate(5, 0)
    // Assert: 0.0 반환

  test('정상 달성률 계산')
    // Arrange: actualCount = 3, goalCount = 7
    // Act: calculateAchievementRate(3, 7)
    // Assert: 42.86 반환
```

**Implementation Order (TDD Cycle)**:
1. Red: 주간 집계 테스트 작성
2. Green: calculateWeeklyRecordCount 구현
3. Refactor: 날짜 계산 로직 최적화
4. Red: 달성률 계산 테스트 작성
5. Green: calculateAchievementRate 구현
6. Refactor: 엣지 케이스 처리

**Dependencies**: WeightLog Entity, SymptomLog Entity

---

### 3.7. Presentation Layer: SettingsScreen (Navigation)

**Location**: `lib/features/settings/presentation/screens/settings_screen.dart`

**Responsibility**:
- 설정 메뉴 목록 표시
- WeeklyGoalSettingsScreen으로 라우팅

**구현 내용**:
```dart
class SettingsScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('설정')),
      body: ListView(
        children: [
          ListTile(
            title: Text('주간 기록 목표 조정'),
            trailing: Icon(Icons.chevron_right),
            onTap: () {
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (_) => WeeklyGoalSettingsScreen(),
                ),
              );
            },
          ),
          // 기타 설정 메뉴...
        ],
      ),
    );
  }
}
```

**Test Strategy**: Manual QA

**QA Sheet**:
| Test Case | Steps | Expected Result |
|-----------|-------|-----------------|
| 설정 화면 진입 | 홈 화면 → 설정 아이콘 터치 | 설정 메뉴 목록 표시 |
| 주간 목표 메뉴 선택 | "주간 기록 목표 조정" 터치 | WeeklyGoalSettingsScreen 표시 |
| 뒤로가기 | 설정 화면 → 뒤로가기 버튼 | 이전 화면으로 복귀 |

**Dependencies**: WeeklyGoalSettingsScreen

---

### 3.8. Presentation Layer: WeeklyGoalSettingsScreen

**Location**: `lib/features/profile/presentation/screens/weekly_goal_settings_screen.dart`

**Responsibility**:
- 주간 목표 조정 화면 렌더링
- 입력 검증 및 사용자 피드백
- ProfileNotifier 호출
- Edge Case 처리 (목표 0 확인, 에러 재시도)

**목표 0 입력 확인 다이얼로그**:
```dart
Future<void> _onSave(BuildContext context, int weightGoal, int symptomGoal) async {
  // 목표 0 입력 시 확인
  if (weightGoal == 0 || symptomGoal == 0) {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (_) => AlertDialog(
        title: Text('목표 0 설정'),
        content: Text('목표를 0으로 설정하시겠습니까?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text('취소'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: Text('확인'),
          ),
        ],
      ),
    );
    if (confirm != true) return;
  }

  // 저장 로직...
  await ref.read(profileNotifierProvider.notifier).updateWeeklyGoals(weightGoal, symptomGoal);
}
```

**네트워크 오류 재시도 UI**:
```dart
@override
Widget build(BuildContext context) {
  final profileState = ref.watch(profileNotifierProvider);

  return profileState.when(
    data: (profile) => _buildForm(profile),
    loading: () => Center(child: CircularProgressIndicator()),
    error: (error, stack) => Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text('저장 중 오류가 발생했습니다'),
          SizedBox(height: 16),
          ElevatedButton(
            onPressed: () => ref.read(profileNotifierProvider.notifier)
              .updateWeeklyGoals(_weightGoal, _symptomGoal),
            child: Text('재시도'),
          ),
        ],
      ),
    ),
  );
}
```

**Test Strategy**: Manual QA (아래 QA Sheet 참고)

**Implementation Order**:
1. Screen 기본 구조 구현 (Scaffold, AppBar)
2. WeeklyGoalInputWidget 통합
3. 저장 버튼 및 ProfileNotifier 연동
4. AsyncValue 상태별 UI 처리 (loading/error/data)
5. 목표 0 입력 시 확인 다이얼로그 구현
6. 에러 상태 재시도 버튼 구현
7. 성공 시 SnackBar 표시 후 Navigator.pop()

**Dependencies**: ProfileNotifier, WeeklyGoalInputWidget

**QA Sheet**:

| Test Case | Steps | Expected Result |
|-----------|-------|-----------------|
| 화면 진입 | 설정 메뉴 → 주간 기록 목표 조정 선택 | 현재 목표 값이 입력 필드에 표시됨 |
| 투여 목표 수정 불가 (BR-4) | 화면 확인 | 투여 목표는 표시 전용(읽기 전용)으로 표시되며 수정 불가 |
| 유효한 값 입력 | 체중 목표: 5, 부작용 목표: 3 입력 → 저장 | 저장 성공 메시지, 설정 화면으로 복귀 |
| 0 입력 확인 다이얼로그 | 체중 목표: 0 입력 → 저장 | "목표를 0으로 설정하시겠습니까?" 다이얼로그 표시 |
| 0 입력 취소 | 다이얼로그 → 취소 선택 | 저장 취소, 화면 유지 |
| 0 입력 확인 | 다이얼로그 → 확인 선택 | 저장 성공, 목표 0으로 설정됨 |
| 음수 입력 | 체중 목표: -1 입력 → 저장 | 에러 메시지: "0 이상의 값을 입력하세요" |
| 7 초과 입력 | 체중 목표: 8 입력 → 저장 | 에러 메시지: "주간 목표는 최대 7회입니다" |
| 비정수 입력 | 체중 목표: 3.5 입력 | 에러 메시지: "정수만 입력 가능합니다" |
| 변경사항 없이 저장 | 기존 값 그대로 → 저장 | 저장 성공, 화면 복귀 |
| 홈 대시보드 반영 | 목표 변경 후 홈 화면 이동 | 주간 진행도가 새 목표 기준으로 표시됨 |
| 달성률 100% 상한선 | 목표 감소 (7→3) 후 홈 화면 확인 | 달성률 100% 표시 (초과하지 않음) |
| 네트워크 오류 재시도 | 저장 중 DB 에러 발생 | 에러 메시지 및 "재시도" 버튼 표시 |
| 재시도 성공 | 재시도 버튼 클릭 | 저장 성공, 화면 복귀 |

---

### 3.9. Presentation Layer: WeeklyGoalInputWidget

**Location**: `lib/features/profile/presentation/widgets/weekly_goal_input_widget.dart`

**Responsibility**:
- 숫자 입력 필드 렌더링
- 실시간 입력 검증
- 입력값 콜백 전달

**Test Strategy**: Manual QA

**Implementation Order**:
1. TextFormField 구현 (키보드 타입: 숫자)
2. 실시간 검증 로직 (0~7 범위)
3. 에러 메시지 표시
4. onChanged 콜백 구현

**Dependencies**: 없음 (Pure Widget)

---

## 4. TDD Workflow

### Phase 1: Domain Layer (Outside-In)
1. **Red**: UserProfile Entity 테스트 작성
2. **Green**: Entity 검증 로직 구현
3. **Refactor**: Entity 불변성 확인
4. **Red**: ProfileRepository Interface 테스트 작성
5. **Green**: Interface 메서드 추가
6. **Refactor**: 메서드 문서화

**Commit Point**: Domain Layer 완료 (Entity + Interface)

---

### Phase 2: Infrastructure Layer
1. **Red**: UserProfileDto 변환 테스트 작성
2. **Green**: DTO 변환 로직 구현
3. **Refactor**: 변환 로직 최적화
4. **Red**: IsarProfileRepository 테스트 작성 (Isar Test Instance)
5. **Green**: Repository 구현 (Isar 트랜잭션)
6. **Refactor**: 에러 핸들링 강화

**Commit Point**: Infrastructure Layer 완료 (DTO + Repository)

---

### Phase 3: Application Layer
1. **Red**: ProfileNotifier 테스트 작성 (Mock Repository)
2. **Green**: Notifier 메서드 구현
3. **Refactor**: 상태 관리 로직 정리
4. **Red**: DashboardNotifier invalidation 테스트 추가
5. **Green**: invalidate 로직 추가
6. **Refactor**: 의존성 정리

**Commit Point**: Application Layer 완료 (Notifier + State Management)

---

### Phase 4: Presentation Layer
1. SettingsScreen 구현 (Navigation)
2. WeeklyGoalInputWidget 구현
3. WeeklyGoalSettingsScreen 기본 구조 구현
4. Smoke Test (화면 렌더링 확인)
5. ProfileNotifier 연동
6. Edge Case 처리 (0 입력 확인 다이얼로그, 에러 재시도)
7. Manual QA 수행 (QA Sheet 기반)
8. UI/UX 최적화

**Commit Point**: Feature 완료 (All Layers Integrated)

---

### Phase 5: Integration Test
1. End-to-End 시나리오 테스트
   - 설정 화면 → 목표 변경 → 홈 대시보드 확인
   - 변경사항 DB 저장 확인
   - 진행도 재계산 확인
2. Edge Case 검증
   - 네트워크 오류
   - 동시 업데이트
   - 입력 검증

**Commit Point**: Integration Test 통과

---

## 5. 핵심 원칙 준수

### Layer Dependency
```
Presentation → Application → Domain ← Infrastructure
```
- Presentation은 ProfileNotifier만 의존
- Application은 ProfileRepository Interface만 의존
- Infrastructure는 Domain의 Interface 구현

### Repository Pattern
```
ProfileNotifier → ProfileRepository Interface
                → IsarProfileRepository Implementation
```
- Phase 1 전환 시 SupabaseProfileRepository로 1줄 변경

### TDD Cycle
```
Red (테스트 작성) → Green (최소 구현) → Refactor (리팩토링)
```
- 모든 Domain/Application/Infrastructure는 테스트 우선
- Presentation은 Manual QA로 검증

### Test Pyramid
- Unit Test: 70% (Domain + Application + Infrastructure)
- Integration Test: 20% (Repository + Notifier)
- Manual QA: 10% (Presentation)

---

## 6. 완료 기준

### Domain & Infrastructure
- [ ] UserProfile Entity 검증 로직 구현 및 테스트 통과
- [ ] ProfileRepository Interface 정의
- [ ] UserProfileDto 변환 로직 구현 및 테스트 통과
- [ ] IsarProfileRepository 구현 및 Integration Test 통과

### Application Layer
- [ ] ProfileNotifier 상태 관리 구현 및 Unit Test 통과
- [ ] DashboardNotifier invalidation 연동 확인
- [ ] BR-3 주간 집계 로직 구현 및 테스트 통과
- [ ] BR-2 달성률 계산 로직 구현 및 테스트 통과 (100% 상한선 확인)

### Presentation Layer
- [ ] SettingsScreen 구현 및 WeeklyGoalSettingsScreen 진입 확인
- [ ] WeeklyGoalSettingsScreen Manual QA 완료
- [ ] 목표 0 입력 시 확인 다이얼로그 동작 확인
- [ ] 네트워크 오류 재시도 옵션 동작 확인
- [ ] BR-4 투여 목표 수정 불가 UI 확인 (읽기 전용)

### Integration Test
- [ ] 홈 대시보드 진행도 재계산 확인
- [ ] 달성률 100% 초과 시 상한선 처리 확인
- [ ] 모든 Edge Case 처리 확인
- [ ] 코드 리뷰 및 리팩토링 완료
</file>

<file path="015/spec.md">
# UF-013: 주간 기록 목표 조정

## Use Case Specification

### Primary Actor
GLP-1 사용자

### Precondition
- 사용자가 로그인된 상태
- 온보딩 완료로 기본 주간 기록 목표가 설정된 상태 (기본값: 체중 7회/주, 부작용 7회/주)
- 설정 메뉴에 접근 가능한 상태

### Trigger
사용자가 설정 메뉴에서 "주간 기록 목표 조정" 메뉴를 선택

### Main Scenario

1. 사용자가 홈 대시보드 또는 다른 화면에서 설정 아이콘/메뉴를 터치
2. 시스템이 설정 화면을 표시
3. 사용자가 "주간 기록 목표 조정" 메뉴를 선택
4. 시스템이 user_profiles 테이블에서 현재 주간 목표 값을 조회
   - weekly_weight_record_goal
   - weekly_symptom_record_goal
5. 시스템이 조정 화면을 표시하며 기존 값을 입력 필드에 표시
6. 사용자가 체중 기록 목표 횟수를 수정 (0~7회)
7. 사용자가 부작용 기록 목표 횟수를 수정 (0~7회)
8. 시스템이 입력값을 실시간 검증
   - 0 이상 7 이하의 정수
   - 음수 불가, 7 초과 불가
9. 사용자가 저장 버튼을 터치
10. 시스템이 변경사항을 user_profiles 테이블에 저장
11. 시스템이 updated_at 필드를 현재 시간으로 갱신
12. 시스템이 DashboardNotifier에 변경 이벤트를 전달
13. 시스템이 홈 대시보드 주간 목표 진행도를 재계산
    - 변경된 목표 기준으로 달성률(%) 재계산
    - 현재 주간 기록 건수는 유지
14. 시스템이 저장 완료 메시지를 표시
15. 시스템이 설정 화면으로 복귀

### Edge Cases

**입력 검증 실패**
- 목표 값 0 입력: 경고 메시지 "목표를 0으로 설정하시겠습니까?" 표시하되 허용
- 7 초과 입력: 에러 메시지 "주간 목표는 최대 7회입니다" 표시, 저장 불가
- 음수 입력: 에러 메시지 "0 이상의 값을 입력하세요" 표시, 저장 불가
- 비정수 입력: 에러 메시지 "정수만 입력 가능합니다" 표시, 저장 불가

**저장 처리 중 오류**
- 변경사항 없이 저장: 검증 생략, 그대로 설정 화면으로 복귀
- 저장 중 앱 종료: 변경사항 폐기, 다음 진입 시 기존 값 유지
- 네트워크/DB 오류: 에러 메시지 표시 후 재시도 옵션 제공

**홈 대시보드 반영**
- 목표 변경 후 홈 화면 이동 시: 변경된 목표 기준으로 진행도 즉시 반영
- 목표 감소로 달성률 100% 초과 시: 100%로 표시하되 실제 기록 건수는 유지
- 목표 증가로 달성률 감소 시: 새 달성률로 표시

### Business Rules

**BR-1: 주간 기록 목표 범위**
- 체중 기록 목표: 0~7회 (주 단위)
- 부작용 기록 목표: 0~7회 (주 단위)
- 기본값: 각각 7회/주

**BR-2: 목표 달성률 계산**
- 달성률(%) = (실제 기록 건수 / 주간 목표 건수) × 100
- 최댓값: 100% (초과 달성 시에도 100%로 표시)
- 최솟값: 0%

**BR-3: 주간 집계 기준**
- 주간 기준: 월요일 00:00 ~ 일요일 23:59
- 기록 건수 계산: log_date 기준 (created_at 아님)
- 중복 날짜 기록: 1건으로 계산

**BR-4: 데이터 동기화**
- 목표 변경 시 홈 대시보드 즉시 재계산
- 기존 기록 데이터는 변경하지 않음
- 투여 목표는 dosage_plans 스케줄 기반으로 자동 계산 (수정 불가)

---

## Sequence Diagram

```plantuml
@startuml
actor User
participant FE
participant BE
database Database

User -> FE: 설정 메뉴 선택
FE -> FE: 설정 화면 표시

User -> FE: "주간 기록 목표 조정" 선택
FE -> BE: 현재 주간 목표 조회 요청
BE -> Database: SELECT weekly_weight_record_goal, weekly_symptom_record_goal\nFROM user_profiles WHERE user_id = ?
Database --> BE: 현재 목표 값 반환
BE --> FE: 현재 목표 값 전달
FE -> FE: 조정 화면 표시 (기존 값 표시)

User -> FE: 체중 기록 목표 수정 (예: 5회)
FE -> FE: 입력값 실시간 검증 (0~7 범위)

User -> FE: 부작용 기록 목표 수정 (예: 3회)
FE -> FE: 입력값 실시간 검증 (0~7 범위)

User -> FE: 저장 버튼 터치
FE -> FE: 최종 검증

alt 검증 성공
    FE -> BE: 목표 변경 저장 요청
    BE -> Database: UPDATE user_profiles\nSET weekly_weight_record_goal = 5,\nweekly_symptom_record_goal = 3,\nupdated_at = now()\nWHERE user_id = ?
    Database --> BE: 저장 완료
    BE --> FE: 저장 성공 응답

    FE -> BE: 홈 대시보드 재계산 요청
    BE -> Database: SELECT log_date FROM weight_logs\nWHERE user_id = ? AND log_date >= [week_start]
    Database --> BE: 이번 주 체중 기록 건수
    BE -> Database: SELECT log_date FROM symptom_logs\nWHERE user_id = ? AND log_date >= [week_start]
    Database --> BE: 이번 주 부작용 기록 건수
    BE -> BE: 달성률 재계산\n(실제 건수 / 새 목표 × 100)
    BE --> FE: 갱신된 진행도 데이터

    FE -> FE: 저장 완료 메시지 표시
    FE -> FE: 설정 화면으로 복귀
else 검증 실패
    FE -> FE: 에러 메시지 표시
    FE -> FE: 입력 필드 유지
end

@enduml
```
</file>

<file path="external/auth_guide.md">
# External Authentication Implementation Guide

This document provides a guide for implementing Kakao and Naver social logins for the GLP-1 management app, following the project's architecture and tech stack.

## 1. Project Context

- **Tech Stack**: Flutter, Riverpod, Isar, `kakao_flutter_sdk`, `flutter_naver_login`, `flutter_secure_storage`.
- **Architecture**: 4-Layer (Presentation, Application, Domain, Infrastructure). Authentication logic resides in `features/authentication/`.
- **Goal**: Implement social login, retrieve user profile (name, email, profile image), and securely store OAuth tokens.

## 2. Kakao Login Implementation

**Library**: `kakao_flutter_sdk`

### Step 1: Configuration

1.  **Kakao Developers**:
    *   Create a new application.
    *   Enable "Kakao Login" in the product settings.
    *   Register the platform (Android/iOS) and set up package name/bundle ID.
    *   Obtain the **Native App Key**.

2.  **Android (`android/app/src/main/AndroidManifest.xml`)**:
    *   Add a `meta-data` tag with the Native App Key.
    *   Add an `intent-filter` for the custom URL scheme (`kakao${NATIVE_APP_KEY}://oauth`).

3.  **iOS (`ios/Runner/Info.plist`)**:
    *   Add `LSApplicationQueriesSchemes` for `kakaokompassauth`, `kakaolink`.
    *   Add a `CFBundleURLTypes` entry with the custom URL scheme (`kakao${NATIVE_APP_KEY}`).

### Step 2: Implementation (`features/authentication/infrastructure/datasources/`)

Create a `KakaoAuthDataSource` class.

```dart
import 'package:kakao_flutter_sdk/kakao_flutter_sdk.dart';

class KakaoAuthDataSource {
  Future<OAuthToken?> login() async {
    if (await isKakaoTalkInstalled()) {
      try {
        return await UserApi.instance.loginWithKakaoTalk();
      } catch (error) {
        // Fallback to account login if KakaoTalk login fails
        return await UserApi.instance.loginWithKakaoAccount();
      }
    } else {
      return await UserApi.instance.loginWithKakaoAccount();
    }
  }

  Future<void> logout() async {
    await UserApi.instance.logout();
  }

  Future<User?> getUser() async {
    try {
      return await UserApi.instance.me();
    } catch (error) {
      return null;
    }
  }
}
```

## 3. Naver Login Implementation

**Library**: `flutter_naver_login`

### Step 1: Configuration

1.  **Naver Developers**:
    *   Create a new application.
    *   Enable "Naver Login".
    *   Register the platform (Android/iOS) and get the **Client ID** and **Client Secret**.
    *   Define the callback URL.

2.  **Android**:
    *   No specific manifest configuration is required by the library itself, but ensure your build settings are correct.

3.  **iOS (`ios/Runner/Info.plist`)**:
    *   Add `LSApplicationQueriesSchemes` for `naversearchapp`, `naversearchthirdlogin`.
    *   Add a `CFBundleURLTypes` entry with your URL scheme.

### Step 2: Implementation (`features/authentication/infrastructure/datasources/`)

Create a `NaverAuthDataSource` class.

```dart
import 'package:flutter_naver_login/flutter_naver_login.dart';

class NaverAuthDataSource {
  Future<NaverLoginResult?> login() async {
    return await FlutterNaverLogin.logIn();
  }

  Future<void> logout() async {
    await FlutterNaverLogin.logOut();
  }

  Future<NaverAccountResult?> getUser(NaverAccessToken token) async {
     return await FlutterNaverLogin.currentAccount();
  }
}
```

## 4. Token Storage

**Library**: `flutter_secure_storage`

Create a `TokenStorage` service in `core/` to handle secure storage of tokens.

```dart
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

class TokenStorage {
  final _storage = const FlutterSecureStorage();

  Future<void> saveTokens({required String accessToken, required String refreshToken}) async {
    await _storage.write(key: 'ACCESS_TOKEN', value: accessToken);
    await _storage.write(key: 'REFRESH_TOKEN', value: refreshToken);
  }

  Future<String?> getAccessToken() async {
    return await _storage.read(key: 'ACCESS_TOKEN');
  }

  Future<String?> getRefreshToken() async {
    return await _storage.read(key: 'REFRESH_TOKEN');
  }

  Future<void> deleteAllTokens() async {
    await _storage.deleteAll();
  }
}
```

## 5. Architectural Integration

1.  **Domain Layer (`features/authentication/domain/`)**:
    *   Define an `AuthRepository` interface.
    *   Define `User` and `AuthToken` entities.

    ```dart
    // domain/repositories/auth_repository.dart
    abstract class AuthRepository {
      Future<User?> login(AuthProvider provider);
      Future<void> logout();
      Future<User?> getLoggedInUser();
    }

    enum AuthProvider { kakao, naver }
    ```

2.  **Infrastructure Layer (`features/authentication/infrastructure/`)**:
    *   Implement `AuthRepository` in `AuthRepositoryImpl`.
    *   This implementation will use the `KakaoAuthDataSource` and `NaverAuthDataSource`.
    *   It will also use the `TokenStorage` to save/retrieve tokens.
    *   Map the DTOs from the data sources to the domain `User` entity.

3.  **Application Layer (`features/authentication/application/`)**:
    *   Create a `Notifier` (e.g., `AuthNotifier`) that uses the `AuthRepository`.
    *   The notifier will manage the authentication state (e.g., logged in, logged out, loading).
    *   Expose methods like `login(AuthProvider)` and `logout`.

4.  **Presentation Layer (`features/authentication/presentation/`)**:
    *   The UI will call the methods on the `AuthNotifier`.
    *   Display login buttons and react to state changes from the notifier.

This structure ensures that the UI is decoupled from the specific implementation of Kakao or Naver login, and that token management is handled securely and centrally.
</file>

<file path="01_initial_schema.sql">
-- Initial Schema for GLP-1 Treatment Management MVP
-- Phase 0: Isar local DB structure
-- Phase 1: Supabase PostgreSQL migration

-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================
-- 1. Authentication & User Management
-- ============================================

-- users table
CREATE TABLE users (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    oauth_provider varchar(20) NOT NULL,
    oauth_user_id varchar(255) NOT NULL,
    name varchar(100) NOT NULL,
    email varchar(255) NOT NULL,
    profile_image_url text,
    created_at timestamptz NOT NULL DEFAULT now(),
    last_login_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT unique_oauth_user UNIQUE (oauth_provider, oauth_user_id)
);

CREATE INDEX idx_users_oauth ON users(oauth_provider, oauth_user_id);

-- consent_records table
CREATE TABLE consent_records (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    terms_of_service boolean NOT NULL,
    privacy_policy boolean NOT NULL,
    agreed_at timestamptz NOT NULL DEFAULT now()
);

CREATE INDEX idx_consent_user ON consent_records(user_id);

-- ============================================
-- 2. User Profile & Goals
-- ============================================

-- user_profiles table
CREATE TABLE user_profiles (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    target_weight_kg numeric(5,2) NOT NULL,
    target_period_weeks integer,
    weekly_loss_goal_kg numeric(4,2),
    weekly_weight_record_goal integer NOT NULL DEFAULT 7,
    weekly_symptom_record_goal integer NOT NULL DEFAULT 7,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT unique_user_profile UNIQUE (user_id),
    CONSTRAINT check_target_weight CHECK (target_weight_kg > 0 AND target_weight_kg < 500),
    CONSTRAINT check_weekly_goals CHECK (weekly_weight_record_goal >= 0 AND weekly_weight_record_goal <= 7 AND weekly_symptom_record_goal >= 0 AND weekly_symptom_record_goal <= 7)
);

CREATE INDEX idx_user_profiles_user ON user_profiles(user_id);

-- ============================================
-- 3. Dosage Management
-- ============================================

-- dosage_plans table
CREATE TABLE dosage_plans (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    medication_name varchar(100) NOT NULL,
    start_date date NOT NULL,
    cycle_days integer NOT NULL,
    initial_dose_mg numeric(6,2) NOT NULL,
    escalation_plan jsonb,
    is_active boolean NOT NULL DEFAULT true,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT check_cycle_days CHECK (cycle_days > 0),
    CONSTRAINT check_initial_dose CHECK (initial_dose_mg > 0)
);

CREATE INDEX idx_dosage_plans_user ON dosage_plans(user_id, is_active);

-- plan_change_history table
CREATE TABLE plan_change_history (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dosage_plan_id uuid NOT NULL REFERENCES dosage_plans(id) ON DELETE CASCADE,
    changed_at timestamptz NOT NULL DEFAULT now(),
    old_plan jsonb NOT NULL,
    new_plan jsonb NOT NULL
);

CREATE INDEX idx_plan_history_plan ON plan_change_history(dosage_plan_id, changed_at DESC);

-- dose_schedules table
CREATE TABLE dose_schedules (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dosage_plan_id uuid NOT NULL REFERENCES dosage_plans(id) ON DELETE CASCADE,
    scheduled_date date NOT NULL,
    scheduled_dose_mg numeric(6,2) NOT NULL,
    notification_time time,
    created_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT check_scheduled_dose CHECK (scheduled_dose_mg > 0)
);

CREATE INDEX idx_dose_schedules_plan_date ON dose_schedules(dosage_plan_id, scheduled_date);

-- dose_records table
CREATE TABLE dose_records (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    dose_schedule_id uuid REFERENCES dose_schedules(id) ON DELETE SET NULL,
    dosage_plan_id uuid NOT NULL REFERENCES dosage_plans(id) ON DELETE CASCADE,
    administered_at timestamptz NOT NULL,
    actual_dose_mg numeric(6,2) NOT NULL,
    injection_site varchar(20),
    is_completed boolean NOT NULL DEFAULT true,
    note text,
    created_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT check_actual_dose CHECK (actual_dose_mg > 0),
    CONSTRAINT check_injection_site CHECK (injection_site IN ('복부', '허벅지', '상완') OR injection_site IS NULL)
);

CREATE INDEX idx_dose_records_plan_date ON dose_records(dosage_plan_id, administered_at DESC);
CREATE INDEX idx_dose_records_injection_site ON dose_records(injection_site, administered_at DESC);

-- ============================================
-- 4. Weight & Symptom Tracking
-- ============================================

-- weight_logs table
CREATE TABLE weight_logs (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    log_date date NOT NULL,
    weight_kg numeric(5,2) NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT unique_weight_log UNIQUE (user_id, log_date),
    CONSTRAINT check_weight CHECK (weight_kg > 0 AND weight_kg < 500)
);

CREATE INDEX idx_weight_logs_user_date ON weight_logs(user_id, log_date DESC);

-- symptom_logs table
CREATE TABLE symptom_logs (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    log_date date NOT NULL,
    symptom_name varchar(50) NOT NULL,
    severity integer NOT NULL,
    days_since_escalation integer,
    is_persistent_24h boolean,
    note text,
    created_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT check_severity CHECK (severity >= 1 AND severity <= 10),
    CONSTRAINT check_symptom_name CHECK (symptom_name IN ('메스꺼움', '구토', '변비', '설사', '복통', '두통', '피로'))
);

CREATE INDEX idx_symptom_logs_user_date ON symptom_logs(user_id, log_date DESC);
CREATE INDEX idx_symptom_logs_symptom ON symptom_logs(symptom_name);

-- symptom_context_tags table
CREATE TABLE symptom_context_tags (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    symptom_log_id uuid NOT NULL REFERENCES symptom_logs(id) ON DELETE CASCADE,
    tag_name varchar(50) NOT NULL
);

CREATE INDEX idx_symptom_tags_log ON symptom_context_tags(symptom_log_id);
CREATE INDEX idx_symptom_tags_name ON symptom_context_tags(tag_name);

-- ============================================
-- 5. Emergency Symptom Checks
-- ============================================

-- emergency_symptom_checks table
CREATE TABLE emergency_symptom_checks (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    checked_at timestamptz NOT NULL DEFAULT now(),
    checked_symptoms jsonb NOT NULL
);

CREATE INDEX idx_emergency_checks_user_date ON emergency_symptom_checks(user_id, checked_at DESC);

-- ============================================
-- 6. Achievement & Badges
-- ============================================

-- badge_definitions table (static data)
CREATE TABLE badge_definitions (
    id varchar(50) PRIMARY KEY,
    name varchar(100) NOT NULL,
    description text NOT NULL,
    category varchar(20) NOT NULL,
    achievement_condition jsonb NOT NULL,
    icon_url text,
    display_order integer NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT check_badge_category CHECK (category IN ('streak', 'weight', 'dose', 'record'))
);

CREATE INDEX idx_badge_definitions_category ON badge_definitions(category, display_order);

-- user_badges table
CREATE TABLE user_badges (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    badge_id varchar(50) NOT NULL REFERENCES badge_definitions(id) ON DELETE CASCADE,
    status varchar(20) NOT NULL,
    progress_percentage integer NOT NULL DEFAULT 0,
    achieved_at timestamptz,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT unique_user_badge UNIQUE (user_id, badge_id),
    CONSTRAINT check_badge_status CHECK (status IN ('locked', 'in_progress', 'achieved')),
    CONSTRAINT check_progress CHECK (progress_percentage >= 0 AND progress_percentage <= 100)
);

CREATE INDEX idx_user_badges_user_status ON user_badges(user_id, status);
CREATE INDEX idx_user_badges_user_achieved ON user_badges(user_id, achieved_at DESC);

-- ============================================
-- 7. Updated At Trigger
-- ============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Apply trigger to user_profiles
CREATE TRIGGER update_user_profiles_updated_at BEFORE UPDATE ON user_profiles
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Apply trigger to dosage_plans
CREATE TRIGGER update_dosage_plans_updated_at BEFORE UPDATE ON dosage_plans
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Apply trigger to user_badges
CREATE TRIGGER update_user_badges_updated_at BEFORE UPDATE ON user_badges
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ============================================
-- 8. Comments
-- ============================================

COMMENT ON TABLE users IS 'User account information from OAuth providers';
COMMENT ON TABLE consent_records IS 'User consent records for terms and privacy policy';
COMMENT ON TABLE user_profiles IS 'User profiles including treatment goals';
COMMENT ON TABLE dosage_plans IS 'Medication dosage plans with escalation schedule';
COMMENT ON TABLE plan_change_history IS 'History of changes to dosage plans';
COMMENT ON TABLE dose_schedules IS 'Auto-generated dosage schedule';
COMMENT ON TABLE dose_records IS 'Actual dose administration records';
COMMENT ON TABLE weight_logs IS 'Daily weight tracking records';
COMMENT ON TABLE symptom_logs IS 'Side effect and symptom logs';
COMMENT ON TABLE symptom_context_tags IS 'Context tags for symptoms (e.g., oily food, stress)';
COMMENT ON TABLE emergency_symptom_checks IS 'Emergency symptom checklist records';
COMMENT ON TABLE badge_definitions IS 'Badge definitions for achievement system (static data)';
COMMENT ON TABLE user_badges IS 'User badge achievement status and progress';

-- ============================================
-- 9. RLS Policies (Phase 1)
-- ============================================

-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE consent_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE dosage_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE plan_change_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE dose_schedules ENABLE ROW LEVEL SECURITY;
ALTER TABLE dose_records ENABLE ROW LEVEL SECURITY;
ALTER TABLE weight_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE symptom_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE symptom_context_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE emergency_symptom_checks ENABLE ROW LEVEL SECURITY;
ALTER TABLE badge_definitions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_badges ENABLE ROW LEVEL SECURITY;

-- RLS Policy: Users can only access their own profile
CREATE POLICY users_policy ON users
    FOR ALL
    USING (id = auth.uid());

-- RLS Policy: Users can only access their own consent records
CREATE POLICY consent_records_policy ON consent_records
    FOR ALL
    USING (user_id = auth.uid());

-- RLS Policy: Users can only access their own profile
CREATE POLICY user_profiles_policy ON user_profiles
    FOR ALL
    USING (user_id = auth.uid());

-- RLS Policy: Users can only access their own dosage plans
CREATE POLICY dosage_plans_policy ON dosage_plans
    FOR ALL
    USING (user_id = auth.uid());

-- RLS Policy: Users can only access their own plan history
CREATE POLICY plan_change_history_policy ON plan_change_history
    FOR ALL
    USING (dosage_plan_id IN (SELECT id FROM dosage_plans WHERE user_id = auth.uid()));

-- RLS Policy: Users can only access their own dose schedules
CREATE POLICY dose_schedules_policy ON dose_schedules
    FOR ALL
    USING (dosage_plan_id IN (SELECT id FROM dosage_plans WHERE user_id = auth.uid()));

-- RLS Policy: Users can only access their own dose records
CREATE POLICY dose_records_policy ON dose_records
    FOR ALL
    USING (dosage_plan_id IN (SELECT id FROM dosage_plans WHERE user_id = auth.uid()));

-- RLS Policy: Users can only access their own weight logs
CREATE POLICY weight_logs_policy ON weight_logs
    FOR ALL
    USING (user_id = auth.uid());

-- RLS Policy: Users can only access their own symptom logs
CREATE POLICY symptom_logs_policy ON symptom_logs
    FOR ALL
    USING (user_id = auth.uid());

-- RLS Policy: Users can only access their own symptom tags
CREATE POLICY symptom_context_tags_policy ON symptom_context_tags
    FOR ALL
    USING (symptom_log_id IN (SELECT id FROM symptom_logs WHERE user_id = auth.uid()));

-- RLS Policy: Users can only access their own emergency checks
CREATE POLICY emergency_symptom_checks_policy ON emergency_symptom_checks
    FOR ALL
    USING (user_id = auth.uid());

-- RLS Policy: Badge definitions are readable by all authenticated users
CREATE POLICY badge_definitions_policy ON badge_definitions
    FOR SELECT
    USING (auth.role() = 'authenticated');

-- RLS Policy: Users can only access their own badges
CREATE POLICY user_badges_policy ON user_badges
    FOR ALL
    USING (user_id = auth.uid());
</file>

<file path="code_structure.md">
# Code Structure

## Feature → Requirements 매핑

| 기능 ID | 기능명 | 위치 |
|---------|--------|------|
| F-001 | 소셜 로그인 | `features/authentication/` |
| F000 | 온보딩 | `features/onboarding/` |
| F001 | 투여 스케줄러 | `features/tracking/` |
| F002 | 증상/체중 기록 | `features/tracking/` |
| F003 | 데이터 공유 모드 | `features/data_sharing/` |
| F004 | 대처 가이드 | `features/tracking/` |
| F005 | 증상 체크 | `features/tracking/` |
| F006 | 홈 대시보드 | `features/dashboard/` |

---

## 폴더 구조

### Top Level

```
lib/
├── features/          # 기능별 모듈
│   ├── authentication/
│   ├── onboarding/
│   ├── tracking/      # F001, F002, F004, F005
│   ├── data_sharing/  # F003
│   └── dashboard/     # F006
│
├── core/              # 전역 공통
│   ├── constants/
│   ├── errors/
│   ├── routing/
│   ├── analytics/
│   └── utils/
│
└── main.dart
```

### Core 상세

```
core/
├── constants/
│   ├── app_constants.dart
│   └── ui_constants.dart
├── errors/
│   ├── domain_exception.dart
│   └── repository_exception.dart
├── routing/
│   └── app_router.dart
├── analytics/
│   ├── analytics_service.dart
│   ├── analytics_events.dart
│   └── crashlytics_service.dart
└── utils/
    ├── date_utils.dart
    ├── validators.dart
    └── formatters.dart
```

### Feature 상세 (4-Layer)

```
features/tracking/
├── presentation/      # UI
│   ├── screens/
│   └── widgets/
├── application/       # 상태 관리
│   ├── notifiers/
│   └── providers.dart
├── domain/            # 비즈니스 로직
│   ├── entities/
│   ├── usecases/
│   └── repositories/  # Interface만
└── infrastructure/    # 데이터 접근
    ├── repositories/  # 구현체
    ├── datasources/
    └── dtos/
```

---

## 4-Layer Architecture

**의존성 방향**: Presentation → Application → Domain ← Infrastructure

### Layer 책임

| Layer | 기술 | 책임 |
|-------|------|------|
| **Presentation** | Flutter Widgets | UI 렌더링, 사용자 입력 |
| **Application** | Riverpod Notifier | 상태 관리, UseCase 호출 |
| **Domain** | Pure Dart | 비즈니스 로직, Entity |
| **Infrastructure** | Isar/Supabase | Repository 구현, DB 접근 |

---

## 핵심 패턴

### 1. Repository Pattern

**Interface (Domain Layer)**
```dart
// domain/repositories/medication_repository.dart
abstract class MedicationRepository {
  Stream<List<Dose>> watchDoses();
  Future<void> saveDose(Dose dose);
}
```

**구현체 (Infrastructure Layer)**
```dart
// infrastructure/repositories/isar_medication_repository.dart
class IsarMedicationRepository implements MedicationRepository {
  final Isar isar;

  @override
  Stream<List<Dose>> watchDoses() {
    return isar.doseRecordDtos
      .watchLazy()
      .map((_) => _loadDoses());
  }

  @override
  Future<void> saveDose(Dose dose) async {
    final dto = DoseRecordDto.fromEntity(dose);
    await isar.writeTxn(() => isar.doseRecordDtos.put(dto));
  }
}
```

**DI (Application Layer)**
```dart
// application/providers.dart
@riverpod
MedicationRepository medicationRepository(ref) {
  return IsarMedicationRepository(ref.watch(isarProvider));
}
```

### 2. DTO ↔ Entity

**DTO (Infrastructure)**
```dart
@collection
class DoseRecordDto {
  Id id = Isar.autoIncrement;
  late double doseMg;
  late DateTime administeredAt;

  Dose toEntity() => Dose(
    id: id,
    doseMg: doseMg,
    administeredAt: administeredAt,
  );
}
```

**Entity (Domain)**
```dart
class Dose {
  final int id;
  final double doseMg;
  final DateTime administeredAt;

  Dose({
    required this.id,
    required this.doseMg,
    required this.administeredAt,
  });
}
```

### 3. UseCase (Optional)

```dart
// domain/usecases/recalculate_dose_schedule_usecase.dart
class RecalculateDoseScheduleUseCase {
  final MedicationRepository repository;

  Future<List<DoseSchedule>> execute(DosagePlan plan) async {
    // 비즈니스 로직
    final schedules = _calculate(plan);
    await repository.saveDoseSchedules(schedules);
    return schedules;
  }
}
```

---

## Phase 전환

### Phase 0
```
infrastructure/repositories/
├── medication_repository.dart      # Interface
└── isar_medication_repository.dart # 구현체
```

### Phase 1 추가
```
infrastructure/repositories/
├── medication_repository.dart          # Interface (동일)
├── isar_medication_repository.dart     # 구현체 (유지)
└── supabase_medication_repository.dart # 구현체 (추가)
```

**변경**: Provider DI 1줄만 수정

```dart
// Phase 0 → Phase 1
return IsarMedicationRepository(...)
     ↓
return SupabaseMedicationRepository(...)
```

---

## 규칙

### DO ✅
- Repository Interface를 통한 데이터 접근
- DTO는 Infrastructure, Entity는 Domain
- 비즈니스 로직은 Domain Layer에만
- 여러 Repository 조합은 Application Layer

### DON'T ❌
- Application에서 Isar 직접 접근
- Presentation에서 Repository 직접 호출
- Domain Layer에 Flutter/Isar 의존성
</file>

<file path="database.md">
# Database Schema Design

## Data Flow

### 1. Authentication & Onboarding
```
users → oauth_tokens
users → consent_records
users → user_profiles
```

### 2. Dosage Management
```
dosage_plans → dose_schedules → dose_records
dosage_plans → plan_change_history
```

### 3. Symptom & Weight Tracking
```
symptom_logs → symptom_context_tags
weight_logs
```

### 4. Emergency Checks
```
emergency_symptom_checks
```

### 5. Achievement & Badges
```
badge_definitions (static)
user_badges ← computed from user activity
```

### 6. Dashboard Aggregation (Read)
```
dose_records + weight_logs + symptom_logs + user_badges
→ weekly statistics, insights, badges, timeline
```

---

## Tables

### users
사용자 계정 정보

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | uuid | PK, DEFAULT gen_random_uuid() | 내부 고유 식별자 |
| oauth_provider | varchar(20) | NOT NULL | naver/kakao |
| oauth_user_id | varchar(255) | NOT NULL | 소셜 제공자 사용자 ID |
| name | varchar(100) | NOT NULL | 사용자 이름 |
| email | varchar(255) | NOT NULL | 이메일 |
| profile_image_url | text | NULL | 프로필 이미지 URL |
| created_at | timestamptz | NOT NULL, DEFAULT now() | 가입일시 |
| last_login_at | timestamptz | NOT NULL, DEFAULT now() | 마지막 로그인 일시 |

**Indexes**
- UNIQUE: (oauth_provider, oauth_user_id)

---

### oauth_tokens
인증 토큰 (Supabase Auth 사용 시 불필요, 참고용)

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | uuid | PK, DEFAULT gen_random_uuid() | |
| user_id | uuid | FK(users.id), NOT NULL | |
| access_token | text | NOT NULL | Access Token |
| refresh_token | text | NOT NULL | Refresh Token |
| expires_at | timestamptz | NOT NULL | 토큰 만료 시간 |
| created_at | timestamptz | NOT NULL, DEFAULT now() | |

---

### consent_records
이용약관 동의 정보

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | uuid | PK, DEFAULT gen_random_uuid() | |
| user_id | uuid | FK(users.id), NOT NULL | |
| terms_of_service | boolean | NOT NULL | 이용약관 동의 |
| privacy_policy | boolean | NOT NULL | 개인정보처리방침 동의 |
| agreed_at | timestamptz | NOT NULL, DEFAULT now() | 동의 일시 |

---

### user_profiles
사용자 프로필 및 목표

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | uuid | PK, DEFAULT gen_random_uuid() | |
| user_id | uuid | FK(users.id), UNIQUE, NOT NULL | |
| target_weight_kg | numeric(5,2) | NOT NULL | 목표 체중 |
| target_period_weeks | integer | NULL | 목표 기간 (주) |
| weekly_loss_goal_kg | numeric(4,2) | NULL | 주간 감량 목표 (자동 계산) |
| weekly_weight_record_goal | integer | NOT NULL, DEFAULT 7 | 주간 체중 기록 목표 |
| weekly_symptom_record_goal | integer | NOT NULL, DEFAULT 7 | 주간 부작용 기록 목표 |
| created_at | timestamptz | NOT NULL, DEFAULT now() | |
| updated_at | timestamptz | NOT NULL, DEFAULT now() | |

**Note**: 현재 체중은 weight_logs 테이블에서 최신 기록으로 조회

---

### dosage_plans
투여 계획

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | uuid | PK, DEFAULT gen_random_uuid() | |
| user_id | uuid | FK(users.id), NOT NULL | |
| medication_name | varchar(100) | NOT NULL | 약물명 |
| start_date | date | NOT NULL | 시작일 |
| cycle_days | integer | NOT NULL | 투여 주기 (일) |
| initial_dose_mg | numeric(6,2) | NOT NULL | 초기 용량 (mg) |
| escalation_plan | jsonb | NULL | 증량 계획 [{weeks: 4, dose_mg: 0.5}] |
| is_active | boolean | NOT NULL, DEFAULT true | 활성 여부 |
| created_at | timestamptz | NOT NULL, DEFAULT now() | |
| updated_at | timestamptz | NOT NULL, DEFAULT now() | |

**Indexes**
- INDEX: (user_id, is_active)

---

### plan_change_history
투여 계획 변경 이력

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | uuid | PK, DEFAULT gen_random_uuid() | |
| dosage_plan_id | uuid | FK(dosage_plans.id), NOT NULL | |
| changed_at | timestamptz | NOT NULL, DEFAULT now() | 변경일시 |
| old_plan | jsonb | NOT NULL | 변경 전 계획 |
| new_plan | jsonb | NOT NULL | 변경 후 계획 |

---

### dose_schedules
투여 스케줄 (자동 생성)

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | uuid | PK, DEFAULT gen_random_uuid() | |
| dosage_plan_id | uuid | FK(dosage_plans.id), NOT NULL | |
| scheduled_date | date | NOT NULL | 투여 예정일 |
| scheduled_dose_mg | numeric(6,2) | NOT NULL | 예정 용량 (mg) |
| notification_time | time | NULL | 알림 시간 |
| created_at | timestamptz | NOT NULL, DEFAULT now() | |

**Indexes**
- INDEX: (dosage_plan_id, scheduled_date)

---

### dose_records
투여 기록

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | uuid | PK, DEFAULT gen_random_uuid() | |
| dose_schedule_id | uuid | FK(dose_schedules.id), NULL | 연관 스케줄 (수동 기록 시 NULL) |
| dosage_plan_id | uuid | FK(dosage_plans.id), NOT NULL | |
| administered_at | timestamptz | NOT NULL | 투여일시 |
| actual_dose_mg | numeric(6,2) | NOT NULL | 실제 용량 (mg) |
| injection_site | varchar(20) | NULL | 복부/허벅지/상완 |
| is_completed | boolean | NOT NULL, DEFAULT true | 완료 여부 |
| note | text | NULL | 메모 |
| created_at | timestamptz | NOT NULL, DEFAULT now() | |

**Indexes**
- INDEX: (dosage_plan_id, administered_at)
- INDEX: (injection_site, administered_at DESC)

**Note**: 주사 부위 순환 관리는 injection_site 컬럼과 administered_at을 통해 구현

---

### weight_logs
체중 기록

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | uuid | PK, DEFAULT gen_random_uuid() | |
| user_id | uuid | FK(users.id), NOT NULL | |
| log_date | date | NOT NULL | 기록 날짜 |
| weight_kg | numeric(5,2) | NOT NULL | 체중 (kg) |
| created_at | timestamptz | NOT NULL, DEFAULT now() | 기록 시간 |

**Indexes**
- UNIQUE: (user_id, log_date)
- INDEX: (user_id, log_date DESC)

---

### symptom_logs
부작용 기록

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | uuid | PK, DEFAULT gen_random_uuid() | |
| user_id | uuid | FK(users.id), NOT NULL | |
| log_date | date | NOT NULL | 기록 날짜 |
| symptom_name | varchar(50) | NOT NULL | 메스꺼움/구토/변비/설사/복통/두통/피로 |
| severity | integer | NOT NULL, CHECK (severity >= 1 AND severity <= 10) | 심각도 (1-10) |
| days_since_escalation | integer | NULL | 용량 증량 후 경과일 |
| is_persistent_24h | boolean | NULL | 24시간 이상 지속 여부 |
| note | text | NULL | 메모 |
| created_at | timestamptz | NOT NULL, DEFAULT now() | 기록 시간 |

**Indexes**
- INDEX: (user_id, log_date DESC)

---

### symptom_context_tags
부작용 컨텍스트 태그

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | uuid | PK, DEFAULT gen_random_uuid() | |
| symptom_log_id | uuid | FK(symptom_logs.id), NOT NULL | |
| tag_name | varchar(50) | NOT NULL | 기름진음식/과식/음주/공복/스트레스/수면부족 등 |

**Indexes**
- INDEX: (symptom_log_id)
- INDEX: (tag_name)

---

### emergency_symptom_checks
증상 체크 기록

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | uuid | PK, DEFAULT gen_random_uuid() | |
| user_id | uuid | FK(users.id), NOT NULL | |
| checked_at | timestamptz | NOT NULL, DEFAULT now() | 체크 날짜시간 |
| checked_symptoms | jsonb | NOT NULL | 선택한 증상 목록 |

**Indexes**
- INDEX: (user_id, checked_at DESC)

---

### badge_definitions
뱃지 정의 (정적 데이터)

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | varchar(50) | PK | 뱃지 ID (예: 'streak_7', 'weight_5percent') |
| name | varchar(100) | NOT NULL | 뱃지 이름 |
| description | text | NOT NULL | 뱃지 설명 |
| category | varchar(20) | NOT NULL | 카테고리 (streak/weight/dose/record) |
| achievement_condition | jsonb | NOT NULL | 획득 조건 (JSON 형식) |
| icon_url | text | NULL | 아이콘 이미지 URL |
| display_order | integer | NOT NULL | 표시 순서 |
| created_at | timestamptz | NOT NULL, DEFAULT now() | |

**Indexes**
- INDEX: (category, display_order)

---

### user_badges
사용자별 뱃지 획득 상태

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | uuid | PK, DEFAULT gen_random_uuid() | |
| user_id | uuid | FK(users.id), NOT NULL | |
| badge_id | varchar(50) | FK(badge_definitions.id), NOT NULL | |
| status | varchar(20) | NOT NULL | 미획득(locked)/진행중(in_progress)/획득(achieved) |
| progress_percentage | integer | NOT NULL, DEFAULT 0 | 진행도 (0-100) |
| achieved_at | timestamptz | NULL | 획득 일시 (획득 시에만) |
| created_at | timestamptz | NOT NULL, DEFAULT now() | |
| updated_at | timestamptz | NOT NULL, DEFAULT now() | |

**Indexes**
- UNIQUE: (user_id, badge_id)
- INDEX: (user_id, status)
- INDEX: (user_id, achieved_at DESC)

**Constraints**
- CHECK: status IN ('locked', 'in_progress', 'achieved')
- CHECK: progress_percentage >= 0 AND progress_percentage <= 100

---

## RLS (Row Level Security) Policies

**Phase 1 적용**

모든 테이블에 다음 정책 적용:
```sql
ALTER TABLE {table_name} ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can only access their own data"
ON {table_name}
FOR ALL
USING (user_id = auth.uid());
```

users 테이블:
```sql
CREATE POLICY "Users can only access their own profile"
ON users
FOR ALL
USING (id = auth.uid());
```

---

## Indexes Summary

성능 최적화를 위한 주요 인덱스:

1. **users**: (oauth_provider, oauth_user_id) UNIQUE
2. **dosage_plans**: (user_id, is_active)
3. **dose_schedules**: (dosage_plan_id, scheduled_date)
4. **dose_records**: (dosage_plan_id, administered_at), (injection_site, administered_at DESC)
5. **weight_logs**: (user_id, log_date) UNIQUE, (user_id, log_date DESC)
6. **symptom_logs**: (user_id, log_date DESC)
7. **symptom_context_tags**: (symptom_log_id), (tag_name)
8. **emergency_symptom_checks**: (user_id, checked_at DESC)
9. **badge_definitions**: (category, display_order)
10. **user_badges**: (user_id, badge_id) UNIQUE, (user_id, status), (user_id, achieved_at DESC)

---

## Data Retention

MVP는 무제한 보관.
Phase 2 이후 GDPR 준수를 위해 데이터 보관 정책 수립 필요.

---

## Notes

- 모든 timestamp는 timestamptz 사용 (timezone 고려)
- JSON 필드는 jsonb 사용 (쿼리 성능 최적화)
- Phase 0에서는 Isar 로컬 DB만 사용
- Phase 1에서 Supabase PostgreSQL로 마이그레이션
- Repository Pattern으로 데이터 소스 전환 대비

### 설계 결정 사항

1. **온보딩 시 weight_logs 자동 생성**: 온보딩에서 입력받은 현재 체중을 weight_logs에 첫 기록으로 자동 생성 필요
</file>

<file path="persona.md">
당신의 역할:
        YC 배치 선정된 스타트업 CTO
        
        당신의 목표:
        - MVP 프로젝트를 최대한 빨리 완성하여, 첫번째 프로토타입을 내부 베타테스트한다.
        
        당신이 추구하는 가치:
        - 신속한 개발 iteration을 위해 간결하면서도 확장성 있는 구조를 추구한다.
        - 오버엔지니어링을 피해 당장 해야만하는 작업만 수행한다.
        - 가장 쉬운 인프라를 지향한다.
        
        당신이 추구하지 않는 가치:
        - 매우 높은 트래픽에서도 작동하도록 최적화한다.
        - 모든 보안 취약점을 제거한다.
</file>

<file path="prd.md">
## [GLP-1 치료 관리 MVP] Product Requirements Document (PRD)

---

### I. 제품 개요 (Product Overview)

| 항목 | 내용 |
| :--- | :--- |
| **제품명** | GLP-1 치료 관리 MVP (Phase 0) |
| **목표** | GLP-1 사용자의 복잡한 **개인별 투여 스케줄**을 자동 관리하고, **주요 증상 및 체중 변화 기록**을 데이터 기반 보고서로 자동 생성하여, 환자의 치료 안전성과 의료진과의 커뮤니케이션 효율을 극대화하며, **개인화된 인사이트와 성취 기록을 통해 사용자의 의욕을 촉진하고 지속 가능한 건강한 삶을 영위하도록 돕는다.** |
| **비전** | GLP-1 치료 과정의 불확실성을 해소하고, 사용자가 안전하고 효율적으로 목표에 도달할 수 있도록 돕는 필수적인 디지털 파트너가 되는 동시에, **긍정적인 피드백을 통해 치료 여정을 완주하도록 돕는 동기 부여 엔진**이 된다. |
| **핵심 가치** | **안전성 확보** (투여 스케줄, 응급 증상 체크), **데이터 기반의 효율적인 치료 관리** (F003 데이터 공유 모드), 그리고 **성취감 기반의 동기 부여** (F006 홈 대시보드). |
| **기술 스택** | Flutter + Isar (Local DB) + Supabase (BaaS) + Repository Pattern |

---

### II. Stakeholders

| Stakeholder | 역할 및 핵심 책임 | MVP 관점에서의 기대 사항 |
| :--- | :--- | :--- |
| **CEO/Product Owner** | 제품 비전 및 출시 결정권자 | 핵심 시나리오(SC0-SC4)의 오류 없는 구현과 알파 런칭 일정 준수. |
| **CTO (본인)** | 아키텍처 설계, 개발 총괄 및 리스크 관리 | 간결하고 확장성 있는 구조로 신속한 개발 iteration 달성 및 기술 부채 최소화. |
| **AI Agent/Development Team** | Flutter/BaaS 기반의 명세 구현 | 명확한 기능 상세 명세(F000-F006)를 기반으로 신속하고 안정적인 코드 작성. |
| **Target User (GLP-1 사용자)** | 앱 사용 및 피드백 제공 | 간편한 기록 관리 외에, **지속적인 성취 확인과 긍정적인 메시지를 통해 꾸준히 치료 목표를 달성할 수 있는 동기 부여.** |
| **Medical Professional** | 환자 데이터 기반의 상담 진행 | F003 (데이터 공유 모드)를 통한 명확하고 구조화된 환자 기록 열람. |

---

### III. 포함 페이지 (Included Pages - P0 Scope)

MVP는 최소한의 기능을 구현하는 것을 목표로 하며, 주요 기능(F-001 ~ F006) 진입에 필요한 페이지만 포함한다.

1.  **로그인/가입 화면 (F-001):** 카카오/네이버 소셜 로그인
2.  **온보딩/목표 설정 화면 (F000):** 초기 프로필 및 투여 계획 설정
3.  **홈 대시보드 (F006):** 치료 진행 상황 요약, 퀵 액션 (체중, 증상, 투여)
4.  **기록 화면:**
    *   **체중/증상 기록 화면 (F002):** 간편 입력, F004 (대처 가이드) 연동
    *   **투여 스케줄러 화면 (F001):** 스케줄 관리, 투여 기록, 부위 관리
5.  **안전 관리 화면:**
    *   **증상 체크 화면 (F005):** 심각 증상 체크리스트, 전문가 상담 권장
6.  **데이터 공유 모드 (F003):** 읽기 전용 요약 리포트 전용 화면
7.  **설정 화면:** 프로필/목표 수정, 투여 계획 수정, 로그아웃

---

### IV. 사용자 여정 (User Journey)

| 시나리오 No. | 타겟 유저 Segment | 여정 단계 (페이지 명시) | 핵심 기능 (Feature ID) |
| :--- | :--- | :--- | :--- |
| **SC0. 치료 여정 시작** | GLP-1 처방 후 앱을 처음 사용하는 신규 사용자 | 로그인/가입(F-001) → 온보딩/목표 설정(F000) → 홈 대시보드(F006) | F-001, F000 |
| **SC1. 일상 투여 및 기록** | GLP-1 치료 중 메스꺼움 등 부작용을 겪은 사용자 | (시스템 푸시 알림) → 투여 스케줄러(F001 - 투여 완료) → 체중/증상 기록(F002) → 대처 가이드(F004) → 홈 대시보드(F006) | F001, F002, F004 |
| **SC2. 전문가 상담** | 정기 상담을 앞두고 데이터를 공유해야 하는 사용자 | 홈 대시보드(F006) → 데이터 공유 모드 진입(F003) → (상담 진행) → 공유 종료 → 홈 대시보드(F006) | F003 |
| **SC3. 심각한 증상 대응** | 구토 등 심각한 증상이 24시간 지속되어 불안감을 느끼는 사용자 | 홈 대시보드(F006) → 증상 체크(F005) → (전문가 상담 필요 안내) | F005 |
| **SC4. 일상 동기 부여** | 치료 목표를 꾸준히 달성하고자 하는 사용자 | 홈 대시보드(F006) 접속 → **개인화 인사/뱃지/주간 진행도/리포트/타임라인 확인** → **성취감 획득 및 지속 동기 부여** | F006 |

---

### V. IA (Information Architecture)

MVP의 신속한 개발과 간결한 구조를 위해, 복잡한 탭 구조 대신 핵심 기능 위주로 트리를 구성한다. **핵심은 홈(F006)을 통한 빠른 기록 진입 및 동기 부여 요소 확인이다.**

```mermaid
graph TD
    A[App 시작] --> B(로그인/가입 F-001)
    B --> C(온보딩/목표 설정 F000)
    C --> D[홈 대시보드 F006 (동기 부여 중심)]
    D --> D1[퀵 액션: 체중 기록 F002]
    D --> D2[퀵 액션: 증상 기록 F002]
    D --> D3[퀵 액션: 투여 완료 F001]
    D --> D4[투여 스케줄러 F001]
    D --> D5[트래킹/기록 관리]
    D --> D6[안전/가이드]
    D --> D7[데이터 공유 모드 F003]
    D --> D8[설정]

    D4 --> D4a(주사 부위 순환 관리)

    D5 --> D5a(체중/부작용 상세 이력 F002)
    D5 --> D5b(투여 기록 상세 F001)

    D6 --> D6a(증상 체크 F005)
    D6 --> D6b(부작용 대처 가이드 상세 F004)

    D8 --> D8a(프로필/목표 수정 F000)
    D8 --> D8b(투여 계획 수정 F001)
    D8 --> D8c(로그아웃)
```
</file>

<file path="requirements.md">
# GLP-1 치료 관리 MVP 요구사항 문서 (Phase 0)

## 1. 제품 개요 및 비전

### 1.1. 제품 개요
본 제품은 GLP-1 주사제 사용자들을 위한 디지털 솔루션으로, 복잡한 **개인별 투여 스케줄**을 자동 관리하고, **주요 증상 및 체중 변화 기록**을 데이터 기반의 보고서로 자동 생성하여 의료진과의 커뮤니케이션 효율과 환자의 치료 안전성을 극대화하는 것을 목표로 한다.

### 1.2. 비전
GLP-1 치료 과정에서 발생하는 모든 불확실성(스케줄 혼동, 증상 보고의 비일관성)을 해소하여, 사용자가 안전하고 효율적으로 치료 목표에 도달할 수 있도록 돕는 필수적인 디지털 파트너가 된다.

---

## 2. 타겟 사용자와 핵심 시나리오

### 2.1. 타겟 사용자
GLP-1 주사제를 복용하는 사용자 (자가 투여에 익숙하지만, 스케줄 관리와 데이터 기록에 비효율을 겪는 모든 연령대의 사용자).

### 2.2. 핵심 시나리오 (P0 기능 기반)

| 시나리오 No. | 시나리오 |
| :--- | :--- |
| **SC0. 회원가입 및 온보딩** | 사용자는 GLP-1 치료를 시작하며 관리 앱이 필요함을 느낀다. 앱을 다운로드하고 실행하면 네이버 또는 카카오 로그인 버튼을 확인한다. 평소 사용하는 카카오 계정으로 간편하게 로그인하고, 이용약관에 동의한다. 로그인 완료 후 자동으로 온보딩 화면으로 이동하여 이름, 목표 체중, 현재 체중, 투여 계획 정보를 입력하고 치료 여정을 시작한다. |
| **SC1. 일상 투여 및 기록** | 사용자는 설정된 투여일과 용량 알림을 받고 주사를 투여한다. 투여 후 메스꺼움이 발생하자, 앱에 메스꺼움 강도를 기록하고, 기록 즉시 앱에서 식사 방법, 피해야 할 음식 등의 **실용적인 대처 가이드**를 확인하여 안전하게 관리한다. |
| **SC2. 전문가 상담 시 데이터 공유** | 사용자는 정기 상담일에 맞춰 앱의 **'데이터 공유 모드'**를 활성화한다. 화면에는 지난 기간의 **용량 변화, 체중 변화, 부작용 기록, 순응도**가 깔끔하게 정리되어 표시된다. 사용자는 자신의 스마트폰 화면을 통해 전문가에게 데이터를 보여주며, 데이터 기반의 대화를 진행한다. |
| **SC3. 심각한 증상 대응** | 사용자는 구토가 24시간 이상 지속되고 물도 마실 수 없게 되자 불안해한다. 앱의 **증상 체크** 기능을 통해 해당 증상을 선택하고, 즉시 "전문가와 상담이 필요합니다" 안내를 받는다. 전문가와 상담이 필요함을 인지하고 직접 연락을 취한다. |
| **SC4. 일상 동기 부여 및 진행 확인** | 사용자는 아침에 앱을 열고 홈 화면에서 "3주차 진행 중, 목표까지 5.3kg 남았어요"라는 개인화 인사를 확인한다. 주간 목표 진행도가 85%임을 보고, 오늘 체중만 기록하면 100% 달성임을 인지한다. 미니 차트를 통해 지난주 대비 1.2kg 감소를 확인하고, "현재 추세라면 2개월 내 목표 달성 가능해요"라는 인사이트 메시지를 보며 동기를 얻는다. 획득한 "7일 연속 기록" 뱃지를 확인하며 성취감을 느낀다. |

---

## 3. 기능 상세 명세

---

### F-001: 소셜 로그인 및 인증

**User Story**
- As a 신규/재방문 사용자, I want to 네이버 또는 카카오 계정으로 간편하게 로그인하길, So that 복잡한 회원가입 절차 없이 빠르게 서비스를 이용할 수 있다.

**Acceptance Criteria**
1. 앱 첫 실행 시 로그인 화면 표시:
   - 네이버 로그인 버튼
   - 카카오 로그인 버튼
   - 서비스 소개 문구 및 이용약관/개인정보처리방침 동의 체크박스
2. 네이버 로그인:
   - 네이버 OAuth 2.0 인증 흐름 구현
   - 네이버 로그인 버튼 클릭 시 네이버 인증 페이지로 리디렉션
   - 인증 성공 시 사용자 프로필 정보(이름, 이메일) 수신
   - Access Token 및 Refresh Token 안전하게 저장
3. 카카오 로그인:
   - 카카오 OAuth 2.0 인증 흐름 구현
   - 카카오 로그인 버튼 클릭 시 카카오 인증 페이지로 리디렉션
   - 인증 성공 시 사용자 프로필 정보(이름, 이메일) 수신
   - Access Token 및 Refresh Token 안전하게 저장
4. 최초 로그인 시 자동으로 F000 온보딩 화면으로 이동
5. 재방문 사용자 자동 로그인:
   - 유효한 토큰 존재 시 자동 로그인 처리
   - F006 홈 대시보드로 직접 이동
6. 로그아웃 기능:
   - 설정 메뉴에서 로그아웃 가능
   - 로그아웃 시 저장된 토큰 삭제 및 로그인 화면으로 이동
7. 토큰 갱신:
   - Access Token 만료 시 Refresh Token으로 자동 갱신
   - Refresh Token 만료 시 재로그인 유도
8. 보안:
   - 토큰은 안전한 저장소(Keychain/Keystore)에 저장
   - HTTPS 통신 필수
   - 민감 정보 암호화

**Data Requirements**
- 사용자 계정 정보:
  - 사용자 ID (내부 고유 식별자)
  - 소셜 제공자 (naver/kakao)
  - 소셜 제공자 사용자 ID
  - 이름
  - 이메일
  - 프로필 이미지 URL (선택적)
  - 가입일시
  - 마지막 로그인 일시
- 인증 토큰:
  - Access Token
  - Refresh Token
  - 토큰 만료 시간
- 동의 정보:
  - 이용약관 동의 여부 및 일시
  - 개인정보처리방침 동의 여부 및 일시

---

### F000: 온보딩 및 목표 설정

**User Story**
- As a 신규 사용자, I want to 치료 목표와 투여 계획 정보를 설정하길, So that 명확한 방향성을 갖고 치료 여정을 시작할 수 있다.

**Acceptance Criteria**
1. 최초 앱 실행 시 온보딩 화면에서 기본 정보 입력:
   - 사용자 이름
   - 목표 체중(kg)
   - 현재 체중(kg)
   - 목표 기간(주 단위, 선택 사항)
2. 입력된 정보 기반 주간 평균 감량 목표 자동 계산 및 제시
3. 투여 계획 정보 입력 (약물명, 시작일, 투여 주기, 초기 용량, 증량 계획)
4. 설정 메뉴에서 목표 및 투여 계획 정보 언제든 수정 가능
5. 온보딩 완료 후 F006 홈 대시보드로 이동

**Data Requirements**
- 사용자 프로필: 이름, 가입일
- 목표 정보: 목표 체중(kg), 현재 체중(kg), 목표 기간(주), 주간 감량 목표(자동 계산)
- 투여 계획 정보: 약물명, 시작일, 투여 주기(일), 초기 용량(mg), 증량 계획

---

### F001: 개인화된 투여 스케줄러

**User Story**
- As a GLP-1 사용자, I want to 자동으로 투여 스케줄이 관리되길, So that 투여일을 놓치지 않고 안전하게 치료받을 수 있다.

**Acceptance Criteria**
1. 초기 투여 계획 정보(시작일, 주기, 초기 용량, 증량 계획) 입력 시 전체 스케줄이 1초 이내 자동 생성됨
2. 사용자가 특정 투여일 또는 용량을 수동 변경 시 이후 모든 스케줄이 1초 이내 재계산됨
3. 투여 예정일 당일 지정된 시간에 푸시 알림 발송됨
4. 스케줄은 캘린더 뷰 및 리스트 뷰로 확인 가능함
5. 투여 완료/미완료 상태를 기록할 수 있음
6. 누락 용량 관리 자동 안내:
   - 5일 이내 누락: "즉시 투여하세요" 알림
   - 5일 초과 누락: "다음 예정일까지 대기" 안내 및 경고
7. 주사 부위 순환 관리:
   - 복부/허벅지/상완 부위 선택 및 기록
   - 같은 부위 재사용 시 최소 1주 간격 알림
   - 부위별 투여 이력 시각화
8. 계획 변경 지원:
   - 증량 계획 변경 시 "계획 변경" 기능 제공
   - 새로운 증량 계획 입력 시 이후 스케줄 자동 재계산
   - 변경 이력 자동 기록 (날짜, 변경 전/후 계획)

**Data Requirements**
- 투여 계획 정보: 약물명, 시작일, 투여 주기(일), 초기 용량(mg), 증량 계획
- 투여 기록: 투여일시, 실제 용량(mg), 투여 부위(복부/허벅지/상완), 완료 여부, 메모
- 누락 관리: 누락 일수 자동 계산, 재개 지침 타입(즉시투여/대기)
- 계획 변경 이력: 변경일시, 변경 전 계획, 변경 후 계획

---

### F002: 주요 증상 및 체중 간편 기록

**User Story**
- As a GLP-1 사용자, I want to 체중과 부작용을 간편하게 기록하길, So that 치료 경과를 정확하게 추적하고 의료진과 공유할 수 있다.

**Acceptance Criteria**
1. 체중 기록은 날짜와 체중 값(kg) 입력으로 3회 터치 이내 완료됨
2. 부작용 기록은 증상 선택 + 10점 척도(1-10점) 선택으로 3회 터치 이내 완료됨
3. 기본 부작용 목록: 메스꺼움, 구토, 변비, 설사, 복통, 두통, 피로
4. 날짜별 여러 증상을 동시에 기록 가능함
5. 과거 날짜 기록 수정 및 삭제 가능함
6. 부작용 기록 시 용량 증량 후 경과일 자동 계산 및 표시
7. 심각도 7-10점 입력 시 추가 확인 질문 1개 표시:
   - "이 증상이 24시간 이상 지속되고 있나요?" (예/아니오 선택)
   - "예" 선택 시 F005 증상 체크 화면으로 안내
8. 부작용 기록 시 선택적 컨텍스트 태그 추가:
   - 기본 태그: #기름진음식, #과식, #음주, #공복, #스트레스, #수면부족
   - 사용자 정의 태그 추가 가능
   - 여러 태그 동시 선택 가능
9. 날짜 입력 편의성 개선:
   - "오늘", "어제", "2일 전" 퀵 선택 버튼
   - 미니 캘린더 뷰 제공

**Data Requirements**
- 체중 기록: 날짜, 체중(kg), 기록 시간
- 부작용 기록: 날짜, 증상명, 심각도(1-10), 용량 증량 후 경과일(자동 계산), 기록 시간, 메모, 컨텍스트 태그(다중 선택)

---

### F003: 데이터 공유 모드

**User Story**
- As a GLP-1 사용자, I want to 내 스마트폰 화면을 통해 기록한 데이터를 다른 사람에게 깔끔하게 보여주길, So that 상담 시 파일 전송 없이 간편하게 내 기록을 공유할 수 있다.

**Acceptance Criteria**
1. 앱 내 '기록 보여주기' 버튼 클릭 시 **'데이터 공유 모드'**로 즉시 전환됨
2. 이 모드에서는 개인화된 인사, 뱃지, 설정 등 데이터 확인과 무관한 메뉴와 기능이 모두 숨겨지고, 오직 기록 요약만 깔끔하게 표시됨
3. **모든 편집 기능이 비활성화**되어 실수로 데이터가 변경되는 것을 방지함 (읽기 전용)
4. 보기 편하도록 차트와 텍스트의 가독성을 높인 전용 UI가 제공됨
5. 화면을 스크롤하고 차트를 터치하여 상세 데이터를 확인하는 등 데이터 탐색 가능
6. 사용자가 '공유 종료' 버튼을 누르기 전까지는 다른 앱 화면으로 이동할 수 없음
7. 표시 내용:
   - 기간 내 투여 기록 (날짜, 용량 변화 타임라인)
   - 투여 순응도 (계획 대비 실제 투여 이력)
   - 주사 부위 순환 이력
   - 체중 변화 추이 그래프 (목표 체중 라인 포함)
   - 부작용 강도 추이 그래프 (용량 증량 시점 표시)
   - 부작용 발생 패턴 (컨텍스트 태그별 빈도)
   - 주요 증상 발생 이력 (F005 증상 체크 기록)
8. 표시 기간은 사용자가 선택 가능 (최근 1개월/3개월/전체)

**Data Requirements**
- 입력: F001의 투여 기록, F002의 체중/부작용 기록, F005의 증상 체크 기록
- 출력: 앱 내 읽기 전용 네이티브 화면

---

### F004: 연계형 부작용 대처 가이드

**User Story**
- As a GLP-1 사용자, I want to 부작용 기록 즉시 실용적인 대처 팁을 확인하길, So that 일상에서 증상을 관리하고 불안감을 해소할 수 있다.

**Acceptance Criteria**
1. F002에서 부작용 기록 완료 시 해당 증상의 간단한 대처 가이드가 자동 표시됨
2. 각 증상별 긍정적이고 실용적인 톤의 가정 관리 가이드 제공:
   - 메스꺼움: 식사 방법, 피해야 할 음식, 도움이 되는 음료, 주사 타이밍 조정 팁
   - 구토: 수분 보충 방법, 식사 재개 순서, 회복 단계별 접근법
   - 설사: 권장 식이요법, 수분 및 전해질 관리, 피해야 할 음식
   - 변비: 식이섬유 섭취, 수분 권장량, 신체 활동, 배변 습관 개선
   - 복통: 완화 방법, 식이 조절, 스트레스 관리 기법
   - 두통: 수분 섭취, 휴식 방법, 일상 관리 팁
   - 피로: 휴식 및 회복, 영양 관리, 활동량 조절
3. 기록 후 "도움이 되었나요?" (예/아니오) 피드백 수집:
   - "예" 선택 시: 간단한 감사 메시지 표시
   - "아니오" 선택 시: "다른 팁 보기" 또는 증상 심각 시 "의료진 상담 권장" 안내
4. "더 자세한 가이드 보기" 옵션으로 전체 관리 가이드 접근 가능
5. 상세 가이드는 단계별 구성 (즉시 조치 → 식이 조절 → 생활 습관 → 경과 관찰)
6. 가이드는 증상 기록 화면 또는 별도 가이드 탭에서 언제든 재확인 가능함

**Data Requirements**
- 증상별 대처 가이드 텍스트 (정적 데이터, 간단 버전 + 상세 버전)
- 가이드 피드백 기록 (선택적)

---

### F005: 증상 체크 및 연락 지원

**User Story**
- As a GLP-1 사용자, I want to 심각한 증상 발생 시 빠르게 확인하고 전문가에게 연락하길, So that 안전하게 대처하고 필요한 조치를 신속하게 받을 수 있다.

**Acceptance Criteria**
1. 메인 화면 또는 부작용 관련 영역에 "증상 체크" 진입점 제공 (별도 섹션 또는 안전 도우미 영역)
2. 증상 체크 화면은 체크리스트 형태로 다음 항목을 일상 언어로 제공:
   - "24시간 이상 계속 구토하고 있어요"
   - "물이나 음식을 전혀 삼킬 수 없어요"
   - "매우 심한 복통이 있어요 (견디기 어려운 정도)"
   - "설사가 48시간 이상 계속되고 있어요"
   - "소변이 진한 갈색이거나 8시간 이상 나오지 않았어요"
   - "대변에 피가 섞여 있거나 검은색이에요"
   - "피부나 눈 흰자위가 노랗게 변했어요"
3. 체크리스트에서 하나라도 선택 시 전문가 상담 권장 화면 자동 표시:
   - 선택한 증상 요약
   - "전문가와 상담이 필요합니다" 안내 문구
   - 증상 기록 자동 저장 (F002 연동, 심각도 10점)
4. 체크한 내역은 기록으로 저장 (날짜시간, 선택한 증상)
5. 해당 없는 경우 쉽게 나갈 수 있는 옵션 제공

**Data Requirements**
- 응급 증상 체크리스트 항목 (정적 데이터, 7개 항목)
- 체크 기록: 날짜시간, 체크한 증상 목록

---

### F006: 개인화된 홈 대시보드

**User Story**
- As a GLP-1 사용자, I want to 한눈에 나의 치료 진행 상황과 성취를 확인하길, So that 동기를 유지하고 일상적인 기록 습관을 강화할 수 있다.

**Acceptance Criteria**

**[필수 기능 - P0]**

1. 개인화 인사 영역이 홈 화면 상단에 표시됨:
   - 사용자 이름
   - 연속 기록일 (일 단위, 마지막 기록일 기준)
   - 현재 치료 주차 (투여 시작일 기준 자동 계산)

2. 주간 목표 진행도가 시각화됨:
   - 투여 완료 목표 (주간 예정 투여 횟수 대비 실제 완료 횟수)
   - 체중 기록 목표 (주간 목표 대비 실제 기록 횟수)
   - 부작용 기록 목표 (주간 목표 대비 실제 기록 횟수)
   - 각 목표의 달성률(%)이 진행 바로 표시됨

3. 퀵 액션 버튼 영역 제공:
   - 체중 기록, 부작용 기록, 투여 완료 버튼
   - 각 버튼 클릭 시 해당 기록 화면(F002 또는 F001)으로 직접 이동
   - 터치하기 쉬운 크기와 명확한 라벨 제공

4. 다음 예정 일정 표시:
   - 다음 투여 예정일 및 용량
   - 다음 용량 증량 예정일 (해당 시)
   - 목표 달성 예상 시기 (현재 추세 기반 자동 계산)

5. 주간 리포트 요약:
   - 텍스트 요약: "지난주: 투여 1회, 체중 0.8kg↓, 메스꺼움 2회" 형식
   - 최근 4주 체중 추이 미니 차트 (목표 체중 라인 함께 표시)
   - 최근 1주 부작용 빈도 시각화
   - 용량 적정 순응도 (%)
   - 각 항목 터치 시 상세 화면(F003)으로 이동

6. 치료 여정 타임라인:
   - 치료 시작일부터 현재까지의 진행 상황 시각화
   - 주요 마일스톤 표시 (용량 증량 시점, 체중 감량 목표 달성, 목표 체중 달성 등)
   - 다음 목표까지의 진행도 표시

7. 성취 뱃지 시스템:
   - 획득 조건: 연속 7일 기록, 연속 30일 기록, 체중 5% 감량, 10% 감량, 첫 투여 완료 등
   - 획득한 뱃지와 다음 뱃지까지의 진행도 표시
   - 뱃지 획득 시 알림 제공
   - 뱃지 목록 및 획득 조건 확인 가능

8. 시각적 피드백 제공:
   - 투여 완료 시 축하 효과 표시
   - 주간 목표 100% 달성 시 시각적 강조
   - 사용자 인터랙션에 부드러운 전환 효과

**[향상 기능 - P1]**

9. 데이터 기반 인사이트 자동 생성:
   - 체중 변화: 전주 대비 1% 이상 감소 시 긍정적 변화 메시지
   - 연속 기록: 7일 이상 달성 시 격려 메시지
   - 부작용 개선: 전주 대비 평균 강도 2점 이상 감소 시 안내 메시지
   - 컨텍스트 패턴: 특정 태그와 증상 상관관계 발견 시 맞춤형 제안 (예: "#기름진음식과 메스꺼움이 자주 기록되었어요")
   - 목표 진행: 현재 추세 기반 목표 달성 가능성 안내 (예: "현재 추세라면 2개월 내 목표 달성 가능해요")
   - 투여 순응도: 투여 누락 시 체중 변화 상관관계 안내 (예: "투여를 거른 주에는 체중 변화가 적었어요")
   - 해당 조건 없을 시 일반 격려 메시지 표시

**Data Requirements**

**[P0 데이터]**
- 사용자 프로필: 이름, 치료 시작일, 가입일
- 목표 진행도 (F000 연동):
  - 목표 체중(kg), 현재 체중(kg), 남은 체중(kg)
  - 목표 달성 예상일 (현재 추세 기반 자동 계산)
- 연속 기록일 계산:
  - 마지막 기록 날짜(F002)부터 현재까지 일수
  - 기록 없는 날 발생 시 0으로 리셋
- 주간 목표 설정:
  - 투여 목표: F001 스케줄 기반 (주간 예정 투여 횟수)
  - 체중 기록 목표: 기본값 7회/주 (사용자 설정 가능)
  - 부작용 기록 목표: 기본값 7회/주 (사용자 설정 가능)
- 뱃지 데이터:
  - 뱃지 정의 목록 (ID, 이름, 설명, 획득 조건, 아이콘 정보)
  - 사용자별 뱃지 획득 상태 (미획득/진행중/획득)
  - 각 뱃지별 진행도 (%)
  - 뱃지 획득 날짜
- 타임라인 데이터:
  - 치료 시작일, 현재 용량, 다음 증량 예정일 (F001 연동)
  - 주요 이벤트 기록 (용량 증량, 목표 달성 등)
- 주간 리포트 데이터:
  - 지난 주 투여 완료 횟수, 체중 변화량, 부작용 기록 횟수
  - 최근 4주 체중 기록 및 목표 체중 (F002, F000 연동)
  - 최근 1주 부작용 기록 (F002)
  - 투여 완료 이력 (F001)

**[P1 데이터]**
- 인사이트 생성 데이터:
  - 전주(최근 7일) 대비 체중 변화율 (%)
  - 전주 대비 부작용 평균 강도 변화
  - 연속 기록일 수
  - 컨텍스트 태그와 증상 상관관계 (F002 연동)
  - 투여 순응도와 체중 변화 상관관계 (F001, F002 연동)
</file>

<file path="state-management.md">
# State Management Design (Flutter/Riverpod)

> GLP-1 치료 관리 MVP의 상태 관리 설계. Riverpod 2.x + 4-Layer Architecture + Repository Pattern.

---

## 1. State Inventory

| Category | State | Type | Feature | Description |
|----------|-------|------|---------|-------------|
| **Domain** | User | `User` | Auth | 사용자 계정 정보 |
| **Domain** | UserProfile | `UserProfile` | F000 | 목표 체중, 주간 목표 설정 |
| **Domain** | DosagePlan | `DosagePlan` | F001 | 투여 계획 |
| **Domain** | DoseSchedule | `List<DoseSchedule>` | F001 | 투여 스케줄 목록 |
| **Domain** | DoseRecord | `List<DoseRecord>` | F001 | 투여 완료 기록 |
| **Domain** | WeightLog | `List<WeightLog>` | F002 | 체중 기록 |
| **Domain** | SymptomLog | `List<SymptomLog>` | F002 | 증상 기록 |
| **Domain** | EmergencySymptomCheck | `List<EmergencySymptomCheck>` | F005 | 심각 증상 체크 기록 |
| **Domain** | BadgeDefinition | `List<BadgeDefinition>` | F006 | 뱃지 정의 (정적) |
| **Domain** | UserBadge | `List<UserBadge>` | F006 | 사용자 뱃지 획득 현황 |
| **Domain** | CopingGuide | `CopingGuide` | F004 | 증상별 대처 가이드 (정적) |
| **UI** | AuthState | `AsyncValue<User?>` | Auth | 인증 상태 |
| **UI** | OnboardingState | `AsyncValue<void>` | F000 | 온보딩 완료 상태 |
| **UI** | DashboardState | `AsyncValue<DashboardData>` | F006 | 대시보드 통합 상태 |
| **UI** | DataSharingMode | `bool` | F003 | 데이터 공유 모드 활성화 |
| **UI** | NotificationEnabled | `bool` | UF-012 | 알림 활성화 상태 |
| **Form** | WeightInput | `double?` | F002 | 체중 입력값 |
| **Form** | SymptomInput | `{String symptomName, int severity, List<String> tags}` | F002 | 증상 입력값 |
| **Form** | DoseInput | `{DateTime date, double doseMg, String? site}` | F001 | 투여 입력값 |
| **Form** | ProfileEditForm | `{String name, double targetWeight, int? periodWeeks}` | UF-008 | 프로필 수정 폼 |
| **Derived** | TodayDoses | `List<DoseRecord>` | F001 | 오늘 투여 기록 (DoseRecord 필터링) |
| **Derived** | WeeklyProgress | `WeeklyGoalProgress` | F006 | 주간 목표 달성률 (기록 개수 계산) |
| **Derived** | ContinuousRecordDays | `int` | F006 | 연속 기록일 (기록 날짜 계산) |
| **Derived** | CurrentWeek | `int` | F006 | 현재 치료 주차 (시작일 기준 계산) |
| **Derived** | InsightMessage | `String?` | F006 | 인사이트 메시지 (데이터 분석 결과) |

---

## 2. State Transitions

| Current State | Trigger | Next State | UI Impact |
|---------------|---------|------------|-----------|
| `AsyncValue.loading()` | 로그인 성공 | `AsyncValue.data(User)` | 홈 대시보드 진입 |
| `AsyncValue.data(User)` | 로그아웃 | `AsyncValue.data(null)` | 로그인 화면 전환 |
| `AsyncValue.loading()` | 온보딩 완료 | `AsyncValue.data(void)` | 투여 계획 생성, 홈 진입 |
| `AsyncValue.data(doses)` | 투여 기록 추가 | `AsyncValue.loading() → data` | 리스트 갱신, 달성률 업데이트 |
| `AsyncValue.data(weights)` | 체중 기록 추가 | `AsyncValue.loading() → data` | 차트 갱신, 대시보드 리렌더링 |
| `AsyncValue.data(symptoms)` | 증상 기록 추가 | `AsyncValue.loading() → data` | 가이드 표시 자동 |
| `DataSharingMode: false` | 공유 모드 활성화 | `DataSharingMode: true` | 읽기 전용 UI 전환 |
| `DataSharingMode: true` | 공유 모드 종료 | `DataSharingMode: false` | 일반 화면 복귀 |
| `AsyncValue.data(plan)` | 투여 계획 수정 | `AsyncValue.loading() → data` | 스케줄 재계산, 대시보드 갱신 |
| `AsyncValue.data(badges)` | 뱃지 조건 달성 | `AsyncValue.data(badges + new)` | 획득 알림 표시 |
| `AsyncValue.data(profile)` | 프로필 수정 | `AsyncValue.loading() → data` | 목표 재계산, 대시보드 갱신 |
| `AsyncValue.data(record)` | 기록 삭제 | `AsyncValue.loading() → data` | 목록 갱신, 통계 재계산 |

---

## 3. Provider Structure

```mermaid
graph TD
    %% Global Providers
    IsarProvider[Provider: isarProvider]
    AuthRepo[Provider: authRepositoryProvider]
    MedicationRepo[Provider: medicationRepositoryProvider]
    TrackingRepo[Provider: trackingRepositoryProvider]
    ProfileRepo[Provider: profileRepositoryProvider]
    BadgeRepo[Provider: badgeRepositoryProvider]

    %% Feature Providers
    AuthNotifier[AsyncNotifierProvider: authNotifierProvider]
    OnboardingNotifier[AsyncNotifierProvider: onboardingNotifierProvider]
    MedicationNotifier[AsyncNotifierProvider: medicationNotifierProvider]
    TrackingNotifier[AsyncNotifierProvider: trackingNotifierProvider]
    ProfileNotifier[AsyncNotifierProvider: profileNotifierProvider]
    DashboardNotifier[AsyncNotifierProvider: dashboardNotifierProvider]
    DataSharingNotifier[NotifierProvider: dataSharingNotifierProvider]

    %% Derived Providers
    TodayDosesProvider[Provider: todayDosesProvider]
    WeeklyProgressProvider[Provider: weeklyProgressProvider]
    ContinuousDaysProvider[Provider: continuousRecordDaysProvider]

    %% Dependencies
    IsarProvider --> AuthRepo
    IsarProvider --> MedicationRepo
    IsarProvider --> TrackingRepo
    IsarProvider --> ProfileRepo
    IsarProvider --> BadgeRepo

    AuthRepo --> AuthNotifier
    ProfileRepo --> OnboardingNotifier
    ProfileRepo --> ProfileNotifier
    MedicationRepo --> MedicationNotifier
    TrackingRepo --> TrackingNotifier

    MedicationRepo --> DashboardNotifier
    TrackingRepo --> DashboardNotifier
    BadgeRepo --> DashboardNotifier
    ProfileRepo --> DashboardNotifier

    MedicationNotifier --> TodayDosesProvider
    TrackingNotifier --> WeeklyProgressProvider
    TrackingNotifier --> ContinuousDaysProvider
    DashboardNotifier --> DataSharingNotifier
```

**Provider 선택 기준:**
- `Provider`: Repository, Service (불변)
- `StateNotifierProvider`: 동기 상태 변경
- `AsyncNotifierProvider`: 비동기 CRUD
- `StreamProvider`: Isar watch (실시간 동기화)
- `FutureProvider`: 일회성 비동기 로드

---

## 4. State Classes

### Auth Feature

```dart
// domain/entities/user.dart
class User {
  final String id;
  final String name;
  final String email;
  final String? profileImageUrl;

  User({required this.id, required this.name, required this.email, this.profileImageUrl});
}
```

### Onboarding Feature (F000)

```dart
// domain/entities/user_profile.dart
class UserProfile {
  final String userId;
  final double targetWeightKg;
  final double? targetPeriodWeeks;
  final double? weeklyLossGoalKg;
  final int weeklyWeightRecordGoal;
  final int weeklySymptomRecordGoal;

  UserProfile({
    required this.userId,
    required this.targetWeightKg,
    this.targetPeriodWeeks,
    this.weeklyLossGoalKg,
    this.weeklyWeightRecordGoal = 7,
    this.weeklySymptomRecordGoal = 7,
  });
}

// domain/entities/dosage_plan.dart
class DosagePlan {
  final String id;
  final String userId;
  final String medicationName;
  final DateTime startDate;
  final int cycleDays;
  final double initialDoseMg;
  final List<EscalationStep>? escalationPlan;
  final bool isActive;

  DosagePlan({
    required this.id,
    required this.userId,
    required this.medicationName,
    required this.startDate,
    required this.cycleDays,
    required this.initialDoseMg,
    this.escalationPlan,
    this.isActive = true,
  });
}
```

### Medication Feature (F001)

```dart
// domain/entities/dose_schedule.dart
class DoseSchedule {
  final String id;
  final String dosagePlanId;
  final DateTime scheduledDate;
  final double scheduledDoseMg;
  final TimeOfDay? notificationTime;

  DoseSchedule({
    required this.id,
    required this.dosagePlanId,
    required this.scheduledDate,
    required this.scheduledDoseMg,
    this.notificationTime,
  });
}

// domain/entities/dose_record.dart
class DoseRecord {
  final String id;
  final String? doseScheduleId;
  final String dosagePlanId;
  final DateTime administeredAt;
  final double actualDoseMg;
  final String? injectionSite; // 복부/허벅지/상완
  final bool isCompleted;
  final String? note;

  DoseRecord({
    required this.id,
    this.doseScheduleId,
    required this.dosagePlanId,
    required this.administeredAt,
    required this.actualDoseMg,
    this.injectionSite,
    this.isCompleted = true,
    this.note,
  });
}

// application/notifiers/medication_notifier.dart
class MedicationState {
  final AsyncValue<DosagePlan?> activePlan;
  final AsyncValue<List<DoseSchedule>> schedules;
  final AsyncValue<List<DoseRecord>> records;

  MedicationState({
    required this.activePlan,
    required this.schedules,
    required this.records,
  });
}
```

### Tracking Feature (F002)

```dart
// domain/entities/weight_log.dart
class WeightLog {
  final String id;
  final String userId;
  final DateTime logDate;
  final double weightKg;
  final DateTime createdAt;

  WeightLog({
    required this.id,
    required this.userId,
    required this.logDate,
    required this.weightKg,
    required this.createdAt,
  });
}

// domain/entities/symptom_log.dart
class SymptomLog {
  final String id;
  final String userId;
  final DateTime logDate;
  final String symptomName;
  final int severity; // 1-10
  final int? daysSinceEscalation;
  final bool? isPersistent24h;
  final String? note;
  final List<String> tags;

  SymptomLog({
    required this.id,
    required this.userId,
    required this.logDate,
    required this.symptomName,
    required this.severity,
    this.daysSinceEscalation,
    this.isPersistent24h,
    this.note,
    this.tags = const [],
  });
}

// application/notifiers/tracking_notifier.dart
class TrackingState {
  final AsyncValue<List<WeightLog>> weights;
  final AsyncValue<List<SymptomLog>> symptoms;

  TrackingState({required this.weights, required this.symptoms});
}
```

### Dashboard Feature (F006)

```dart
// application/notifiers/dashboard_notifier.dart
class DashboardData {
  final String userName;
  final int continuousRecordDays;
  final int currentWeek;
  final WeeklyProgress weeklyProgress;
  final NextSchedule nextSchedule;
  final WeeklySummary weeklySummary;
  final List<UserBadge> badges;
  final List<TimelineEvent> timeline;
  final String? insightMessage;

  DashboardData({
    required this.userName,
    required this.continuousRecordDays,
    required this.currentWeek,
    required this.weeklyProgress,
    required this.nextSchedule,
    required this.weeklySummary,
    required this.badges,
    required this.timeline,
    this.insightMessage,
  });
}

class WeeklyProgress {
  final int doseCompletedCount;
  final int doseTargetCount;
  final double doseRate; // 0.0 ~ 1.0
  final int weightRecordCount;
  final int weightTargetCount;
  final double weightRate;
  final int symptomRecordCount;
  final int symptomTargetCount;
  final double symptomRate;

  WeeklyProgress({
    required this.doseCompletedCount,
    required this.doseTargetCount,
    required this.doseRate,
    required this.weightRecordCount,
    required this.weightTargetCount,
    required this.weightRate,
    required this.symptomRecordCount,
    required this.symptomTargetCount,
    required this.symptomRate,
  });
}
```

### Emergency Feature (F005)

```dart
// domain/entities/emergency_symptom_check.dart
class EmergencySymptomCheck {
  final String id;
  final String userId;
  final DateTime checkedAt;
  final List<String> checkedSymptoms;

  EmergencySymptomCheck({
    required this.id,
    required this.userId,
    required this.checkedAt,
    required this.checkedSymptoms,
  });
}
```

### Data Sharing Feature (F003)

```dart
// application/notifiers/data_sharing_notifier.dart
class DataSharingState {
  final bool isActive;
  final DateRange? selectedPeriod;

  DataSharingState({this.isActive = false, this.selectedPeriod});
}
```

---

## 5. Provider Signatures

### Global Providers

```dart
// infrastructure/providers.dart
@riverpod
Isar isar(IsarRef ref);

@riverpod
AuthRepository authRepository(AuthRepositoryRef ref);

@riverpod
MedicationRepository medicationRepository(MedicationRepositoryRef ref);

@riverpod
TrackingRepository trackingRepository(TrackingRepositoryRef ref);

@riverpod
ProfileRepository profileRepository(ProfileRepositoryRef ref);

@riverpod
BadgeRepository badgeRepository(BadgeRepositoryRef ref);
```

### Auth Feature

```dart
// application/notifiers/auth_notifier.dart
@riverpod
class AuthNotifier extends _$AuthNotifier {
  @override
  Future<User?> build();
  Future<void> loginWithKakao();
  Future<void> loginWithNaver();
  Future<void> logout();
}
```

### Onboarding Feature (F000)

```dart
// application/notifiers/onboarding_notifier.dart
@riverpod
class OnboardingNotifier extends _$OnboardingNotifier {
  @override
  Future<void> build();
  Future<void> saveOnboardingData({
    required String name,
    required double currentWeight,
    required double targetWeight,
    int? targetPeriodWeeks,
    required String medicationName,
    required DateTime startDate,
    required int cycleDays,
    required double initialDose,
    List<EscalationStep>? escalationPlan,
  });
}
```

### Medication Feature (F001)

```dart
// application/notifiers/medication_notifier.dart
@riverpod
class MedicationNotifier extends _$MedicationNotifier {
  @override
  Future<MedicationState> build();
  Future<void> recordDose(DoseRecord dose);
  Future<void> updateSchedule(String scheduleId, DateTime newDate);
  Future<void> updateDosagePlan(DosagePlan plan);
  Future<void> deleteDoseRecord(String recordId);
}

@riverpod
List<DoseRecord> todayDoses(TodayDosesRef ref);
```

### Tracking Feature (F002)

```dart
// application/notifiers/tracking_notifier.dart
@riverpod
class TrackingNotifier extends _$TrackingNotifier {
  @override
  Future<TrackingState> build();
  Future<void> saveWeightLog(WeightLog log);
  Future<void> saveSymptomLog(SymptomLog log);
  Future<void> deleteWeightLog(String id);
  Future<void> deleteSymptomLog(String id);
  Future<void> updateWeightLog(String id, double newWeight);
  Future<void> updateSymptomLog(String id, SymptomLog updatedLog);
}

@riverpod
int continuousRecordDays(ContinuousRecordDaysRef ref);
```

### Dashboard Feature (F006)

```dart
// application/notifiers/dashboard_notifier.dart
@riverpod
class DashboardNotifier extends _$DashboardNotifier {
  @override
  Future<DashboardData> build();
  Future<void> refresh();
}

@riverpod
WeeklyProgress weeklyProgress(WeeklyProgressRef ref);

@riverpod
String? insightMessage(InsightMessageRef ref);
```

### Profile Feature (UF-008)

```dart
// application/notifiers/profile_notifier.dart
@riverpod
class ProfileNotifier extends _$ProfileNotifier {
  @override
  Future<UserProfile> build();
  Future<void> updateProfile(UserProfile profile);
  Future<void> updateWeeklyGoals(int weightGoal, int symptomGoal);
}
```

### Data Sharing Feature (F003)

```dart
// application/notifiers/data_sharing_notifier.dart
@riverpod
class DataSharingNotifier extends _$DataSharingNotifier {
  @override
  DataSharingState build();
  void enterSharingMode(DateRange period);
  void exitSharingMode();
}
```

### Emergency Feature (F005)

```dart
// application/notifiers/emergency_notifier.dart
@riverpod
class EmergencyNotifier extends _$EmergencyNotifier {
  @override
  Future<List<EmergencySymptomCheck>> build();
  Future<void> saveSymptomCheck(List<String> symptoms);
}
```

---

## 6. Initial State

```dart
// Auth
const initialAuthState = AsyncValue<User?>.loading();

// Medication
const initialMedicationState = MedicationState(
  activePlan: AsyncValue.loading(),
  schedules: AsyncValue.loading(),
  records: AsyncValue.loading(),
);

// Tracking
const initialTrackingState = TrackingState(
  weights: AsyncValue.loading(),
  symptoms: AsyncValue.loading(),
);

// Dashboard
const initialDashboardState = AsyncValue<DashboardData>.loading();

// Data Sharing
const initialDataSharingState = DataSharingState(isActive: false);
```

---

## 7. Repository Integration Patterns

### Pattern 1: AsyncNotifier + CRUD

```dart
@riverpod
class MedicationNotifier extends _$MedicationNotifier {
  @override
  Future<MedicationState> build() async {
    final repository = ref.watch(medicationRepositoryProvider);
    final plan = await repository.getActiveDosagePlan();
    final schedules = await repository.getDoseSchedules(plan?.id);
    final records = await repository.getDoseRecords(plan?.id);

    return MedicationState(
      activePlan: AsyncValue.data(plan),
      schedules: AsyncValue.data(schedules),
      records: AsyncValue.data(records),
    );
  }

  Future<void> recordDose(DoseRecord dose) async {
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(medicationRepositoryProvider);
      await repository.saveDoseRecord(dose);

      // 재조회
      final plan = await repository.getActiveDosagePlan();
      final schedules = await repository.getDoseSchedules(plan?.id);
      final records = await repository.getDoseRecords(plan?.id);

      return MedicationState(
        activePlan: AsyncValue.data(plan),
        schedules: AsyncValue.data(schedules),
        records: AsyncValue.data(records),
      );
    });
  }
}
```

### Pattern 2: StreamProvider (실시간 동기화)

```dart
@riverpod
Stream<List<WeightLog>> weightLogsStream(WeightLogsStreamRef ref) {
  final repository = ref.watch(trackingRepositoryProvider);
  return repository.watchWeightLogs();
}
```

### Pattern 3: Derived Provider (계산 상태)

```dart
@riverpod
int continuousRecordDays(ContinuousRecordDaysRef ref) {
  final trackingState = ref.watch(trackingNotifierProvider).value;
  if (trackingState == null) return 0;

  final allLogs = [
    ...trackingState.weights.value ?? [],
    ...trackingState.symptoms.value ?? [],
  ];

  if (allLogs.isEmpty) return 0;

  // 연속 기록일 계산 로직
  final sortedDates = allLogs
      .map((log) => log.logDate)
      .toSet()
      .toList()
    ..sort((a, b) => b.compareTo(a));

  final today = DateTime.now();
  int days = 0;

  for (var date in sortedDates) {
    if (date.difference(today.subtract(Duration(days: days))).inDays == 0) {
      days++;
    } else {
      break;
    }
  }

  return days;
}
```

---

## 8. Repository Interface 예시

```dart
// domain/repositories/medication_repository.dart
abstract class MedicationRepository {
  Future<DosagePlan?> getActiveDosagePlan();
  Future<List<DoseSchedule>> getDoseSchedules(String? planId);
  Future<List<DoseRecord>> getDoseRecords(String? planId);
  Future<void> saveDosagePlan(DosagePlan plan);
  Future<void> saveDoseRecord(DoseRecord record);
  Future<void> updateDosagePlan(DosagePlan plan);
  Future<void> deleteDoseRecord(String id);
  Stream<List<DoseRecord>> watchDoseRecords();
}

// domain/repositories/tracking_repository.dart
abstract class TrackingRepository {
  Future<List<WeightLog>> getWeightLogs();
  Future<List<SymptomLog>> getSymptomLogs();
  Future<void> saveWeightLog(WeightLog log);
  Future<void> saveSymptomLog(SymptomLog log);
  Future<void> deleteWeightLog(String id);
  Future<void> deleteSymptomLog(String id);
  Future<void> updateWeightLog(String id, double newWeight);
  Future<void> updateSymptomLog(String id, SymptomLog updatedLog);
  Stream<List<WeightLog>> watchWeightLogs();
  Stream<List<SymptomLog>> watchSymptomLogs();
}
```

**Phase 전환 전략:**
- Repository Interface만 의존
- Infrastructure Layer에서 `IsarMedicationRepository` / `SupabaseMedicationRepository` 구현
- Provider DI 변경만으로 전환 완료

---

## 9. 핵심 원칙

### DO ✅
- Repository Interface만 의존, 구현 분리
- DTO는 Infrastructure, Entity는 Domain
- 비즈니스 로직은 Domain Layer에만
- 모든 Repository 호출은 Application Layer
- 모든 비동기 상태는 `AsyncValue<T>` 사용

### DON'T ❌
- Application에서 Isar 직접 사용
- Presentation에서 Repository 직접 호출
- Domain Layer에 Flutter/Isar 의존성
- Provider 의존성 순환
</file>

<file path="tdd.md">
# TDD Process Guidelines - Cursor Rules

## ⚠️ MANDATORY: Follow these rules for EVERY implementation and modification

**This document defines the REQUIRED process for all code changes. No exceptions without explicit team approval.**

## Core Cycle: Red → Green → Refactor

### 1. RED Phase
- Write a failing test FIRST
- Test the simplest scenario
- Verify test fails for the right reason
- One test at a time

### 2. GREEN Phase  
- Write MINIMAL code to pass
- "Fake it till you make it" is OK
- No premature optimization
- YAGNI principle

### 3. REFACTOR Phase
- Remove duplication
- Improve naming
- Simplify structure
- Keep tests passing

## Test Quality: FIRST Principles
- **Fast**: Milliseconds, not seconds
- **Independent**: No shared state
- **Repeatable**: Same result every time
- **Self-validating**: Pass/fail, no manual checks
- **Timely**: Written just before code

## Test Structure: AAA Pattern
```
// Arrange
Set up test data and dependencies

// Act
Execute the function/method

// Assert
Verify expected outcome
```

## Implementation Flow
1. **List scenarios** before coding
2. **Pick one scenario** → Write test
3. **Run test** → See it fail (Red)
4. **Implement** → Make it pass (Green)
5. **Refactor** → Clean up (Still Green)
6. **Commit** → Small, frequent commits
7. **Repeat** → Next scenario

## Test Pyramid Strategy
- **Unit Tests** (70%): Fast, isolated, numerous
- **Integration Tests** (20%): Module boundaries
- **Acceptance Tests** (10%): User scenarios

## Outside-In vs Inside-Out
- **Outside-In**: Start with user-facing test → Mock internals → Implement details
- **Inside-Out**: Start with core logic → Build outward → Integrate components

## Common Anti-patterns to Avoid
- Testing implementation details
- Fragile tests tied to internals  
- Missing assertions
- Slow, environment-dependent tests
- Ignored failing tests

## When Tests Fail
1. **Identify**: Regression, flaky test, or spec change?
2. **Isolate**: Narrow down the cause
3. **Fix**: Code bug or test bug
4. **Learn**: Add missing test cases

## Team Practices
- CI/CD integration mandatory
- No merge without tests
- Test code = Production code quality
- Pair programming for complex tests
- Regular test refactoring

## Pragmatic Exceptions
- UI/Graphics: Manual + snapshot tests
- Performance: Benchmark suites
- Exploratory: Spike then test
- Legacy: Test on change

## Remember
- Tests are living documentation
- Test behavior, not implementation
- Small steps, fast feedback
- When in doubt, write a test
</file>

<file path="userflow.md">
# Userflow

## UF-F-001: 소셜 로그인 및 인증

### 입력
- 사용자가 앱 최초 실행
- 네이버 또는 카카오 로그인 버튼 선택
- 이용약관/개인정보처리방침 동의 체크박스 선택
- OAuth 제공자 인증 페이지에서 로그인 정보 입력 및 승인

### 처리
1. 앱 실행 시 토큰 존재 여부 확인
   - 유효한 토큰 존재: 자동 로그인 처리 후 홈 대시보드로 이동
   - 토큰 없음 또는 만료: 로그인 화면 표시
2. 사용자가 소셜 로그인 버튼 클릭
3. 동의 체크박스 미선택 시 버튼 비활성화 유지
4. 동의 완료 후 선택한 제공자의 OAuth 인증 흐름 시작
5. 사용자의 동의 정보를 내부 DB에 기록
   - 이용약관 동의 여부 및 동의 일시
   - 개인정보처리방침 동의 여부 및 동의 일시
6. 인증 성공 시 사용자 프로필 정보 수신
7. Access Token, Refresh Token, 토큰 만료 시간을 안전한 저장소에 저장
8. 내부 DB에 사용자 계정 정보 저장 또는 업데이트
9. 가입일시/마지막 로그인 일시 기록
10. 최초 로그인 여부 확인
   - 최초 로그인: 온보딩 화면으로 이동
   - 재방문 사용자: 홈 대시보드로 이동

### 출력
- 로그인 성공 시 온보딩 화면 또는 홈 대시보드 화면으로 전환
- 인증 실패 시 에러 메시지 표시 및 재시도 유도
- 네트워크 오류 시 연결 확인 안내

### 엣지케이스
- OAuth 인증 과정 중 사용자가 취소: 로그인 화면 유지, 안내 메시지 표시
- Access Token 만료 시: Refresh Token으로 자동 갱신 시도
- Refresh Token 만료 시: 재로그인 유도
- 동시에 여러 기기에서 로그인: 각 기기의 세션 독립적으로 유지
- 네트워크 불안정 시: 재시도 로직 실행 (최대 3회)
- OAuth 제공자 서버 오류: 사용자에게 안내 후 다른 로그인 방법 제안

---

## UF-F000: 온보딩 및 목표 설정

### 입력
- 사용자 이름 입력
- 목표 체중 입력 (kg 단위)
- 현재 체중 입력 (kg 단위)
- 목표 기간 입력 (주 단위, 선택 사항)
- 약물명 입력
- 투여 시작일 선택
- 투여 주기 입력 (일 단위)
- 초기 용량 입력 (mg 단위)
- 증량 계획 입력 (용량, 시기)

### 처리
1. 온보딩 화면 표시
2. 사용자 정보 입력 필드 검증
   - 이름: 비어있지 않은지 확인
   - 목표/현재 체중: 양수 값, 현실적 범위 확인
   - 목표 기간: 양수 값 또는 미입력
3. 목표 기간 입력된 경우 주간 평균 감량 목표 자동 계산
   - 공식: (현재 체중 - 목표 체중) / 목표 기간
4. 계산된 주간 감량 목표가 안전 범위 초과 시 경고 표시
5. 투여 계획 정보 입력 필드 검증
   - 약물명: 비어있지 않은지 확인
   - 시작일: 현재 또는 미래 날짜인지 확인
   - 투여 주기: 양수 값 확인
   - 초기 용량: 양수 값 확인
   - 증량 계획: 논리적 순서 검증
6. 모든 정보를 Repository를 통해 저장
7. 투여 스케줄 자동 생성 로직 실행
8. 저장 완료 후 홈 대시보드로 이동

### 출력
- 입력 필드별 실시간 검증 피드백
- 계산된 주간 감량 목표 표시
- 안전하지 않은 목표 설정 시 경고 메시지
- 온보딩 완료 후 홈 대시보드 화면으로 전환
- 저장 실패 시 에러 메시지 및 재시도 안내

### 엣지케이스
- 목표 체중이 현재 체중보다 큰 경우: 에러 메시지 표시
- 목표 기간 미입력: 주간 감량 목표 계산 건너뛰기
- 주간 감량 목표가 과도한 경우 (주당 1kg 초과): 경고 표시하되 진행 허용
- 증량 계획이 비논리적인 경우 (감량, 역순): 에러 메시지 표시
- 저장 중 앱 종료: 다음 실행 시 온보딩 재진행
- 시작일이 과거인 경우: 현재 날짜로 자동 조정 제안

---

## UF-F001: 투여 스케줄 관리

### 입력
- 투여 계획 정보 (F000에서 설정)
- 특정 투여일 수동 변경 요청
- 특정 용량 수동 변경 요청
- 투여 완료/미완료 상태 기록
- 주사 부위 선택 (복부/허벅지/상완)
- 증량 계획 변경 요청

### 처리
1. 초기 투여 계획 정보 기반 전체 스케줄 생성
   - 시작일부터 종료일까지 투여일 계산
   - 각 투여일에 용량 매핑
   - 증량 계획 반영
   - 1초 이내 완료 필수
2. 투여일/용량 수동 변경 시
   - 변경 지점 이후 모든 스케줄 재계산
   - 재계산 1초 이내 완료 필수
3. 투여 예정일 당일 지정 시간에 푸시 알림 생성
4. 투여 완료 기록 시
   - 투여일시, 실제 용량, 투여 부위, 메모 저장
   - 주사 부위 순환 관리 로직 실행
5. 주사 부위 순환 확인
   - 같은 부위 마지막 사용일로부터 7일 경과 확인
   - 미경과 시 경고 표시하되 진행 허용
6. 투여 누락 관리
   - 예정일로부터 경과 일수 계산
   - 5일 이내: "즉시 투여" 알림 생성
   - 5일 초과: "다음 예정일까지 대기" 안내
7. 증량 계획 변경 시
   - 변경일시, 변경 전/후 계획 기록
   - 변경 지점 이후 스케줄 재계산

### 출력
- 캘린더 뷰와 리스트 뷰로 스케줄 표시
- 투여일 당일 푸시 알림 발송
- 투여 완료 시 완료 상태 UI 업데이트
- 주사 부위 재사용 경고 메시지
- 부위별 투여 이력 시각화
- 누락 용량 관리 안내 메시지
- 스케줄 변경 시 재계산 완료 피드백
- 변경 이력 확인 가능

### 엣지케이스
- 투여일 변경으로 증량 시점이 앞당겨지는 경우: 안전성 경고 표시
- 같은 날 여러 번 투여 기록 시도: 중복 기록 방지 확인 메시지
- 과거 날짜에 투여 미완료 기록 추가: 누락 관리 로직 재실행
- 주사 부위 미선택 투여: 선택 유도하되 진행 허용
- 증량 계획 삭제 시: 현재 용량 유지 스케줄로 재계산
- 앱 알림 권한 거부 시: 인앱 알림 또는 설정 변경 유도
- 스케줄 재계산 중 앱 종료: 다음 실행 시 자동 재계산
- 투여 완료 후 기록 삭제 요청: 삭제 확인 후 스케줄 재계산

---

## UF-F002: 증상 및 체중 기록

### 입력
- 날짜 선택 (오늘/어제/2일 전/캘린더)
- 체중 값 입력 (kg 단위)
- 부작용 증상 선택 (메스꺼움/구토/변비/설사/복통/두통/피로)
- 부작용 심각도 선택 (1-10점 척도)
- 심각도 7-10점 시 24시간 이상 지속 여부 선택 (예/아니오)
- 컨텍스트 태그 선택 (기름진음식/과식/음주/공복/스트레스/수면부족)
- 사용자 정의 태그 추가
- 메모 입력 (선택 사항)

### 처리
1. 날짜 선택 처리
   - 퀵 선택 또는 캘린더에서 날짜 선택
   - 선택된 날짜 검증 (미래 날짜 불가)
2. 체중 기록 처리
   - 체중 값 검증 (양수, 현실적 범위)
   - 날짜, 체중, 기록 시간 저장
   - 3회 터치 이내 완료 확인
3. 부작용 기록 처리
   - 증상 선택 및 심각도 입력
   - 용량 증량 후 경과일 자동 계산 (투여 스케줄 참조)
   - 컨텍스트 태그 저장
   - 날짜, 증상명, 심각도, 경과일, 기록 시간, 메모, 태그 저장
   - 3회 터치 이내 완료 확인
4. 심각도 7-10점 입력 시
   - "24시간 이상 지속 여부" 추가 질문 표시
   - "예" 선택 시 증상 체크 화면으로 안내
   - "아니오" 선택 시 기록 저장 진행
5. 날짜별 여러 증상 동시 기록 허용
6. 기록 완료 후 대처 가이드 자동 표시 (UF-F004 연동)

### 출력
- 입력 필드별 실시간 검증 피드백
- 용량 증량 후 경과일 표시
- 심각도 높은 경우 추가 질문 화면
- 기록 완료 확인 메시지
- 대처 가이드 카드 표시
- 기록 실패 시 에러 메시지

### 엣지케이스
- 미래 날짜 선택: 에러 메시지 표시
- 체중 값이 비현실적인 경우 (20kg 미만, 300kg 초과): 확인 메시지 표시
- 같은 날짜에 체중 중복 기록: 덮어쓰기 확인 메시지
- 같은 날짜/증상 중복 기록: 덮어쓰기 또는 별도 기록 선택
- 증량 이력이 없는 경우: 경과일 계산 건너뛰기
- 과거 기록 수정 시: 수정 확인 후 저장
- 네트워크 오류로 저장 실패 시: 로컬 저장 후 재시도 큐에 추가
- 입력 중 앱 종료: 임시 저장 없이 폐기

---

## UF-F003: 데이터 공유 모드

### 입력
- "기록 보여주기" 버튼 클릭
- 표시 기간 선택 (최근 1개월/3개월/전체)
- 차트 터치로 상세 데이터 확인
- 화면 스크롤로 데이터 탐색
- "공유 종료" 버튼 클릭

### 처리
1. 데이터 공유 모드로 전환
   - 개인화 인사, 뱃지, 설정 등 UI 요소 숨김
   - 모든 편집 기능 비활성화 (읽기 전용)
2. 선택된 기간의 데이터 조회
   - 투여 기록 (날짜, 용량 변화)
   - 투여 순응도 계산
   - 주사 부위 순환 이력
   - 체중 변화 추이 데이터 (목표 체중 포함)
   - 부작용 강도 추이 데이터 (증량 시점 포함)
   - 부작용 패턴 (컨텍스트 태그별 빈도)
   - 증상 체크 기록
3. 가독성 높은 전용 UI로 데이터 렌더링
   - 타임라인 형태 투여 기록
   - 순응도 백분율
   - 주사 부위 이력 표
   - 체중 추이 그래프
   - 부작용 추이 그래프
   - 패턴 분석 차트
   - 증상 체크 이력
4. 차트 터치 시 해당 시점의 상세 데이터 표시
5. 화면 이동 방지 (공유 종료 전까지)
6. "공유 종료" 버튼 클릭 시 일반 모드로 복귀

### 출력
- 읽기 전용 데이터 요약 화면
- 기간별 투여 기록 타임라인
- 투여 순응도 표시
- 주사 부위 순환 이력 표
- 체중 변화 그래프 (목표선 포함)
- 부작용 강도 추이 그래프 (증량 시점 표시)
- 컨텍스트 태그별 부작용 빈도
- 증상 체크 이력
- 공유 종료 시 홈 대시보드로 복귀

### 엣지케이스
- 선택 기간에 데이터 없음: 안내 메시지 표시
- 일부 데이터만 존재: 존재하는 데이터만 표시
- 공유 모드에서 편집 시도: 읽기 전용 안내
- 백 버튼 또는 제스처로 나가기 시도: 공유 종료 확인 메시지
- 화면 캡처 시도: 허용 (제한 없음)
- 데이터 로딩 실패: 에러 메시지 및 재시도 옵션
- 대용량 데이터로 렌더링 지연: 로딩 인디케이터 표시

---

## UF-F004: 부작용 대처 가이드

### 입력
- 부작용 기록 완료 (UF-F002에서 트리거)
- "더 자세한 가이드 보기" 버튼 클릭
- "도움이 되었나요?" 피드백 선택 (예/아니오)
- 가이드 탭에서 증상별 가이드 직접 조회

### 처리
1. 기록된 증상에 해당하는 간단 가이드 자동 조회
   - 메스꺼움: 식사 방법, 피해야 할 음식, 도움 되는 음료, 주사 타이밍 조정
   - 구토: 수분 보충, 식사 재개 순서, 회복 단계별 접근
   - 설사: 식이요법, 수분/전해질 관리, 피해야 할 음식
   - 변비: 식이섬유, 수분 권장량, 신체 활동, 배변 습관
   - 복통: 완화 방법, 식이 조절, 스트레스 관리
   - 두통: 수분 섭취, 휴식 방법, 일상 관리
   - 피로: 휴식/회복, 영양 관리, 활동량 조절
2. 간단 버전 가이드 카드로 표시
3. "도움이 되었나요?" 피드백 수집
   - "예": 감사 메시지 표시
   - "아니오": "다른 팁 보기" 또는 "의료진 상담 권장" 안내
4. "더 자세한 가이드 보기" 선택 시
   - 단계별 상세 가이드 표시
   - 즉시 조치 → 식이 조절 → 생활 습관 → 경과 관찰 순서
5. 가이드 화면에서 증상별 가이드 직접 조회 가능
6. 피드백 기록 저장 (선택적)

### 출력
- 증상별 간단 대처 가이드 카드
- "도움이 되었나요?" 피드백 UI
- "예" 선택 시 감사 메시지
- "아니오" 선택 시 추가 옵션 제공
- "더 자세한 가이드 보기" 버튼
- 상세 가이드 화면 (단계별 구성)
- 가이드 탭에서 모든 증상 가이드 목록

### 엣지케이스
- 등록되지 않은 증상: 일반 대처 가이드 표시
- 여러 증상 동시 기록: 각 증상별 가이드 순차 표시 또는 목록 제공
- 피드백 미선택: 가이드 확인 후 자유롭게 화면 이동 허용
- 상세 가이드 로딩 실패: 간단 가이드 유지 및 재시도 옵션
- 가이드 내용 업데이트 필요 시: 앱 업데이트로 관리

---

## UF-F005: 증상 체크 및 전문가 상담 권장

### 입력
- "증상 체크" 메뉴 진입
- 심각 증상 체크리스트 항목 선택
  - 24시간 이상 계속 구토
  - 물/음식 전혀 삼킬 수 없음
  - 매우 심한 복통
  - 48시간 이상 설사 지속
  - 소변 진한 갈색 또는 8시간 이상 미배출
  - 대변에 피 또는 검은색
  - 피부/눈 흰자위 노란색 변화

### 처리
1. 증상 체크 화면 표시
2. 체크리스트 항목 선택 시
   - 선택 항목 저장
   - 전문가 상담 권장 화면 자동 표시
3. 선택한 증상 요약 표시
4. 증상 기록 자동 저장 (심각도 10점)
   - UF-F002 연동하여 부작용 기록 생성
5. 체크 기록 저장 (날짜시간, 선택 증상)
6. 해당 없는 경우 화면 나가기 허용

### 출력
- 일상 언어로 작성된 증상 체크리스트
- 항목 선택 시 전문가 상담 권장 화면
- 선택한 증상 요약 표시
- "전문가와 상담이 필요합니다" 안내 문구
- 자동 저장된 증상 기록 확인
- 해당 없음 시 나가기 옵션

### 엣지케이스
- 여러 증상 동시 선택: 모두 기록하고 가장 심각한 증상 우선 표시
- 증상 체크 후 안내만 확인하고 나가기: 저장된 기록 유지
- 같은 증상 반복 체크: 각 기록 별도 저장
- 증상 체크 중 증상 완화: 기록 삭제 또는 수정 허용

---

## UF-F006: 홈 대시보드

### 입력
- 앱 실행 또는 홈 탭 선택
- 퀵 액션 버튼 클릭 (체중 기록/부작용 기록/투여 완료)
- 주간 리포트 영역 터치
- 뱃지 영역 터치
- 인사이트 메시지 터치

### 처리 (P0 - MVP 필수)
1. 사용자 프로필 정보 조회
2. 개인화 인사 영역 데이터 생성
   - 사용자 이름
   - 연속 기록일 계산 (마지막 기록 날짜 기준)
   - 현재 치료 주차 계산 (시작일 기준)
3. 주간 목표 진행도 계산
   - 투여 완료 목표: 주간 예정 투여 횟수 대비 실제 완료 횟수
   - 체중 기록 목표: 주간 목표 대비 실제 기록 횟수
   - 부작용 기록 목표: 주간 목표 대비 실제 기록 횟수
   - 각 목표 달성률(%) 계산
4. 다음 예정 일정 조회
   - 다음 투여 예정일 및 용량
   - 다음 증량 예정일 (해당 시)
   - 목표 달성 예상 시기 (현재 추세 기반 계산)
5. 주간 리포트 요약 생성
   - 텍스트 요약: 지난주 투여 횟수, 체중 변화, 부작용 빈도
   - 최근 4주 체중 추이 데이터
   - 최근 1주 부작용 빈도 데이터
   - 투여 순응도(%)
6. 치료 여정 타임라인 생성
   - 시작일부터 현재까지 진행 상황
   - 주요 마일스톤 (증량 시점, 체중 감량 목표 달성)
   - 다음 목표까지 진행도
7. 성취 뱃지 확인
   - 각 뱃지 획득 조건 검증
   - 획득한 뱃지 및 진행도 계산
   - 새 뱃지 획득 시 알림 생성
8. 퀵 액션 버튼 클릭 시 해당 기록 화면으로 이동
9. 리포트/뱃지 터치 시 상세 화면으로 이동

### 처리 (P1 - 향상 기능)
10. 데이터 기반 인사이트 자동 생성 **(P1)**
   - 체중 변화: 전주 대비 1% 이상 감소 시 긍정 메시지
   - 연속 기록: 7일 이상 달성 시 격려 메시지
   - 부작용 개선: 전주 대비 평균 강도 2점 이상 감소 시 안내
   - 컨텍스트 패턴: 태그와 증상 상관관계 발견 시 맞춤 제안
   - 목표 진행: 현재 추세 기반 목표 달성 가능성 안내
   - 투여 순응도: 투여 누락과 체중 변화 상관관계 안내
   - 조건 미충족 시 일반 격려 메시지

### 출력 (P0 - MVP 필수)
- 개인화 인사 (이름, 연속 기록일, 치료 주차)
- 주간 목표 진행도 (투여/체중/부작용 기록 달성률)
- 퀵 액션 버튼 (체중 기록/부작용 기록/투여 완료)
- 다음 예정 일정 (투여일, 증량일, 목표 달성 예상)
- 주간 리포트 요약 (텍스트, 차트)
- 치료 여정 타임라인
- 성취 뱃지 (획득/진행 중)
- 투여 완료 시 축하 효과
- 주간 목표 100% 달성 시 시각적 강조

### 출력 (P1 - 향상 기능)
- 데이터 기반 인사이트 메시지 **(P1)**

### 엣지케이스
- 데이터 없는 신규 사용자: 환영 메시지 및 첫 기록 유도
- 연속 기록일 중단: 0으로 리셋하고 새로 시작 격려
- 주간 목표 미설정: 기본값 사용
- 목표 달성 후: 새 목표 설정 유도 또는 유지 모드 안내
- 인사이트 생성 조건 미충족: 일반 격려 메시지 표시
- 뱃지 획득 조건 동시 충족: 우선순위에 따라 순차 알림
- 데이터 로딩 지연: 스켈레톤 UI 또는 로딩 인디케이터
- 과거 데이터 수정으로 인한 통계 변동: 실시간 재계산
- 퀵 액션 연속 클릭: 중복 방지 처리

---

## UF-SETTINGS: 설정 화면

### 입력
- 홈 대시보드 또는 다른 화면에서 설정 아이콘/메뉴 선택

### 처리
1. 설정 화면으로 이동
2. 사용자 프로필 정보 조회 및 표시
3. 설정 메뉴 목록 렌더링

### 출력
- 설정 메뉴 목록:
  - 프로필 및 목표 수정 (→ UF-008)
  - 투여 계획 수정 (→ UF-009)
  - 주간 기록 목표 조정 (→ UF-013)
  - 푸시 알림 설정 (→ UF-012)
  - 로그아웃 (→ UF-007)
- 현재 사용자 정보 (이름, 가입일 등)

### 엣지케이스
- 로그인 세션 만료 시: 자동으로 로그인 화면으로 이동
- 네트워크 오류로 프로필 로딩 실패: 캐시된 정보 표시 또는 재시도 옵션

---

## UF-007: 로그아웃

### 입력
- 설정 메뉴 진입
- 로그아웃 버튼 클릭
- 로그아웃 확인 대화상자에서 확인 선택

### 처리
1. 설정 화면에서 로그아웃 버튼 표시
2. 로그아웃 버튼 클릭 시 확인 대화상자 표시
3. 확인 선택 시 로그아웃 처리 시작
4. 저장된 Access Token 및 Refresh Token 삭제
5. 로컬 세션 정보 초기화
6. 로그인 화면으로 이동

### 출력
- 로그아웃 확인 대화상자
- 로그아웃 처리 중 인디케이터
- 로그인 화면으로 전환
- 로그아웃 실패 시 에러 메시지

### 엣지케이스
- 로그아웃 중 네트워크 오류: 로컬 토큰 삭제 후 로그인 화면 이동
- 로그아웃 확인 취소: 설정 화면 유지
- 로그아웃 중 앱 종료: 다음 실행 시 로그인 화면 표시
- 로그아웃 후 로컬 데이터 유지 여부: 로컬 데이터는 보존 (재로그인 시 동기화)

---

## UF-008: 프로필 및 목표 수정

### 입력
- 설정 메뉴에서 프로필/목표 수정 선택
- 수정할 정보 입력 (이름/목표 체중/현재 체중/목표 기간)
- 저장 버튼 클릭

### 처리
1. 현재 프로필 및 목표 정보 조회
2. 수정 화면에 기존 정보 표시
3. 사용자 입력 필드 검증
   - 이름: 비어있지 않은지 확인
   - 목표/현재 체중: 양수 값, 현실적 범위
   - 목표 기간: 양수 값 또는 미입력
4. 목표 체중 변경 시 주간 평균 감량 목표 재계산
5. 변경사항 저장
6. 홈 대시보드 관련 데이터 재계산 트리거
7. 저장 완료 후 설정 화면으로 복귀

### 출력
- 기존 정보가 채워진 수정 폼
- 입력 필드별 실시간 검증 피드백
- 재계산된 주간 감량 목표 표시
- 저장 완료 확인 메시지
- 저장 실패 시 에러 메시지

### 엣지케이스
- 목표 체중이 현재 체중보다 큰 경우: 에러 메시지
- 변경사항 없이 저장: 그대로 유지
- 저장 중 앱 종료: 변경사항 폐기
- 현재 체중 변경 시 최근 체중 기록과 불일치: 확인 메시지
- 목표 변경으로 인한 목표 달성 예상일 변동: 홈 대시보드에 반영

---

## UF-009: 투여 계획 수정

### 입력
- 설정 메뉴에서 투여 계획 수정 선택
- 수정할 정보 입력 (약물명/시작일/주기/초기 용량/증량 계획)
- 저장 버튼 클릭

### 처리
1. 현재 투여 계획 정보 조회
2. 수정 화면에 기존 정보 표시
3. 사용자 입력 필드 검증
   - 약물명: 비어있지 않은지 확인
   - 시작일: 현재 또는 미래 날짜 (과거 변경 시 경고)
   - 주기: 양수 값
   - 초기 용량: 양수 값
   - 증량 계획: 논리적 순서
4. 변경사항이 기존 투여 기록에 미치는 영향 분석
5. 영향이 있는 경우 확인 메시지 표시
6. 변경 이력 저장 (날짜, 변경 전/후 계획)
7. 투여 스케줄 재계산 실행
8. 저장 완료 후 설정 화면으로 복귀

### 출력
- 기존 정보가 채워진 수정 폼
- 입력 필드별 실시간 검증 피드백
- 변경 영향 확인 메시지
- 스케줄 재계산 완료 피드백
- 저장 완료 확인 메시지
- 저장 실패 시 에러 메시지

### 엣지케이스
- 과거 시작일로 변경: 경고하되 허용
- 이미 진행 중인 증량 계획 변경: 영향 범위 명확히 안내
- 주기 변경으로 인한 기존 기록과 불일치: 기록 유지, 스케줄만 재계산
- 저장 중 앱 종료: 변경사항 폐기
- 증량 계획 대폭 변경 시: 안전성 경고 표시

---

## UF-011: 과거 기록 수정/삭제

### 입력
- 기록 목록에서 특정 기록 선택
- 수정 또는 삭제 선택
- 수정 시 새로운 값 입력
- 삭제 확인

### 처리
1. 선택한 기록 상세 정보 조회
2. 수정 또는 삭제 옵션 표시
3. 수정 선택 시
   - 기존 값이 채워진 수정 폼 표시
   - 입력 필드 검증
   - 변경사항 저장
   - 관련 통계 및 인사이트 재계산
     * 홈 대시보드(UF-F006) 데이터 갱신
     * 데이터 공유 모드(UF-F003) 리포트 갱신
     * Application Layer의 DashboardNotifier를 통한 상태 관리 로직 실행
4. 삭제 선택 시
   - 삭제 확인 대화상자 표시
   - 확인 시 기록 삭제
   - 관련 통계 및 인사이트 재계산
     * 홈 대시보드(UF-F006) 데이터 갱신
     * 데이터 공유 모드(UF-F003) 리포트 갱신
     * Application Layer의 DashboardNotifier를 통한 상태 관리 로직 실행
5. 완료 후 기록 목록으로 복귀

### 출력
- 기록 상세 화면
- 수정/삭제 옵션
- 수정 폼 (기존 값 표시)
- 삭제 확인 대화상자
- 저장/삭제 완료 확인 메시지
- 실패 시 에러 메시지

### 엣지케이스
- 투여 기록 삭제 시 스케줄 영향: 스케줄은 유지, 기록만 삭제
- 증상 기록 삭제 시 대처 가이드 피드백도 삭제
- 삭제 취소 불가: 명확한 경고 표시
- 여러 기록 일괄 수정/삭제: MVP에서는 개별 처리만 지원
- 수정/삭제 중 앱 종료: 변경사항 폐기

---

## UF-012: 푸시 알림 설정

### 입력
- 설정 메뉴에서 알림 설정 선택
- 투여 알림 시간 설정
- 알림 활성화/비활성화 토글

### 처리
1. 현재 알림 설정 상태 조회
2. 알림 설정 화면 표시
3. 사용자 입력 반영
   - 알림 시간 변경 시 저장
   - 활성화/비활성화 상태 저장
4. 디바이스 알림 권한 확인
   - 권한 없음: 권한 요청
   - 권한 거부: 설정 앱으로 이동 안내
5. 알림 스케줄 업데이트
6. 저장 완료 후 설정 화면으로 복귀

### 출력
- 현재 알림 설정 상태 표시
- 알림 시간 선택 UI
- 활성화/비활성화 토글
- 권한 요청 대화상자
- 저장 완료 확인 메시지

### 엣지케이스
- 디바이스 알림 권한 거부: 설정 앱으로 이동 유도
- 여러 투여 예정일이 같은 날: 한 번만 알림
- 알림 시간이 투여 예정일 이후: 다음날 알림 또는 즉시 알림 선택
- 알림 설정 변경 후 즉시 반영되지 않음: 다음 알림부터 적용 안내

---

## UF-013: 주간 기록 목표 조정

### 입력
- 설정 메뉴에서 주간 기록 목표 조정 선택
- 수정할 목표 값 입력 (체중 기록/부작용 기록 주간 목표 횟수)
- 저장 버튼 클릭

### 처리
1. 현재 주간 목표 설정 조회
2. 수정 화면에 기존 값 표시
3. 사용자 입력 필드 검증
   - 주간 체중 기록 목표: 0~7회 (양수 값)
   - 주간 부작용 기록 목표: 0~7회 (양수 값)
4. 변경사항 저장
5. 홈 대시보드(UF-F006) 주간 목표 진행도 재계산 트리거
6. 저장 완료 후 설정 화면으로 복귀

### 출력
- 기존 값이 채워진 수정 폼
- 입력 필드별 실시간 검증 피드백
- 저장 완료 확인 메시지
- 저장 실패 시 에러 메시지

### 엣지케이스
- 목표 값 0 입력: 경고 메시지 표시하되 허용
- 변경사항 없이 저장: 그대로 유지
- 저장 중 앱 종료: 변경사항 폐기
- 목표 변경 후 홈 대시보드 반영: 실시간 재계산
</file>

</files>
